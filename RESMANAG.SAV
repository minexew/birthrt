/* ========================================================================
	MemManag.c - Memory manager routines
   Copyright (c) 1989-1994 by Alan B. Clark
   Right for non-exclusive use by Synergistic Software granted.
	All other rights reserved.
	========================================================================
	Contains the following internal functions:
.		get_free_mem	- returns the available in the far heap
.		CheckValidBlk	- verify block number is acceptable
.		FindFreeHeader	- find a free block header
.		SetBlockAttr	- Used by all the Set and Clr functions below
.		GetBlockSize	- returns the size of a block in bytes
.		FindBlock		- finds a block of memory and returns an index to it
.		CleanUpBlock	- perform housekeeping on a block of memory
.		MergeBlocks		- If current and next blocks are free then concatinate them
.		ReportFreeMem	- return the largest block that could be made by compaction
.		CompactMem		- move blocks around to concentrate free memory
.		PurgeMem			- remove purged blocks to satisfy an allocation request
.		MoveFreeBlock	- swap the positions of an empty and an inuse block

	Contains the following general functions:
+		InitMemManag	- initializes the memory manager
+		QuitMemManag	- Releases the memory allocated to the memory manager
.		ValidateBlockID - Check for a valid block ID: fatal_error or pass-thru
+		ClrLock			- unlock a locked block
.		SetPurge			- allow a block to be purged
.		ClrPurge			- dissallow purging a block
+		SetResource		- mark a block as a resource
+		ClrResource		- remove the resource mark
+		SetClassPerm	- mark a block as perminent
+		SetClass1		- mark a block as class 1
+		SetClass2		- mark a block as class 2
+		SetClassTemp	- mark a block as temporary
.		GetBlockIndex	- find the block index cooresponding to a pointer
+		NewExternalBlock - Make a block header point to a block outside the manager
+		NewBlock			- allocates a new block of memory
+		DisposBlock		- deallocates a block of memory. if a resource, inform the resource manager
+		DisposClass		- deallocates all blocks of memory within a class
.		SetPurgeClass	-	sets all blocks of memory within a class as purgable
.		SetBlockSize	- enlarge or shrink a block while preserving its contents
+		SetLock			- lock a block of memory in place

	======================================================================== */
/* ®RM200¯ */
/* includes */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <dos.h>

#ifndef _WINDOWS
#include <i86.h>
#include <bios.h>
#else
#include <windows.h>
#endif

#include <conio.h>
#include "system.h"
#include "machine.h"

#include "memmanag.h"

/* ------------------------------------------------------------------------
	Defines for memory manager functions
   ------------------------------------------------------------------------ */

// heap allocations
#ifdef _WINDOWS
	#define malloc(size)	HeapAlloc(hHeap, 0, size)
	#define free(p)			HeapFree(hHeap, 0, p)
	extern HANDLE hHeap;
#endif

/* ------------------------------------------------------------------------ */
/* Defines and Compile flags */

#define RES_MANAGER		1
#define CHECKLINKS		0

// Try and get the memory blocks to move as often as possible.
#define MOVE_MEMORY_TEST	0
#define CHECK_REALLY_OFTEN	0		// GWP Blows up DOS from sierra sound.

#define UP_IN_MEM		1
#define DOWN_IN_MEM		2
#define START_BLOCK		0
#define FIRST_BLOCK		1
#define END_BLOCK		2

#define	CLEAN_TO_HIGHER		0
#define	CLEAN_TO_LOWER		1

// Used for debugging by writing a test block at the head & tail of the block.
#define MEMORY_MARKER		0xDEADC0DE
#define UNINITED_MEMORY		0xDC

#if defined(MEMORY_CHK)
#define MAX_HEADER_NAME_LEN_SIZE	14
#define MAX_HEADER_NAME_LEN	(MAX_HEADER_NAME_LEN_SIZE - 1)
typedef struct {
	char	FileName[MAX_HEADER_NAME_LEN_SIZE];
	char	BlockName[MAX_HEADER_NAME_LEN_SIZE];
	LONG	FileLineNo;
	LONG	HeadMarker;
} MEMORY_DEBUG_INFO;

// For debugging I've included this next structure.
typedef struct {
	MEMORY_DEBUG_INFO	fHeaderBlk;
	
	// Put a watch on this fDataStart and cast it to the correct type.
	void				*fDataStart;
} LOOK_AT_BLOCK;
static LOOK_AT_BLOCK *pLook = 0;	// variable to use with debugging otherwise the struct is unknown.

#define MARKER_SPACE		(sizeof(MEMORY_DEBUG_INFO) + sizeof(LONG))
#define HEADER_SPACE		(sizeof(MEMORY_DEBUG_INFO))
#else
#define MARKER_SPACE		0
#define HEADER_SPACE		0
#endif

/* ------------------------------------------------------------------------ */
/* Macros */

#define TEST_BLK_INUSE(x)	((((x) & BLKTYPEMASK) >= BLKINUSE) && (((x) & BLKTYPEMASK) != ENDBLK))
/* ------------------------------------------------------------------------ */

/* Prototypes */
typedef enum {
	MEM_ERROR_NONE = 0,
	MEM_ERROR_BAD_HANDLE,
	MEM_ERROR_BAD_HEAD,
	MEM_ERROR_BAD_TAIL,
	MEM_ERROR_ZERO_BLOCK,
	MEM_ERROR_UNUSED_BLOCK,
	MEM_ERROR_FREE_BLOCK,
} MEM_ERROR_CODE;

#if defined (MEMORY_CHK)
static MEM_ERROR_CODE CheckBlockOverwrite(LONG i);
static void ReportBlockError(LONG iHandle,MEM_ERROR_CODE ErrorCode);
#endif

static SHORT		CheckValidBlock (SHORT, LONG);
static SHORT		ValidateBlockID (SHORT);
static SHORT		FindFreeHeader (void);
static SHORT		FindBlock (ULONG);
static SHORT		CleanUpBlock (SHORT, BOOL, ULONG);
static SHORT		MergeBlocks (SHORT);
static ULONG		CompactMem_ (ULONG, BOOL);
static ULONG		PurgeMem_ (ULONG, BOOL *);
static UBYTE		MoveFreeBlock (SHORT, UBYTE);
#if CHECK_LINKS
static void		CheckLinks (CSTRPTR);
#endif

#ifdef _WINDOWS
ULONG WinCheckMem(void);
#endif

/* ------------------------------------------------------------------------ */
/* Global Variables */

PTR		pHeap;

ULONG	*	apBlocks;
SHORT	*	aiNextBlk;
SHORT	*	aiPrevBlk;
ATTR_BLK_TYPE	*	abBlockAttr;

USHORT	cNumBlkHeads = 0;
USHORT	iMaxBlkHeadUsed = 0;

BOOL	fReport;

// memory model flags default for full glory mode
BOOL	fMinMemory = FALSE;
BOOL	fLowMemory = FALSE;
BOOL 	fSmallMap = FALSE;
BOOL 	fRestrictAni = FALSE;
BOOL 	fLowResAni = FALSE;
BOOL 	fMedResAni = FALSE;
BOOL 	fLowResTextures = FALSE;
BOOL 	fMedResTextures = FALSE;

struct meminfo {
	ULONG		LargestBlockAvail;
	ULONG		MaxUnlockedPage;
	ULONG		LargestLockablePage;
	ULONG		LinAddrSpace;
	ULONG		NumFreePagesAvail;
	ULONG		NumPhysicalPagesFree;
	ULONG		TotalPhysicalPages;
	ULONG		FreeLinAddrSpace;
	ULONG		SizeOfPageFile;
	ULONG		Reserved[3];
} MemInfo;

static ULONG	cbFreemem;
	
#if CHECK_REALLY_OFTEN
static void ScanAllBlocks();
#endif


/* ========================================================================
	InitMemManager -	initializes the memory manager
	Setup the block header linked list.
	======================================================================== */
ULONG InitMemManag (
	ULONG cbMinMemoryNeeded,
	USHORT cNumBlkHeads_,
	USHORT cNumResHeads_,
	BOOL fReport_)
{
	ULONG		cbMaxFree;
	SHORT		i = 0;
	CHAR		buffer[128];

	fReport = fReport_;
	
	#if defined(MEMORY_CHK)
	pLook = 0;
	#endif

	if (fReport & fREPORT_MEMMGR)
		printf("\n\n\nMemory Manager Initialization\n");

	cNumBlkHeads = cNumBlkHeads_;
	apBlocks	 = (ULONG *)malloc((ULONG)(cNumBlkHeads*sizeof(ULONG *)));
	aiNextBlk	 = (SHORT *)malloc((ULONG)(cNumBlkHeads*sizeof(SHORT)));
	aiPrevBlk	 = (SHORT *)malloc((ULONG)(cNumBlkHeads*sizeof(SHORT)));
	abBlockAttr	 = (ATTR_BLK_TYPE *)malloc((ULONG)cNumBlkHeads *sizeof(ATTR_BLK_TYPE));
	
	for (i=0; i<cNumBlkHeads; i++)		/* init all blocks to unused */
		abBlockAttr[i] = UNUSED;

#if defined(MEMORY_CHK)
	memset(apBlocks,  UNINITED_MEMORY, (sizeof(ULONG *) * cNumBlkHeads));
	memset(aiNextBlk, UNINITED_MEMORY, (sizeof(SHORT)   * cNumBlkHeads));
	memset(aiPrevBlk, UNINITED_MEMORY, (sizeof(SHORT)   * cNumBlkHeads));
#endif

#if RES_MANAGER
	// The resource manager also uses malloc memory.
	InitResourceManager(cNumResHeads_);
#endif

#ifdef _WINDOWS
	// WINDOWS VERSION
	cbMaxFree = WinCheckMem();
#else
	// DOS VERSION
	cbMaxFree = get_free_mem();
#endif
	//cbMaxFree = (45 * 1014 * 1024) / 10;

	printf("memory available: %ld\n",cbMaxFree);

	cbFreemem = cbMaxFree - 4000;
//	cbFreemem = MIN_MEMORY_16MEG_WINDOWS - 4000;

	// count down til we find the real size of free memory or we can't find enough
	for (pHeap = NULL; pHeap == NULL && cbFreemem > cbMinMemoryNeeded; cbFreemem -= 0x10000)
		pHeap = (PTR)malloc(cbFreemem);

	printf("memory allocated: %ld Starting at 0x%lx\n",cbFreemem, pHeap);

	if (cbFreemem < cbMinMemoryNeeded || pHeap == NULL)
	{
		if (pHeap == NULL)
			puts("Unable to allocate memory in Memmanag. pHeap is NULL\n");
		else
		{
			sprintf(buffer,"Insufficient memory to execute program.\nNeeded at least %ldk bytes free, found %ldk bytes free.\nPlease remove some system resident utilities and try again.\n",
				(cbMinMemoryNeeded/1024L), (cbFreemem/1024L) );
			puts(buffer);
		}
		
		FreeResourceManager();
		
		free(pHeap);
		free(apBlocks);
		free(aiNextBlk);
		free(aiPrevBlk);
		free(abBlockAttr);
		exit(EXIT_SUCCESS);
	}

	apBlocks[START_BLOCK] = (ULONG)pHeap;				/* START-OF-SPACE marker */
	aiNextBlk[START_BLOCK] = 1;
	aiPrevBlk[START_BLOCK] = (SHORT)fERROR;						/* means no link */
	abBlockAttr[START_BLOCK] = STARTBLK | LOCKED;

	apBlocks[FIRST_BLOCK] = (ULONG)pHeap;				/* first free space */
	aiNextBlk[FIRST_BLOCK] = 2;
	aiPrevBlk[FIRST_BLOCK] = 0;
	abBlockAttr[FIRST_BLOCK] = FREEMEM;

	apBlocks[END_BLOCK] = (ULONG)pHeap+cbFreemem;	/* END-OF-CONTIGUOUS-SPACE marker */
	aiNextBlk[END_BLOCK] = (SHORT)fERROR;						/* means no link */
	aiPrevBlk[END_BLOCK] = 1;
	abBlockAttr[END_BLOCK] = ENDBLK | LOCKED;

#if CHECKLINKS
	CheckLinks("InitMemManag");
#endif

	return cbFreemem;
}

/*	=======================================================================
	QuitMemManag -
	======================================================================= */
void QuitMemManag ()
{
#if defined(MEMORY_CHK)
	// Purge all the memory you can, we're looking for leaks.
	BOOL SingleBlock = FALSE;
	
	PurgeMem_(ReportFreeMem(TRUE), &SingleBlock);
	PrintUnFreedMemoryReport();
#endif

#if RES_MANAGER
//  FreeResourceManager();
#endif

//	free(pHeap);
//	free(apBlocks);
//	free(aiNextBlk);
//	free(aiPrevBlk);
//	free(abBlockAttr);

	if (fReport & fREPORT_MEMMGR)
		puts("MemManager removed");
}

/* ====================================================================
	get_free_mem	-
	==================================================================== */
#ifndef _WINDOWS
ULONG get_free_mem()
{
union REGS regs;
struct SREGS sregs;

	regs.x.eax = 0x00000500;
	memset( &sregs, 0, sizeof(sregs) );
	sregs.es = FP_SEG( &MemInfo );
	regs.x.edi = FP_OFF( &MemInfo );

	int386x( DPMI_INT, &regs, &regs, &sregs );
	return( MemInfo.LargestBlockAvail );
}
#endif

/* ========================================================================
	CheckValidBlock -
	======================================================================== */
static SHORT CheckValidBlock (SHORT i, LONG LineNo)
{
	if (i < 1 || i >= cNumBlkHeads)
	{
		if (fReport & fREPORT_MEMMGR)
			printf("MEMMANAG WARNING CheckValidBlock - out of range block number: %d [%d]\n",i, LineNo);
#if defined (MEMORY_CHK)
		fatal_error("MEMMANAG ERROR CheckValidBlock - out of range block number: %d [%d]\n",i, LineNo);
#else
		return (SHORT)fERROR;
#endif
	}

	if ((abBlockAttr[i] & BLKTYPEMASK) == UNUSED)
	{
		if (fReport & fREPORT_MEMMGR)
			printf("MEMMANAG WARNING CheckValidBlock - not currently using block number: %d [%d]\n",i, LineNo);
#if defined (MEMORY_CHK)
		fatal_error("MEMMANAG ERROR CheckValidBlock - not currently using block number: %d [%d]\n",i, LineNo);
#else
		return (SHORT)fERROR;
#endif
	}
	return fNOERR;
}

/* ========================================================================
	ValidateBlockID -
	======================================================================== */
static SHORT ValidateBlockID (SHORT i)
{
	if (i < 1 || i >= cNumBlkHeads)
	{
#if defined (MEMORY_CHK)
		fatal_error("MEMMANAG ERROR - out of range block number: %d\n",i);
#else
		return (SHORT)fERROR;
#endif
	}
	if ((abBlockAttr[i] & BLKTYPEMASK) == UNUSED)
	{
#if defined (MEMORY_CHK)
		fatal_error("MEMMANAG ERROR ValidateBlockID - not currently using block number: %d\n",i);
#else
		return (SHORT)fERROR;
#endif
	}
	return i;
}

/* ========================================================================
	FindFreeHeader	- find a free block header
	======================================================================== */
static SHORT FindFreeHeader (void)
{
	static SHORT	j = 0;
	SHORT			jj = j;
	BOOL			fAlreadyTriedAgain = FALSE;

TryAgain:

	j++;
	// if we are already at the end of the list,
	// start back at the first posibile empty block
	if (j >= cNumBlkHeads)
		jj = j = 1;

	while (abBlockAttr[j] != UNUSED)
	{
		j++;

		if (j >= cNumBlkHeads)
			j = 0;

		if (j == jj)				/* search is exhausted, no free block found */
		{
			if (fAlreadyTriedAgain)
			{
				/* no free block header error */
#if defined (MEMORY_CHK)
				fatal_error("MEMMANAG ERROR - no free block header\n");
#else
				return (SHORT)fERROR;
#endif
			}
			else
			{
				// compact all memory but don't purge
				CompactMem_(0x7FFFFFFF, FALSE);
				fAlreadyTriedAgain = TRUE;
				goto TryAgain;
			}
		}
	}

	iMaxBlkHeadUsed++;

	if (fReport & fREPORT_MEMMGR)
		printf("FindFreeHeader: found free header %d\n",j);
	
	return j;
}

/* ========================================================================
	NewExternalBlock - Make a block header point to a block outside the manager
	======================================================================== */
SHORT NewExternalBlock (PTR p)
{
	SHORT		i;

	if ((i = FindFreeHeader()) == fERROR)	/* find an unused header */
		return (SHORT)fERROR;

	abBlockAttr[i] = BLKTYPE4;			/* mark the header as allocated */
	apBlocks[i] = (ULONG)p;
	aiNextBlk[i] = (SHORT)fERROR;
	aiPrevBlk[i] = (SHORT)fERROR;

	if (fReport & fREPORT_MEMMGR)
		printf("NewExternalBlock: assigned block %d\n",i);

#if CHECKLINKS
	CheckLinks("NewExternalBlock");
#endif
	return i;
}

/* ========================================================================
	The routine SetBlockAttr set or clears the attribute bits for the block
	specified by the handle. The following functions are supported as macros:
		ClrLock			-	unlock a locked block
		SetPurge			-	allow a block to be purged
		ClrPurge			-	dissallow purging a block
		SetResource		-	mark a block as a resource
		ClrResource		-	remove the resource mark
	======================================================================== */

SHORT SetBlockAttr (SHORT i, ATTR_BLK_TYPE mask, ATTR_BLK_TYPE value)
{
#if RES_MANAGER
	if ( IsResourceHandle(i))
	{
		SHORT iResBlk = GetResourceHandleBlk(i);
		
		if (iResBlk < 0 || iResBlk >= iMaxResSlots)
		{
	#if defined (MEMORY_CHK)
			fatal_error("MEMMANAG ERROR! SetBlockAttr, Res Handle %d out of range.\n", i);
	#else
			return fERROR;
	#endif
		}
		
#if fUSE_RES_FILES
		if (mask == CLASS2)
		{
			if (value)
			{
				gResFlags[iResBlk] &= (0xFFFF ^ RM_CLASS2);
			}
			else
			{
				gResFlags[iResBlk] |= RM_CLASS2;
			}
		}
		else if (mask == PURGEABLE)
		{
			if (value)
			{
				gResFlags[iResBlk] &= (0xFFFF ^ RM_PURGEABLE);
			}
			else
			{
				gResFlags[iResBlk] |= RM_PURGEABLE;
			}
		}
		else if (mask == MULTI_USER_BIT)
		{
			if (value)
			{
				gResFlags[iResBlk] &= (0xFFFF ^ RM_MULTI_USER);
			}
			else
			{
				gResFlags[iResBlk] |= RM_MULTI_USER;
			}
		}
		else if (mask == LOCKED)
		{
			if (value)
			{
				gResFlags[iResBlk] &= (0xFFFF ^ RM_LOCKED);
			}
			else
			{
				gResFlags[iResBlk] |= RM_LOCKED;
			}
		}
		
		i = iResBlock[iResBlk];
		if (i == 0 && giResFileNames != 0)	// It's not in memory but that's ok.
			return fNOERR;
#endif

		if ( i <= 0)
		{
			return fERROR;	// its not in memory.
		}
	}
#endif

	if (i == fERROR)
		return (SHORT)fERROR;

	if (i < 1 || i >= cNumBlkHeads)
	{
		if (fReport & fREPORT_MEMMGR)
			printf("MEMMANAG WARNING - out of range block number: %d\n",i);
#if defined (MEMORY_CHK)
		fatal_error("MEMMANAG ERROR - out of range block number: %d\n",i);
#else
		return (SHORT)fERROR;
#endif
	}

	if (!TEST_BLK_INUSE(abBlockAttr[i]))
		return fERROR;
		
#if defined (MEMORY_CHK)

	#if RES_MANAGER
	if ((value & PURGABLE) &&
	    !(abBlockAttr[i] & RESOURCE))
	{
		fatal_error("MEMMANAGE ERROR! Cannot mark block %ld, a non-resource, as purgable.\n", i);
	}
	#endif

	if (!(abBlockAttr[i] & LOCKED) && mask == LOCKED && value == 0)
		fatal_error("MEMMANAGE ERROR! Cannot clear lock on unlocked block %ld.\n", i);
	
#endif


	abBlockAttr[i] &= (0xFFFF ^ mask);		/* clear field to zero */
	abBlockAttr[i] |= value;				/* set new value */
	return i;
}

/* ========================================================================
	The routine GetBlockAttr returns the attribute bits for the block
	specified by the handle.  Returns 0 in case of error.  (Returning
	fERROR would indicate all bits set, which we don't want.)
	======================================================================== */

ATTR_BLK_TYPE GetBlockAttr (SHORT i)
{
	ATTR_BLK_TYPE Result = 0;
#if RES_MANAGER
	if ( IsResourceHandle(i))
	{
		SHORT iResBlk = GetResourceHandleBlk(i);
		
		if (iResBlk < 0 || iResBlk >= iMaxResSlots)
		{
	#if defined (MEMORY_CHK)
			fatal_error("MEMMANAG ERROR! GetBlockAttr, Res Handle %d out of range.\n", i);
	#else
			return (ATTR_BLK_TYPE) 0;
	#endif
		}
		
		i = iResBlock[iResBlk];
	#if fUSE_RES_FILES
		if (i == 0 && giResFileNames[iResBlk] != 0)	// we're currently paged out, but we could come back.
		{
			if ((gResFlags & RM_LOCKED) == RM_LOCKED)
				Result |= LOCKED;
			
			if ((gResFlags & RM_CLASS2) == RM_CLASS2)
				Result |= CLASS2;
		
			if ((gResFlags & RM_MULTI_USER) == RM_MULTI_USER)
				Result |= MULTI_USER_BIT;
		}
	#endif
		if ( i <= 0)
		{
			return Result;	// it's not in memory.
		}
	}
#endif

	if (i == fERROR)
		return Result;

	if (i < 1 || i >= cNumBlkHeads)
	{
		if (fReport & fREPORT_MEMMGR)
			printf("MEMMANAG WARNING - out of range block number: %d\n",i);
#if defined (MEMORY_CHK)
		fatal_error("MEMMANAG ERROR - out of range block number: %d\n",i);
#else
		return Result;
#endif
	}

	return abBlockAttr[i];
}

/* ========================================================================
	GetDataBlkSize	- returns the size of a data block in bytes (Less any
					  debug or header info we choose to keep.  The difference
					  in the addresses of the current block and the next
					  block is the size of the current block.
	======================================================================== */
ULONG GetDataBlkSize (LONG i)
{
	if (aiNextBlk[i] == fERROR)		/* handle size request of ENDBLOCK */
		return 0L;

	return (
			(apBlocks[aiNextBlk[i]] - apBlocks[i])
#if defined (MEMORY_CHK)
			 - MARKER_SPACE
#endif
			);
}

/* ========================================================================
	GetBlockSize	- returns the size of a block in bytes
	The difference in the addresses of the current block and the next
	block is the size of the current block.
	======================================================================== */
ULONG	GetBlockSize (LONG i)
{
	if (aiNextBlk[i] == fERROR)		/* handle size request of ENDBLOCK */
		return 0L;

	return (apBlocks[aiNextBlk[i]] - apBlocks[i]);
}

/* ========================================================================
	GetBlockIndex	-  Recover a lost pointer back to the handle.
	======================================================================== */
SHORT	GetBlockIndex (PTR p)
{
	SHORT	i = 0;

	while ((abBlockAttr[i] & BLKTYPEMASK) != ENDBLK && apBlocks[i] != (ULONG)p)
		i = aiNextBlk[i];			/* move to next block */

	if (apBlocks[i] == (ULONG)p)
		return (i);

	return fERROR;
}
#if defined (MEMORY_CHK)
/* ========================================================================
   Function    - WriteTestMemory
   Description - Write a marker at the head and tail of the block.
   Returns     -
   ======================================================================== */
static void WriteTestMemory(SHORT iHandle,LONG cBytes)
{
	MEMORY_DEBUG_INFO * pHeader = (MEMORY_DEBUG_INFO *)apBlocks[iHandle];
	
	// GWP Test code to see if we are overwritting the blocks.
	// GWP if (cBytes <= (sizeof (LONG) + sizeof(MEMORY_DEBUG_INFO)) || 
	// GWP     GetBlockSize(iHandle) > cBytes)
	// GWP {
	// GWP 	fatal_error("MEMMANAG ERROR! Bad allocation %ld.\n", cBytes);
	// GWP }
	
	// Set the whole block to a default setting.
	memset((void *)apBlocks[iHandle], UNINITED_MEMORY, cBytes);
	
	// Now initialize the header marker.
	pHeader->FileName[0]			= 0;
	pHeader->FileLineNo				= 0;
	pHeader->BlockName[0]			= 0;
	pHeader->HeadMarker				= MEMORY_MARKER;
	
	// Now initialize the tail marker.
	*((LONG *)((PTR)(apBlocks[iHandle]) + cBytes - sizeof(LONG))) 	= MEMORY_MARKER;
	
	// GWP Test code to see if we are overwriting the next block.
	// GWP if (TEST_BLK_INUSE(abBlockAttr[aiNextBlk[iHandle]]))
	// GWP {
	// GWP 	PTR pFoo = (PTR) BLKPTR(aiNextBlk[iHandle]);
	// GWP 	pFoo = 0;
	// GWP }
	
}
#endif

/* ========================================================================
	NewBlock			-	allocates a new block of memory
	Find a free block of at least the desired size then mark it as in use
	then clean up any excess bytes into a new free block.
	======================================================================== */
SHORT _NewBlock (ULONG cBytes)
{
	SHORT		i;
	
	//printf("_NewBlock (%ld)\n", cBytes);

#if defined (MEMORY_CHK)
	if (cBytes <= 0)
	{
		fatal_error("MEMMANAG ERROR! Not allowed to allocate blocks of %ld.\n", cBytes);
	}
	
	cBytes += MARKER_SPACE;
#endif

	/* find a block of the requested size */
	if ((i = FindBlock(cBytes)) == fERROR)
	{
#if defined (_DEBUG)
		printf("MEMMANAG ERROR - Unable to find a block.\n");
#endif
		return (SHORT)fERROR;
	}

	/* mark the block as allocated */
	abBlockAttr[i] = BLKINUSE;

	// GWPif (i == 18)
	// GWP{
	// GWP	volatile int x = i;
	// GWP}
	
	/* clean up the block to the requested size */
	CleanUpBlock(i, CLEAN_TO_HIGHER, cBytes);

#if CHECKLINKS
	CheckLinks("NewBlock");
#endif

#if defined (MEMORY_CHK)
	WriteTestMemory(i, cBytes);
	
	#if CHECK_REALLY_OFTEN
	ScanAllBlocks();
	#endif
#endif
	
	return i;
}

/* ========================================================================
	FindBlock	- finds a large enough block and returns an index to it
	======================================================================== */
static SHORT FindBlock (ULONG cBytes)
{
	LONG		cbFound;
	LONG		i;
	LONG		attrMask;

	if (cBytes == 0)					/* can't have zero size blocks */
		return (SHORT)fERROR;
			
#if MOVE_MEMORY_TEST
	CompactMem_(cbFreemem,TRUE);
#endif

Restart:
	i = 0;
	attrMask = abBlockAttr[i] & BLKTYPEMASK;

	/* search for a free block at least as big as we need */
	while (attrMask != FREEMEM || GetBlockSize(i) < cBytes)
	{
		i = aiNextBlk[i];			/* move to next block */

		attrMask = abBlockAttr[i] & BLKTYPEMASK;
		if (attrMask == ENDBLK)	/* search unsucessful */
		{
		/* No block has been found which is large enough. Therefore we must
			do garbage collection. We will attempt the following steps:
				1st	call CompactMem, if still not enough...
				2nd	PurgeMem will be called to free some memory...
				3rd	which will call CompactMem again */
			cbFound=CompactMem_(cBytes,TRUE);
			if (cbFound >= (LONG)cBytes)
				goto Restart;

			if (HandleOutOfMemory())	/* application specific out-of-memory handler */
				goto Restart;				/* returns true if some memory was freed */

			/* Search unsucessful after compact and purge */
#if defined(MEMORY_CHK)
			PrintMemList();
			PrintUnFreedMemoryReport();
			fatal_error("MEMMANAG ERROR - insufficient memory, requested:%ld  available:%ld\n",cBytes,cbFound);
#else
			printf("MEMMANAG ERROR - insufficient memory, requested:%ld  available:%ld\n",cBytes,cbFound);
			PrintMemList();
			return (SHORT)fERROR;
#endif
		}
	}

	if(i < 0 || i > cNumBlkHeads)
		i = fERROR;
		
	/* a free block of an acceptable size has been found */
	if (fReport & fREPORT_MEMMGR)
		printf("FindBlock: need 0x%lx (%lu) bytes. Found block %u\n", cBytes, cBytes, i);
	return (SHORT)i;
}

/* ========================================================================
	NewBlockHigh - finds a large enough block high in memory, returns index
	======================================================================== */
SHORT _NewBlockHigh (ULONG cBytes)
{
	LONG		cbFound;
	SHORT		i;

	//printf("_NewBlockHigh (%ld)\n", cBytes);
	
	if (cBytes == 0)					/* can't have zero size blocks */
		return (SHORT)fERROR;

#if defined (MEMORY_CHK)
	cBytes += MARKER_SPACE;
#endif

Restart:
	i = aiPrevBlk[END_BLOCK];

	/* search for a free block at least as big as we need */
	while ((abBlockAttr[i] & BLKTYPEMASK) != FREEMEM || GetBlockSize(i) < cBytes)
	{
		i = aiPrevBlk[i];			/* move to previous block */

		if ((abBlockAttr[i] & BLKTYPEMASK) == STARTBLK) /* search unsucessful */
		{
			cbFound=CompactMem_(cBytes,TRUE);
			if (cbFound >= (LONG)cBytes)
				goto Restart;

			if (HandleOutOfMemory())	/* application specific out-of-memory handler */
				goto Restart;				/* returns true if some memory was freed */

			/* Search unsucessful after compact and purge */
#if defined(MEMORY_CHK)
			fatal_error("MEMMANAG ERROR - insufficient memory, requested:%ld  available:%ld\n",cBytes,cbFound);
#else
			return (SHORT)fERROR;
#endif
		}
	}

	/* a free block of an acceptable size has been found */
	if (fReport & fREPORT_MEMMGR)
		printf("NewBlockHigh: need 0x%lx (%lu) bytes. Found block %u\n", cBytes, cBytes, i);

	/* mark the block as allocated */
	abBlockAttr[i] = BLKINUSE;

	// GWPif (i == 18)
	// GWP{
	// GWP	volatile int x = i;
	// GWP}
	
	/* clean up the block to the requested size */
	CleanUpBlock(i, CLEAN_TO_LOWER, cBytes);

#if CHECKLINKS
	CheckLinks("NewBlockHigh");
#endif

#if defined (MEMORY_CHK)
	WriteTestMemory(i, cBytes);
	
	#if CHECK_REALLY_OFTEN
	ScanAllBlocks();
	#endif
#endif

	return i;
}

/* ========================================================================
	_SetPurge	-	Support the extensable resource manager's SetPurge feature
	======================================================================== */
#if RES_MANAGER	// Only resources can be marked puragable.
SHORT _SetPurge (SHORT iHandle)
{

	if (iHandle < 0)
	{
	#if defined (MEMORY_CHK)
		fatal_error("MEMMANAG ERROR! SetPurge, Res Handle %d out of range.\n", iHandle);
	#else
		return fNOERR;
	#endif
	}
		
	if (IsResourceHandle(iHandle))
	{
		SHORT iMemBlk;
		SHORT iResBlk = GetResourceHandleBlk(iHandle);
		
		if (iResBlk >= iMaxResSlots)
		{
	#if defined (MEMORY_CHK)
			fatal_error("MEMMANAG ERROR! SetPurge, Res Handle %d out of range.\n", iHandle);
	#else
			return fNOERR;
	#endif
		}
		
		iMemBlk = iResBlock[iResBlk];
		if (iMemBlk < 0)
			return fNOERR;	// Its either not available or already gone.
		
	#if defined (MEMORY_CHK)
		if (CheckValidBlock(iMemBlk, __LINE__) == fERROR)
			return (SHORT)fERROR;
	
			ReportBlockError(iMemBlk,CheckBlockOverwrite(iMemBlk));
	#endif
	
		/* inform the resource manager */
	#if MOVE_MEMORY_TEST
		return (*ResExtentions[iResExtIndex[iResBlk]].pfDisposeProc)(iResBlk,iMemBlk);
	#else
		return (*ResExtentions[iResExtIndex[iResBlk]].pfSetPurgeProc)(iResBlk,iMemBlk);
	#endif
	}

	/* check for invalid block */
	if (CheckValidBlock(iHandle, __LINE__) == fERROR)
		return (SHORT)fERROR;

#if defined (MEMORY_CHK)
	ReportBlockError(iHandle,CheckBlockOverwrite(iHandle));
#endif

	return DisposBlock(iHandle);
}
#endif

/* ========================================================================
	_ClrPurge	-	Support the extensable resource manager's ClrPurge feature
	======================================================================== */
#if RES_MANAGER	// Only resources can be purgable.
SHORT _ClrPurge (SHORT iHandle)
{
	if (iHandle < 0)
	{
	#if defined (MEMORY_CHK)
		fatal_error("MEMMANAG ERROR! ClrPurge, Res Handle %d out of range.\n", iHandle);
	#else
		return fERROR;
	#endif
	}
	
	if (IsResourceHandle(iHandle))
	{
		SHORT iMemBlk;
		SHORT iResBlk = GetResourceHandleBlk(iHandle);
		
		if (iResBlk >= iMaxResSlots)
		{
	#if defined (MEMORY_CHK)
			fatal_error("MEMMANAG ERROR! ClrPurge, Res Handle %d out of range.\n", iHandle);
	#else
			return fERROR;
	#endif
		}
		
		iMemBlk = iResBlock[iResBlk];
		if (iMemBlk < 0)
			return fERROR;	// Its either not available or already gone.
		
	#if defined (MEMORY_CHK)
		if (iMemBlk != 0)
		{
			if (CheckValidBlock(iMemBlk, __LINE__) == fERROR)
				return fERROR;
		
				ReportBlockError(iMemBlk,CheckBlockOverwrite(iMemBlk));
		}
	#endif
	
		/* inform the resource manager */
		return (*ResExtentions[iResExtIndex[iResBlk]].pfClrPurgeProc)(iResBlk,iMemBlk);
	}

	return fNOERR;
}
#endif

/* ========================================================================
	DisposBlock		-	deallocates a block of memory
	First check for a valid index. If the block is a resource, inform the
	resource manager. Then mark the block as free and try to clean it out
	of existance.
	======================================================================== */
SHORT DisposBlock (SHORT iHandle)
{
	SHORT iPrev;

#if RES_MANAGER
	
	if (IsResourceHandle(iHandle))
	{
		SHORT iMemBlk;
		SHORT iResBlk = GetResourceHandleBlk(iHandle);
		
		if (iResBlk < 0 || iResBlk >= iMaxResSlots)
		{
	#if defined (MEMORY_CHK)
			fatal_error("MEMMANAG ERROR! DisposBlock, Res Handle %d out of range.\n", iHandle);
	#else
			return fERROR;
	#endif
		}
		
		iMemBlk = iResBlock[iResBlk];
		if (iMemBlk < 0)
			return fERROR;	// Its either not available or already gone.
		
	#if defined (MEMORY_CHK)
		if (iMemBlk != 0)
		{
			if (CheckValidBlock(iMemBlk, __LINE__) == fERROR)
				return fERROR;
		
				ReportBlockError(iMemBlk,CheckBlockOverwrite(iMemBlk));
			}
	#endif
		
		return (*ResExtentions[iResExtIndex[iResBlk]].pfDisposeProc)(iResBlk,iMemBlk);
	}
#endif

	/* check for invalid block */
	if (CheckValidBlock(iHandle, __LINE__) == fERROR)
		return fERROR;

#if defined (MEMORY_CHK)
	ReportBlockError(iHandle,CheckBlockOverwrite(iHandle));
	// Mark the data so it can't be used again.
	if (!(abBlockAttr[iHandle] & RESOURCE))
	{
		// The disposeProc will call us again after checking the checksum and removing
		// the resource flag. Then we'll zero out the memory. (Gives us one more place
		// to do a checksum on the resource.
		WriteTestMemory(iHandle, GetBlockSize(iHandle));
	}
#endif

#if RES_MANAGER
	/* test for block being a resource */
	if (abBlockAttr[iHandle] & RESOURCE)
	{
		SHORT iResBlk;
		
		// Note: We got here by being called by PurgeMem_ and do not have the
		//       resource handle.
		/* inform the resource manager */
		for (iResBlk=0; iResBlk<iMaxResSlots; iResBlk++)
			if (iResBlock[iResBlk] == iHandle)		/* if block has been found */
				return (*ResExtentions[iResExtIndex[iResBlk]].pfDisposeProc)(iResBlk,iHandle);

		/* no resource using this block. print an error */
	#if defined(MEMORY_CHK)
		fatal_error("MEMMANAG ERROR - no resource using this block: %d\n",iHandle);
	#endif
		// Otherwise keep on going and toss this block.
	}
#endif

	if (fReport & fREPORT_MEMMGR)
		printf("DisposBlock: %u\n", iHandle);

	if (aiNextBlk[iHandle] == fERROR)		/* check for an external block */
	{
		abBlockAttr[iHandle] = UNUSED;		/* block is external, NOT a managed part of the heap */
		iMaxBlkHeadUsed--;
		return fNOERR;
	}

	abBlockAttr[iHandle] = FREEMEM;			/* mark the block as free */
   	
   	// Concatinate adjacent free blocks.
   	
   	// First try the next block
	if ((abBlockAttr[aiNextBlk[iHandle]] & BLKTYPEMASK) == FREEMEM)
	   	MergeBlocks(iHandle);
   	
	/* also try previous block */
	iPrev = aiPrevBlk[iHandle];
	if ((abBlockAttr[iPrev] & BLKTYPEMASK) == FREEMEM)
		MergeBlocks(iPrev);

	
#if defined(MEMORY_CHK)
	#if CHECK_REALLY_OFTEN
	ScanAllBlocks();
	#endif
#endif
	
#if CHECKLINKS
	CheckLinks("DisposBlock");
#endif

	return fNOERR;
}

/* ========================================================================
	DisposClass		-	deallocates all blocks of memory within a class
	======================================================================== */
SHORT DisposClass (UBYTE Class)
{
	SHORT		iHandle;

#if defined (MEMORY_CHK)
	// We do this twice, incase the act of disposing a block trashes the memory.
	for ( iHandle = 0;
	      (abBlockAttr[iHandle] & BLKTYPEMASK) != ENDBLK;
		  iHandle = aiNextBlk[iHandle]				/* move to next block */
	    )
	{
		if ((abBlockAttr[iHandle] & BLKTYPEMASK) > FREEMEM &&
				(abBlockAttr[iHandle] & BLKTYPEMASK) < STARTBLK &&
				(abBlockAttr[iHandle] & CLASSMASK) == Class)
		{
			ReportBlockError(iHandle,CheckBlockOverwrite(iHandle));
		}
	}
#endif

	/* search for a free block */
	iHandle = 0;
	while ((abBlockAttr[iHandle] & BLKTYPEMASK) != ENDBLK)
	{
		if ((abBlockAttr[iHandle] & BLKTYPEMASK) > FREEMEM &&
				(abBlockAttr[iHandle] & BLKTYPEMASK) < STARTBLK &&
				(abBlockAttr[iHandle] & CLASSMASK) == Class)
		{
			DisposBlock(iHandle);
			// We don't just move to the next block, because after disposing
			// of this block we could now be the last block. So test again
			// then get the next block handle.
		}
		else
		{
			iHandle = aiNextBlk[iHandle];				/* move to next block */
		}
	}

#if CHECKLINKS
	CheckLinks("DisposClass");
#endif
	return fNOERR;
}

/* ========================================================================
	SetPurgeClass	-	sets all blocks of memory within a class as purgable
	======================================================================== */
#if RES_MANAGER		// Only Resources can be marked purgable.
SHORT SetPurgeClass (UBYTE Class)
{
	SHORT		iHandle;

	/* search for blocks of this class type */
	for ( iHandle = 0;
	      (abBlockAttr[iHandle] & BLKTYPEMASK) != ENDBLK;
		  iHandle = aiNextBlk[iHandle])				/* move to next block */
	{
		if ((abBlockAttr[iHandle] & BLKTYPEMASK) > FREEMEM &&
				(abBlockAttr[iHandle] & BLKTYPEMASK) < STARTBLK &&
				(abBlockAttr[iHandle] & CLASSMASK) == Class)
		{
			SetPurge(iHandle);
		}
	}
	return fNOERR;
}
#endif

/* ========================================================================
	CleanUpBlock		 -	perform housekeeping on a block of memory
	======================================================================== */
static SHORT CleanUpBlock (SHORT iHandle,
						   BOOL fCleanDirection,
						   ULONG cBytes)
{
	SHORT		j;
	SHORT		iNext;
	SHORT		iPrev;

	if (fReport & fREPORT_MEMMGR)
		printf("   CleanUpBlock: %u to 0x%lx (%lu) bytes\n", iHandle, cBytes, cBytes);

	/* check for invalid block */
	if (CheckValidBlock(iHandle, __LINE__) == fERROR)
		return (SHORT)fERROR;

	iNext = aiNextBlk[iHandle];					/* get index of next link */
	iPrev = aiPrevBlk[iHandle];					/* get index of previous link */

	if (cBytes == 0)							/* if request is to eliminate block */
	{
		abBlockAttr[iHandle] = FREEMEM;			/* then mark the block as free */
		j = iHandle;							/* free block is current block */
	}
	else
	if (GetBlockSize(iHandle) > cBytes)	/* make a new block from extra bytes */
	{
		/* find a free block header */
		j = FindFreeHeader();
		if (j == fERROR)
			return (SHORT)fERROR;

		if (fCleanDirection == CLEAN_TO_HIGHER)
		{
			/* Link new block header in after current block */
			aiNextBlk[iHandle] = j;					   	/* link j in forward */
			aiNextBlk[j] = iNext;
			aiPrevBlk[iNext] = j;						/* link j in back */
			aiPrevBlk[j] = iHandle;
			apBlocks[j] = apBlocks[iHandle] + cBytes;	/* calc address of new block */
			abBlockAttr[j] = FREEMEM;					/* set attribute */
		}
		else
		{
			/* Link new block header in before current block */
			aiPrevBlk[iHandle] = j;						 /* relink j before i */
			aiPrevBlk[j] = iPrev;
			aiNextBlk[j] = iHandle;
			aiNextBlk[iPrev] = j;
			apBlocks[j] = apBlocks[iHandle];			/* calc address of new block */
			apBlocks[iHandle] = apBlocks[iNext]-cBytes;	/* move address of old block */
			abBlockAttr[j] = FREEMEM;					/* set attribute */
		}
	}
	else
		return fNOERR;										/* nothing to fix so leave */

	if (fReport & fREPORT_MEMMGR)
		printf("   Created new block %u with 0x%lx (%lu) bytes\n", j, GetBlockSize(j), GetBlockSize(j));

	/* j is always a valid index to the free block at this point */
	/* if current block and next block are both free then concatinate them */
	MergeBlocks(j);

	/* also try previous block */
	iHandle = aiPrevBlk[j];
	if ((abBlockAttr[iHandle] & BLKTYPEMASK) == FREEMEM)
		MergeBlocks(iHandle);

#if CHECKLINKS
	CheckLinks("CleanUpBlock");
#endif
	return fNOERR;
}

/* ========================================================================
	MergeBlocks			- If current and next blocks are free then concatinate
	them. Mark the appropriate header as unused.
	======================================================================== */
static SHORT MergeBlocks (SHORT iHandle)
{
	SHORT		iNext;
	SHORT		iNN;

	/* check for invalid block */
	if (CheckValidBlock(iHandle, __LINE__) == fERROR)
		return (SHORT)fERROR;

	iNext = aiNextBlk[iHandle];
	if ((abBlockAttr[iNext] & BLKTYPEMASK) != FREEMEM)
		return (SHORT)fERROR;

	if (fReport & fREPORT_MEMMGR)
		printf("   MergeBlocks: %u with %u\n", iHandle, iNext);

	iNN = aiNextBlk[iNext];
	aiNextBlk[iHandle] = iNN;			/* unlink iNext forward */
	aiPrevBlk[iNN] = iHandle;			/* unlink iNext back */
	apBlocks[iNext] = 0;				/* clear pointer */
	abBlockAttr[iNext] = UNUSED;		/* clear attribute */
	iMaxBlkHeadUsed--;

#if CHECKLINKS
	CheckLinks("MergeBlocks");
#endif

	return fNOERR;
}

/* ========================================================================
	ReportFreeMem - return the largest block that could be made by compaction
	======================================================================== */
ULONG ReportFreeMem (ULONG fPurgable)
{
	ULONG		cbMaxBlock = 0;
	ULONG		cbAccum = 0;
	SHORT		i;
	ULONG		abBlockMask;

	/* search for free blocks */
	for (i = 0, abBlockMask = abBlockAttr[i] & BLKTYPEMASK;
	     abBlockMask != ENDBLK;
		 i = aiNextBlk[i], abBlockMask = abBlockAttr[i] & BLKTYPEMASK)
	{
		if (abBlockAttr[i] & LOCKED)
		{
			cbMaxBlock = MAX(cbMaxBlock, cbAccum);
			cbAccum = 0;
		}
		else
		if ( abBlockMask == FREEMEM || (fPurgable && (abBlockAttr[i] & PURGABLE)) )
			cbAccum += GetBlockSize(i);

	}

	cbMaxBlock = MAX(cbMaxBlock, cbAccum);
	return cbMaxBlock;
}

/* ========================================================================
   Function    - ReportInUse
   Description - return the total of all blocks in use.
   Returns     -
   ======================================================================== */
ULONG ReportInUse(ULONG fPurgable)
{
	SHORT i = 0;
	ULONG Result = cbFreemem;
	
	for (i = 0;
		 i >= 0 && ((abBlockAttr[i] & BLKTYPEMASK) != ENDBLK);
		 i = aiNextBlk[i])
	{
		if ((fPurgable && (abBlockAttr[i] & PURGABLE)) ||
			(abBlockAttr[i] & BLKTYPEMASK) == FREEMEM
			)
		{
			Result -= GetBlockSize(i);
		}
	}
	
	return Result;
}


/* ========================================================================
	CompactMem		-	move blocks around to concentrate free memory
	======================================================================== */
static ULONG CompactMem_ (ULONG cBytes, BOOL fAllowPurge)
{
	ULONG		cbMaxBlock;
	SHORT		i;
	ULONG		cbBlockSize;
	ULONG		abBlockMask;

	if (fReport & fREPORT_MEMMGR)
		printf("CompactMem\n");

#if RES_MANAGER		// Only Resources can be marked purgable.
	/* purge enough to insure that compact will succeed */
	if (fAllowPurge)
	{
		ULONG cbCurrentFree = ReportFreeMem(FALSE);
		
		if (cbCurrentFree < cBytes)
		{
			BOOL SingleBlock = FALSE;
			
			cbMaxBlock = PurgeMem_(cBytes, &SingleBlock);
			if (cbMaxBlock < cBytes || SingleBlock == TRUE)
				goto LeaveFn;
		}
	}
#endif

	cbMaxBlock = 0;				/* initialize largest block found variable */

	/* search for a free block */
	i = 0;
	abBlockMask = abBlockAttr[i] & BLKTYPEMASK;
	while (abBlockMask != ENDBLK && cbMaxBlock < cBytes)
	{
		if ( abBlockMask != FREEMEM) /* if not free block.. */
		{
			i = aiNextBlk[i];										/* ..move to next block */
			abBlockMask = abBlockAttr[i] & BLKTYPEMASK;
			continue;
		}

		/* Current block is free, if next block is also free, concatinate them */
		if (MergeBlocks(i) != fERROR)
			continue;												/* loop to try again */

		cbBlockSize = GetBlockSize(i);
		cbMaxBlock = MAX(cbBlockSize, cbMaxBlock);

		/* if current block is free and next block is not locked then switch */
		if ( abBlockMask == FREEMEM &&
				(abBlockAttr[aiNextBlk[i]] & LOCKED) == FALSE )
			MoveFreeBlock(i, UP_IN_MEM);	/* switch positions and try again */
		else
		{
			i = aiNextBlk[i];					/* otherwise move to next block */
			abBlockMask = abBlockAttr[i] & BLKTYPEMASK;
		}
	}

LeaveFn:
	if (fReport & fREPORT_MEMMGR)
		printf(" compact free: %lx (%lu)\n", cbMaxBlock, cbMaxBlock);

#if CHECKLINKS
	CheckLinks("CompactMem");
#endif
	return cbMaxBlock;
}

#if RES_MANAGER	// Only resources get marked Purgeable.
/* ========================================================================
	PurgeMem_				-	remove purged blocks to satisfy an allocation request
	======================================================================== */
static ULONG PurgeMem_ (ULONG cBytes, BOOL *pSingleBlock)
{
	ULONG		cbMaxBlock = 0;
	SHORT		i;
	ULONG		cbOriginalSpace;
	ULONG		cBytesPlus10Percent;
	

	if (fReport & fREPORT_MEMMGR)
	{
		printf("PurgeMem\n");
	}
	
	if (fReport & fREPORT_MEMMGR)
	{
		cbOriginalSpace = ReportFreeMem(FALSE);
	}
	
	cBytesPlus10Percent = cBytes + cBytes/10;
	
	*pSingleBlock = FALSE;


	// search for one "same size" block to free up first.
	// Then we can skip the compact phase.
	for (i = 0;
		 (abBlockAttr[i] & BLKTYPEMASK) != ENDBLK && cbMaxBlock < cBytes;
		  i = aiNextBlk[i]					/* move to next block */
		 )
	{
		if (abBlockAttr[i] & PURGABLE &&
		    !((abBlockAttr[i] & MOLDYBIT) ||
		      (abBlockAttr[i] & MOLDYBITLASTTIME)))
		{
		    ULONG	BlockSize = GetBlockSize(i);
		
			// find a similar size block to reuse.
			if (cBytes <= BlockSize &&
			    cBytesPlus10Percent <= BlockSize)
			{
				DisposBlock(i);
				cbMaxBlock = ReportFreeMem(FALSE);
				*pSingleBlock = TRUE;
				goto Leave_fn;
			}
		}
	}
	
	/* search for purgable & Moldy blocks first */
	for ( i = 0;
		 (abBlockAttr[i] & BLKTYPEMASK) != ENDBLK && cbMaxBlock < cBytes;
		  i = aiNextBlk[i]					/* move to next block */
		 )
	{
		if (abBlockAttr[i] & PURGABLE &&
		 !((abBlockAttr[i] & MOLDYBIT) || (abBlockAttr[i] & MOLDYBITLASTTIME)))
		{
			if (GetBlockSize(i) >= cBytes)
			{
				*pSingleBlock = TRUE;
			}
			DisposBlock(i);
			cbMaxBlock = ReportFreeMem(FALSE);
		}
	}
	
	/* search for purgable blocks */
	for (i = 0;
	     (abBlockAttr[i] & BLKTYPEMASK) != ENDBLK && cbMaxBlock < cBytes;
		 i = aiNextBlk[i]					/* move to next block */
	     )
	{
		if (abBlockAttr[i] & PURGABLE)
		{
			if (GetBlockSize(i) >= cBytes)
			{
				*pSingleBlock = TRUE;
			}
			DisposBlock(i);
			cbMaxBlock = ReportFreeMem(FALSE);
		}
	}

Leave_fn:
	if (fReport & fREPORT_MEMMGR)
	{
		ULONG cbPurgedSpace = cbOriginalSpace - cbMaxBlock;
		
		printf("	purge free: %lx (%lu)\n", cbPurgedSpace, cbPurgedSpace);
	}

	return cbMaxBlock;
}
#endif

/* ========================================================================
	MoveFreeBlock		-	Swap the positions of an empty and an inuse block
	i is the index to the free block, dir is the direction to move it.
	======================================================================== */
static UBYTE MoveFreeBlock (SHORT i, UBYTE dir)
{
	ULONG		Src, Dest, cBytes;
	SHORT		iPrev, iNext, iNN, iPP;


	if (fReport & fREPORT_MEMMGR)
		printf("MoveFreeBlock: %u moves %s\n", i, (dir==DOWN_IN_MEM)?"down":"up");

	iPrev = aiPrevBlk[i];
	iPP	= aiPrevBlk[iPrev];
	iNext = aiNextBlk[i];
	iNN	= aiNextBlk[iNext];

	if (dir == DOWN_IN_MEM)
	{
		/* move i down by moving previous block up */
		/* before: iPP-iPrev-i-iNext-iNN		After:iPP-i-iPrev-iNext-iNN */

		/* can't move locked block or start block */
		if ((abBlockAttr[iPrev] & LOCKED) || (abBlockAttr[iPrev] & BLKTYPEMASK)==STARTBLK)
			return FALSE;

		Src = apBlocks[iPrev];
		Dest = Src + GetBlockSize(i);				/* Dest is new position of prev */
		cBytes = GetBlockSize(iPrev);

		if (fReport & fREPORT_MEMMGR)
			printf(" moving block %u from %lx to %lx length %lx (%lu)\n", iPrev, Src, Dest, cBytes, cBytes);

		memmove((PTR)Dest, (PTR)Src, cBytes);

		apBlocks[i] = Src;					/* new position for i is old position of prev */
		apBlocks[iPrev] = Dest;				/* set position of the moved block */
		aiNextBlk[iPP] = i;					/* relink forward */
		aiNextBlk[i] = iPrev;
		aiNextBlk[iPrev] = iNext;
		aiPrevBlk[iNext] = iPrev;			/* relink back */
		aiPrevBlk[iPrev] = i;
		aiPrevBlk[i] = iPP;
	}

	else		/* UP_IN_MEM */
	{
		/* move i up by moving next block down */
		/* before: iPP-iPrev-i-iNext-iNN		After:iPP-iPrev-iNext-i-iNN */

		/* can't move locked block or end block */
		if ((abBlockAttr[iNext] & LOCKED) || (abBlockAttr[iNext] & BLKTYPEMASK)==ENDBLK)
			return FALSE;
		Dest = apBlocks[i];
		Src = apBlocks[iNext];
		cBytes = GetBlockSize(iNext);		/* get the size of the inuse block */
		if (fReport & fREPORT_MEMMGR)
			printf(" moving block %u from %lx to %lx length %lx (%lu)\n",
				iNext, Src, Dest, cBytes, cBytes);
		memmove((PTR)Dest, (PTR)Src, cBytes);

		apBlocks[iNext] = Dest;				/* new position for i is old position of prev */
		apBlocks[i] = Dest + cBytes;
		aiNextBlk[iPrev] = iNext;			/* relink forward */
		aiNextBlk[iNext] = i;
		aiNextBlk[i] = iNN;
		aiPrevBlk[iNN] = i;					/* relink back */
		aiPrevBlk[i] = iNext;
		aiPrevBlk[iNext] = iPrev;
	}


#if CHECKLINKS
	CheckLinks("MoveFreeBlock");
#endif
	return TRUE;
}

/* ========================================================================
	SetBlockSize	-	enlarge or shrink a block while preserving its contents
	======================================================================== */
SHORT SetBlockSize (SHORT i, ULONG cBytes)
{
	SHORT		iNew;

#if RES_MANAGER
	if (IsResourceHandle(i))
	{
		// I'll let the resource come in now if it isn't already. I think these
		// cases are really few. (Where calling this actually the resource is gone.)
		i = Query_iResBlock(i);
		if (i <= 0 || i > cNumBlkHeads)
			return fERROR;
		
	#if defined (CRC_CHK)
		if (!(abBlockAttr[i] & MODIFYABLE_RESOURCE))
		{
			fatal_error("MEMMANAG ERROR! Modify'ing a non-modify'able resource %d.\n",
								i);
		}
	#endif

	}
#endif

#if defined (MEMORY_CHK)
	ReportBlockError(i,CheckBlockOverwrite(i));
	cBytes += MARKER_SPACE;
#endif

SetHandleSizeLoop:

	/* Attemp to join current and next blocks */
	MergeBlocks(i);

	/* clean up current block to the requested size */
	CleanUpBlock(i, CLEAN_TO_HIGHER, cBytes);

	/* If too small then allocate a block the size of the difference
		and move it to the end of the current block */
	if (GetBlockSize(i) < cBytes)
	{
		/* if FindBlock fails then return from SetHandleSize with error */
		if ((iNew = FindBlock(cBytes - GetBlockSize(i))) == fERROR)
			return (SHORT)fERROR;

		/* While the new block is not adjacent and above the current block,
			move the new block toward the end of the current block. */
		while (aiNextBlk[i] != iNew)
		{
			if (MoveFreeBlock(iNew, (UBYTE)((apBlocks[iNew] < apBlocks[i]) ? UP_IN_MEM : DOWN_IN_MEM)) == FALSE)
			{
				DisposBlock(iNew);	/* if the move fails then release the block */
				return (SHORT)fERROR;			/* and return from SetHandleSize with error */
			}
		}

		goto SetHandleSizeLoop;
	}

	if (fReport & fREPORT_MEMMGR)
		printf("SetHandleSize: Block %u to 0x%lx (%lu) bytes\n", i, cBytes, cBytes);

#if CHECKLINKS
	CheckLinks("SetBlockSize");
#endif
#if defined (MEMORY_CHK)
	// zero out the overflow bytes.
	*((LONG *)((PTR)(apBlocks[i]) + cBytes - sizeof(LONG)))  		= MEMORY_MARKER;
	
	#if CHECK_REALLY_OFTEN
	ScanAllBlocks();
	#endif
	
#endif

	return fNOERR;
}

/* ========================================================================
	SetLock	- Locks the position of a block in memory, after moving it
	as far up as it can. HEY DONT USE THIS IF MEMORY_CHK IS ON
	======================================================================== */
SHORT SetLock (SHORT iHandle)
{
	SHORT		i, j, ni, pi, nj, pj;
	ULONG		l;

#if RES_MANAGER
	if (IsResourceHandle(iHandle))
	{
	#if fUSE_RES_FILES
		SHORT iResBlk = GetResourceHandleBlk(i);
		
		// Test if purged out.
		if (iResBlock[iResBlk] == 0 && giResFileNames[iResBlk] != 0)
		{
			gResFlags |= RM_LOCKED;
			return fNOERR;
		}
	#endif
		
		i = Query_iResBlock(iHandle);
		if ( i < 0 || i > cNumBlkHeads)
			return fERROR;		// It's not in memory.
	}
	else
	{
		i = iHandle;
	}
#else
	i = iHandle;
#endif

	if (fReport & fREPORT_MEMMGR)
	{
//		PrintMemList();
		printf("SetLock on block %d\n",i);
	}

	if (CheckValidBlock(i, __LINE__) == fERROR)
		return (SHORT)fERROR;

#if defined (MEMORY_CHK)
	ReportBlockError(i,CheckBlockOverwrite(i));
#endif

	/* check to see if its already locked */
	if (abBlockAttr[i] & LOCKED)
		return fNOERR;

	l = GetDataBlkSize(i);						/* find the size of the block */
	j = _NewBlockHigh(l);						/* get a new block of the same size */
	if (j == fERROR)							/* if no more room */
	{
		SetBlockAttr(i,LOCKED,LOCKED);	/* let's just lock in place (re. GEH and GWP) */
		return (SHORT)fNOERR;
	}

	while (MoveFreeBlock(j, UP_IN_MEM)) ;

//	if (fReport & fREPORT_MEMMGR)
//		PrintMemList();

	l = GetBlockSize(i);
	memcpy((PTR)apBlocks[j], (PTR)apBlocks[i], l);	/* copy the contents */

	/* reset the block number to the old value */
	l = apBlocks[j];
	apBlocks[j] = apBlocks[i];				/* j now points at the old block */
	apBlocks[i] = l;							/* i now points at the new block */

	/* fix-up the linked list */
	pi = aiPrevBlk[i];
	ni = aiNextBlk[i];
	pj = aiPrevBlk[j];
	nj = aiNextBlk[j];

	if (pi==j)									/* blocks are adjacent, pj-j-i-ni */
	{
		aiNextBlk[pj] = i;					/* change to pj-i-j-ni */
		aiNextBlk[i]  = j;
		aiNextBlk[j]  = ni;
		aiPrevBlk[ni] = j;
		aiPrevBlk[j]  = i;
		aiPrevBlk[i]  = pj;
	}
	else if (pj==i)							/* blocks are adjacent, pi-i-j-nj */
	{
		aiNextBlk[pi] = j;					/* change to pi-j-i-nj */
		aiNextBlk[j]  = i;
		aiNextBlk[i]  = nj;
		aiPrevBlk[nj] = i;
		aiPrevBlk[i]  = j;
		aiPrevBlk[j]  = pi;
	}
	else
	{
		aiPrevBlk[i] = pj;					/* blocks are not adjacent */
		aiNextBlk[i] = nj;
		aiPrevBlk[nj] = i;
		aiNextBlk[pj] = i;

		aiPrevBlk[j] = pi;
		aiNextBlk[j] = ni;
		aiPrevBlk[ni] = j;
		aiNextBlk[pi] = j;
	}

//	if (fReport & fREPORT_MEMMGR)
//		PrintMemList();

	//SetBlockAttr(i,LOCKED,LOCKED);		/* lock the new block */
	abBlockAttr[i] |= LOCKED;
	
	if (IsClass1(j))
	{
		SetClass1(i);
	}
	
	if (IsClass2(j))
	{
		SetClass2(i);
	}
	
	if (IsClassTemp(j))
	{
		SetClassTemp(i);
	}
	
	if (IsResource(j))
	{
		SHORT iResBlk = GetResourceHandleBlk(iHandle);
		
		if (iResBlk < 0 || iResBlk >= iMaxResSlots)
		{
	#if defined (MEMORY_CHK)
			fatal_error("MEMMANAG ERROR! SetLock, Res Handle %d out of range.\n", iHandle);
	#else
			return fERROR;
	#endif
		}
		
		SetResource(i);
		// Find the resource handle and update it.
		iResBlock[iResBlk] = i;
		
		ClrResource(j);
	}
	
	
	if (IsPurgable(j))
	{
		SetPurge(i);
	}
	
	DisposBlock(j);

#if CHECKLINKS
	CheckLinks("SetLock");
#endif
#if defined (MEMORY_CHK)
	ReportBlockError(i,CheckBlockOverwrite(i));
	
	#if CHECK_REALLY_OFTEN
	ScanAllBlocks();
	#endif
	
#endif
	return fNOERR;
}

/* ======================================================================== */
/* Replace the following error reporting code with an application specific
	out-of-memory handler and an application specific out-of-memory reporting
	routine. */
/* ======================================================================== */
SHORT HandleOutOfMemory ()
{
#if 0
	if (FALSE /* replace with some-memory-avail-to-release test */)
	{
		/* release some memory here */
		return TRUE;
	}

	/* application specific out-of-memory reporting goes here */
#endif

	return FALSE;		/* no more memory availabe to release */
}

#if CHECKLINKS
/* ========================================================================

	======================================================================== */
void CheckLinks (CSTRPTR sz)
{
	SHORT		i, n;
	SHORT		c = 0;

	for (i=0; i!=fERROR; i=aiNextBlk[i])
	{
		c++;
		n = aiNextBlk[i];
		if (n != fERROR && (n == i || aiPrevBlk[n] != i || c > cNumBlkHeads))
			fatal_error("MEMMANAG ERROR - faulty links after function: %s\n",sz);
	}
}
#endif


/* ========================================================================

	======================================================================== */
void PrintMemList ()
{
#if 01
	SHORT		i, i2, col2, cc, type;
	#if defined (_WINDOWS)
		FILE *fp = fopen("memdmp.txt", "w");
		if (!fp)
			return;
	#else
		FILE *fp = stderr;
	#endif

	for (col2=i=0; i!=fERROR; i=aiNextBlk[i],col2++) ;
	col2 = (col2+1) / 2;
	for (cc=1,i2=aiNextBlk[0]; cc!=col2; i2=aiNextBlk[i2],cc++) ;
	i = 0;

	fprintf(fp," #  Ptr     Size   CSum Cls Attrib    |  #  Ptr     Size   CSum Cls Attrib\n");
	fprintf(fp,"--- ------- ------ ---- --- --------- | --- ------- ------ ---- --- ---------\n");

	for (cc=0; cc < col2; cc++)
	{
		fprintf(fp,"%03u %07lx %06lx %04x %03u ",i, apBlocks[i], GetBlockSize(i), CheckSum(i), (abBlockAttr[i]&CLASSMASK)>>3 );
		type = abBlockAttr[i] & BLKTYPEMASK;
		if (type != ENDBLK && aiPrevBlk[aiNextBlk[i]] != i)
			fprintf(fp,"*********");
		else
		{
			if (type == UNUSED)					fprintf(fp,"UNUSD");
			else if (type == FREEMEM)			fprintf(fp,"FREE ");
			else if (type == BLKINUSE)			fprintf(fp,"INUSE");
			else if (type == BLKTYPE3)			fprintf(fp,"TYPE3");
			else if (type == BLKTYPE4)			fprintf(fp,"TYPE4");
			else if (type == STARTBLK)			fprintf(fp,"START");
			else if (type == ENDBLK)			fprintf(fp,"END  ");
			else								fprintf(fp,"ERROR");
			
			if (abBlockAttr[i] & LOCKED)		fprintf(fp," L"); else fprintf(fp," -");
			if (abBlockAttr[i] & RESOURCE)		fprintf(fp,"R");  else fprintf(fp,"-");
			if (abBlockAttr[i] & PURGABLE)		fprintf(fp,"P");  else fprintf(fp,"-");
		}
		i = aiNextBlk[i];

		if (i2 != fERROR)
		{
			fprintf(fp," | %03u %07lx %06lx %04x %03u ",i2, apBlocks[i2], GetBlockSize(i2), CheckSum(i2), (abBlockAttr[i]&CLASSMASK)>>3 );
			type = abBlockAttr[i2] & BLKTYPEMASK;
			if (type != ENDBLK && aiPrevBlk[aiNextBlk[i2]] != i2)
				fprintf(fp,"*********");
			else
			{
				if (type == UNUSED)					fprintf(fp,"UNUSD");
				else if (type == FREEMEM)			fprintf(fp,"FREE ");
				else if (type == BLKINUSE)			fprintf(fp,"INUSE");
				else if (type == BLKTYPE3)			fprintf(fp,"TYPE3");
				else if (type == BLKTYPE4)			fprintf(fp,"TYPE4");
				else if (type == STARTBLK)			fprintf(fp,"START");
				else if (type == ENDBLK)			fprintf(fp,"END  ");
				else							  	fprintf(fp,"ERROR");
				
				if (abBlockAttr[i2] & LOCKED)		fprintf(fp," L"); else fprintf(fp," -");
				if (abBlockAttr[i2] & RESOURCE)		fprintf(fp,"R");  else fprintf(fp,"-");
				if (abBlockAttr[i2] & PURGABLE)		fprintf(fp,"P");  else fprintf(fp,"-");
			}
			i2 = aiNextBlk[i2];
		}

		fprintf(fp,"\n");
	}
	
	#if defined(_WINDOWS)
	fclose(fp);
	#endif

#endif
}

/* ========================================================================
   Function    - CheckBlockOverwrite
   Description - For memory checks, look at the end of the block to see if
                 it was written on.
   Returns     -
   ======================================================================== */

#if defined (MEMORY_CHK)
static MEM_ERROR_CODE CheckBlockOverwrite(LONG i)
{
	LONG size;
	MEM_ERROR_CODE Result = MEM_ERROR_NONE;
	
	if (i < 1 || i > cNumBlkHeads)
	{
		Result = MEM_ERROR_BAD_HANDLE;
	}
	else
	if ((abBlockAttr[i] & BLKTYPEMASK) == UNUSED)
	{
		Result = MEM_ERROR_UNUSED_BLOCK;
	}
	else
	if ((abBlockAttr[i] & BLKTYPEMASK) == FREEMEM)
	{
		Result = MEM_ERROR_FREE_BLOCK;
	}
	else
	if ((abBlockAttr[i] & BLKTYPEMASK) != BLKTYPE4)	// Check for external blks.
	{
		size = GetBlockSize(i);
		
		if (size > MARKER_SPACE)
		{
			MEMORY_DEBUG_INFO * pHeader = (MEMORY_DEBUG_INFO *)apBlocks[i];
			if ( pHeader->HeadMarker != MEMORY_MARKER)
		    {
				Result = MEM_ERROR_BAD_HEAD;
		    }
		    else
			if ( *((LONG *)((PTR)(apBlocks[i]) + size - sizeof(LONG))) 	!= MEMORY_MARKER)
			{
				Result = MEM_ERROR_BAD_TAIL;
			}
		}
		else
		{
			Result = MEM_ERROR_ZERO_BLOCK;
		}
	}
	return Result;
}
#endif

/* ========================================================================
   Function    - ReportBlockError
   Description - Validate the data tree.
   Returns     -
   ======================================================================== */

#if defined(MEMORY_CHK)
static void ReportBlockError(LONG i, MEM_ERROR_CODE ErrorCode)
{
	switch (ErrorCode)
	{
	case MEM_ERROR_BAD_HANDLE:
		fatal_error("MEMMANAGE ERROR! Accessing a block with a bad handle %ld\n", i);
		break;
	case MEM_ERROR_BAD_HEAD:
		{
		
  		if ((abBlockAttr[i] & BLKTYPEMASK) != ENDBLK)
		{
			FILE *fp = fopen("memdmp.txt", "w");
			if (fp)
			{
				LONG infiniteLoop;
				SHORT PrevBlock = i;
				
				for (infiniteLoop = 0, PrevBlock = aiPrevBlk[i];
				
				     PrevBlock > 0 &&
				     ((abBlockAttr[PrevBlock] & BLKTYPEMASK) != STARTBLK) &&
				     infiniteLoop < 10;
				
				     infiniteLoop++, PrevBlock = aiPrevBlk[PrevBlock])
				{
					ULONG BlockSize = 0;
					MEM_ERROR_CODE ErrorResult;
					
					if (!TEST_BLK_INUSE(abBlockAttr[PrevBlock]))
					{
						fprintf(fp,"Previous block %d not in use.\n", PrevBlock);
						fflush(fp);
						break;
					}
						
					BlockSize = GetBlockSize(PrevBlock);
					ErrorResult = CheckBlockOverwrite(PrevBlock);
					if (ErrorResult == MEM_ERROR_NONE)
					{
						fprintf(fp,"Last Good block %d, size = %lu\n.", PrevBlock, BlockSize);
						fflush(fp);
						break;
					}
					
					if (ErrorResult == MEM_ERROR_BAD_HEAD)
					{
						fprintf(fp,"Previous block Head %d overwritten, size = %lu.\n",
									PrevBlock, BlockSize);
						fflush(fp);
					}
					else
					if (ErrorResult == MEM_ERROR_BAD_TAIL)
					{
						fprintf(fp,"Previous block Tail %d overwritten, size = %lu.\n",
									PrevBlock, BlockSize);
						fflush(fp);
					}
					else
					if (ErrorResult == MEM_ERROR_ZERO_BLOCK)
					{
						fprintf(fp,"Previous block %d is zero size.\n", PrevBlock);
						fflush(fp);
					}
					else
					if (ErrorResult == MEM_ERROR_BAD_HANDLE)
					{
						fprintf(fp,"Previous block %d is a bad handle.\n", PrevBlock);
						fflush(fp);
					}
				}
				
				fclose(fp);
			}
		}
		
		fatal_error("MEMMANAG ERROR! Block %ld head was overwritten!\n", i);
		}
		break;
	case MEM_ERROR_BAD_TAIL:
		{
		
		if ((abBlockAttr[i] & BLKTYPEMASK) != ENDBLK)
		{
			FILE *fp = fopen("memdmp.txt", "w");
			if (fp)
			{
				LONG infiniteLoop;
				SHORT NextBlock;
				
				for (infiniteLoop = 0, NextBlock = aiNextBlk[i];
				
				     NextBlock > 0 &&
				     ((abBlockAttr[NextBlock] & BLKTYPEMASK) != ENDBLK) &&
				     infiniteLoop < 10;
				
				     infiniteLoop++, NextBlock = aiNextBlk[NextBlock])
				{
					MEM_ERROR_CODE ErrorResult;
					ULONG BlockSize = 0;
					
					if (!TEST_BLK_INUSE(abBlockAttr[NextBlock]))
					{
						fprintf(fp,"Next block %d not in use.\n", NextBlock);
						fflush(fp);
						break;
					}
						
					BlockSize = GetBlockSize(NextBlock);
					ErrorResult = CheckBlockOverwrite(NextBlock);
					
					if (ErrorResult == MEM_ERROR_NONE)
					{
						fprintf(fp,"Last Good block %d, size = %lu\n.", NextBlock, BlockSize);
						fflush(fp);
						break;
					}
					
					if (ErrorResult == MEM_ERROR_BAD_HEAD)
					{
						fprintf(fp,"Previous block Head %d overwritten, size = %lu.\n",
									NextBlock, BlockSize);
						fflush(fp);
					}
					else
					if (ErrorResult == MEM_ERROR_BAD_TAIL)
					{
						fprintf(fp,"Previous block Tail %d overwritten, size = %lu.\n",
									NextBlock, BlockSize);
						fflush(fp);
					}
					else
					if (ErrorResult == MEM_ERROR_ZERO_BLOCK)
					{
						fprintf(fp,"Previous block %d is zero size.\n", NextBlock);
						fflush(fp);
					}
					else
					if (ErrorResult == MEM_ERROR_BAD_HANDLE)
					{
						fprintf(fp,"Previous block %d is a bad handle.\n", NextBlock);
						fflush(fp);
					}
				}
				
				fclose(fp);
			}
		}
		
		fatal_error("MEMMANAG ERROR! Block %ld tail was overwritten!\n", i);
		}
		break;
	case MEM_ERROR_ZERO_BLOCK:
		fatal_error("MEMMANAG ERROR! Block %ld: Accessing a Zero size block.\n", i);
		break;
	case MEM_ERROR_UNUSED_BLOCK:
		fatal_error("MEMMANAGE ERROR! Block %ld has not been allocated.\n",i);
		break;
	case MEM_ERROR_FREE_BLOCK:
		fatal_error("MEMMANAGE ERROR! Block %ld has been free'd.\n", i);
		break;
	}
	
}
#endif
/* ========================================================================
   Function    - BLKPTR
   Description - Get the block pointer, with memory checking.
   Returns     - void * (You must cast to use.)
   ======================================================================== */

void * BLKPTR(LONG i)
{
	if (i < 0)
	{
#if defined (MEMORY_CHK)
		fatal_error("MEMMANAG ERROR! Invalid block handle BLKPTR(%ld).\n", i);
#else
		return (void *) i;
#endif
	}
	
#if RES_MANAGER
	if (IsResourceHandle(i))
	{
		// Here is where we'll get the resource if we can.
		i = Query_iResBlock(i);	// Convert a resource handle to a memory handle.
		if ( i <= 0)
			return (void *)i;
		
		if ( i > cNumBlkHeads)
			return (void *) fERROR;
	
		//SetBlockAttr(i,MOLDYBIT, MOLDYBIT);		/* set the moldy bit */
		abBlockAttr[i] |= MOLDYBIT;
	}
#endif

#if defined (MEMORY_CHK)
	if (CheckValidBlock(i, __LINE__) == fERROR)
	{
		fatal_error("MEMMANAG ERROR! Invalid block handle BLKPTR(%ld).\n", i);
	}
	ReportBlockError(i,CheckBlockOverwrite(i));
	
	// #if CHECK_REALLY_OFTEN
	// Don't call this from interupt or threaded code!
	//ScanAllBlocks();
	//#endif
#endif

	
#if defined(MEMORY_CHK)
	if ((abBlockAttr[i] & BLKTYPEMASK) == BLKTYPE4)	// Check for external blks.
	{
		return (void *)((LONG *)apBlocks[i]);
	}
	return (void *)(((char *)apBlocks[i]) + HEADER_SPACE);
#else
	return (void *)((LONG *)apBlocks[i]);
#endif
}

/* ========================================================================
   Function    - zalloc
   Description - Allocate locked blocks of high memory.
   Returns     - pointer to the memory.
   ======================================================================== */

void *_zalloc(char * FileName, LONG FileLineNo, LONG size)
{				
	SHORT iHandle = _NewBlockHigh(size);
	if (iHandle > 0)
	{
		ValidateBlockID(iHandle);
		SetBlockAttr(iHandle,LOCKED|CLASSMASK,LOCKED|CLASS1);
		SetDebugInfo( FileName, FileLineNo, iHandle);
	}
	else
	{
#if defined (_DEBUG)
		fatal_error("MEMMANAG ERROR! Can't allocate memory zalloc %ld.\n", size);
#else
		return NULL;
#endif
	}
	return BLKPTR(iHandle);
}

/* ========================================================================
   Function    - zone_alloc
   Description -
   Returns     - pointer to the memory.
   ======================================================================== */

void *_zone_alloc(LONG size)
{		
	SHORT iHandle = _NewBlockHigh(size);
	if (iHandle > 0)
	{
		ValidateBlockID(iHandle);
		SetBlockAttr(iHandle,LOCKED|CLASSMASK,LOCKED|CLASS1);
	}
	else
	{
#if defined (_DEBUG)
		fatal_error("MEMMANAG ERROR! Can't allocate memory zone_alloc %ld.\n", size);
#else
		return NULL;
#endif
	}
	
	return BLKPTR(iHandle);
}


#ifdef _WINDOWS
/* ========================================================================
   Function    - WinCheckMem
   Description - find the max abount of free mem in a window05 system
   Returns     - size of free mem availible
   ======================================================================== */
ULONG WinCheckMem(void)
{
	MEMORYSTATUS	memStats;
	ULONG			MaxFree = 0;
	//PTR				pBallast;
	//ULONG			i;
	//volatile ULONG	x;

	memset( &memStats, sizeof(MEMORYSTATUS), 0 );
	memStats.dwLength = sizeof(MEMORYSTATUS);
	
	// ask about memory
	GlobalMemoryStatus(&memStats) ;
	
	// while this scheme is cool, dosen't appear to work
	// // malloc the whole physical memory
	// pBallast = malloc(memStats.dwTotalPhys);
	//
	// // touch memory every 4K, to flush out as much of other
	// // people as we can
	// for(i = 0; i < memStats.dwTotalPhys; i+= 4096)
	// {
	// 	x = *(pBallast + i);
	// }
	// x++;  // compiler tease
	//
	// // now blow this big ol' block away
	// free(pBallast);
	//
	// // ask about memory again and see if we get a better answer
	// GlobalMemoryStatus(&memStats) ;
	//
	// MaxFree = (ULONG)(memStats.dwAvailPhys&0xFFFFFFF0);
		
	MaxFree = (ULONG)(memStats.dwTotalPhys&0xFFFFFFF0);
	
	// on a >32Meg, try to run hires
	if(MaxFree > (34*1024*1024) )
	{
		MaxFree = (24*1024*1024);
	}
	else
	// on a 32Meg or better machine, try to run med res
	if(MaxFree > (29*1024*1024) )
	{
		MaxFree = MIN_MEMORY_32MEG_WINDOWS;
	}
	// or else just give them Min amount
	else
	{
		MaxFree = MIN_MEMORY_16MEG_WINDOWS;
	}
	
	return (MaxFree);
}
#endif // _WINDOWS

/* ========================================================================
   Function    - ClearAllMoldyBits
   Description - At the begining of each render call this.
   				 If the last pass had set the Moldy bit, then set the
   				 Lasttime moldy bit flag.
   Returns     -
   ======================================================================== */

#if RES_MANAGER		// Without resources why bother?
void ClearAllMoldyBits()
{
	LONG iHandle;
	// Start at 1 past the head to use the first real block.
	
	for (iHandle = aiNextBlk[START_BLOCK];
		 iHandle >= 0;
		 iHandle = aiNextBlk[iHandle])
	{
		ATTR_BLK_TYPE * const pabBlockAttr = &abBlockAttr[iHandle];
		ULONG	const abAttr = *pabBlockAttr;
		ULONG	const abMaskedAttr = abAttr & BLKTYPEMASK;
		
		// WARNING!!! This next test counts on FREEMEM being < ENDBLK!!!!!!!!
		if (abMaskedAttr > FREEMEM)
		{
			if (abMaskedAttr == ENDBLK)
				break;
			
			if (abAttr & RESOURCE)		// Only resources get marked purgable.
			{
				/* set the moldy last time bit */
				if (abAttr & MOLDYBIT)
				{
					//SetBlockAttr(iHandle,MOLDYBITLASTTIME,MOLDYBITLASTTIME);
					*pabBlockAttr |= MOLDYBITLASTTIME;
					
					//SetBlockAttr(iHandle,MOLDYBIT,0);					/* clear the moldy bit */
					*pabBlockAttr &= (0xFFFF ^ MOLDYBIT);
				}
				else
				{
					//SetBlockAttr(iHandle,MOLDYBITLASTTIME,0);
					//SetBlockAttr(iHandle,MOLDYBIT,0);					/* clear the moldy bit */
					*pabBlockAttr &= (0xFFFF ^ (MOLDYBITLASTTIME | MOLDYBIT));
				}
				
			}
		}
	}
}
#endif

/* ========================================================================
   Function    - IsBlockMoldy
   Description - Test if the moldy bit was tripped since last call to
   				 ClearAllMoldyBits
   Returns     - TRUE If it has not been touched yet.
                 FALSE otherwise.
   ======================================================================== */

BOOL IsBlockMoldy(SHORT iBlk)
{
	SHORT iHandle;
#if RES_MANAGER
	if (IsResourceHandle(iBlk))
	{
	#if fUSE_RES_FILES
		SHORT iResBlk = GetResourceHandleBlk(iHandle);
	
		if (iResBlock[iResBlk] == 0 && giResFileName[iResBlk] != 0)
		{
			return FALSE;
		}
	#endif
		iHandle = Query_iResBlock(iBlk);	// Convert a resource handle to a memory handle.
	}
	else
#endif
	{
		iHandle = iBlk;
	}
	
	if (CheckValidBlock(iHandle, __LINE__) == fERROR)
		return FALSE;

#if defined (MEMORY_CHK)
	ReportBlockError(iHandle,CheckBlockOverwrite(iHandle));
#endif
	
	// If we touched it this time or last time its not moldy.
	if ((abBlockAttr[iHandle] & MOLDYBIT) || (abBlockAttr[iHandle] & MOLDYBITLASTTIME))
		return FALSE;
	
	return TRUE;
}

/* ========================================================================
   Function    - IsBlockPurgable
   Description - Test if the Purgable bit is set
   Returns     - TRUE | FALSE
   ======================================================================== */

BOOL IsBlockPurgable(SHORT iBlk)
{
	SHORT iHandle;
	BOOL Result = FALSE;
	
#if RES_MANAGER
	if (IsResourceHandle(iBlk))
	{
	#if fUSE_RES_FILES
		SHORT iResBlk = GetResourceHandleBlk(iHandle);
	
		if (iResBlock[iResBlk] == 0 && giResFileName[iResBlk] != 0)
		{
			Result = ((gResFlags[iResBlk] & RM_PURAGEBLE) == RM_PURAGEABLE)
			return Result;
		}
	#endif
		iHandle = Query_iResBlock(iBlk);	// Convert a resource handle to a memory handle.
	}
	else
#endif
	{
		iHandle = iBlk;
	}
	if (CheckValidBlock(iHandle, __LINE__) == fERROR)
		return Result;

#if defined (MEMORY_CHK)
	ReportBlockError(iHandle,CheckBlockOverwrite(iHandle));
#endif
	
	return ((abBlockAttr[iHandle] & PURGABLE) ? TRUE : FALSE);
}

/* ========================================================================
   Function    - IsBlockMultiUser
   Description - Test if this block is referenced by more than one thing.
   Returns     - TRUE | FALSE
   ======================================================================== */

BOOL IsBlockMultiUser(SHORT iBlk)
{
	BOOL Result = FALSE;
	SHORT iHandle;
#if RES_MANAGER
	if (IsResourceHandle(iBlk))
	{
	#if fUSE_RES_FILES
		SHORT iResBlk = GetResourceHandleBlk(iHandle);
	
		if (iResBlock[iResBlk] == 0 && giResFileName[iResBlk] != 0)
		{
			Result = ((gResFlags[iResBlk] & RM_MULTI_USER) == RM_MULTI_USER)
			return Result;
		}
	#endif
		iHandle = Query_iResBlock(iBlk);	// Convert a resource handle to a memory handle.
	}
	else
#endif
	{
		iHandle = iBlk;
	}
	if (CheckValidBlock(iHandle, __LINE__) == fERROR)
		return TRUE;	// Return TRUE so the resource manager won't try to purge it.

#if defined (MEMORY_CHK)
	ReportBlockError(iHandle,CheckBlockOverwrite(iHandle));
#endif
	
	return ((abBlockAttr[iHandle] & MULTI_USER_BIT) ? TRUE : FALSE);
}

#if defined(MEMORY_CHK)
#if CHECK_REALLY_OFTEN
/* ========================================================================
   Function    - ScanAllBlocks
   Description - Scan the entire list of headers to validate the data.
   Returns     -
   ======================================================================== */
static void ScanAllBlocks()
{
	SHORT iHandle;
	
	for (iHandle = aiNextBlk[START_BLOCK];
	     (abBlockAttr[iHandle] & BLKTYPEMASK) != ENDBLK;
	     iHandle = aiNextBlk[iHandle]
	    )
	{
		MEM_ERROR_CODE ErrorCode;
		LONG BlkBits = abBlockAttr[iHandle] & BLKTYPEMASK;
		
		
		if (BlkBits == BLKTYPE4 || 	// Check for external blks.
		    BlkBits == UNUSED ||
		    BlkBits == FREEMEM
		   )
		{
			continue;
		}
		
		ErrorCode = CheckBlockOverwrite(iHandle);
		if (ErrorCode != MEM_ERROR_FREE_BLOCK)
		{
			ReportBlockError(iHandle,ErrorCode);
		}
	}
}
#endif
#endif
#if defined(MEMORY_CHK)
/* ========================================================================
   Function    - SetBlockName
   Description - Add a name (Last N characters) to the name field of the
                 debug stucture.
   Returns     - The handle
   ======================================================================== */
SHORT SetBlockName( char * Name, SHORT iBlk)
{
	if (iBlk > 0)
	{
		MEMORY_DEBUG_INFO * pHeader;
		LONG	startIndex = 0;
		LONG	NameLen;
		SHORT	iHandle;
		
	#if RES_MANAGER
		if (IsResourceHandle(iBlk))
		{
		#if fUSE_RES_FILES
			SHORT iResBlk = GetResourceHandleBlk(iHandle);
		
			// Do nothing, we'll write the name in later.
			if (iResBlock[iResBlk] == 0 && giResFileName[iResBlk] != 0)
				return iBlk;
		#endif
			iHandle = Query_iResBlock(iBlk);	// Convert a resource handle to a memory handle.
			if ( iHandle <= 0 || iHandle > cNumBlkHeads)
				return iBlk;
		}
		else
		{
		    iHandle = iBlk;
		}
    #else
	    iHandle = iBlk;
	#endif
	
		pHeader = (MEMORY_DEBUG_INFO *)apBlocks[iHandle];
		
		// Now initialize the header marker.
		NameLen = strlen(Name);
		if (NameLen > MAX_HEADER_NAME_LEN)
		{
			startIndex = NameLen - MAX_HEADER_NAME_LEN;
		}
		
		strncpy(pHeader->BlockName, &Name[startIndex], MAX_HEADER_NAME_LEN);
		pHeader->BlockName[MAX_HEADER_NAME_LEN] = 0;
	}
	
	return iBlk;
}
#endif

#if defined(MEMORY_CHK)
/* ========================================================================
   Function    - SetDebugInfo
   Description - Write the File and line number in the debug structure.
   Returns     - The handle
   ======================================================================== */
SHORT SetDebugInfo(char * FileName, LONG LineNo, SHORT iBlk)
{
	if (iBlk > 0)
	{
		LONG	startIndex = 0;
		LONG	FileNameLen;
		MEMORY_DEBUG_INFO * pHeader;
		SHORT	iHandle;
		
	#if RES_MANAGER
		if (IsResourceHandle(iBlk))
		{
		#if fUSE_RES_FILES
			SHORT iResBlk = GetResourceHandleBlk(iHandle);
		
			// Do nothing, Sorry its purged out at this moment..
			if (iResBlock[iResBlk] == 0 && giResFileName[iResBlk] != 0)
				return iBlk;
		#endif
		
			iHandle = Query_iResBlock(iBlk);	// Convert a resource handle to a memory handle.
			if ( iHandle <= 0 || iHandle > cNumBlkHeads)
				return iBlk;
		}
		else
		{
		    iHandle = iBlk;
		}
    #else
	    iHandle = iBlk;
	#endif
	
		pHeader = (MEMORY_DEBUG_INFO *)apBlocks[iHandle];
		
		// Now initialize the header marker.
		FileNameLen = strlen(FileName);
		if (FileNameLen > MAX_HEADER_NAME_LEN)
		{
			startIndex = FileNameLen - MAX_HEADER_NAME_LEN;
		}
		
		strncpy(pHeader->FileName, &FileName[startIndex], MAX_HEADER_NAME_LEN);
		pHeader->FileName[MAX_HEADER_NAME_LEN] = 0;
		
		pHeader->FileLineNo	= LineNo;
	}
	
	return iBlk;
}

#endif

#if defined(MEMORY_CHK)
/* ========================================================================
   Function    - PrintUnFreedMemoryReport
   Description - Dump into a file all the blocks not released and some
                 information about them.
                 (Should help find memory leaks & miss-locked blocks.)
   Returns     - 
   ======================================================================== */

void PrintUnFreedMemoryReport()
{
	FILE	*fp;
	
	fp = fopen("inuseblk.txt", "w");
	if (fp)
	{
		ULONG	TotalSpaceInUse = 0;
		ULONG	Class1SpaceInUse = 0;
		ULONG	Class2SpaceInUse = 0;
		ULONG	TotalNumberOfHandles = 0;
		SHORT	iHandle;
		
		// Print File Header.
		fprintf(fp, "Non purgeable memory blocks still in use when the program quit.\n\n");
		fprintf(fp,"  Id     Size Locked Resource Moldy Class  FileName[LineNo] BlockName\n");
		fprintf(fp,"=====================================================================\n");
		
		for (iHandle = aiNextBlk[START_BLOCK];
		     (abBlockAttr[iHandle] & BLKTYPEMASK) != ENDBLK;
		     iHandle = aiNextBlk[iHandle]
		    )
		{
			MEM_ERROR_CODE ErrorCode;
			MEMORY_DEBUG_INFO * pHeader = (MEMORY_DEBUG_INFO *)apBlocks[iHandle];
			ULONG	SpaceThisBlock;
			
			if ((abBlockAttr[iHandle] & BLKTYPEMASK) == BLKTYPE4 || 	// Check for external blks.
			    (abBlockAttr[iHandle] & BLKTYPEMASK) == UNUSED ||
			    (abBlockAttr[iHandle] & BLKTYPEMASK) == FREEMEM ||
			    IsBlockPurgable(iHandle)
			   )
			{
				continue;
			}
			
			TotalNumberOfHandles++;
			
			ErrorCode = CheckBlockOverwrite(iHandle);
			switch (ErrorCode)
			{
			case MEM_ERROR_BAD_TAIL:
				fprintf(fp," ERROR! Tail Overwritten. Block Id = %d.\n", iHandle);
				fflush(fp);
				break;
			case MEM_ERROR_BAD_HEAD:
				fprintf(fp," ERROR! Head overwritten. Block Id = %d.\n", iHandle);
				fflush(fp);
				break;
			}
			
			SpaceThisBlock = GetDataBlkSize(iHandle);
			TotalSpaceInUse += SpaceThisBlock;
			
			fprintf(fp, "%4d %8ld",	iHandle, SpaceThisBlock);
			
			if (IsLocked(iHandle))
			{
				fprintf(fp, " LOCKED");
			}
			else
			{
				fprintf(fp, "       ");
			}
			
			if (IsResource(iHandle))
			{
				fprintf(fp, " RESOURCE");
			}
			else
			{
				fprintf(fp, "         ");
			}	
			
			if (IsBlockMoldy(iHandle))
			{
				fprintf(fp, " MOLDY");
			}
			else
			{
				fprintf(fp, "      ");
			}
			
			if (IsClass1(iHandle))
			{
				fprintf(fp, " CLASS1");
				Class1SpaceInUse += SpaceThisBlock;
			}
			else
			if (IsClass2(iHandle))
			{
				fprintf(fp, " CLASS2");
				Class2SpaceInUse += SpaceThisBlock;
			}
			else
			if (IsClassTemp(iHandle))
			{
				fprintf(fp, " CLASST");
			}
			else
			{
				fprintf(fp, "       ");
			}
			
			
		#if defined(MEMORY_CHK)
			fprintf(fp," %13s[%ld] %s", pHeader->FileName, pHeader->FileLineNo, pHeader->BlockName);
		#endif
				
			fprintf(fp, "\n");
			fflush(fp);
			
		}
		
		fprintf(fp, "\n");
		fprintf(fp,"Total space still in use = %lu\n", TotalSpaceInUse);
		fprintf(fp,"Total number of Handles used by this space = %lu\n", TotalNumberOfHandles);
		fprintf(fp, "\n");
		fprintf(fp,"Total class1 space still in use = %lu\n", Class1SpaceInUse);
		fprintf(fp,"Total class2 space still in use = %lu\n", Class2SpaceInUse);
		
		fclose(fp);
	}
}

#endif

/* ========================================================================
   Function    - IsPointerFlushed
   Description - Test whether the resource handle has been flushed.
   Returns     - TRUE || FALSE
   ======================================================================== */

BOOL IsHandleFlushed(LONG iHandle)
{
	void *ptr = BLKPTR(iHandle);
	
	return ( !IsPointerGood(ptr));
}

/* ======================================================================== */
