WATCOM Make Version 10.6
Copyright by WATCOM International Corp. 1988, 1996. All rights reserved.
WATCOM is a trademark of WATCOM International Corp.
	wpp386 -i=SOLAUDIO\INC -dWIN32 -d_WINDOWS -dSCENE_EDITOR -dAUDIO_LIB   -dMEMORY_CHK -d_VECTOR_CHK    -w3 -zq -pcl -ew .\winsys\ddraw.cpp
#line 1 ".\winsys\ddraw.cpp"
//
//              Copyright 1995/1996 by NW Synergistic Software, Inc.
//
//              DDraw.C  - handles all direct draw functionality.
//



#line 1 "C:\WATCOM\H\NT\windows.h"
/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) 1985-1995, Microsoft Corporation

Module Name:


    windows.h

Abstract:

    Master include file for Windows applications.

--*/





// WIN32#line 23 "C:\WATCOM\H\NT\windows.h"


// _WIN32





typedef long char wchar_t;
// _WCHAR_T_DEFINED_
// __cplusplus#line 40 "C:\WATCOM\H\NT\windows.h"






// _M_IX86#line 49 "C:\WATCOM\H\NT\windows.h"


struct _EXCEPTION_RECORD;
struct _CONTEXT;
struct _RTL_CRITICAL_SECTION;
struct tagCREATESTRUCTA;
struct tagCREATESTRUCTW;
// __WATCOMC__










/*  If defined, the following flags inhibit definition
 *     of the indicated items.
 *
 *  NOGDICAPMASKS     - CC_*, LC_*, PC_*, CP_*, TC_*, RC_
 *  NOVIRTUALKEYCODES - VK_*
 *  NOWINMESSAGES     - WM_*, EM_*, LB_*, CB_*
 *  NOWINSTYLES       - WS_*, CS_*, ES_*, LBS_*, SBS_*, CBS_*
 *  NOSYSMETRICS      - SM_*
 *  NOMENUS           - MF_*
 *  NOICONS           - IDI_*
 *  NOKEYSTATES       - MK_*
 *  NOSYSCOMMANDS     - SC_*
 *  NORASTEROPS       - Binary and Tertiary raster ops
 *  NOSHOWWINDOW      - SW_*
 *  OEMRESOURCE       - OEM Resource values
 *  NOATOM            - Atom Manager routines
 *  NOCLIPBOARD       - Clipboard routines
 *  NOCOLOR           - Screen colors
 *  NOCTLMGR          - Control and Dialog routines
 *  NODRAWTEXT        - DrawText() and DT_*
 *  NOGDI             - All GDI defines and routines
 *  NOKERNEL          - All KERNEL defines and routines
 *  NOUSER            - All USER defines and routines
 *  NONLS             - All NLS defines and routines
 *  NOMB              - MB_* and MessageBox()
 *  NOMEMMGR          - GMEM_*, LMEM_*, GHND, LHND, associated routines
 *  NOMETAFILE        - typedef METAFILEPICT
 *  NOMINMAX          - Macros min(a,b) and max(a,b)
 *  NOMSG             - typedef MSG and associated routines
 *  NOOPENFILE        - OpenFile(), OemToAnsi, AnsiToOem, and OF_*
 *  NOSCROLL          - SB_* and scrolling routines
 *  NOSERVICE         - All Service Controller routines, SERVICE_ equates, etc.
 *  NOSOUND           - Sound driver routines
 *  NOTEXTMETRIC      - typedef TEXTMETRIC and associated routines
 *  NOWH              - SetWindowsHook and WH_*
 *  NOWINOFFSETS      - GWL_*, GCL_*, associated routines
 *  NOCOMM            - COMM driver routines
 *  NOKANJI           - Kanji support stuff.
 *  NOHELP            - Help engine interface.
 *  NOPROFILER        - Profiler interface.
 *  NODEFERWINDOWPOS  - DeferWindowPos routines
 *  NOMCX             - Modem Configuration Extensions
 */

/* RC_INVOKED */#line 130 "C:\WATCOM\H\NT\windows.h"

#line 134 "C:\WATCOM\H\NT\windows.h"

#line 138 "C:\WATCOM\H\NT\windows.h"

#line 142 "C:\WATCOM\H\NT\windows.h"

#line 146 "C:\WATCOM\H\NT\windows.h"


#line 151 "C:\WATCOM\H\NT\windows.h"
#line 154 "C:\WATCOM\H\NT\windows.h"
#line 1 "C:\WATCOM\H\stdarg.h"
/*
 *  stdarg.h	Variable argument macros
 *		definitions for use with variable argument lists
 *
 *  Copyright by WATCOM International Corp. 1988-1996.  All rights reserved.
 */


extern "C" {


/* macros for MS compatibility */

 


 


 


#line 33 "C:\WATCOM\H\stdarg.h"
typedef char *va_list[1];











};


#line 154 "C:\WATCOM\H\NT\windows.h"

/* RC_INVOKED */

#line 1 "C:\WATCOM\H\NT\windef.h"
/****************************************************************************
*                                                                           *
* windef.h -- Basic Windows Type Definitions                                *
*                                                                           *
* Copyright (c) 1985-1995, Microsoft Corp. All rights reserved.             *
*                                                                           *
****************************************************************************/







extern "C" {


#line 21 "C:\WATCOM\H\NT\windef.h"


/*
 * BASETYPES is defined in ntdef.h if these types are already defined
 */



typedef unsigned long ULONG;
typedef ULONG *PULONG;
typedef unsigned short USHORT;
typedef USHORT *PUSHORT;
typedef unsigned char UCHAR;
typedef UCHAR *PUCHAR;
typedef char *PSZ;
/* !BASETYPES */






#line 46 "C:\WATCOM\H\NT\windef.h"






























#line 79 "C:\WATCOM\H\NT\windef.h"

#line 86 "C:\WATCOM\H\NT\windef.h"













#line 107 "C:\WATCOM\H\NT\windef.h"







typedef unsigned long       DWORD;
typedef int                 BOOL;
typedef unsigned char       BYTE;
typedef unsigned short      WORD;
typedef float               FLOAT;
typedef FLOAT               *PFLOAT;
typedef BOOL              *PBOOL;
typedef BOOL               *LPBOOL;
typedef BYTE              *PBYTE;
typedef BYTE               *LPBYTE;
typedef int               *PINT;
typedef int                *LPINT;
typedef WORD              *PWORD;
typedef WORD               *LPWORD;
typedef long               *LPLONG;
typedef DWORD             *PDWORD;
typedef DWORD              *LPDWORD;
typedef void               *LPVOID;
typedef  const  void         *LPCVOID;

typedef int                 INT;
typedef unsigned int        UINT;
typedef unsigned int        *PUINT;


#line 1 "C:\WATCOM\H\NT\winnt.h"
/*++ BUILD Version: 0093     Increment this if a change has global effects

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    winnt.h

Abstract:

    This module defines the 32-Bit Windows types and constants that are
    defined by NT, but exposed through the Win32 API.

Revision History:

--*/





extern "C" {


#line 1 "C:\WATCOM\H\ctype.h"
/*
 *  ctype.h	Character Handling
 *
 *  Copyright by WATCOM International Corp. 1988-1996.  All rights reserved.
 */


extern "C" {


/* macros for MS compatibility */
#line 15 "C:\WATCOM\H\ctype.h"
#line 18 "C:\WATCOM\H\ctype.h"
#line 21 "C:\WATCOM\H\ctype.h"

#line 37 "C:\WATCOM\H\ctype.h"

#line 47 "C:\WATCOM\H\ctype.h"










extern	int	isalnum(int);
extern	int	isalpha(int);
extern	int	iscntrl(int);
extern	int	isdigit(int);
extern	int	isgraph(int);
extern	int	islower(int);
extern	int	isprint(int);
extern	int	ispunct(int);
extern	int	isspace(int);
extern	int	isupper(int);
extern	int	isxdigit(int);
extern	int	tolower(int);
extern	int	_tolower(int);
extern	int	toupper(int);
extern	int	_toupper(int);
extern	int	__iscsymf(int);
extern	int	__iscsym(int);

/* extensions enabled */
 extern  int	isascii(int);
 extern  int	__isascii(int);
 
 


#line 85 "C:\WATCOM\H\ctype.h"
extern const char __near _IsTable[257];
















#line 118 "C:\WATCOM\H\ctype.h"



};


#line 25 "C:\WATCOM\H\NT\winnt.h"
  


#line 31 "C:\WATCOM\H\NT\winnt.h"



#line 37 "C:\WATCOM\H\NT\winnt.h"






#line 46 "C:\WATCOM\H\NT\winnt.h"

typedef void *PVOID;    



//
// Define API decoration for direct importing system DLL references.
//



#line 60 "C:\WATCOM\H\NT\winnt.h"


//
// Basics
//



typedef char CHAR;
typedef short SHORT;
typedef long LONG;


//
// UNICODE (Wide Character) types
//

typedef wchar_t WCHAR;    // wc,   16-bit UNICODE character 

typedef WCHAR *PWCHAR;
typedef WCHAR *LPWCH, *PWCH;
typedef  const  WCHAR *LPCWCH, *PCWCH;
typedef WCHAR *NWPSTR;
typedef WCHAR *LPWSTR, *PWSTR;

typedef  const  WCHAR *LPCWSTR, *PCWSTR;

//
// ANSI (Multi-byte Character) types
//
typedef CHAR *PCHAR;
typedef CHAR *LPCH, *PCH;

typedef  const  CHAR *LPCCH, *PCCH;
typedef CHAR *NPSTR;
typedef CHAR *LPSTR, *PSTR;
typedef  const  CHAR *LPCSTR, *PCSTR;

//
// Neutral ANSI/UNICODE types and macros
//
/* UNICODE */#line 116 "C:\WATCOM\H\NT\winnt.h"


typedef char TCHAR, *PTCHAR;
typedef unsigned char TBYTE , *PTBYTE ;

/* !_TCHAR_DEFINED */

typedef LPSTR LPTCH, PTCH;
typedef LPSTR PTSTR, LPTSTR;
typedef LPCSTR LPCTSTR;


/* UNICODE */






typedef SHORT *PSHORT;  
typedef LONG *PLONG;    

#line 142 "C:\WATCOM\H\NT\winnt.h"
typedef PVOID HANDLE;


typedef HANDLE *PHANDLE;

typedef char CCHAR;          
typedef DWORD LCID;         
typedef PDWORD PLCID;       
typedef WORD   LANGID;      
/*lint -e624 */  
/*lint +e624 */  






//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//

#line 175 "C:\WATCOM\H\NT\winnt.h"
typedef double LONGLONG;
typedef double DWORDLONG;


typedef LONGLONG *PLONGLONG;
typedef DWORDLONG *PDWORDLONG;

// Update Sequence Number

typedef LONGLONG USN;

// MIDL_PASS#line 189 "C:\WATCOM\H\NT\winnt.h"
typedef union _LARGE_INTEGER {
    struct {
        DWORD LowPart;
        LONG HighPart;
    };
    struct {
        DWORD LowPart;
        LONG HighPart;
    } u;
//MIDL_PASS
    LONGLONG QuadPart;
} LARGE_INTEGER;

typedef LARGE_INTEGER *PLARGE_INTEGER;


// MIDL_PASS#line 208 "C:\WATCOM\H\NT\winnt.h"
typedef union _ULARGE_INTEGER {
    struct {
        DWORD LowPart;
        DWORD HighPart;
    };
    struct {
        DWORD LowPart;
        DWORD HighPart;
    } u;
//MIDL_PASS
    DWORDLONG QuadPart;
} ULARGE_INTEGER;

typedef ULARGE_INTEGER *PULARGE_INTEGER;

// end_ntminiport end_ntndis

//
// Locally Unique Identifier
//

typedef LARGE_INTEGER LUID, *PLUID;


//
// Define operations to logically shift an int64 by 0..31 bits and to multiply
// 32-bits by 32-bits to form a 64-bit product.
//

#line 317 "C:\WATCOM\H\NT\winnt.h"



LONGLONG
Int32x32To64 (
    LONG Multiplier,
    LONG Multiplicand
    );

DWORDLONG
UInt32x32To64 (
    DWORD Multiplier,
    DWORD Multiplicand
    );

DWORDLONG
Int64ShllMod32 (
    DWORDLONG Value,
    DWORD ShiftCount
    );

LONGLONG
Int64ShraMod32 (
    LONGLONG Value,
    DWORD ShiftCount
    );

DWORDLONG
Int64ShrlMod32 (
    DWORDLONG Value,
    DWORD ShiftCount
    );

#pragma aux Int32x32To64 = \
    "imul edx" \
    parm [eax] [edx] \
    value no8087 [eax edx];

#pragma aux UInt32x32To64 = \
    "mul edx" \
    parm [eax] [edx] \
    value no8087 [eax edx];

#pragma aux Int64ShllMod32 = \
    "shld edx,eax,cl" \
    "shl eax,cl" \
    parm [eax edx] [ecx] \
    modify exact [eax edx] \
    value no8087 [eax edx];

#pragma aux Int64ShraMod32 = \
    "shrd eax,edx,cl" \
    "sar edx,cl" \
    parm [eax edx] [ecx] \
    modify exact [eax edx] \
    value no8087 [eax edx];

#pragma aux Int64ShrlMod32 = \
    "shrd eax,edx,cl" \
    "shr edx,cl" \
    parm [eax edx] [ecx] \
    modify exact [eax edx] \
    value no8087 [eax edx];

#line 477 "C:\WATCOM\H\NT\winnt.h"

#line 509 "C:\WATCOM\H\NT\winnt.h"


typedef BYTE  BOOLEAN;           
typedef BOOLEAN *PBOOLEAN;       
//
//  Doubly linked list structure.  Can be used as either a list head, or
//  as link words.
//

typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY, *   PRLIST_ENTRY;

//
//  Singly linked list structure. Can be used as either a list head, or
//  as link words.
//

typedef struct _SINGLE_LIST_ENTRY {
    struct _SINGLE_LIST_ENTRY *Next;
} SINGLE_LIST_ENTRY, *PSINGLE_LIST_ENTRY;

//
// Base data structures for OLE support
//




typedef struct _GUID {          // size is 16 
    DWORD Data1;
    WORD   Data2;
    WORD   Data3;
    BYTE  Data4[8];
} GUID;

// !GUID_DEFINED




typedef struct  _OBJECTID {     // size is 20 
    GUID Lineage;
    DWORD Uniquifier;
} OBJECTID;
// !_OBJECTID_DEFINED










//
// Calculate the byte offset of a field in a structure of type type.
//




//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//





/*
 *  Language IDs.
 *
 *  The following two combinations of primary language ID and
 *  sublanguage ID have special semantics:
 *
 *    Primary Language ID   Sublanguage ID      Result
 *    -------------------   ---------------     ------------------------
 *    LANG_NEUTRAL          SUBLANG_NEUTRAL     Language neutral
 *    LANG_NEUTRAL          SUBLANG_DEFAULT     User default language
 *    LANG_NEUTRAL          SUBLANG_SYS_DEFAULT System default language
 */

/*
 *  Primary language IDs.
 */













































/*
 *  Sublanguage IDs.
 *
 *  The name immediately following SUBLANG_ dictates which primary
 *  language ID that sublanguage ID can be combined with to form a
 *  valid language ID.
 */
/* language neutral */
/* user default */
/* system default */

/* Arabic (Saudi Arabia) */
/* Arabic (Iraq) */
/* Arabic (Egypt) */
/* Arabic (Libya) */
/* Arabic (Algeria) */
/* Arabic (Morocco) */
/* Arabic (Tunisia) */
/* Arabic (Oman) */
/* Arabic (Yemen) */
/* Arabic (Syria) */
/* Arabic (Jordan) */
/* Arabic (Lebanon) */
/* Arabic (Kuwait) */
/* Arabic (United Arab Emirates) */
/* Arabic (Bahrain) */
/* Arabic (Qatar) */
/* Chinese (Taiwan) */
/* Chinese (PR China) */
/* Chinese (Hong Kong) */
/* Chinese (Singapore) */
/* Dutch */
/* Dutch (Belgian) */
/* English (USA) */
/* English (UK) */
/* English (Australian) */
/* English (Canadian) */
/* English (New Zealand) */
/* English (Irish) */
/* English (South Africa) */
/* English (Jamaica) */
/* English (Carribean) */
/* French */
/* French (Belgian) */
/* French (Canadian) */
/* French (Swiss) */
/* French (Luxembourg) */
/* German */
/* German (Swiss) */
/* German (Austrian) */
/* German (Luxembourg) */
/* German (Liechtenstein) */
/* Italian */
/* Italian (Swiss) */
/* Korean */
/* Korean (Johab) */
/* Norwegian (Bokmal) */
/* Norwegian (Nynorsk) */
/* Portuguese */
/* Portuguese (Brazilian) */
/* Spanish (Castilian) */
/* Spanish (Mexican) */
/* Spanish (Modern) */
/* Spanish (Guatemala) */
/* Spanish (Costa Rica) */
/* Spanish (Panama) */
/* Spanish (Dominican Republic) */
/* Spanish (Venezuela) */
/* Spanish (Colombia) */
/* Spanish (Peru) */
/* Spanish (Argentina) */
/* Spanish (Ecuador) */
/* Spanish (Chile) */
/* Spanish (Uruguay) */
/* Spanish (Paraguay) */
/* Spanish (Bolivia) */

/*
 *  Sorting IDs.
 *
 */
/* sorting default */

/* Japanese XJIS order */
/* Japanese Unicode order */

/* Chinese BIG5 order */
/* Chinese Unicode order */

/* Korean KSC order */
/* Korean Unicode order */


/*
 *  A language ID is a 16 bit value which is the combination of a
 *  primary language ID and a secondary language ID.  The bits are
 *  allocated as follows:
 *
 *       +-----------------------+-------------------------+
 *       |     Sublanguage ID    |   Primary Language ID   |
 *       +-----------------------+-------------------------+
 *        15                   10 9                       0   bit
 *
 *
 *  Language ID creation/extraction macros:
 *
 *    MAKELANGID    - construct language id from a primary language id and
 *                    a sublanguage id.
 *    PRIMARYLANGID - extract primary language id from a language id.
 *    SUBLANGID     - extract sublanguage id from a language id.
 */





/*
 *  A locale ID is a 32 bit value which is the combination of a
 *  language ID, a sort ID, and a reserved area.  The bits are
 *  allocated as follows:
 *
 *       +-------------+---------+-------------------------+
 *       |   Reserved  | Sort ID |      Language ID        |
 *       +-------------+---------+-------------------------+
 *        31         20 19     16 15                      0   bit
 *
 *
 *  Locale ID creation/extraction macros:
 *
 *    MAKELCID       - construct locale id from a language id and a sort id.
 *    LANGIDFROMLCID - extract language id from a locale id.
 *    SORTIDFROMLCID - extract sort id from a locale id.
 */








/*
 *  Default System and User IDs for language and locale.
 */








// begin_ntminiport begin_ntndis

//
// Macros used to eliminate compiler warning generated when formal
// parameters or local variables are not declared.
//
// Use DBG_UNREFERENCED_PARAMETER() when a parameter is not yet
// referenced but will be once the module is completely developed.
//
// Use DBG_UNREFERENCED_LOCAL_VARIABLE() when a local variable is not yet
// referenced but will be once the module is completely developed.
//
// Use UNREFERENCED_PARAMETER() if a parameter will never be referenced.
//
// DBG_UNREFERENCED_PARAMETER and DBG_UNREFERENCED_LOCAL_VARIABLE will
// eventually be made into a null macro to help determine whether there
// is unfinished work.
//






// lint or _lint#line 845 "C:\WATCOM\H\NT\winnt.h"



/*lint -save -e767 */  





























/*lint -restore */  

// Maximum number of wait objects

// Maximum times thread can be suspended
typedef DWORD KSPIN_LOCK;  

// _ALPHA_#line 1324 "C:\WATCOM\H\NT\winnt.h"


// _ALPHA_#line 1335 "C:\WATCOM\H\NT\winnt.h"




//
// Disable these two pramas that evaluate to "sti" "cli" on x86 so that driver
// writers to not leave them inadvertantly in their code.
//




#pragma warning(disable:4164)   // disable C4164 warning so that apps that 
                                // build with /Od don't get weird errors !

#pragma function(_enable)
#pragma function(_disable)


#pragma warning(default:4164)   // reenable C4164 warning 





//
//  Define the size of the 80387 save area, which is in the context frame.
//



//
// The following flags control the contents of the CONTEXT structure.
//



// this assumes that i386 and
// i486 have identical context records

// SS:SP, CS:IP, FLAGS, BP
// AX, BX, CX, DX, SI, DI
// DS, ES, FS, GS
// 387 state
// DB 0-3,6,7






typedef struct _FLOATING_SAVE_AREA {
    DWORD   ControlWord;
    DWORD   StatusWord;
    DWORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    BYTE    RegisterArea[ 80 ];
    DWORD   Cr0NpxState;
} FLOATING_SAVE_AREA;

typedef FLOATING_SAVE_AREA *PFLOATING_SAVE_AREA;

//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) is is used to constuct a call frame for APC delivery,
//  and 3) it is used in the user level thread creation routines.
//
//  The layout of the record conforms to a standard call frame.
//

typedef struct _CONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    DWORD ContextFlags;

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //

    DWORD   Dr0;
    DWORD   Dr1;
    DWORD   Dr2;
    DWORD   Dr3;
    DWORD   Dr6;
    DWORD   Dr7;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //

    FLOATING_SAVE_AREA FloatSave;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_SEGMENTS.
    //

    DWORD   SegGs;
    DWORD   SegFs;
    DWORD   SegEs;
    DWORD   SegDs;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //

    DWORD   Edi;
    DWORD   Esi;
    DWORD   Ebx;
    DWORD   Edx;
    DWORD   Ecx;
    DWORD   Eax;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //

    DWORD   Ebp;
    DWORD   Eip;
    DWORD   SegCs;              // MUST BE SANITIZED 
    DWORD   EFlags;             // MUST BE SANITIZED 
    DWORD   Esp;
    DWORD   SegSs;

} CONTEXT;



typedef CONTEXT *PCONTEXT;

// begin_ntminiport

//_X86_


typedef struct _LDT_ENTRY {
    WORD    LimitLow;
    WORD    BaseLow;
    union {
        struct {
            BYTE    BaseMid;
            BYTE    Flags1;     // Declare as bytes to avoid alignment 
            BYTE    Flags2;     // Problems. 
            BYTE    BaseHi;
        } Bytes;
        struct {
            DWORD   BaseMid : 8;
            DWORD   Type : 5;
            DWORD   Dpl : 2;
            DWORD   Pres : 1;
            DWORD   LimitHi : 4;
            DWORD   Sys : 1;
            DWORD   Reserved_0 : 1;
            DWORD   Default_Big : 1;
            DWORD   Granularity : 1;
            DWORD   BaseHi : 8;
        } Bits;
    } HighWord;
} LDT_ENTRY, *PLDT_ENTRY;


// MIPS#line 1694 "C:\WATCOM\H\NT\winnt.h"


// MIPS#line 1705 "C:\WATCOM\H\NT\winnt.h"


// _PPC_#line 1904 "C:\WATCOM\H\NT\winnt.h"


// _PPC_#line 1917 "C:\WATCOM\H\NT\winnt.h"

// Noncontinuable exception
// maximum number of exception parameters

//
// Exception record definition.
//

typedef struct _EXCEPTION_RECORD {
    /*lint -e18 */  // Don't complain about different definitions
    DWORD    ExceptionCode;
    /*lint +e18 */  // Resume checking for different definitions
    DWORD ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    DWORD ExceptionInformation[ 15 ];
    } EXCEPTION_RECORD;

typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;

//
// Typedef for pointer returned by exception_info()
//

typedef struct _EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;






















// begin_ntddk




// end_ntddk

// value that gets a thread to LowRealtime-1
// maximum thread base priority boost
// minimum thread base priority boost
// value that gets a thread to idle

typedef struct _QUOTA_LIMITS {
    DWORD PagedPoolLimit;
    DWORD NonPagedPoolLimit;
    DWORD MinimumWorkingSetSize;
    DWORD MaximumWorkingSetSize;
    DWORD PagefileLimit;
    LARGE_INTEGER TimeLimit;
} QUOTA_LIMITS;
typedef QUOTA_LIMITS *PQUOTA_LIMITS;

























typedef struct _MEMORY_BASIC_INFORMATION {
    PVOID BaseAddress;
    PVOID AllocationBase;
    DWORD AllocationProtect;
    DWORD RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;




































//
// Define access rights to files and directories
//

//
// The FILE_READ_DATA and FILE_WRITE_DATA constants are also defined in
// devioctl.h as FILE_READ_ACCESS and FILE_WRITE_ACCESS. The values for these
// constants *MUST* always be in sync.
// The values are redefined in devioctl.h because they must be available to
// both DOS and NT.
//

// file & pipe
// directory

// file & pipe
// directory

// file
// directory
// named pipe

// file & directory


// file & directory


// file
// directory

// directory

// all

// all



















































typedef PVOID PACCESS_TOKEN;            
typedef PVOID PSECURITY_DESCRIPTOR;     
typedef PVOID PSID;     
////////////////////////////////////////////////////////////////////////
//                                                                    //
//                             ACCESS MASK                            //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
//  Define the access mask as a longword sized structure divided up as
//  follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------+---------------+-------------------------------+
//      |G|G|G|G|Res'd|A| StandardRights|         SpecificRights        |
//      |R|W|E|A|     |S|               |                               |
//      +-+-------------+---------------+-------------------------------+
//
//      typedef struct _ACCESS_MASK {
//          WORD   SpecificRights;
//          BYTE  StandardRights;
//          BYTE  AccessSystemAcl : 1;
//          BYTE  Reserved : 3;
//          BYTE  GenericAll : 1;
//          BYTE  GenericExecute : 1;
//          BYTE  GenericWrite : 1;
//          BYTE  GenericRead : 1;
//      } ACCESS_MASK;
//      typedef ACCESS_MASK *PACCESS_MASK;
//
//  but to make life simple for programmer's we'll allow them to specify
//  a desired access mask by simply OR'ing together mulitple single rights
//  and treat an access mask as a DWORD.  For example
//
//      DesiredAccess = DELETE | READ_CONTROL
//
//  So we'll declare ACCESS_MASK as DWORD
//

// begin_ntddk begin_nthal begin_ntifs
typedef DWORD ACCESS_MASK;
typedef ACCESS_MASK *PACCESS_MASK;

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                             ACCESS TYPES                           //
//                                                                    //
////////////////////////////////////////////////////////////////////////


// begin_ntddk begin_nthal begin_ntifs
//
//  The following are masks for the predefined standard access types
//

















//
// AccessSystemAcl access type
//



//
// MaximumAllowed access type
//



//
//  These are the generic rights.
//







//
//  Define the generic mapping array.  This is used to denote the
//  mapping of each generic access right to a specific access mask.
//

typedef struct _GENERIC_MAPPING {
    ACCESS_MASK GenericRead;
    ACCESS_MASK GenericWrite;
    ACCESS_MASK GenericExecute;
    ACCESS_MASK GenericAll;
} GENERIC_MAPPING;
typedef GENERIC_MAPPING *PGENERIC_MAPPING;



////////////////////////////////////////////////////////////////////////
//                                                                    //
//                        LUID_AND_ATTRIBUTES                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//


#line 1 "C:\WATCOM\H\NT\pshpack4.h"
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pshpack4.h

Abstract:

    This file turns 4 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push)

#pragma pack(4)
#line 32 "C:\WATCOM\H\NT\pshpack4.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 2265 "C:\WATCOM\H\NT\winnt.h"


typedef struct _LUID_AND_ATTRIBUTES {
    LUID Luid;
    DWORD Attributes;
    } LUID_AND_ATTRIBUTES, * PLUID_AND_ATTRIBUTES;
typedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[ 1 ];
typedef LUID_AND_ATTRIBUTES_ARRAY *PLUID_AND_ATTRIBUTES_ARRAY;

#line 1 "C:\WATCOM\H\NT\poppack.h"
/*++

Copyright (c) 1990,95  Microsoft Corporation

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)
#line 33 "C:\WATCOM\H\NT\poppack.h"
#line 36 "C:\WATCOM\H\NT\poppack.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 2274 "C:\WATCOM\H\NT\winnt.h"



////////////////////////////////////////////////////////////////////////
//                                                                    //
//              Security Id     (SID)                                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//
// Pictorially the structure of an SID is as follows:
//
//         1   1   1   1   1   1
//         5   4   3   2   1   0   9   8   7   6   5   4   3   2   1   0
//      +---------------------------------------------------------------+
//      |      SubAuthorityCount        |Reserved1 (SBZ)|   Revision    |
//      +---------------------------------------------------------------+
//      |                   IdentifierAuthority[0]                      |
//      +---------------------------------------------------------------+
//      |                   IdentifierAuthority[1]                      |
//      +---------------------------------------------------------------+
//      |                   IdentifierAuthority[2]                      |
//      +---------------------------------------------------------------+
//      |                                                               |
//      +- -  -  -  -  -  -  -  SubAuthority[]  -  -  -  -  -  -  -  - -+
//      |                                                               |
//      +---------------------------------------------------------------+
//
//


// begin_ntifs

typedef struct _SID_IDENTIFIER_AUTHORITY {
    BYTE  Value[6];
} SID_IDENTIFIER_AUTHORITY, *PSID_IDENTIFIER_AUTHORITY;


typedef struct _SID {
   BYTE  Revision;
   BYTE  SubAuthorityCount;
   SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
// MIDL_PASS#line 2319 "C:\WATCOM\H\NT\winnt.h"
   DWORD SubAuthority[ 1 ];
// MIDL_PASS
} SID, *PISID;


// Current revision level

// Will change to around 6
                                                // in a future release.

typedef enum _SID_NAME_USE {
    SidTypeUser = 1,
    SidTypeGroup,
    SidTypeDomain,
    SidTypeAlias,
    SidTypeWellKnownGroup,
    SidTypeDeletedAccount,
    SidTypeInvalid,
    SidTypeUnknown
} SID_NAME_USE, *PSID_NAME_USE;

// end_ntifs

typedef struct _SID_AND_ATTRIBUTES {
    PSID Sid;
    DWORD Attributes;
    } SID_AND_ATTRIBUTES, * PSID_AND_ATTRIBUTES;

typedef SID_AND_ATTRIBUTES SID_AND_ATTRIBUTES_ARRAY[ 1 ];
typedef SID_AND_ATTRIBUTES_ARRAY *PSID_AND_ATTRIBUTES_ARRAY;



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Universal well-known SIDs                                               //
//                                                                         //
//     Null SID              S-1-0-0                                       //
//     World                 S-1-1-0                                       //
//     Local                 S-1-2-0                                       //
//     Creator Owner ID      S-1-3-0                                       //
//     Creator Group ID      S-1-3-1                                       //
//                                                                         //
//     (Non-unique IDs)      S-1-4                                         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

















/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// NT well-known SIDs                                                      //
//                                                                         //
//     NT Authority          S-1-5                                         //
//     Dialup                S-1-5-1                                       //
//                                                                         //
//     Network               S-1-5-2                                       //
//     Batch                 S-1-5-3                                       //
//     Interactive           S-1-5-4                                       //
//     Service               S-1-5-6                                       //
//     AnonymousLogon        S-1-5-7       (aka null logon session)        //
//                                                                         //
//     (Logon IDs)           S-1-5-5-X-Y                                   //
//                                                                         //
//     (NT non-unique IDs)   S-1-5-0x15-...                                //
//                                                                         //
//     (Built-in domain)     s-1-5-0x20                                    //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


// ntifs





















/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// well-known domain relative sub-authority values (RIDs)...               //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

// Well-known users ...






// well-known groups ...








// well-known aliases ...


















//
// Allocate the System Luid.  The first 1000 LUIDs are reserved.
// Use #999 here (0x3E7 = 999)
//



// end_ntifs

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                          User and Group related SID attributes     //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
// Group attributes
//









//
// User attributes
//

// (None yet defined.)




////////////////////////////////////////////////////////////////////////
//                                                                    //
//                         ACL  and  ACE                              //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
//  Define an ACL and the ACE format.  The structure of an ACL header
//  followed by one or more ACEs.  Pictorally the structure of an ACL header
//  is as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +-------------------------------+---------------+---------------+
//      |            AclSize            |      Sbz1     |  AclRevision  |
//      +-------------------------------+---------------+---------------+
//      |              Sbz2             |           AceCount            |
//      +-------------------------------+-------------------------------+
//
//  The current AclRevision is defined to be ACL_REVISION.
//
//  AclSize is the size, in bytes, allocated for the ACL.  This includes
//  the ACL header, ACES, and remaining free space in the buffer.
//
//  AceCount is the number of ACES in the ACL.
//

// begin_ntddk begin_ntifs
// This is the *current* ACL revision



// This is the history of ACL revisions.  Add a new one whenever
// ACL_REVISION is updated




typedef struct _ACL {
    BYTE  AclRevision;
    BYTE  Sbz1;
    WORD   AclSize;
    WORD   AceCount;
    WORD   Sbz2;
} ACL;
typedef ACL *PACL;

// end_ntddk

//
//  The structure of an ACE is a common ace header followed by ace type
//  specific data.  Pictorally the structure of the common ace header is
//  as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------+-------+-------+---------------+---------------+
//      |            AceSize            |    AceFlags   |     AceType   |
//      +---------------+-------+-------+---------------+---------------+
//
//  AceType denotes the type of the ace, there are some predefined ace
//  types
//
//  AceSize is the size, in bytes, of ace.
//
//  AceFlags are the Ace flags for audit and inheritance, defined shortly.

typedef struct _ACE_HEADER {
    BYTE  AceType;
    BYTE  AceFlags;
    WORD   AceSize;
} ACE_HEADER;
typedef ACE_HEADER *PACE_HEADER;

//
//  The following are the predefined ace types that go into the AceType
//  field of an Ace header.
//






//
//  The following are the inherit flags that go into the AceFlags field
//  of an Ace header.
//








//  The following are the currently defined ACE flags that go into the
//  AceFlags field of an ACE header.  Each ACE type has its own set of
//  AceFlags.
//
//  SUCCESSFUL_ACCESS_ACE_FLAG - used only with system audit and alarm ACE
//  types to indicate that a message is generated for successful accesses.
//
//  FAILED_ACCESS_ACE_FLAG - used only with system audit and alarm ACE types
//  to indicate that a message is generated for failed accesses.
//

//
//  SYSTEM_AUDIT and SYSTEM_ALARM AceFlags
//
//  These control the signaling of audit and alarms for success or failure.
//





//
//  We'll define the structure of the predefined ACE types.  Pictorally
//  the structure of the predefined ACE's is as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------+-------+-------+---------------+---------------+
//      |    AceFlags   | Resd  |Inherit|    AceSize    |     AceType   |
//      +---------------+-------+-------+---------------+---------------+
//      |                              Mask                             |
//      +---------------------------------------------------------------+
//      |                                                               |
//      +                                                               +
//      |                                                               |
//      +                              Sid                              +
//      |                                                               |
//      +                                                               +
//      |                                                               |
//      +---------------------------------------------------------------+
//
//  Mask is the access mask associated with the ACE.  This is either the
//  access allowed, access denied, audit, or alarm mask.
//
//  Sid is the Sid associated with the ACE.
//

//  The following are the four predefined ACE types.

//  Examine the AceType field in the Header to determine
//  which structure is appropriate to use for casting.


typedef struct _ACCESS_ALLOWED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_ALLOWED_ACE;

typedef ACCESS_ALLOWED_ACE *PACCESS_ALLOWED_ACE;

typedef struct _ACCESS_DENIED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_DENIED_ACE;
typedef ACCESS_DENIED_ACE *PACCESS_DENIED_ACE;

typedef struct _SYSTEM_AUDIT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_AUDIT_ACE;
typedef SYSTEM_AUDIT_ACE *PSYSTEM_AUDIT_ACE;

typedef struct _SYSTEM_ALARM_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_ALARM_ACE;
typedef SYSTEM_ALARM_ACE *PSYSTEM_ALARM_ACE;

// end_ntifs


//
//  The following declarations are used for setting and querying information
//  about and ACL.  First are the various information classes available to
//  the user.
//

typedef enum _ACL_INFORMATION_CLASS {
    AclRevisionInformation = 1,
    AclSizeInformation
} ACL_INFORMATION_CLASS;

//
//  This record is returned/sent if the user is requesting/setting the
//  AclRevisionInformation
//

typedef struct _ACL_REVISION_INFORMATION {
    DWORD AclRevision;
} ACL_REVISION_INFORMATION;
typedef ACL_REVISION_INFORMATION *PACL_REVISION_INFORMATION;

//
//  This record is returned if the user is requesting AclSizeInformation
//

typedef struct _ACL_SIZE_INFORMATION {
    DWORD AceCount;
    DWORD AclBytesInUse;
    DWORD AclBytesFree;
} ACL_SIZE_INFORMATION;
typedef ACL_SIZE_INFORMATION *PACL_SIZE_INFORMATION;


////////////////////////////////////////////////////////////////////////
//                                                                    //
//                             SECURITY_DESCRIPTOR                    //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//  Define the Security Descriptor and related data types.
//  This is an opaque data structure.
//

// begin_ntddk begin_ntifs
//
// Current security descriptor revision value
//




// end_ntddk

//
// Minimum length, in bytes, needed to build a security descriptor
// (NOTE: This must manually be kept consistent with the)
// (sizeof(SECURITY_DESCRIPTOR)                         )
//




typedef WORD   SECURITY_DESCRIPTOR_CONTROL, *PSECURITY_DESCRIPTOR_CONTROL;









//
//  Where:
//
//      SE_OWNER_DEFAULTED - This boolean flag, when set, indicates that the
//          SID pointed to by the Owner field was provided by a
//          defaulting mechanism rather than explicitly provided by the
//          original provider of the security descriptor.  This may
//          affect the treatment of the SID with respect to inheritence
//          of an owner.
//
//      SE_GROUP_DEFAULTED - This boolean flag, when set, indicates that the
//          SID in the Group field was provided by a defaulting mechanism
//          rather than explicitly provided by the original provider of
//          the security descriptor.  This may affect the treatment of
//          the SID with respect to inheritence of a primary group.
//
//      SE_DACL_PRESENT - This boolean flag, when set, indicates that the
//          security descriptor contains a discretionary ACL.  If this
//          flag is set and the Dacl field of the SECURITY_DESCRIPTOR is
//          null, then a null ACL is explicitly being specified.
//
//      SE_DACL_DEFAULTED - This boolean flag, when set, indicates that the
//          ACL pointed to by the Dacl field was provided by a defaulting
//          mechanism rather than explicitly provided by the original
//          provider of the security descriptor.  This may affect the
//          treatment of the ACL with respect to inheritence of an ACL.
//          This flag is ignored if the DaclPresent flag is not set.
//
//      SE_SACL_PRESENT - This boolean flag, when set,  indicates that the
//          security descriptor contains a system ACL pointed to by the
//          Sacl field.  If this flag is set and the Sacl field of the
//          SECURITY_DESCRIPTOR is null, then an empty (but present)
//          ACL is being specified.
//
//      SE_SACL_DEFAULTED - This boolean flag, when set, indicates that the
//          ACL pointed to by the Sacl field was provided by a defaulting
//          mechanism rather than explicitly provided by the original
//          provider of the security descriptor.  This may affect the
//          treatment of the ACL with respect to inheritence of an ACL.
//          This flag is ignored if the SaclPresent flag is not set.
//
//      SE_SELF_RELATIVE - This boolean flag, when set, indicates that the
//          security descriptor is in self-relative form.  In this form,
//          all fields of the security descriptor are contiguous in memory
//          and all pointer fields are expressed as offsets from the
//          beginning of the security descriptor.  This form is useful
//          for treating security descriptors as opaque data structures
//          for transmission in communication protocol or for storage on
//          secondary media.
//
//
//
// Pictorially the structure of a security descriptor is as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------------------------------------------------------+
//      |            Control            |Reserved1 (SBZ)|   Revision    |
//      +---------------------------------------------------------------+
//      |                            Owner                              |
//      +---------------------------------------------------------------+
//      |                            Group                              |
//      +---------------------------------------------------------------+
//      |                            Sacl                               |
//      +---------------------------------------------------------------+
//      |                            Dacl                               |
//      +---------------------------------------------------------------+
//
// In general, this data structure should be treated opaquely to ensure future
// compatibility.
//
//

typedef struct _SECURITY_DESCRIPTOR {
   BYTE  Revision;
   BYTE  Sbz1;
   SECURITY_DESCRIPTOR_CONTROL Control;
   PSID Owner;
   PSID Group;
   PACL Sacl;
   PACL Dacl;
   } SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;

// end_ntifs

// Where:
//
//     Revision - Contains the revision level of the security
//         descriptor.  This allows this structure to be passed between
//         systems or stored on disk even though it is expected to
//         change in the future.
//
//     Control - A set of flags which qualify the meaning of the
//         security descriptor or individual fields of the security
//         descriptor.
//
//     Owner - is a pointer to an SID representing an object's owner.
//         If this field is null, then no owner SID is present in the
//         security descriptor.  If the security descriptor is in
//         self-relative form, then this field contains an offset to
//         the SID, rather than a pointer.
//
//     Group - is a pointer to an SID representing an object's primary
//         group.  If this field is null, then no primary group SID is
//         present in the security descriptor.  If the security descriptor
//         is in self-relative form, then this field contains an offset to
//         the SID, rather than a pointer.
//
//     Sacl - is a pointer to a system ACL.  This field value is only
//         valid if the DaclPresent control flag is set.  If the
//         SaclPresent flag is set and this field is null, then a null
//         ACL  is specified.  If the security descriptor is in
//         self-relative form, then this field contains an offset to
//         the ACL, rather than a pointer.
//
//     Dacl - is a pointer to a discretionary ACL.  This field value is
//         only valid if the DaclPresent control flag is set.  If the
//         DaclPresent flag is set and this field is null, then a null
//         ACL (unconditionally granting access) is specified.  If the
//         security descriptor is in self-relative form, then this field
//         contains an offset to the ACL, rather than a pointer.
//



////////////////////////////////////////////////////////////////////////
//                                                                    //
//               Privilege Related Data Structures                    //
//                                                                    //
////////////////////////////////////////////////////////////////////////


// begin_ntddk begin_nthal begin_ntifs
//
// Privilege attributes
//





//
// Privilege Set Control flags
//



//
//  Privilege Set - This is defined for a privilege set of one.
//                  If more than one privilege is needed, then this structure
//                  will need to be allocated with more space.
//
//  Note: don't change this structure without fixing the INITIAL_PRIVILEGE_SET
//  structure (defined in se.h)
//

typedef struct _PRIVILEGE_SET {
    DWORD PrivilegeCount;
    DWORD Control;
    LUID_AND_ATTRIBUTES Privilege[ 1 ];
    } PRIVILEGE_SET, * PPRIVILEGE_SET;


////////////////////////////////////////////////////////////////////////
//                                                                    //
//               NT Defined Privileges                                //
//                                                                    //
////////////////////////////////////////////////////////////////////////



























////////////////////////////////////////////////////////////////////
//                                                                //
//           Security Quality Of Service                          //
//                                                                //
//                                                                //
////////////////////////////////////////////////////////////////////

// begin_ntddk begin_nthal begin_ntifs
//
// Impersonation Level
//
// Impersonation level is represented by a pair of bits in Windows.
// If a new impersonation level is added or lowest value is changed from
// 0 to something else, fix the Windows CreateFile call.
//

typedef enum _SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous,
    SecurityIdentification,
    SecurityImpersonation,
    SecurityDelegation
    } SECURITY_IMPERSONATION_LEVEL, * PSECURITY_IMPERSONATION_LEVEL;





// end_nthal
//
// Security Tracking Mode
//




typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE,
                    * PSECURITY_CONTEXT_TRACKING_MODE;



//
// Quality Of Service
//

typedef struct _SECURITY_QUALITY_OF_SERVICE {
    DWORD Length;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
    BOOLEAN EffectiveOnly;
    } SECURITY_QUALITY_OF_SERVICE, * PSECURITY_QUALITY_OF_SERVICE;


//
// Used to represent information related to a thread impersonation
//

typedef struct _SE_IMPERSONATION_STATE {
    PACCESS_TOKEN Token;
    BOOLEAN CopyOnOpen;
    BOOLEAN EffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL Level;
} SE_IMPERSONATION_STATE, *PSE_IMPERSONATION_STATE;


////////////////////////////////////////////////////////////////////
//                                                                //
//           Token Object Definitions                             //
//                                                                //
//                                                                //
////////////////////////////////////////////////////////////////////


//
// Token Specific Access Rights.
//

































// begin_ntifs
//
// Token Types
//

typedef enum _TOKEN_TYPE {
    TokenPrimary = 1,
    TokenImpersonation
    } TOKEN_TYPE;
typedef TOKEN_TYPE *PTOKEN_TYPE;

// end_ntifs

//
// Token Information Classes.
//


typedef enum _TOKEN_INFORMATION_CLASS {
    TokenUser = 1,
    TokenGroups,
    TokenPrivileges,
    TokenOwner,
    TokenPrimaryGroup,
    TokenDefaultDacl,
    TokenSource,
    TokenType,
    TokenImpersonationLevel,
    TokenStatistics
} TOKEN_INFORMATION_CLASS, *PTOKEN_INFORMATION_CLASS;

//
// Token information class structures
//


typedef struct _TOKEN_USER {
    SID_AND_ATTRIBUTES User;
} TOKEN_USER, *PTOKEN_USER;


typedef struct _TOKEN_GROUPS {
    DWORD GroupCount;
    SID_AND_ATTRIBUTES Groups[ 1 ];
} TOKEN_GROUPS, *PTOKEN_GROUPS;


typedef struct _TOKEN_PRIVILEGES {
    DWORD PrivilegeCount;
    LUID_AND_ATTRIBUTES Privileges[ 1 ];
} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;


typedef struct _TOKEN_OWNER {
    PSID Owner;
} TOKEN_OWNER, *PTOKEN_OWNER;


typedef struct _TOKEN_PRIMARY_GROUP {
    PSID PrimaryGroup;
} TOKEN_PRIMARY_GROUP, *PTOKEN_PRIMARY_GROUP;


typedef struct _TOKEN_DEFAULT_DACL {
    PACL DefaultDacl;
} TOKEN_DEFAULT_DACL, *PTOKEN_DEFAULT_DACL;


// begin_ntifs



typedef struct _TOKEN_SOURCE {
    CHAR SourceName[ 8 ];
    LUID SourceIdentifier;
} TOKEN_SOURCE, *PTOKEN_SOURCE;

// end_ntifs

typedef struct _TOKEN_STATISTICS {
    LUID TokenId;
    LUID AuthenticationId;
    LARGE_INTEGER ExpirationTime;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    DWORD DynamicCharged;
    DWORD DynamicAvailable;
    DWORD GroupCount;
    DWORD PrivilegeCount;
    LUID ModifiedId;
} TOKEN_STATISTICS, *PTOKEN_STATISTICS;


// begin_ntifs

typedef struct _TOKEN_CONTROL {
    LUID TokenId;
    LUID AuthenticationId;
    LUID ModifiedId;
    TOKEN_SOURCE TokenSource;
    } TOKEN_CONTROL, *PTOKEN_CONTROL;


typedef DWORD SECURITY_INFORMATION, *PSECURITY_INFORMATION;







//
// Image Format
//

#line 1 "C:\WATCOM\H\NT\pshpack1.h"
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pshpack1.h

Abstract:

    This file turns 1 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push)

#pragma pack(1)
#line 32 "C:\WATCOM\H\NT\pshpack1.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 3174 "C:\WATCOM\H\NT\winnt.h"


// MZ
// NE
// LE
// LE
// PE00

typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header 
    WORD   e_magic;                     // Magic number 
    WORD   e_cblp;                      // Bytes on last page of file 
    WORD   e_cp;                        // Pages in file 
    WORD   e_crlc;                      // Relocations 
    WORD   e_cparhdr;                   // Size of header in paragraphs 
    WORD   e_minalloc;                  // Minimum extra paragraphs needed 
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed 
    WORD   e_ss;                        // Initial (relative) SS value 
    WORD   e_sp;                        // Initial SP value 
    WORD   e_csum;                      // Checksum 
    WORD   e_ip;                        // Initial IP value 
    WORD   e_cs;                        // Initial (relative) CS value 
    WORD   e_lfarlc;                    // File address of relocation table 
    WORD   e_ovno;                      // Overlay number 
    WORD   e_res[4];                    // Reserved words 
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo) 
    WORD   e_oeminfo;                   // OEM information; e_oemid specific 
    WORD   e_res2[10];                  // Reserved words 
    LONG   e_lfanew;                    // File address of new exe header 
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_OS2_HEADER {      // OS/2 .EXE header 
    WORD   ne_magic;                    // Magic number 
    CHAR   ne_ver;                      // Version number 
    CHAR   ne_rev;                      // Revision number 
    WORD   ne_enttab;                   // Offset of Entry Table 
    WORD   ne_cbenttab;                 // Number of bytes in Entry Table 
    LONG   ne_crc;                      // Checksum of whole file 
    WORD   ne_flags;                    // Flag word 
    WORD   ne_autodata;                 // Automatic data segment number 
    WORD   ne_heap;                     // Initial heap allocation 
    WORD   ne_stack;                    // Initial stack allocation 
    LONG   ne_csip;                     // Initial CS:IP setting 
    LONG   ne_sssp;                     // Initial SS:SP setting 
    WORD   ne_cseg;                     // Count of file segments 
    WORD   ne_cmod;                     // Entries in Module Reference Table 
    WORD   ne_cbnrestab;                // Size of non-resident name table 
    WORD   ne_segtab;                   // Offset of Segment Table 
    WORD   ne_rsrctab;                  // Offset of Resource Table 
    WORD   ne_restab;                   // Offset of resident name table 
    WORD   ne_modtab;                   // Offset of Module Reference Table 
    WORD   ne_imptab;                   // Offset of Imported Names Table 
    LONG   ne_nrestab;                  // Offset of Non-resident Names Table 
    WORD   ne_cmovent;                  // Count of movable entries 
    WORD   ne_align;                    // Segment alignment shift count 
    WORD   ne_cres;                     // Count of resource segments 
    BYTE   ne_exetyp;                   // Target Operating system 
    BYTE   ne_flagsothers;              // Other .EXE flags 
    WORD   ne_pretthunks;               // offset to return thunks 
    WORD   ne_psegrefbytes;             // offset to segment ref. bytes 
    WORD   ne_swaparea;                 // Minimum code swap area size 
    WORD   ne_expver;                   // Expected Windows version number 
  } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;

typedef struct _IMAGE_VXD_HEADER {      // Windows VXD header 
    WORD   e32_magic;                   // Magic number 
    BYTE   e32_border;                  // The byte ordering for the VXD 
    BYTE   e32_worder;                  // The word ordering for the VXD 
    DWORD  e32_level;                   // The EXE format level for now = 0 
    WORD   e32_cpu;                     // The CPU type 
    WORD   e32_os;                      // The OS type 
    DWORD  e32_ver;                     // Module version 
    DWORD  e32_mflags;                  // Module flags 
    DWORD  e32_mpages;                  // Module # pages 
    DWORD  e32_startobj;                // Object # for instruction pointer 
    DWORD  e32_eip;                     // Extended instruction pointer 
    DWORD  e32_stackobj;                // Object # for stack pointer 
    DWORD  e32_esp;                     // Extended stack pointer 
    DWORD  e32_pagesize;                // VXD page size 
    DWORD  e32_lastpagesize;            // Last page size in VXD 
    DWORD  e32_fixupsize;               // Fixup section size 
    DWORD  e32_fixupsum;                // Fixup section checksum 
    DWORD  e32_ldrsize;                 // Loader section size 
    DWORD  e32_ldrsum;                  // Loader section checksum 
    DWORD  e32_objtab;                  // Object table offset 
    DWORD  e32_objcnt;                  // Number of objects in module 
    DWORD  e32_objmap;                  // Object page map offset 
    DWORD  e32_itermap;                 // Object iterated data map offset 
    DWORD  e32_rsrctab;                 // Offset of Resource Table 
    DWORD  e32_rsrccnt;                 // Number of resource entries 
    DWORD  e32_restab;                  // Offset of resident name table 
    DWORD  e32_enttab;                  // Offset of Entry Table 
    DWORD  e32_dirtab;                  // Offset of Module Directive Table 
    DWORD  e32_dircnt;                  // Number of module directives 
    DWORD  e32_fpagetab;                // Offset of Fixup Page Table 
    DWORD  e32_frectab;                 // Offset of Fixup Record Table 
    DWORD  e32_impmod;                  // Offset of Import Module Name Table 
    DWORD  e32_impmodcnt;               // Number of entries in Import Module Name Table 
    DWORD  e32_impproc;                 // Offset of Import Procedure Name Table 
    DWORD  e32_pagesum;                 // Offset of Per-Page Checksum Table 
    DWORD  e32_datapage;                // Offset of Enumerated Data Pages 
    DWORD  e32_preload;                 // Number of preload pages 
    DWORD  e32_nrestab;                 // Offset of Non-resident Names Table 
    DWORD  e32_cbnrestab;               // Size of Non-resident Name Table 
    DWORD  e32_nressum;                 // Non-resident Name Table Checksum 
    DWORD  e32_autodata;                // Object # for automatic data object 
    DWORD  e32_debuginfo;               // Offset of the debugging information 
    DWORD  e32_debuglen;                // The length of the debugging info. in bytes 
    DWORD  e32_instpreload;             // Number of instance pages in preload section of VXD file 
    DWORD  e32_instdemand;              // Number of instance pages in demand load section of VXD file 
    DWORD  e32_heapsize;                // Size of heap - for 16-bit apps 
    BYTE   e32_res3[12];                // Reserved words 
    DWORD  e32_winresoff;
    DWORD  e32_winreslen;
    WORD   e32_devid;                   // Device ID for VxD 
    WORD   e32_ddkver;                  // DDK version for VxD 
  } IMAGE_VXD_HEADER, *PIMAGE_VXD_HEADER;

//
// File header format.
//

typedef struct _IMAGE_FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;



// Relocation info stripped from file.
// File is executable  (i.e. no unresolved externel references).
// Line nunbers stripped from file.
// Local symbols stripped from file.
// Bytes of machine word are reversed.
// 32 bit word machine.
// Debugging info stripped from file in .DBG file
// System File.
// File is a DLL.
// Bytes of machine word are reversed.


// Intel 386.
// MIPS little-endian, 0x160 big-endian
// MIPS little-endian
// MIPS little-endian
// Alpha_AXP
// IBM PowerPC Little-Endian

//
// Directory format.
//

typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;



//
// Optional header format.
//

typedef struct _IMAGE_OPTIONAL_HEADER {
    //
    // Standard fields.
    //

    WORD    Magic;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;
    DWORD   BaseOfCode;
    DWORD   BaseOfData;

    //
    // NT additional fields.
    //

    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Reserved1;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[ 16 ];
} IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;

typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
    WORD   Magic;
    BYTE   MajorLinkerVersion;
    BYTE   MinorLinkerVersion;
    DWORD  SizeOfCode;
    DWORD  SizeOfInitializedData;
    DWORD  SizeOfUninitializedData;
    DWORD  AddressOfEntryPoint;
    DWORD  BaseOfCode;
    DWORD  BaseOfData;
    DWORD  BaseOfBss;
    DWORD  GprMask;
    DWORD  CprMask[4];
    DWORD  GpValue;
} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;








typedef struct _IMAGE_NT_HEADERS {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER OptionalHeader;
} IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;

typedef struct _IMAGE_ROM_HEADERS {
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;








// Subsystem Values

// Unknown subsystem.
// Image doesn't require a subsystem.
// Image runs in the Windows GUI subsystem.
// Image runs in the Windows character subsystem.
// image runs in the OS/2 character subsystem.
// image run  in the Posix character subsystem.


// Directory Entries

// Export Directory
// Import Directory
// Resource Directory
// Exception Directory
// Security Directory
// Base Relocation Table
// Debug Directory
// Description String
// Machine Value (MIPS GP)
// TLS Directory
// Load Configuration Directory
// Bound Import Directory in headers
// Import Address Table

//
// Section header format.
//



typedef struct _IMAGE_SECTION_HEADER {
    BYTE    Name[ 8 ];
    union {
            DWORD   PhysicalAddress;
            DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;



//
// Section characteristics.
//

//      IMAGE_SCN_TYPE_REG                   0x00000000  // Reserved.
//      IMAGE_SCN_TYPE_DSECT                 0x00000001  // Reserved.
//      IMAGE_SCN_TYPE_NOLOAD                0x00000002  // Reserved.
//      IMAGE_SCN_TYPE_GROUP                 0x00000004  // Reserved.
// Reserved.
//      IMAGE_SCN_TYPE_COPY                  0x00000010  // Reserved.

// Section contains code.
// Section contains initialized data.
// Section contains uninitialized data.

// Reserved.
// Section contains comments or some other type of information.
//      IMAGE_SCN_TYPE_OVER                  0x00000400  // Reserved.
// Section contents will not become part of image.
// Section contents comdat.
//                                           0x00002000  // Reserved.

//      IMAGE_SCN_MEM_PROTECTED - Obsolete   0x00004000

//      IMAGE_SCN_MEM_SYSHEAP  - Obsolete    0x00010000





//
//
//
//
// Default alignment if no others are specified.
//
//
// Unused                                    0x00800000

// Section contains extended relocations.
// Section can be discarded.
// Section is not cachable.
// Section is not pageable.
// Section is shareable.
// Section is executable.
// Section is readable.
// Section is writeable.

//
// Symbol format.
//

typedef struct _IMAGE_SYMBOL {
    union {
        BYTE    ShortName[8];
        struct {
            DWORD   Short;     // if 0, use LongName 
            DWORD   Long;      // offset into string table 
        } Name;
        PBYTE   LongName[2];
    } N;
    DWORD   Value;
    SHORT   SectionNumber;
    WORD    Type;
    BYTE    StorageClass;
    BYTE    NumberOfAuxSymbols;
} IMAGE_SYMBOL;
typedef IMAGE_SYMBOL    *PIMAGE_SYMBOL;



//
// Section values.
//
// Symbols have a section number of the section in which they are
// defined. Otherwise, section numbers have the following meanings:
//

// Symbol is undefined or is common.
// Symbol is an absolute value.
// Symbol is a special debug item.

//
// Type (fundamental) values.
//

// no type.
//
// type character.
// type short integer.
//
//
//
//
//
//
// enumeration.
// member of enumeration.
//
//
//
//
//

//
// Type (derived) values.
//

// no derived type.
// pointer.
// function.
// array.

//
// Storage classes.
//






















//





// new



// type packing constants








// MACROS

// Basic Type of  x


// Is x a pointer?




// Is x a function?




// Is x an array?





// Is x a structure, union, or enumeration TAG?











//
// Auxiliary entry format.
//

typedef union _IMAGE_AUX_SYMBOL {
    struct {
        DWORD    TagIndex;                      // struct, union, or enum tag index 
        union {
            struct {
                WORD    Linenumber;             // declaration line number 
                WORD    Size;                   // size of struct, union, or enum 
            } LnSz;
           DWORD    TotalSize;
        } Misc;
        union {
            struct {                            // if ISFCN, tag, or .bb 
                DWORD    PointerToLinenumber;
                DWORD    PointerToNextFunction;
            } Function;
            struct {                            // if ISARY, up to 4 dimen. 
                WORD     Dimension[4];
            } Array;
        } FcnAry;
        WORD    TvIndex;                        // tv index 
    } Sym;
    struct {
        BYTE    Name[ 18 ];
    } File;
    struct {
        DWORD   Length;                         // section length 
        WORD    NumberOfRelocations;            // number of relocation entries 
        WORD    NumberOfLinenumbers;            // number of line numbers 
        DWORD   CheckSum;                       // checksum for communal 
        SHORT   Number;                         // section number to associate with 
        BYTE    Selection;                      // communal selection type 
    } Section;
} IMAGE_AUX_SYMBOL;
typedef IMAGE_AUX_SYMBOL    *PIMAGE_AUX_SYMBOL;



//
// Communal selection types.
//













//
// Relocation format.
//

typedef struct _IMAGE_RELOCATION {
    union {
        DWORD   VirtualAddress;
        DWORD   RelocCount;             // Set to the real count when IMAGE_SCN_LNK_NRELOC_OVFL is set 
    };
    DWORD   SymbolTableIndex;
    WORD    Type;
} IMAGE_RELOCATION;
typedef IMAGE_RELOCATION    *PIMAGE_RELOCATION;



//
// I386 relocation types.
//

// Reference is absolute, no relocation is necessary
// Direct 16-bit reference to the symbols virtual address
// PC-relative 16-bit reference to the symbols virtual address
// Direct 32-bit reference to the symbols virtual address
// Direct 32-bit reference to the symbols virtual address, base not included
// Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address


// PC-relative 32-bit reference to the symbols virtual address

//
// MIPS relocation types.
//

// Reference is absolute, no relocation is necessary









// Low 16-bit section relative referemce (used for >32k TLS)
// High 16-bit section relative reference (used for >32k TLS)



//
// Alpha Relocation types.
//


















// Low 16-bit section relative reference
// High 16-bit section relative reference

//
// IBM PowerPC relocation types.
//

// NOP
// 64-bit address
// 32-bit address
// 26-bit address, shifted left 2 (branch absolute)
// 16-bit address
// 16-bit address, shifted left 2 (load doubleword)
// 26-bit PC-relative offset, shifted left 2 (branch relative)
// 16-bit PC-relative offset, shifted left 2 (br cond relative)
// 16-bit offset from TOC base
// 16-bit offset from TOC base, shifted left 2 (load doubleword)

// 32-bit addr w/o image base
// va of containing section (as in an image sectionhdr)
// sectionheader number
// substitute TOC restore instruction iff symbol is glue code
// symbol is glue code; virtual address is TOC restore instruction
// va of containing section (limited to 16 bits)




// mask to isolate above values in IMAGE_RELOCATION.Type

// Flag bits in IMAGE_RELOCATION.TYPE

// subtract reloc value rather than adding it
// fix branch prediction bit to predict branch taken
// fix branch prediction bit to predict branch not taken
// toc slot defined in file (or, data in toc)

//
// Based relocation format.
//

typedef struct _IMAGE_BASE_RELOCATION {
    DWORD   VirtualAddress;
    DWORD   SizeOfBlock;
//  WORD    TypeOffset[1];
} IMAGE_BASE_RELOCATION, *PIMAGE_BASE_RELOCATION;



//
// Based relocation types.
//








//
// Line number format.
//

typedef struct _IMAGE_LINENUMBER {
    union {
        DWORD   SymbolTableIndex;               // Symbol table index of function name if Linenumber is 0. 
        DWORD   VirtualAddress;                 // Virtual address of line number. 
    } Type;
    WORD    Linenumber;                         // Line number. 
} IMAGE_LINENUMBER;
typedef IMAGE_LINENUMBER    *PIMAGE_LINENUMBER;



//
// Archive format.
//








typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
    BYTE     Name[16];                          // File member name - `/' terminated. 
    BYTE     Date[12];                          // File member date - decimal. 
    BYTE     UserID[6];                         // File member user id - decimal. 
    BYTE     GroupID[6];                        // File member group id - decimal. 
    BYTE     Mode[8];                           // File member mode - octal. 
    BYTE     Size[10];                          // File member size - decimal. 
    BYTE     EndHeader[2];                      // String to end header. 
} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;



//
// DLL support.
//

//
// Export Format
//

typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Name;
    DWORD   Base;
    DWORD   NumberOfFunctions;
    DWORD   NumberOfNames;
    PDWORD  *AddressOfFunctions;
    PDWORD  *AddressOfNames;
    PWORD   *AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

//
// Import Format
//

typedef struct _IMAGE_IMPORT_BY_NAME {
    WORD    Hint;
    BYTE    Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;

typedef struct _IMAGE_THUNK_DATA {
    union {
        PBYTE  ForwarderString;
        PDWORD Function;
        DWORD Ordinal;
        PIMAGE_IMPORT_BY_NAME AddressOfData;
    } u1;
} IMAGE_THUNK_DATA, *PIMAGE_THUNK_DATA;





typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD   Characteristics;                // 0 for terminating null import descriptor 
        PIMAGE_THUNK_DATA OriginalFirstThunk;   // RVA to original unbound IAT 
    };
    DWORD   TimeDateStamp;                  // 0 if not bound, 
                                            // -1 if bound, and real date\time stamp
                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                                            // O.W. date/time stamp of DLL bound to (Old BIND)

    DWORD   ForwarderChain;                 // -1 if no forwarders 
    DWORD   Name;
    PIMAGE_THUNK_DATA FirstThunk;           // RVA to IAT (if bound this IAT has actual addresses) 
} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;

//
// New format import descriptors pointed to by DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ]
//

typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {
    DWORD   TimeDateStamp;
    WORD    OffsetModuleName;
    WORD    NumberOfModuleForwarderRefs;
// Array of zero or more IMAGE_BOUND_FORWARDER_REF follows
} IMAGE_BOUND_IMPORT_DESCRIPTOR, *PIMAGE_BOUND_IMPORT_DESCRIPTOR;

typedef struct _IMAGE_BOUND_FORWARDER_REF {
    DWORD   TimeDateStamp;
    WORD    OffsetModuleName;
    WORD    Reserved;
} IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF;


//
// Thread Local Storage
//

typedef  void 
( __stdcall  *PIMAGE_TLS_CALLBACK) (
    PVOID DllHandle,
    DWORD Reason,
    PVOID Reserved
    );

typedef struct _IMAGE_TLS_DIRECTORY {
    DWORD   StartAddressOfRawData;
    DWORD   EndAddressOfRawData;
    PDWORD  AddressOfIndex;
    PIMAGE_TLS_CALLBACK *AddressOfCallBacks;
    DWORD   SizeOfZeroFill;
    DWORD   Characteristics;
} IMAGE_TLS_DIRECTORY, *PIMAGE_TLS_DIRECTORY;


//
// Resource Format.
//

//
// Resource directory consists of two counts, following by a variable length
// array of directory entries.  The first count is the number of entries at
// beginning of the array that have actual names associated with each entry.
// The entries are in ascending order, case insensitive strings.  The second
// count is the number of entries that immediately follow the named entries.
// This second count identifies the number of entries that have 16-bit integer
// Ids as their name.  These entries are also sorted in ascending order.
//
// This structure allows fast lookup by either name or number, but for any
// given resource entry only one form of lookup is supported, not both.
// This is consistant with the syntax of the .RC file and the .RES file.
//

typedef struct _IMAGE_RESOURCE_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    WORD    NumberOfNamedEntries;
    WORD    NumberOfIdEntries;
//  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];
} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;




//
// Each directory contains the 32-bit Name of the entry and an offset,
// relative to the beginning of the resource directory of the data associated
// with this directory entry.  If the name of the entry is an actual text
// string instead of an integer Id, then the high order bit of the name field
// is set to one and the low order 31-bits are an offset, relative to the
// beginning of the resource directory of the string, which is of type
// IMAGE_RESOURCE_DIRECTORY_STRING.  Otherwise the high bit is clear and the
// low-order 16-bits are the integer Id that identify this resource directory
// entry. If the directory entry is yet another resource directory (i.e. a
// subdirectory), then the high order bit of the offset field will be
// set to indicate this.  Otherwise the high bit is clear and the offset
// field points to a resource data entry.
//

typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union {
        struct {
            DWORD NameOffset:31;
            DWORD NameIsString:1;
        };
        DWORD   Name;
        WORD    Id;
    };
    union {
        DWORD   OffsetToData;
        struct {
            DWORD   OffsetToDirectory:31;
            DWORD   DataIsDirectory:1;
        };
    };
} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;

//
// For resource directory entries that have actual string names, the Name
// field of the directory entry points to an object of the following type.
// All of these string objects are stored together after the last resource
// directory entry and before the first resource data object.  This minimizes
// the impact of these variable length objects on the alignment of the fixed
// size directory entry objects.
//

typedef struct _IMAGE_RESOURCE_DIRECTORY_STRING {
    WORD    Length;
    CHAR    NameString[ 1 ];
} IMAGE_RESOURCE_DIRECTORY_STRING, *PIMAGE_RESOURCE_DIRECTORY_STRING;


typedef struct _IMAGE_RESOURCE_DIR_STRING_U {
    WORD    Length;
    WCHAR   NameString[ 1 ];
} IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;


//
// Each resource data entry describes a leaf node in the resource directory
// tree.  It contains an offset, relative to the beginning of the resource
// directory of the data for the resource, a size field that gives the number
// of bytes of data at that offset, a CodePage that should be used when
// decoding code point values within the resource data.  Typically for new
// applications the code page would be the unicode code page.
//

typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
    DWORD   OffsetToData;
    DWORD   Size;
    DWORD   CodePage;
    DWORD   Reserved;
} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;

//
// Load Configuration Directory Entry
//

typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   GlobalFlagsClear;
    DWORD   GlobalFlagsSet;
    DWORD   CriticalSectionDefaultTimeout;
    DWORD   DeCommitFreeBlockThreshold;
    DWORD   DeCommitTotalFreeThreshold;
    PVOID   LockPrefixTable;
    DWORD   MaximumAllocationSize;
    DWORD   VirtualMemoryThreshold;
    DWORD   ProcessHeapFlags;
    DWORD   Reserved[ 4 ];
} IMAGE_LOAD_CONFIG_DIRECTORY, *PIMAGE_LOAD_CONFIG_DIRECTORY;


//
// Function table entry format for MIPS/ALPHA images.  Function table is
// pointed to by the IMAGE_DIRECTORY_ENTRY_EXCEPTION directory entry.
// This definition duplicates ones in ntmips.h and ntalpha.h for use
// by portable image file mungers.
//

typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    PVOID ExceptionHandler;
    PVOID HandlerData;
    DWORD PrologEndAddress;
} IMAGE_RUNTIME_FUNCTION_ENTRY, *PIMAGE_RUNTIME_FUNCTION_ENTRY;

//
// Debug Format
//

typedef struct _IMAGE_DEBUG_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Type;
    DWORD   SizeOfData;
    DWORD   AddressOfRawData;
    DWORD   PointerToRawData;
} IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;











typedef struct _IMAGE_COFF_SYMBOLS_HEADER {
    DWORD   NumberOfSymbols;
    DWORD   LvaToFirstSymbol;
    DWORD   NumberOfLinenumbers;
    DWORD   LvaToFirstLinenumber;
    DWORD   RvaToFirstByteOfCode;
    DWORD   RvaToLastByteOfCode;
    DWORD   RvaToFirstByteOfData;
    DWORD   RvaToLastByteOfData;
} IMAGE_COFF_SYMBOLS_HEADER, *PIMAGE_COFF_SYMBOLS_HEADER;






typedef struct _FPO_DATA {
    DWORD       ulOffStart;             // offset 1st byte of function code 
    DWORD       cbProcSize;             // # bytes in function 
    DWORD       cdwLocals;              // # bytes in locals/4 
    WORD        cdwParams;              // # bytes in params/4 
    WORD        cbProlog : 8;           // # bytes in prolog 
    WORD        cbRegs   : 3;           // # regs saved 
    WORD        fHasSEH  : 1;           // TRUE if SEH in func 
    WORD        fUseBP   : 1;           // TRUE if EBP has been allocated 
    WORD        reserved : 1;           // reserved for future use 
    WORD        cbFrame  : 2;           // frame type 
} FPO_DATA, *PFPO_DATA;





typedef struct _IMAGE_DEBUG_MISC {
    DWORD       DataType;               // type of misc data, see defines 
    DWORD       Length;                 // total length of record, rounded to four 
                                        // byte multiple.
    BOOLEAN     Unicode;                // TRUE if data is unicode string 
    BYTE        Reserved[ 3 ];
    BYTE        Data[ 1 ];              // Actual data 
} IMAGE_DEBUG_MISC, *PIMAGE_DEBUG_MISC;


//
// Function table extracted from MIPS/ALPHA images.  Does not contain
// information needed only for runtime support.  Just those fields for
// each entry needed by a debugger.
//

typedef struct _IMAGE_FUNCTION_ENTRY {
    DWORD   StartingAddress;
    DWORD   EndingAddress;
    DWORD   EndOfPrologue;
} IMAGE_FUNCTION_ENTRY, *PIMAGE_FUNCTION_ENTRY;

//
// Debugging information can be stripped from an image file and placed
// in a separate .DBG file, whose file name part is the same as the
// image file name part (e.g. symbols for CMD.EXE could be stripped
// and placed in CMD.DBG).  This is indicated by the IMAGE_FILE_DEBUG_STRIPPED
// flag in the Characteristics field of the file header.  The beginning of
// the .DBG file contains the following structure which captures certain
// information from the image file.  This allows a debug to proceed even if
// the original image file is not accessable.  This header is followed by
// zero of more IMAGE_SECTION_HEADER structures, followed by zero or more
// IMAGE_DEBUG_DIRECTORY structures.  The latter structures and those in
// the image file contain file offsets relative to the beginning of the
// .DBG file.
//
// If symbols have been stripped from an image, the IMAGE_DEBUG_MISC structure
// is left in the image file, but not mapped.  This allows a debugger to
// compute the name of the .DBG file, from the name of the image in the
// IMAGE_DEBUG_MISC structure.
//

typedef struct _IMAGE_SEPARATE_DEBUG_HEADER {
    WORD        Signature;
    WORD        Flags;
    WORD        Machine;
    WORD        Characteristics;
    DWORD       TimeDateStamp;
    DWORD       CheckSum;
    DWORD       ImageBase;
    DWORD       SizeOfImage;
    DWORD       NumberOfSections;
    DWORD       ExportedNamesSize;
    DWORD       DebugDirectorySize;
    DWORD       Reserved[ 3 ];          // Note: reserved[0] is actually the section alignment 
} IMAGE_SEPARATE_DEBUG_HEADER, *PIMAGE_SEPARATE_DEBUG_HEADER;



#line 1 "C:\WATCOM\H\NT\poppack.h"
/*++

Copyright (c) 1990,95  Microsoft Corporation

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)
#line 33 "C:\WATCOM\H\NT\poppack.h"
#line 36 "C:\WATCOM\H\NT\poppack.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 4243 "C:\WATCOM\H\NT\winnt.h"


//
// End Image Format
//

//
// for move macros
//
#line 1 "C:\WATCOM\H\string.h"
/*
 *  string.h	String functions
 *
 *  Copyright by WATCOM International Corp. 1988-1996.  All rights reserved.
 */


extern "C" {


/* macros for MS compatibility */
#line 15 "C:\WATCOM\H\string.h"
#line 18 "C:\WATCOM\H\string.h"
#line 21 "C:\WATCOM\H\string.h"

#line 37 "C:\WATCOM\H\string.h"

#line 47 "C:\WATCOM\H\string.h"



 typedef unsigned size_t;


#line 60 "C:\WATCOM\H\string.h"

extern void *memchr( const void *__s, int __c, size_t __n );
extern int   memcmp( const void *__s1, const void *__s2, size_t __n );
extern void *memcpy( void *__s1, const void *__s2, size_t __n );
extern void *memmove( void *__s1, const void *__s2, size_t __n );
extern void *memset( void *__s, int __c, size_t __n );
extern char *strcat( char *__s1, const char *__s2 );
extern char *strchr( const char *__s, int __c );
extern int strcmp( const char *__s1, const char *__s2 );
extern int strcoll( const char *__s1, const char *__s2 );
extern size_t strxfrm( char *__s1, const char *__s2, size_t __n );
extern char *strcpy( char *__s1, const char *__s2 );
extern size_t strcspn( const char *__s1, const char *__s2 );
extern char *strerror( int __errnum );
extern size_t strlen( const char *__s );
extern char *strncat( char *__s1, const char *__s2, size_t __n );
extern int strncmp( const char *__s1, const char *__s2, size_t __n );
extern char *strncpy( char *__s1, const char *__s2, size_t __n );
extern char *strpbrk( const char *__s1, const char *__s2 );
extern char *strrchr( const char *__s, int __c );
extern size_t strspn( const char *__s1, const char *__s2 );
extern char *strstr( const char *__s1, const char *__s2 );
extern char *strtok( char *__s1, const char *__s2 );

/* extensions enabled */

/* WATCOM's Additional Functions (non-ANSI, non-POSIX) */


extern void __far *_fmemccpy(void __far *__s1,const void __far *__s2,int __c,size_t __n);


extern void __far *_fmemchr( const void __far *__s, int __c, size_t __n );


extern void __far *_fmemcpy( void __far *__s1, const void __far *__s2, size_t __n );


extern void __far *_fmemmove( void __far *__s1, const void __far *__s2, size_t __n );


extern void __far *_fmemset( void __far *__s, int __c, size_t __n );


extern int  _fmemcmp( const void __far *__s1, const void __far *__s2, size_t __n );


extern int  _fmemicmp( const void __far *__s1, const void __far *__s2, size_t __n );


extern char __far *_fstrcat( char __far *__s1, const char __far *__s2 );


extern char __far *_fstrchr( const char __far *__s, int __c );


extern int  _fstrcmp( const char __far *__s1, const char __far *__s2 );


extern char __far *_fstrcpy( char __far *__s1, const char __far *__s2 );


extern size_t _fstrcspn( const char __far *__s1, const char __far *__s2 );


extern char __far *_fstrdup( const char __far *__string );


extern int  _fstricmp( const char __far *__s1, const char __far *__s2 );


extern char __far *_fstrncat( char __far *__s1, const char __far *__s2, size_t __n );


extern size_t _fstrlen( const char __far *__s );


extern char __far *_fstrlwr( char __far *__string );


extern int  _fstrncmp( const char __far *__s1, const char __far *__s2, size_t __n );


extern char __far *_fstrncpy( char __far *__s1, const char __far *__s2, size_t __n );


extern int  _fstrnicmp( const char __far *__s1, const char __far *__s2, size_t __n );


extern char __far *_fstrnset( char __far *__string, int __c, size_t __len );


extern char __far *_fstrpbrk( const char __far *__s1, const char __far *__s2 );


extern char __far *_fstrrchr( const char __far *__s, int __c );


extern char __far *_fstrrev( char __far *__string );


extern char __far *_fstrset( char __far *__string, int __c );


extern size_t _fstrspn( const char __far *__s1, const char __far *__s2 );


extern char __far *_fstrstr( const char __far *__s1, const char __far *__s2 );


extern char __far *_fstrtok( char __far *__s1, const char __far *__s2 );


extern char __far *_fstrupr( char __far *__string );

extern void movedata( unsigned __srcseg, unsigned __srcoff,
	       unsigned __tgtseg, unsigned __tgtoff, unsigned __len );
extern void *memccpy( void *__s1, const void *__s2, int __c, size_t __n );
extern int  memicmp( const void *__s1, const void *__s2, size_t __n );
extern int  _memicmp( const void *__s1, const void *__s2, size_t __n );
extern int   strcmpi( const char *__s1, const char *__s2 );
extern char *strdup( const char *__string );
extern char *_strdup( const char *__string );
extern int   stricmp( const char *__s1, const char *__s2 );
extern int   _stricmp( const char *__s1, const char *__s2 );
extern char *strlwr( char *__string );
extern char *_strlwr( char *__string );
extern int   strnicmp( const char *__s1, const char *__s2, size_t __n );
extern int   _strnicmp( const char *__s1, const char *__s2, size_t __n );
extern char *strnset( char *__string, int __c, size_t __len );
extern char *strrev( char *__string );
extern char *_strrev( char *__string );
extern char *strset( char *__string, int __c );
extern char *strupr( char *__string );
extern char *_strupr( char *__string );
#line 222 "C:\WATCOM\H\string.h"

/* EXTENSIONS */

/* __INLINE_FUNCTIONS__ */#line 235 "C:\WATCOM\H\string.h"



};


#line 4252 "C:\WATCOM\H\NT\winnt.h"
















































#line 4337 "C:\WATCOM\H\NT\winnt.h"

typedef struct _MESSAGE_RESOURCE_ENTRY {
    WORD   Length;
    WORD   Flags;
    BYTE  Text[ 1 ];
} MESSAGE_RESOURCE_ENTRY, *PMESSAGE_RESOURCE_ENTRY;



typedef struct _MESSAGE_RESOURCE_BLOCK {
    DWORD LowId;
    DWORD HighId;
    DWORD OffsetToEntries;
} MESSAGE_RESOURCE_BLOCK, *PMESSAGE_RESOURCE_BLOCK;

typedef struct _MESSAGE_RESOURCE_DATA {
    DWORD NumberOfBlocks;
    MESSAGE_RESOURCE_BLOCK Blocks[ 1 ];
} MESSAGE_RESOURCE_DATA, *PMESSAGE_RESOURCE_DATA;


typedef struct _RTL_CRITICAL_SECTION_DEBUG {
    WORD   Type;
    WORD   CreatorBackTraceIndex;
    struct _RTL_CRITICAL_SECTION *CriticalSection;
    LIST_ENTRY ProcessLocksList;
    DWORD EntryCount;
    DWORD ContentionCount;
    DWORD Spare[ 2 ];
} RTL_CRITICAL_SECTION_DEBUG, *PRTL_CRITICAL_SECTION_DEBUG;




typedef struct _RTL_CRITICAL_SECTION {
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;

    //
    //  The following three fields control entering and exiting the critical
    //  section for the resource
    //

    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread;        // from the thread's ClientId->UniqueThread 
    HANDLE LockSemaphore;
    DWORD Reserved;
} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;





//
// Defines for the READ flags for Eventlogging
//





//
// The types of events that can be logged.
//







//
// Defines for the WRITE flags used by Auditing for paired events
// These are not implemented in Product 1
//







//
// Structure that defines the header of the Eventlog record. This is the
// fixed-sized portion before all the variable-length strings, binary
// data and pad bytes.
//
// TimeGenerated is the time it was generated at the client.
// TimeWritten is the time it was put into the log at the server end.
//

typedef struct _EVENTLOGRECORD {
    DWORD  Length;        // Length of full record 
    DWORD  Reserved;      // Used by the service 
    DWORD  RecordNumber;  // Absolute record number 
    DWORD  TimeGenerated; // Seconds since 1-1-1970 
    DWORD  TimeWritten;   // Seconds since 1-1-1970 
    DWORD  EventID;
    WORD   EventType;
    WORD   NumStrings;
    WORD   EventCategory;
    WORD   ReservedFlags; // For use with paired events (auditing) 
    DWORD  ClosingRecordNumber; // For use with paired events (auditing) 
    DWORD  StringOffset;  // Offset from beginning of record 
    DWORD  UserSidLength;
    DWORD  UserSidOffset;
    DWORD  DataLength;
    DWORD  DataOffset;    // Offset from beginning of record 
    //
    // Then follow:
    //
    // WCHAR SourceName[]
    // WCHAR Computername[]
    // SID   UserSid
    // WCHAR Strings[]
    // BYTE  Data[]
    // CHAR  Pad[]
    // DWORD Length;
    //
} EVENTLOGRECORD, *PEVENTLOGRECORD;







//

// begin_ntddk begin_nthal
//
// Registry Specific Access Rights.
//




































//
// Open/Create Options
//

// Parameter is reserved

// Key is preserved
                                                    // when system is rebooted

// Key is not preserved
                                                    // when system is rebooted

// Created key is a
                                                    // symbolic link

// open for backup or restore
                                                    // special access rules
                                                    // privilege required








//
// Key creation/open disposition
//

// New Registry Key created
// Existing Key opened

//
// Key restore flags
//

// Restore whole hive volatile
// Unwind changes to last flush

// end_ntddk end_nthal

//
// Notify filter values
//
// Create or delete (child)

// time stamp








//
//
// Predefined Value Types.
//

// No value type
// Unicode nul terminated string
// Unicode nul terminated string
                                            // (with environment variable references)
// Free form binary
// 32-bit number
// 32-bit number (same as REG_DWORD)
// 32-bit number
// Symbolic Link (unicode)
// Multiple Unicode strings
// Resource list in the resource map
// Resource list in the hardware description


// end_ntddk end_nthal

// begin_ntddk begin_nthal
//
// Service Types (Bit Mask)
//





















//
// Start Type
//







//
// Error control type
//





//
//
// Define the registry driver node enumerations
//

typedef enum _CM_SERVICE_NODE_TYPE {
    DriverType               =  0x00000001 ,
    FileSystemType           =  0x00000002 ,
    Win32ServiceOwnProcess   =  0x00000010 ,
    Win32ServiceShareProcess =  0x00000020 ,
    AdapterType              =  0x00000004 ,
    RecognizerType           =  0x00000008 
} SERVICE_NODE_TYPE;

typedef enum _CM_SERVICE_LOAD_TYPE {
    BootLoad    =  0x00000000 ,
    SystemLoad  =  0x00000001 ,
    AutoLoad    =  0x00000002 ,
    DemandLoad  =  0x00000003 ,
    DisableLoad =  0x00000004 
} SERVICE_LOAD_TYPE;

typedef enum _CM_ERROR_CONTROL_TYPE {
    IgnoreError   =  0x00000000 ,
    NormalError   =  0x00000001 ,
    SevereError   =  0x00000002 ,
    CriticalError =  0x00000003 
} SERVICE_ERROR_TYPE;


//
// IOCTL_TAPE_ERASE definitions
//




typedef struct _TAPE_ERASE {
    DWORD Type;
    BOOLEAN Immediate;
} TAPE_ERASE, *PTAPE_ERASE;

//
// IOCTL_TAPE_PREPARE definitions
//








typedef struct _TAPE_PREPARE {
    DWORD Operation;
    BOOLEAN Immediate;
} TAPE_PREPARE, *PTAPE_PREPARE;

//
// IOCTL_TAPE_WRITE_MARKS definitions
//






typedef struct _TAPE_WRITE_MARKS {
    DWORD Type;
    DWORD Count;
    BOOLEAN Immediate;
} TAPE_WRITE_MARKS, *PTAPE_WRITE_MARKS;

//
// IOCTL_TAPE_GET_POSITION definitions
//





typedef struct _TAPE_GET_POSITION {
    DWORD Type;
    DWORD Partition;
    LARGE_INTEGER Offset;
} TAPE_GET_POSITION, *PTAPE_GET_POSITION;

//
// IOCTL_TAPE_SET_POSITION definitions
//












typedef struct _TAPE_SET_POSITION {
    DWORD Method;
    DWORD Partition;
    LARGE_INTEGER Offset;
    BOOLEAN Immediate;
} TAPE_SET_POSITION, *PTAPE_SET_POSITION;

//
// IOCTL_TAPE_GET_DRIVE_PARAMS definitions
//

//
// Definitions for FeaturesLow parameter
//



























//don't use this bit!
//                                              //can't be a low features bit!
//                                              //reserved; high features only

//
// Definitions for FeaturesHigh parameter
//







































//mask for high features flag

typedef struct _TAPE_GET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD DefaultBlockSize;
    DWORD MaximumBlockSize;
    DWORD MinimumBlockSize;
    DWORD MaximumPartitionCount;
    DWORD FeaturesLow;
    DWORD FeaturesHigh;
    DWORD EOTWarningZoneSize;
} TAPE_GET_DRIVE_PARAMETERS, *PTAPE_GET_DRIVE_PARAMETERS;

//
// IOCTL_TAPE_SET_DRIVE_PARAMETERS definitions
//

typedef struct _TAPE_SET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD EOTWarningZoneSize;
} TAPE_SET_DRIVE_PARAMETERS, *PTAPE_SET_DRIVE_PARAMETERS;

//
// IOCTL_TAPE_GET_MEDIA_PARAMETERS definitions
//

typedef struct _TAPE_GET_MEDIA_PARAMETERS {
    LARGE_INTEGER Capacity;
    LARGE_INTEGER Remaining;
    DWORD BlockSize;
    DWORD PartitionCount;
    BOOLEAN WriteProtected;
} TAPE_GET_MEDIA_PARAMETERS, *PTAPE_GET_MEDIA_PARAMETERS;

//
// IOCTL_TAPE_SET_MEDIA_PARAMETERS definitions
//

typedef struct _TAPE_SET_MEDIA_PARAMETERS {
    DWORD BlockSize;
} TAPE_SET_MEDIA_PARAMETERS, *PTAPE_SET_MEDIA_PARAMETERS;

//
// IOCTL_TAPE_CREATE_PARTITION definitions
//





typedef struct _TAPE_CREATE_PARTITION {
    DWORD Method;
    DWORD Count;
    DWORD Size;
} TAPE_CREATE_PARTITION, *PTAPE_CREATE_PARTITION;



}


/* _WINNT_ */
#line 139 "C:\WATCOM\H\NT\windef.h"

/* NT_INCLUDED */

/* Types use for passing & returning polymorphic values */
typedef UINT WPARAM;
typedef LONG LPARAM;
typedef LONG LRESULT;











/* NOMINMAX */










             typedef HANDLE HWND ;
             typedef HANDLE HHOOK ;


typedef WORD                ATOM;

typedef HANDLE            *SPHANDLE;
typedef HANDLE             *LPHANDLE;
typedef HANDLE              HGLOBAL;
typedef HANDLE              HLOCAL;
typedef HANDLE              GLOBALHANDLE;
typedef HANDLE              LOCALHANDLE;
typedef int (    __stdcall  *FARPROC)();
typedef int (    __stdcall  *NEARPROC)();
typedef int ( __stdcall  *PROC)();

#line 187 "C:\WATCOM\H\NT\windef.h"
 typedef HANDLE HGDIOBJ ;


 typedef HANDLE HACCEL ;
 typedef HANDLE HBITMAP ;
 typedef HANDLE HBRUSH ;
 
 typedef HANDLE HCOLORSPACE ;
/* WINVER >= 0x0400 */
 typedef HANDLE HDC ;
 typedef HANDLE HGLRC ;          // OpenGL 
 typedef HANDLE HDESK ;
 typedef HANDLE HENHMETAFILE ;
 typedef HANDLE HFONT ;
 typedef HANDLE HICON ;
 typedef HANDLE HMENU ;
 typedef HANDLE HMETAFILE ;
 typedef HANDLE HINSTANCE ;
typedef HINSTANCE HMODULE;      /* HMODULEs can be used in place of HINSTANCEs */ 
 typedef HANDLE HPALETTE ;
 typedef HANDLE HPEN ;
 typedef HANDLE HRGN ;
 typedef HANDLE HRSRC ;
 typedef HANDLE HSTR ;
 typedef HANDLE HTASK ;
 typedef HANDLE HWINSTA ;
 typedef HANDLE HKL ;

typedef int HFILE;      
typedef HICON HCURSOR;      /* HICONs & HCURSORs are polymorphic */ 

typedef DWORD   COLORREF;
typedef DWORD   *LPCOLORREF;



typedef struct tagRECT
{
    LONG    left;
    LONG    top;
    LONG    right;
    LONG    bottom;
} RECT, *PRECT,    *NPRECT,    *LPRECT;

typedef const RECT   * LPCRECT;

typedef struct _RECTL       /* rcl */ 
{
    LONG    left;
    LONG    top;
    LONG    right;
    LONG    bottom;
} RECTL, *PRECTL, *LPRECTL;

typedef const RECTL   * LPCRECTL;

typedef struct tagPOINT
{
    LONG  x;
    LONG  y;
} POINT, *PPOINT,    *NPPOINT,    *LPPOINT;

typedef struct _POINTL      /* ptl  */ 
{
    LONG  x;
    LONG  y;
} POINTL, *PPOINTL;

typedef struct tagSIZE
{
    LONG        cx;
    LONG        cy;
} SIZE, *PSIZE, *LPSIZE;

typedef SIZE               SIZEL;
typedef SIZE               *PSIZEL, *LPSIZEL;

typedef struct tagPOINTS
{
    SHORT   x;
    SHORT   y;
} POINTS, *PPOINTS, *LPPOINTS;

/* mode selections for the device mode function */










/* device capabilities indices */




















}



/* _WINDEF_ */
#line 157 "C:\WATCOM\H\NT\windows.h"

#line 1 "C:\WATCOM\H\NT\winbase.h"
/************************************************************************
*                                                                       *
*   winbase.h -- This module defines the 32-Bit Windows Base APIs       *
*                                                                       *
*   Copyright (c) 1990-1995, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/




//
// Define API decoration for direct importing of DLL references.
//



#line 21 "C:\WATCOM\H\NT\winbase.h"



#line 27 "C:\WATCOM\H\NT\winbase.h"


extern "C" {


/*
 * Compatibility macros
 */























































//
// File creation flags must start at the high end since they
// are combined with the attributes
//
















//
// Define the NamedPipe definitions
//


//
// Define the dwOpenMode values for CreateNamedPipe
//





//
// Define the Named Pipe End flags for GetNamedPipeInfo
//




//
// Define the dwPipeMode values for CreateNamedPipe
//








//
// Define the well known values for CreateNamedPipe nMaxInstances
//



//
// Define the Security Quality of Service bits to be passed
// into CreateFile
//












//
//  File structures
//

typedef struct _OVERLAPPED {
    DWORD   Internal;
    DWORD   InternalHigh;
    DWORD   Offset;
    DWORD   OffsetHigh;
    HANDLE  hEvent;
} OVERLAPPED, *LPOVERLAPPED;

typedef struct _SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
} SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;

typedef struct _PROCESS_INFORMATION {
    HANDLE hProcess;
    HANDLE hThread;
    DWORD dwProcessId;
    DWORD dwThreadId;
} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;

//
//  File System time stamps are represented with the following structure:
//

typedef struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, *PFILETIME, *LPFILETIME;

//
// System time is represented with the following structure:
//

typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME;

typedef DWORD ( __stdcall  *PTHREAD_START_ROUTINE)(
    LPVOID lpThreadParameter
    );
typedef PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;

typedef RTL_CRITICAL_SECTION CRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION PCRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION LPCRITICAL_SECTION;

typedef RTL_CRITICAL_SECTION_DEBUG CRITICAL_SECTION_DEBUG;
typedef PRTL_CRITICAL_SECTION_DEBUG PCRITICAL_SECTION_DEBUG;
typedef PRTL_CRITICAL_SECTION_DEBUG LPCRITICAL_SECTION_DEBUG;


typedef PLDT_ENTRY LPLDT_ENTRY;
#line 230 "C:\WATCOM\H\NT\winbase.h"




//
// Serial provider type.
//



//
// Provider SubTypes
//
















//
// Provider capabilities flags.
//












//
// Comm provider settable parameters.
//









//
// Settable baud rates in the provider.
//






















//
// Settable Data Bits
//








//
// Settable Stop and Parity bits.
//










typedef struct _COMMPROP {
    WORD wPacketLength;
    WORD wPacketVersion;
    DWORD dwServiceMask;
    DWORD dwReserved1;
    DWORD dwMaxTxQueue;
    DWORD dwMaxRxQueue;
    DWORD dwMaxBaud;
    DWORD dwProvSubType;
    DWORD dwProvCapabilities;
    DWORD dwSettableParams;
    DWORD dwSettableBaud;
    WORD wSettableData;
    WORD wSettableStopParity;
    DWORD dwCurrentTxQueue;
    DWORD dwCurrentRxQueue;
    DWORD dwProvSpec1;
    DWORD dwProvSpec2;
    WCHAR wcProvChar[1];
} COMMPROP,*LPCOMMPROP;

//
// Set dwProvSpec1 to COMMPROP_INITIALIZED to indicate that wPacketLength
// is valid before a call to GetCommProperties().
//


typedef struct _COMSTAT {
    DWORD fCtsHold : 1;
    DWORD fDsrHold : 1;
    DWORD fRlsdHold : 1;
    DWORD fXoffHold : 1;
    DWORD fXoffSent : 1;
    DWORD fEof : 1;
    DWORD fTxim : 1;
    DWORD fReserved : 25;
    DWORD cbInQue;
    DWORD cbOutQue;
} COMSTAT, *LPCOMSTAT;

//
// DTR Control Flow Values.
//




//
// RTS Control Flow Values
//





typedef struct _DCB {
    DWORD DCBlength;      /* sizeof(DCB)                     */ 
    DWORD BaudRate;       /* Baudrate at which running       */ 
    DWORD fBinary: 1;     /* Binary Mode (skip EOF check)    */ 
    DWORD fParity: 1;     /* Enable parity checking          */ 
    DWORD fOutxCtsFlow:1; /* CTS handshaking on output       */ 
    DWORD fOutxDsrFlow:1; /* DSR handshaking on output       */ 
    DWORD fDtrControl:2;  /* DTR Flow control                */ 
    DWORD fDsrSensitivity:1; /* DSR Sensitivity              */ 
    DWORD fTXContinueOnXoff: 1; /* Continue TX when Xoff sent */ 
    DWORD fOutX: 1;       /* Enable output X-ON/X-OFF        */ 
    DWORD fInX: 1;        /* Enable input X-ON/X-OFF         */ 
    DWORD fErrorChar: 1;  /* Enable Err Replacement          */ 
    DWORD fNull: 1;       /* Enable Null stripping           */ 
    DWORD fRtsControl:2;  /* Rts Flow control                */ 
    DWORD fAbortOnError:1; /* Abort all reads and writes on Error */ 
    DWORD fDummy2:17;     /* Reserved                        */ 
    WORD wReserved;       /* Not currently used              */ 
    WORD XonLim;          /* Transmit X-ON threshold         */ 
    WORD XoffLim;         /* Transmit X-OFF threshold        */ 
    BYTE ByteSize;        /* Number of bits/byte, 4-8        */ 
    BYTE Parity;          /* 0-4=None,Odd,Even,Mark,Space    */ 
    BYTE StopBits;        /* 0,1,2 = 1, 1.5, 2               */ 
    char XonChar;         /* Tx and Rx X-ON character        */ 
    char XoffChar;        /* Tx and Rx X-OFF character       */ 
    char ErrorChar;       /* Error replacement char          */ 
    char EofChar;         /* End of Input character          */ 
    char EvtChar;         /* Received Event character        */ 
    WORD wReserved1;      /* Fill for now.                   */ 
} DCB, *LPDCB;

typedef struct _COMMTIMEOUTS {
    DWORD ReadIntervalTimeout;          /* Maximum time between read chars. */ 
    DWORD ReadTotalTimeoutMultiplier;   /* Multiplier of characters.        */ 
    DWORD ReadTotalTimeoutConstant;     /* Constant in milliseconds.        */ 
    DWORD WriteTotalTimeoutMultiplier;  /* Multiplier of characters.        */ 
    DWORD WriteTotalTimeoutConstant;    /* Constant in milliseconds.        */ 
} COMMTIMEOUTS,*LPCOMMTIMEOUTS;

typedef struct _COMMCONFIG {
    DWORD dwSize;               /* Size of the entire struct */ 
    WORD wVersion;              /* version of the structure */ 
    WORD wReserved;             /* alignment */ 
    DCB dcb;                    /* device control block */ 
    DWORD dwProviderSubType;    /* ordinal value for identifying
                                   provider-defined data structure format*/ 
    DWORD dwProviderOffset;     /* Specifies the offset of provider specific
                                   data field in bytes from the start */ 
    DWORD dwProviderSize;       /* size of the provider-specific data field */ 
    WCHAR wcProviderData[1];    /* provider-specific data */ 
} COMMCONFIG,*LPCOMMCONFIG;

typedef struct _SYSTEM_INFO {
    union {
        DWORD dwOemId;          // Obsolete field...do not use 
        struct {
            WORD wProcessorArchitecture;
            WORD wReserved;
        };
    };
    DWORD dwPageSize;
    LPVOID lpMinimumApplicationAddress;
    LPVOID lpMaximumApplicationAddress;
    DWORD dwActiveProcessorMask;
    DWORD dwNumberOfProcessors;
    DWORD dwProcessorType;
    DWORD dwAllocationGranularity;
    WORD wProcessorLevel;
    WORD wProcessorRevision;
} SYSTEM_INFO, *LPSYSTEM_INFO;

//
//




// do nothing

/* Global Memory Flags */






















/* Flags returned by GlobalFlags (in addition to GMEM_DISCARDABLE) */



typedef struct _MEMORYSTATUS {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    DWORD dwTotalPhys;
    DWORD dwAvailPhys;
    DWORD dwTotalPageFile;
    DWORD dwAvailPageFile;
    DWORD dwTotalVirtual;
    DWORD dwAvailVirtual;
} MEMORYSTATUS, *LPMEMORYSTATUS;

/* Local Memory Flags */


















/* Flags returned by LocalFlags (in addition to LMEM_DISCARDABLE) */



//
// dwCreationFlag values
//






































//
// Debug APIs
//










typedef struct _EXCEPTION_DEBUG_INFO {
    EXCEPTION_RECORD ExceptionRecord;
    DWORD dwFirstChance;
} EXCEPTION_DEBUG_INFO, *LPEXCEPTION_DEBUG_INFO;

typedef struct _CREATE_THREAD_DEBUG_INFO {
    HANDLE hThread;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
} CREATE_THREAD_DEBUG_INFO, *LPCREATE_THREAD_DEBUG_INFO;

typedef struct _CREATE_PROCESS_DEBUG_INFO {
    HANDLE hFile;
    HANDLE hProcess;
    HANDLE hThread;
    LPVOID lpBaseOfImage;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
    LPVOID lpImageName;
    WORD fUnicode;
} CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;

typedef struct _EXIT_THREAD_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_THREAD_DEBUG_INFO, *LPEXIT_THREAD_DEBUG_INFO;

typedef struct _EXIT_PROCESS_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_PROCESS_DEBUG_INFO, *LPEXIT_PROCESS_DEBUG_INFO;

typedef struct _LOAD_DLL_DEBUG_INFO {
    HANDLE hFile;
    LPVOID lpBaseOfDll;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpImageName;
    WORD fUnicode;
} LOAD_DLL_DEBUG_INFO, *LPLOAD_DLL_DEBUG_INFO;

typedef struct _UNLOAD_DLL_DEBUG_INFO {
    LPVOID lpBaseOfDll;
} UNLOAD_DLL_DEBUG_INFO, *LPUNLOAD_DLL_DEBUG_INFO;

typedef struct _OUTPUT_DEBUG_STRING_INFO {
    LPSTR lpDebugStringData;
    WORD fUnicode;
    WORD nDebugStringLength;
} OUTPUT_DEBUG_STRING_INFO, *LPOUTPUT_DEBUG_STRING_INFO;

typedef struct _RIP_INFO {
    DWORD dwError;
    DWORD dwType;
} RIP_INFO, *LPRIP_INFO;


typedef struct _DEBUG_EVENT {
    DWORD dwDebugEventCode;
    DWORD dwProcessId;
    DWORD dwThreadId;
    union {
        EXCEPTION_DEBUG_INFO Exception;
        CREATE_THREAD_DEBUG_INFO CreateThread;
        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
        EXIT_THREAD_DEBUG_INFO ExitThread;
        EXIT_PROCESS_DEBUG_INFO ExitProcess;
        LOAD_DLL_DEBUG_INFO LoadDll;
        UNLOAD_DLL_DEBUG_INFO UnloadDll;
        OUTPUT_DEBUG_STRING_INFO DebugString;
        RIP_INFO RipInfo;
    } u;
} DEBUG_EVENT, *LPDEBUG_EVENT;


typedef PCONTEXT LPCONTEXT;
typedef PEXCEPTION_RECORD LPEXCEPTION_RECORD;
typedef PEXCEPTION_POINTERS LPEXCEPTION_POINTERS;



































// Ignore signal
// Infinite timeout

//
// Basud rates at which the communication device operates
//

















//
// Error Flags
//

// Receive Queue overflow
// Receive Overrun Error
// Receive Parity Error
// Receive Framing error
// Break Detected
// TX Queue is full
// LPTx Timeout
// LPTx I/O Error
// LPTx Device not selected
// LPTx Out-Of-Paper
// Requested mode unsupported

// Invalid or unsupported id
// Device Already Open
// Device Not Open
// Unable to allocate queues
// Error in default parameters
// Hardware Not Present
// Illegal Byte Size
// Unsupported BaudRate

//
// Events
//

// Any Character received
// Received certain character
// Transmitt Queue Empty
// CTS changed state
// DSR changed state
// RLSD changed state
// BREAK received
// Line status error occurred
// Ring signal detected
// Printer error occured
// Receive buffer is 80 percent full
// Provider specific event 1
// Provider specific event 2

//
// Escape Functions
//

// Simulate XOFF received
// Simulate XON received
// Set RTS high
// Set RTS low
// Set DTR high
// Set DTR low
// Reset device if possible
// Set the device break line.
// Clear the device break line.

//
// PURGE function flags.
//
// Kill the pending/current writes to the comm port.
// Kill the pending/current reads to the comm port.
// Kill the transmit queue if there.
// Kill the typeahead buffer if there.

// Set if ID is for LPT device

//
// Modem Status Flags
//





//
// WaitSoundState() Constants
//





//
// Accent Modes
//





//
// SetSoundNoise() Sources
//

// Freq = N/512 high pitch, less coarse hiss
// Freq = N/1024
// Freq = N/2048 low pitch, more coarse hiss
// Source is frequency from voice channel (3)
// Freq = N/512 high pitch, less coarse hiss
// Freq = N/1024
// Freq = N/2048 low pitch, more coarse hiss
// Source is frequency from voice channel (3)

// Device not available
// Out of memory
// Music active
// Queue full
// Invalid note
// Invalid note length
// Invalid note count
// Invalid tempo
// Invalid volume
// Invalid mode
// Invalid shape
// Invalid pitch
// Invalid frequency
// Invalid duration
// Invalid source
// Invalid state








































typedef struct _OFSTRUCT {
    BYTE cBytes;
    BYTE fFixedDisk;
    WORD nErrCode;
    WORD Reserved1;
    WORD Reserved2;
    CHAR szPathName[ 128 ];
} OFSTRUCT, *LPOFSTRUCT, *POFSTRUCT;

//
// The MS-MIPS and Alpha compilers support intrinsic functions for interlocked
// increment, decrement, and exchange.
//

#line 928 "C:\WATCOM\H\NT\winbase.h"



 __declspec(dllimport) 
LONG
 __stdcall 
InterlockedIncrement(
    LPLONG lpAddend
    );

 __declspec(dllimport) 
LONG
 __stdcall 
InterlockedDecrement(
    LPLONG lpAddend
    );

 __declspec(dllimport) 
LONG
 __stdcall 
InterlockedExchange(
    LPLONG Target,
    LONG Value
    );

/* NT_INCLUDED */



 __declspec(dllimport) 
BOOL
 __stdcall 
FreeResource(
        HGLOBAL hResData
        );

 __declspec(dllimport) 
LPVOID
 __stdcall 
LockResource(
        HGLOBAL hResData
        );






int
 __stdcall 
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nShowCmd
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
FreeLibrary(
    HMODULE hLibModule
    );


 __declspec(dllimport) 
 void 
 __stdcall 
FreeLibraryAndExitThread(
    HMODULE hLibModule,
    DWORD dwExitCode
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
DisableThreadLibraryCalls(
    HMODULE hLibModule
    );

 __declspec(dllimport) 
FARPROC
 __stdcall 
GetProcAddress(
    HMODULE hModule,
    LPCSTR lpProcName
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
GetVersion(  void  );

 __declspec(dllimport) 
HGLOBAL
 __stdcall 
GlobalAlloc(
    UINT uFlags,
    DWORD dwBytes
    );

 __declspec(dllimport) 
HGLOBAL
 __stdcall 
GlobalReAlloc(
    HGLOBAL hMem,
    DWORD dwBytes,
    UINT uFlags
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
GlobalSize(
    HGLOBAL hMem
    );

 __declspec(dllimport) 
UINT
 __stdcall 
GlobalFlags(
    HGLOBAL hMem
    );


 __declspec(dllimport) 
LPVOID
 __stdcall 
GlobalLock(
    HGLOBAL hMem
    );

//!!!MWH My version  win31 = DWORD WINAPI GlobalHandle(UINT)
 __declspec(dllimport) 
HGLOBAL
 __stdcall 
GlobalHandle(
    LPCVOID pMem
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
GlobalUnlock(
    HGLOBAL hMem
    );


 __declspec(dllimport) 
HGLOBAL
 __stdcall 
GlobalFree(
    HGLOBAL hMem
    );

 __declspec(dllimport) 
UINT
 __stdcall 
GlobalCompact(
    DWORD dwMinFree
    );

 __declspec(dllimport) 
 void 
 __stdcall 
GlobalFix(
    HGLOBAL hMem
    );

 __declspec(dllimport) 
 void 
 __stdcall 
GlobalUnfix(
    HGLOBAL hMem
    );

 __declspec(dllimport) 
LPVOID
 __stdcall 
GlobalWire(
    HGLOBAL hMem
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GlobalUnWire(
    HGLOBAL hMem
    );

 __declspec(dllimport) 
 void 
 __stdcall 
GlobalMemoryStatus(
    LPMEMORYSTATUS lpBuffer
    );

 __declspec(dllimport) 
HLOCAL
 __stdcall 
LocalAlloc(
    UINT uFlags,
    UINT uBytes
    );

 __declspec(dllimport) 
HLOCAL
 __stdcall 
LocalReAlloc(
    HLOCAL hMem,
    UINT uBytes,
    UINT uFlags
    );

 __declspec(dllimport) 
LPVOID
 __stdcall 
LocalLock(
    HLOCAL hMem
    );

 __declspec(dllimport) 
HLOCAL
 __stdcall 
LocalHandle(
    LPCVOID pMem
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
LocalUnlock(
    HLOCAL hMem
    );

 __declspec(dllimport) 
UINT
 __stdcall 
LocalSize(
    HLOCAL hMem
    );

 __declspec(dllimport) 
UINT
 __stdcall 
LocalFlags(
    HLOCAL hMem
    );

 __declspec(dllimport) 
HLOCAL
 __stdcall 
LocalFree(
    HLOCAL hMem
    );

 __declspec(dllimport) 
UINT
 __stdcall 
LocalShrink(
    HLOCAL hMem,
    UINT cbNewSize
    );

 __declspec(dllimport) 
UINT
 __stdcall 
LocalCompact(
    UINT uMinFree
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
FlushInstructionCache(
    HANDLE hProcess,
    LPCVOID lpBaseAddress,
    DWORD dwSize
    );

 __declspec(dllimport) 
LPVOID
 __stdcall 
VirtualAlloc(
    LPVOID lpAddress,
    DWORD dwSize,
    DWORD flAllocationType,
    DWORD flProtect
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
VirtualFree(
    LPVOID lpAddress,
    DWORD dwSize,
    DWORD dwFreeType
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
VirtualProtect(
    LPVOID lpAddress,
    DWORD dwSize,
    DWORD flNewProtect,
    PDWORD lpflOldProtect
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
VirtualQuery(
    LPCVOID lpAddress,
    PMEMORY_BASIC_INFORMATION lpBuffer,
    DWORD dwLength
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
VirtualProtectEx(
    HANDLE hProcess,
    LPVOID lpAddress,
    DWORD dwSize,
    DWORD flNewProtect,
    PDWORD lpflOldProtect
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
VirtualQueryEx(
    HANDLE hProcess,
    LPCVOID lpAddress,
    PMEMORY_BASIC_INFORMATION lpBuffer,
    DWORD dwLength
    );

 __declspec(dllimport) 
HANDLE
 __stdcall 
HeapCreate(
    DWORD flOptions,
    DWORD dwInitialSize,
    DWORD dwMaximumSize
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
HeapDestroy(
    HANDLE hHeap
    );


 __declspec(dllimport) 
LPVOID
 __stdcall 
HeapAlloc(
    HANDLE hHeap,
    DWORD dwFlags,
    DWORD dwBytes
    );

 __declspec(dllimport) 
LPVOID
 __stdcall 
HeapReAlloc(
    HANDLE hHeap,
    DWORD dwFlags,
    LPVOID lpMem,
    DWORD dwBytes
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
HeapFree(
    HANDLE hHeap,
    DWORD dwFlags,
    LPVOID lpMem
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
HeapSize(
    HANDLE hHeap,
    DWORD dwFlags,
    LPCVOID lpMem
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
HeapValidate(
    HANDLE hHeap,
    DWORD dwFlags,
    LPCVOID lpMem
    );

 __declspec(dllimport) 
UINT
 __stdcall 
HeapCompact(
    HANDLE hHeap,
    DWORD dwFlags
    );

 __declspec(dllimport) 
HANDLE
 __stdcall 
GetProcessHeap(  void  );

 __declspec(dllimport) 
DWORD
 __stdcall 
GetProcessHeaps(
    DWORD NumberOfHeaps,
    PHANDLE ProcessHeaps
    );

typedef struct _PROCESS_HEAP_ENTRY {
    PVOID lpData;
    DWORD cbData;
    BYTE cbOverhead;
    BYTE iRegionIndex;
    WORD wFlags;
    union {
        struct {
            HANDLE hMem;
            DWORD dwReserved[ 3 ];
        } Block;
        struct {
            DWORD dwCommittedSize;
            DWORD dwUnCommittedSize;
            LPVOID lpFirstBlock;
            LPVOID lpLastBlock;
        } Region;
    };
} PROCESS_HEAP_ENTRY, *LPPROCESS_HEAP_ENTRY, *PPROCESS_HEAP_ENTRY;







 __declspec(dllimport) 
BOOL
 __stdcall 
HeapLock(
    HANDLE hHeap
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
HeapUnlock(
    HANDLE hHeap
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
HeapWalk(
    HANDLE hHeap,
    LPPROCESS_HEAP_ENTRY lpEntry
    );

// GetBinaryType return values.








 __declspec(dllimport) 
BOOL
 __stdcall 
GetBinaryTypeA(
    LPCSTR lpApplicationName,
    LPDWORD lpBinaryType
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
GetBinaryTypeW(
    LPCWSTR lpApplicationName,
    LPDWORD lpBinaryType
    );
#line 1427 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
DWORD
 __stdcall 
GetShortPathNameA(
    LPCSTR lpszLongPath,
    LPSTR  lpszShortPath,
    DWORD    cchBuffer
    );
 __declspec(dllimport) 
DWORD
 __stdcall 
GetShortPathNameW(
    LPCWSTR lpszLongPath,
    LPWSTR  lpszShortPath,
    DWORD    cchBuffer
    );
#line 1449 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
GetProcessAffinityMask(
    HANDLE hProcess,
    LPDWORD lpProcessAffinityMask,
    LPDWORD lpSystemAffinityMask
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetProcessTimes(
    HANDLE hProcess,
    LPFILETIME lpCreationTime,
    LPFILETIME lpExitTime,
    LPFILETIME lpKernelTime,
    LPFILETIME lpUserTime
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetProcessWorkingSetSize(
    HANDLE hProcess,
    LPDWORD lpMinimumWorkingSetSize,
    LPDWORD lpMaximumWorkingSetSize
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetProcessWorkingSetSize(
    HANDLE hProcess,
    DWORD dwMinimumWorkingSetSize,
    DWORD dwMaximumWorkingSetSize
    );

 __declspec(dllimport) 
HANDLE
 __stdcall 
OpenProcess(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwProcessId
    );

 __declspec(dllimport) 
HANDLE
 __stdcall 
GetCurrentProcess(
     void 
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
GetCurrentProcessId(
     void 
    );

 __declspec(dllimport) 
 void 
 __stdcall 
ExitProcess(
    UINT uExitCode
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
TerminateProcess(
    HANDLE hProcess,
    UINT uExitCode
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetExitCodeProcess(
    HANDLE hProcess,
    LPDWORD lpExitCode
    );


 __declspec(dllimport) 
 void 
 __stdcall 
FatalExit(
    int ExitCode
    );

 __declspec(dllimport) 
LPSTR
 __stdcall 
GetEnvironmentStrings(
     void 
    );

 __declspec(dllimport) 
LPWSTR
 __stdcall 
GetEnvironmentStringsW(
     void 
    );

#line 1561 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
FreeEnvironmentStringsA(
    LPSTR
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
FreeEnvironmentStringsW(
    LPWSTR
    );
#line 1579 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
 void 
 __stdcall 
RaiseException(
    DWORD dwExceptionCode,
    DWORD dwExceptionFlags,
    DWORD nNumberOfArguments,
     const  DWORD *lpArguments
    );

 __declspec(dllimport) 
LONG
 __stdcall 
UnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );

typedef LONG ( __stdcall  *PTOP_LEVEL_EXCEPTION_FILTER)(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );
typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;

 __declspec(dllimport) 
LPTOP_LEVEL_EXCEPTION_FILTER
 __stdcall 
SetUnhandledExceptionFilter(
    LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
    );

 __declspec(dllimport) 
HANDLE
 __stdcall 
CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    DWORD dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    );

 __declspec(dllimport) 
HANDLE
 __stdcall 
CreateRemoteThread(
    HANDLE hProcess,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    DWORD dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    );

 __declspec(dllimport) 
HANDLE
 __stdcall 
GetCurrentThread(
     void 
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
GetCurrentThreadId(
     void 
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
SetThreadAffinityMask(
    HANDLE hThread,
    DWORD dwThreadAffinityMask
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetThreadPriority(
    HANDLE hThread,
    int nPriority
    );

 __declspec(dllimport) 
int
 __stdcall 
GetThreadPriority(
    HANDLE hThread
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetThreadTimes(
    HANDLE hThread,
    LPFILETIME lpCreationTime,
    LPFILETIME lpExitTime,
    LPFILETIME lpKernelTime,
    LPFILETIME lpUserTime
    );

 __declspec(dllimport) 
 void 
 __stdcall 
ExitThread(
    DWORD dwExitCode
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
TerminateThread(
    HANDLE hThread,
    DWORD dwExitCode
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetExitCodeThread(
    HANDLE hThread,
    LPDWORD lpExitCode
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetThreadSelectorEntry(
    HANDLE hThread,
    DWORD dwSelector,
    LPLDT_ENTRY lpSelectorEntry
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
GetLastError(
     void 
    );

 __declspec(dllimport) 
 void 
 __stdcall 
SetLastError(
    DWORD dwErrCode
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetOverlappedResult(
    HANDLE hFile,
    LPOVERLAPPED lpOverlapped,
    LPDWORD lpNumberOfBytesTransferred,
    BOOL bWait
    );

 __declspec(dllimport) 
HANDLE
 __stdcall 
CreateIoCompletionPort(
    HANDLE FileHandle,
    HANDLE ExistingCompletionPort,
    DWORD CompletionKey,
    DWORD NumberOfConcurrentThreads
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetQueuedCompletionStatus(
    HANDLE CompletionPort,
    LPDWORD lpNumberOfBytesTransferred,
    LPDWORD lpCompletionKey,
    LPOVERLAPPED *lpOverlapped,
    DWORD dwMilliseconds
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
PostQueuedCompletionStatus(
    HANDLE CompletionPort,
    DWORD dwNumberOfBytesTransferred,
    DWORD dwCompletionKey,
    LPOVERLAPPED lpOverlapped
    );






 __declspec(dllimport) 
UINT
 __stdcall 
SetErrorMode(
    UINT uMode
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
ReadProcessMemory(
    HANDLE hProcess,
    LPCVOID lpBaseAddress,
    LPVOID lpBuffer,
    DWORD nSize,
    LPDWORD lpNumberOfBytesRead
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
WriteProcessMemory(
    HANDLE hProcess,
    LPVOID lpBaseAddress,
    LPVOID lpBuffer,
    DWORD nSize,
    LPDWORD lpNumberOfBytesWritten
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
GetThreadContext(
    HANDLE hThread,
    LPCONTEXT lpContext
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetThreadContext(
    HANDLE hThread,
     const  CONTEXT *lpContext
    );


 __declspec(dllimport) 
DWORD
 __stdcall 
SuspendThread(
    HANDLE hThread
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
ResumeThread(
    HANDLE hThread
    );

 __declspec(dllimport) 
 void 
 __stdcall 
DebugBreak(
     void 
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
WaitForDebugEvent(
    LPDEBUG_EVENT lpDebugEvent,
    DWORD dwMilliseconds
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
ContinueDebugEvent(
    DWORD dwProcessId,
    DWORD dwThreadId,
    DWORD dwContinueStatus
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
DebugActiveProcess(
    DWORD dwProcessId
    );

 __declspec(dllimport) 
 void 
 __stdcall 
InitializeCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
    );

 __declspec(dllimport) 
 void 
 __stdcall 
EnterCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
    );

 __declspec(dllimport) 
 void 
 __stdcall 
LeaveCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
    );

 __declspec(dllimport) 
 void 
 __stdcall 
DeleteCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetEvent(
    HANDLE hEvent
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
ResetEvent(
    HANDLE hEvent
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
PulseEvent(
    HANDLE hEvent
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
ReleaseSemaphore(
    HANDLE hSemaphore,
    LONG lReleaseCount,
    LPLONG lpPreviousCount
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
ReleaseMutex(
    HANDLE hMutex
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
WaitForSingleObject(
    HANDLE hHandle,
    DWORD dwMilliseconds
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
WaitForMultipleObjects(
    DWORD nCount,
     const  HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds
    );

 __declspec(dllimport) 
 void 
 __stdcall 
Sleep(
    DWORD dwMilliseconds
    );

 __declspec(dllimport) 
HGLOBAL
 __stdcall 
LoadResource(
    HMODULE hModule,
    HRSRC hResInfo
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
SizeofResource(
    HMODULE hModule,
    HRSRC hResInfo
    );


 __declspec(dllimport) 
ATOM
 __stdcall 
GlobalDeleteAtom(
    ATOM nAtom
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
InitAtomTable(
    DWORD nSize
    );

 __declspec(dllimport) 
ATOM
 __stdcall 
DeleteAtom(
    ATOM nAtom
    );

 __declspec(dllimport) 
UINT
 __stdcall 
SetHandleCount(
    UINT uNumber
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
GetLogicalDrives(
     void 
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
LockFile(
    HANDLE hFile,
    DWORD dwFileOffsetLow,
    DWORD dwFileOffsetHigh,
    DWORD nNumberOfBytesToLockLow,
    DWORD nNumberOfBytesToLockHigh
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
UnlockFile(
    HANDLE hFile,
    DWORD dwFileOffsetLow,
    DWORD dwFileOffsetHigh,
    DWORD nNumberOfBytesToUnlockLow,
    DWORD nNumberOfBytesToUnlockHigh
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
LockFileEx(
    HANDLE hFile,
    DWORD dwFlags,
    DWORD dwReserved,
    DWORD nNumberOfBytesToLockLow,
    DWORD nNumberOfBytesToLockHigh,
    LPOVERLAPPED lpOverlapped
    );




 __declspec(dllimport) 
BOOL
 __stdcall 
UnlockFileEx(
    HANDLE hFile,
    DWORD dwReserved,
    DWORD nNumberOfBytesToUnlockLow,
    DWORD nNumberOfBytesToUnlockHigh,
    LPOVERLAPPED lpOverlapped
    );

typedef struct _BY_HANDLE_FILE_INFORMATION {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD dwVolumeSerialNumber;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD nNumberOfLinks;
    DWORD nFileIndexHigh;
    DWORD nFileIndexLow;
} BY_HANDLE_FILE_INFORMATION, *PBY_HANDLE_FILE_INFORMATION, *LPBY_HANDLE_FILE_INFORMATION;

 __declspec(dllimport) 
BOOL
 __stdcall 
GetFileInformationByHandle(
    HANDLE hFile,
    LPBY_HANDLE_FILE_INFORMATION lpFileInformation
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
GetFileType(
    HANDLE hFile
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
GetFileSize(
    HANDLE hFile,
    LPDWORD lpFileSizeHigh
    );

 __declspec(dllimport) 
HANDLE
 __stdcall 
GetStdHandle(
    DWORD nStdHandle
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetStdHandle(
    DWORD nStdHandle,
    HANDLE hHandle
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
WriteFile(
    HANDLE hFile,
    LPCVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten,
    LPOVERLAPPED lpOverlapped
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
ReadFile(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
FlushFileBuffers(
    HANDLE hFile
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
DeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned,
    LPOVERLAPPED lpOverlapped
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetEndOfFile(
    HANDLE hFile
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
SetFilePointer(
    HANDLE hFile,
    LONG lDistanceToMove,
    PLONG lpDistanceToMoveHigh,
    DWORD dwMoveMethod
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
FindClose(
    HANDLE hFindFile
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetFileTime(
    HANDLE hFile,
    LPFILETIME lpCreationTime,
    LPFILETIME lpLastAccessTime,
    LPFILETIME lpLastWriteTime
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetFileTime(
    HANDLE hFile,
     const  FILETIME *lpCreationTime,
     const  FILETIME *lpLastAccessTime,
     const  FILETIME *lpLastWriteTime
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
CloseHandle(
    HANDLE hObject
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
DuplicateHandle(
    HANDLE hSourceProcessHandle,
    HANDLE hSourceHandle,
    HANDLE hTargetProcessHandle,
    LPHANDLE lpTargetHandle,
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwOptions
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetHandleInformation(
    HANDLE hObject,
    LPDWORD lpdwFlags
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetHandleInformation(
    HANDLE hObject,
    DWORD dwMask,
    DWORD dwFlags
    );






 __declspec(dllimport) 
DWORD
 __stdcall 
LoadModule(
    LPCSTR lpModuleName,
    LPVOID lpParameterBlock
    );

 __declspec(dllimport) 
UINT
 __stdcall 
WinExec(
    LPCSTR lpCmdLine,
    UINT uCmdShow
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
ClearCommBreak(
    HANDLE hFile
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
ClearCommError(
    HANDLE hFile,
    LPDWORD lpErrors,
    LPCOMSTAT lpStat
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetupComm(
    HANDLE hFile,
    DWORD dwInQueue,
    DWORD dwOutQueue
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
EscapeCommFunction(
    HANDLE hFile,
    DWORD dwFunc
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetCommConfig(
    HANDLE hCommDev,
    LPCOMMCONFIG lpCC,
    LPDWORD lpdwSize
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetCommMask(
    HANDLE hFile,
    LPDWORD lpEvtMask
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetCommProperties(
    HANDLE hFile,
    LPCOMMPROP lpCommProp
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetCommModemStatus(
    HANDLE hFile,
    LPDWORD lpModemStat
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetCommState(
    HANDLE hFile,
    LPDCB lpDCB
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetCommTimeouts(
    HANDLE hFile,
    LPCOMMTIMEOUTS lpCommTimeouts
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
PurgeComm(
    HANDLE hFile,
    DWORD dwFlags
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetCommBreak(
    HANDLE hFile
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetCommConfig(
    HANDLE hCommDev,
    LPCOMMCONFIG lpCC,
    DWORD dwSize
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetCommMask(
    HANDLE hFile,
    DWORD dwEvtMask
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetCommState(
    HANDLE hFile,
    LPDCB lpDCB
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetCommTimeouts(
    HANDLE hFile,
    LPCOMMTIMEOUTS lpCommTimeouts
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
TransmitCommChar(
    HANDLE hFile,
    char cChar
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
WaitCommEvent(
    HANDLE hFile,
    LPDWORD lpEvtMask,
    LPOVERLAPPED lpOverlapped
    );


 __declspec(dllimport) 
DWORD
 __stdcall 
SetTapePosition(
    HANDLE hDevice,
    DWORD dwPositionMethod,
    DWORD dwPartition,
    DWORD dwOffsetLow,
    DWORD dwOffsetHigh,
    BOOL bImmediate
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
GetTapePosition(
    HANDLE hDevice,
    DWORD dwPositionType,
    LPDWORD lpdwPartition,
    LPDWORD lpdwOffsetLow,
    LPDWORD lpdwOffsetHigh
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
PrepareTape(
    HANDLE hDevice,
    DWORD dwOperation,
    BOOL bImmediate
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
EraseTape(
    HANDLE hDevice,
    DWORD dwEraseType,
    BOOL bImmediate
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
CreateTapePartition(
    HANDLE hDevice,
    DWORD dwPartitionMethod,
    DWORD dwCount,
    DWORD dwSize
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
WriteTapemark(
    HANDLE hDevice,
    DWORD dwTapemarkType,
    DWORD dwTapemarkCount,
    BOOL bImmediate
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
GetTapeStatus(
    HANDLE hDevice
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
GetTapeParameters(
    HANDLE hDevice,
    DWORD dwOperation,
    LPDWORD lpdwSize,
    LPVOID lpTapeInformation
    );




 __declspec(dllimport) 
DWORD
 __stdcall 
SetTapeParameters(
    HANDLE hDevice,
    DWORD dwOperation,
    LPVOID lpTapeInformation
    );




 __declspec(dllimport) 
BOOL
 __stdcall 
Beep(
    DWORD dwFreq,
    DWORD dwDuration
    );

 __declspec(dllimport) 
 void 
 __stdcall 
OpenSound(
     void 
    );

 __declspec(dllimport) 
 void 
 __stdcall 
CloseSound(
     void 
    );

 __declspec(dllimport) 
 void 
 __stdcall 
StartSound(
     void 
    );

 __declspec(dllimport) 
 void 
 __stdcall 
StopSound(
     void 
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
WaitSoundState(
    DWORD nState
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
SyncAllVoices(
     void 
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
CountVoiceNotes(
    DWORD nVoice
    );

 __declspec(dllimport) 
LPDWORD
 __stdcall 
GetThresholdEvent(
     void 
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
GetThresholdStatus(
     void 
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
SetSoundNoise(
    DWORD nSource,
    DWORD nDuration
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
SetVoiceAccent(
    DWORD nVoice,
    DWORD nTempo,
    DWORD nVolume,
    DWORD nMode,
    DWORD nPitch
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
SetVoiceEnvelope(
    DWORD nVoice,
    DWORD nShape,
    DWORD nRepeat
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
SetVoiceNote(
    DWORD nVoice,
    DWORD nValue,
    DWORD nLength,
    DWORD nCdots
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
SetVoiceQueueSize(
    DWORD nVoice,
    DWORD nBytes
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
SetVoiceSound(
    DWORD nVoice,
    DWORD Frequency,
    DWORD nDuration
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
SetVoiceThreshold(
    DWORD nVoice,
    DWORD nNotes
    );

 __declspec(dllimport) 
int
 __stdcall 
MulDiv(
    int nNumber,
    int nNumerator,
    int nDenominator
    );

 __declspec(dllimport) 
 void 
 __stdcall 
GetSystemTime(
    LPSYSTEMTIME lpSystemTime
    );

 __declspec(dllimport) 
 void 
 __stdcall 
GetSystemTimeAsFileTime(
    LPFILETIME lpSystemTimeAsFileTime
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetSystemTime(
     const  SYSTEMTIME *lpSystemTime
    );

 __declspec(dllimport) 
 void 
 __stdcall 
GetLocalTime(
    LPSYSTEMTIME lpSystemTime
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetLocalTime(
     const  SYSTEMTIME *lpSystemTime
    );

 __declspec(dllimport) 
 void 
 __stdcall 
GetSystemInfo(
    LPSYSTEM_INFO lpSystemInfo
    );

typedef struct _TIME_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
} TIME_ZONE_INFORMATION, *PTIME_ZONE_INFORMATION, *LPTIME_ZONE_INFORMATION;

 __declspec(dllimport) 
BOOL
 __stdcall 
SystemTimeToTzSpecificLocalTime(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation,
    LPSYSTEMTIME lpUniversalTime,
    LPSYSTEMTIME lpLocalTime
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
GetTimeZoneInformation(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetTimeZoneInformation(
     const  TIME_ZONE_INFORMATION *lpTimeZoneInformation
    );


//
// Routines to convert back and forth between system time and file time
//

 __declspec(dllimport) 
BOOL
 __stdcall 
SystemTimeToFileTime(
     const  SYSTEMTIME *lpSystemTime,
    LPFILETIME lpFileTime
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
FileTimeToLocalFileTime(
     const  FILETIME *lpFileTime,
    LPFILETIME lpLocalFileTime
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
LocalFileTimeToFileTime(
     const  FILETIME *lpLocalFileTime,
    LPFILETIME lpFileTime
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
FileTimeToSystemTime(
     const  FILETIME *lpFileTime,
    LPSYSTEMTIME lpSystemTime
    );

 __declspec(dllimport) 
LONG
 __stdcall 
CompareFileTime(
     const  FILETIME *lpFileTime1,
     const  FILETIME *lpFileTime2
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
FileTimeToDosDateTime(
     const  FILETIME *lpFileTime,
    LPWORD lpFatDate,
    LPWORD lpFatTime
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
DosDateTimeToFileTime(
    WORD wFatDate,
    WORD wFatTime,
    LPFILETIME lpFileTime
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
GetTickCount(
     void 
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetSystemTimeAdjustment(
    DWORD dwTimeAdjustment,
    BOOL  bTimeAdjustmentDisabled
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetSystemTimeAdjustment(
    PDWORD lpTimeAdjustment,
    PDWORD lpTimeIncrement,
    PBOOL  lpTimeAdjustmentDisabled
    );


 __declspec(dllimport) 
DWORD
 __stdcall 
FormatMessageA(
    DWORD dwFlags,
    LPCVOID lpSource,
    DWORD dwMessageId,
    DWORD dwLanguageId,
    LPSTR lpBuffer,
    DWORD nSize,
    va_list *Arguments
    );
 __declspec(dllimport) 
DWORD
 __stdcall 
FormatMessageW(
    DWORD dwFlags,
    LPCVOID lpSource,
    DWORD dwMessageId,
    DWORD dwLanguageId,
    LPWSTR lpBuffer,
    DWORD nSize,
    va_list *Arguments
    );
#line 2828 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE











 __declspec(dllimport) 
BOOL
 __stdcall 
CreatePipe(
    PHANDLE hReadPipe,
    PHANDLE hWritePipe,
    LPSECURITY_ATTRIBUTES lpPipeAttributes,
    DWORD nSize
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
ConnectNamedPipe(
    HANDLE hNamedPipe,
    LPOVERLAPPED lpOverlapped
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
DisconnectNamedPipe(
    HANDLE hNamedPipe
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetNamedPipeHandleState(
    HANDLE hNamedPipe,
    LPDWORD lpMode,
    LPDWORD lpMaxCollectionCount,
    LPDWORD lpCollectDataTimeout
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetNamedPipeInfo(
    HANDLE hNamedPipe,
    LPDWORD lpFlags,
    LPDWORD lpOutBufferSize,
    LPDWORD lpInBufferSize,
    LPDWORD lpMaxInstances
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
PeekNamedPipe(
    HANDLE hNamedPipe,
    LPVOID lpBuffer,
    DWORD nBufferSize,
    LPDWORD lpBytesRead,
    LPDWORD lpTotalBytesAvail,
    LPDWORD lpBytesLeftThisMessage
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
TransactNamedPipe(
    HANDLE hNamedPipe,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesRead,
    LPOVERLAPPED lpOverlapped
    );

 __declspec(dllimport) 
HANDLE
 __stdcall 
CreateMailslotA(
    LPCSTR lpName,
    DWORD nMaxMessageSize,
    DWORD lReadTimeout,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
 __declspec(dllimport) 
HANDLE
 __stdcall 
CreateMailslotW(
    LPCWSTR lpName,
    DWORD nMaxMessageSize,
    DWORD lReadTimeout,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
#line 2933 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
GetMailslotInfo(
    HANDLE hMailslot,
    LPDWORD lpMaxMessageSize,
    LPDWORD lpNextSize,
    LPDWORD lpMessageCount,
    LPDWORD lpReadTimeout
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetMailslotInfo(
    HANDLE hMailslot,
    DWORD lReadTimeout
    );

 __declspec(dllimport) 
LPVOID
 __stdcall 
MapViewOfFile(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    DWORD dwNumberOfBytesToMap
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
FlushViewOfFile(
    LPCVOID lpBaseAddress,
    DWORD dwNumberOfBytesToFlush
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
UnmapViewOfFile(
    LPCVOID lpBaseAddress
    );


//
// _l Compat Functions
//

 __declspec(dllimport) 
int
 __stdcall 
lstrcmpA(
    LPCSTR lpString1,
    LPCSTR lpString2
    );
 __declspec(dllimport) 
int
 __stdcall 
lstrcmpW(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );
#line 3003 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
int
 __stdcall 
lstrcmpiA(
    LPCSTR lpString1,
    LPCSTR lpString2
    );
 __declspec(dllimport) 
int
 __stdcall 
lstrcmpiW(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );
#line 3023 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
LPSTR
 __stdcall 
lstrcpynA(
    LPSTR lpString1,
    LPCSTR lpString2,
    int iMaxLength
    );
 __declspec(dllimport) 
LPWSTR
 __stdcall 
lstrcpynW(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int iMaxLength
    );
#line 3045 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
LPSTR
 __stdcall 
lstrcpyA(
    LPSTR lpString1,
    LPCSTR lpString2
    );
 __declspec(dllimport) 
LPWSTR
 __stdcall 
lstrcpyW(
    LPWSTR lpString1,
    LPCWSTR lpString2
    );
#line 3065 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
LPSTR
 __stdcall 
lstrcatA(
    LPSTR lpString1,
    LPCSTR lpString2
    );
 __declspec(dllimport) 
LPWSTR
 __stdcall 
lstrcatW(
    LPWSTR lpString1,
    LPCWSTR lpString2
    );
#line 3085 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
int
 __stdcall 
lstrlenA(
    LPCSTR lpString
    );
 __declspec(dllimport) 
int
 __stdcall 
lstrlenW(
    LPCWSTR lpString
    );
#line 3103 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
HFILE
 __stdcall 
OpenFile(
    LPCSTR lpFileName,
    LPOFSTRUCT lpReOpenBuff,
    UINT uStyle
    );

 __declspec(dllimport) 
HFILE
 __stdcall 
_lopen(
    LPCSTR lpPathName,
    int iReadWrite
    );

 __declspec(dllimport) 
HFILE
 __stdcall 
_lcreat(
    LPCSTR lpPathName,
    int  iAttribute
    );

 __declspec(dllimport) 
UINT
 __stdcall 
_lread(
    HFILE hFile,
    LPVOID lpBuffer,
    UINT uBytes
    );

 __declspec(dllimport) 
UINT
 __stdcall 
_lwrite(
    HFILE hFile,
    LPCSTR lpBuffer,
    UINT uBytes
    );

 __declspec(dllimport) 
long
 __stdcall 
_hread(
    HFILE hFile,
    LPVOID lpBuffer,
    long lBytes
    );

 __declspec(dllimport) 
long
 __stdcall 
_hwrite(
    HFILE hFile,
    LPCSTR lpBuffer,
    long lBytes
    );

 __declspec(dllimport) 
HFILE
 __stdcall 
_lclose(
    HFILE hFile
    );

 __declspec(dllimport) 
LONG
 __stdcall 
_llseek(
    HFILE hFile,
    LONG lOffset,
    int iOrigin
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
IsTextUnicode(
     const  LPVOID lpBuffer,
    int cb,
    LPINT lpi
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
TlsAlloc(
     void 
    );



 __declspec(dllimport) 
LPVOID
 __stdcall 
TlsGetValue(
    DWORD dwTlsIndex
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
TlsSetValue(
    DWORD dwTlsIndex,
    LPVOID lpTlsValue
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
TlsFree(
    DWORD dwTlsIndex
    );

typedef
 void 
( __stdcall  *LPOVERLAPPED_COMPLETION_ROUTINE)(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    LPOVERLAPPED lpOverlapped
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
SleepEx(
    DWORD dwMilliseconds,
    BOOL bAlertable
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
WaitForSingleObjectEx(
    HANDLE hHandle,
    DWORD dwMilliseconds,
    BOOL bAlertable
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
WaitForMultipleObjectsEx(
    DWORD nCount,
     const  HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds,
    BOOL bAlertable
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
ReadFileEx(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPOVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
WriteFileEx(
    HANDLE hFile,
    LPCVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPOVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
BackupRead(
    HANDLE hFile,
    LPBYTE lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    BOOL bAbort,
    BOOL bProcessSecurity,
    LPVOID *lpContext
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
BackupSeek(
    HANDLE hFile,
    DWORD  dwLowBytesToSeek,
    DWORD  dwHighBytesToSeek,
    LPDWORD lpdwLowByteSeeked,
    LPDWORD lpdwHighByteSeeked,
    LPVOID *lpContext
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
BackupWrite(
    HANDLE hFile,
    LPBYTE lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten,
    BOOL bAbort,
    BOOL bProcessSecurity,
    LPVOID *lpContext
    );

//
//  Stream id structure
//
typedef struct _WIN32_STREAM_ID {
        DWORD          dwStreamId ;
        DWORD          dwStreamAttributes ;
        LARGE_INTEGER  Size ;
        DWORD          dwStreamNameSize ;
        WCHAR          cStreamName[  1  ] ;
} WIN32_STREAM_ID, *LPWIN32_STREAM_ID ;

//
//  Stream Ids
//









//
//  Stream Attributes
//






//
// Dual Mode API below this line. Dual Mode Structures also included.
//






// ignored for non-x86 platforms



 

/* WINVER >= 0x0400 */

typedef struct _STARTUPINFOA {
    DWORD   cb;
    LPSTR   lpReserved;
    LPSTR   lpDesktop;
    LPSTR   lpTitle;
    DWORD   dwX;
    DWORD   dwY;
    DWORD   dwXSize;
    DWORD   dwYSize;
    DWORD   dwXCountChars;
    DWORD   dwYCountChars;
    DWORD   dwFillAttribute;
    DWORD   dwFlags;
    WORD    wShowWindow;
    WORD    cbReserved2;
    LPBYTE  lpReserved2;
    HANDLE  hStdInput;
    HANDLE  hStdOutput;
    HANDLE  hStdError;
} STARTUPINFOA, *LPSTARTUPINFOA;
typedef struct _STARTUPINFOW {
    DWORD   cb;
    LPWSTR  lpReserved;
    LPWSTR  lpDesktop;
    LPWSTR  lpTitle;
    DWORD   dwX;
    DWORD   dwY;
    DWORD   dwXSize;
    DWORD   dwYSize;
    DWORD   dwXCountChars;
    DWORD   dwYCountChars;
    DWORD   dwFillAttribute;
    DWORD   dwFlags;
    WORD    wShowWindow;
    WORD    cbReserved2;
    LPBYTE  lpReserved2;
    HANDLE  hStdInput;
    HANDLE  hStdOutput;
    HANDLE  hStdError;
} STARTUPINFOW, *LPSTARTUPINFOW;
#line 3412 "C:\WATCOM\H\NT\winbase.h"
typedef STARTUPINFOA STARTUPINFO;
typedef LPSTARTUPINFOA LPSTARTUPINFO;
// UNICODE



typedef struct _WIN32_FIND_DATAA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    CHAR   cFileName[  260  ];
    CHAR   cAlternateFileName[ 14 ];
} WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;
typedef struct _WIN32_FIND_DATAW {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    WCHAR  cFileName[  260  ];
    WCHAR  cAlternateFileName[ 14 ];
} WIN32_FIND_DATAW, *PWIN32_FIND_DATAW, *LPWIN32_FIND_DATAW;
#line 3447 "C:\WATCOM\H\NT\winbase.h"
typedef WIN32_FIND_DATAA WIN32_FIND_DATA;
typedef PWIN32_FIND_DATAA PWIN32_FIND_DATA;
typedef LPWIN32_FIND_DATAA LPWIN32_FIND_DATA;
// UNICODE

 __declspec(dllimport) 
HANDLE
 __stdcall 
CreateMutexA(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCSTR lpName
    );
 __declspec(dllimport) 
HANDLE
 __stdcall 
CreateMutexW(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCWSTR lpName
    );
#line 3471 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
HANDLE
 __stdcall 
OpenMutexA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );
 __declspec(dllimport) 
HANDLE
 __stdcall 
OpenMutexW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );
#line 3493 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
HANDLE
 __stdcall 
CreateEventA(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCSTR lpName
    );
 __declspec(dllimport) 
HANDLE
 __stdcall 
CreateEventW(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    );
#line 3517 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
HANDLE
 __stdcall 
OpenEventA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );
 __declspec(dllimport) 
HANDLE
 __stdcall 
OpenEventW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );
#line 3539 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
HANDLE
 __stdcall 
CreateSemaphoreA(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCSTR lpName
    );
 __declspec(dllimport) 
HANDLE
 __stdcall 
CreateSemaphoreW(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCWSTR lpName
    );
#line 3563 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
HANDLE
 __stdcall 
OpenSemaphoreA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );
 __declspec(dllimport) 
HANDLE
 __stdcall 
OpenSemaphoreW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );
#line 3585 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
HANDLE
 __stdcall 
CreateFileMappingA(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCSTR lpName
    );
 __declspec(dllimport) 
HANDLE
 __stdcall 
CreateFileMappingW(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName
    );
#line 3613 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
HANDLE
 __stdcall 
OpenFileMappingA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );
 __declspec(dllimport) 
HANDLE
 __stdcall 
OpenFileMappingW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );
#line 3635 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
DWORD
 __stdcall 
GetLogicalDriveStringsA(
    DWORD nBufferLength,
    LPSTR lpBuffer
    );
 __declspec(dllimport) 
DWORD
 __stdcall 
GetLogicalDriveStringsW(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    );
#line 3655 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
HMODULE
 __stdcall 
LoadLibraryA(
    LPCSTR lpLibFileName
    );
 __declspec(dllimport) 
HMODULE
 __stdcall 
LoadLibraryW(
    LPCWSTR lpLibFileName
    );
#line 3673 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
HMODULE
 __stdcall 
LoadLibraryExA(
    LPCSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    );
 __declspec(dllimport) 
HMODULE
 __stdcall 
LoadLibraryExW(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    );
#line 3695 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE







 __declspec(dllimport) 
DWORD
 __stdcall 
GetModuleFileNameA(
    HMODULE hModule,
    LPSTR lpFilename,
    DWORD nSize
    );
 __declspec(dllimport) 
DWORD
 __stdcall 
GetModuleFileNameW(
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    );
#line 3723 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
HMODULE
 __stdcall 
GetModuleHandleA(
    LPCSTR lpModuleName
    );
 __declspec(dllimport) 
HMODULE
 __stdcall 
GetModuleHandleW(
    LPCWSTR lpModuleName
    );
#line 3741 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
CreateProcessA(
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
CreateProcessW(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );
#line 3777 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
SetProcessShutdownParameters(
    DWORD dwLevel,
    DWORD dwFlags
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetProcessShutdownParameters(
    LPDWORD lpdwLevel,
    LPDWORD lpdwFlags
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
GetProcessVersion(
    DWORD ProcessId
    );

 __declspec(dllimport) 
 void 
 __stdcall 
FatalAppExitA(
    UINT uAction,
    LPCSTR lpMessageText
    );
 __declspec(dllimport) 
 void 
 __stdcall 
FatalAppExitW(
    UINT uAction,
    LPCWSTR lpMessageText
    );
#line 3820 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
 void 
 __stdcall 
GetStartupInfoA(
    LPSTARTUPINFOA lpStartupInfo
    );
 __declspec(dllimport) 
 void 
 __stdcall 
GetStartupInfoW(
    LPSTARTUPINFOW lpStartupInfo
    );
#line 3838 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
LPSTR
 __stdcall 
GetCommandLineA(
     void 
    );
 __declspec(dllimport) 
LPWSTR
 __stdcall 
GetCommandLineW(
     void 
    );
#line 3856 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
DWORD
 __stdcall 
GetEnvironmentVariableA(
    LPCSTR lpName,
    LPSTR lpBuffer,
    DWORD nSize
    );
 __declspec(dllimport) 
DWORD
 __stdcall 
GetEnvironmentVariableW(
    LPCWSTR lpName,
    LPWSTR lpBuffer,
    DWORD nSize
    );
#line 3878 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
SetEnvironmentVariableA(
    LPCSTR lpName,
    LPCSTR lpValue
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
SetEnvironmentVariableW(
    LPCWSTR lpName,
    LPCWSTR lpValue
    );
#line 3898 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
DWORD
 __stdcall 
ExpandEnvironmentStringsA(
    LPCSTR lpSrc,
    LPSTR lpDst,
    DWORD nSize
    );
 __declspec(dllimport) 
DWORD
 __stdcall 
ExpandEnvironmentStringsW(
    LPCWSTR lpSrc,
    LPWSTR lpDst,
    DWORD nSize
    );
#line 3920 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
 void 
 __stdcall 
OutputDebugStringA(
    LPCSTR lpOutputString
    );
 __declspec(dllimport) 
 void 
 __stdcall 
OutputDebugStringW(
    LPCWSTR lpOutputString
    );
#line 3938 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
HRSRC
 __stdcall 
FindResourceA(
    HMODULE hModule,
    LPCSTR lpName,
    LPCSTR lpType
    );
 __declspec(dllimport) 
HRSRC
 __stdcall 
FindResourceW(
    HMODULE hModule,
    LPCWSTR lpName,
    LPCWSTR lpType
    );
#line 3960 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
HRSRC
 __stdcall 
FindResourceExA(
    HMODULE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    WORD    wLanguage
    );
 __declspec(dllimport) 
HRSRC
 __stdcall 
FindResourceExW(
    HMODULE hModule,
    LPCWSTR lpType,
    LPCWSTR lpName,
    WORD    wLanguage
    );
#line 3984 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

#line 3995 "C:\WATCOM\H\NT\winbase.h"
typedef FARPROC ENUMRESTYPEPROC;
typedef FARPROC ENUMRESNAMEPROC;
typedef FARPROC ENUMRESLANGPROC;


 __declspec(dllimport) 
BOOL
 __stdcall 
EnumResourceTypesA(
    HMODULE hModule,
    ENUMRESTYPEPROC lpEnumFunc,
    LONG lParam
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
EnumResourceTypesW(
    HMODULE hModule,
    ENUMRESTYPEPROC lpEnumFunc,
    LONG lParam
    );
#line 4019 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE


 __declspec(dllimport) 
BOOL
 __stdcall 
EnumResourceNamesA(
    HMODULE hModule,
    LPCSTR lpType,
    ENUMRESNAMEPROC lpEnumFunc,
    LONG lParam
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
EnumResourceNamesW(
    HMODULE hModule,
    LPCWSTR lpType,
    ENUMRESNAMEPROC lpEnumFunc,
    LONG lParam
    );
#line 4044 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
EnumResourceLanguagesA(
    HMODULE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    ENUMRESLANGPROC lpEnumFunc,
    LONG lParam
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
EnumResourceLanguagesW(
    HMODULE hModule,
    LPCWSTR lpType,
    LPCWSTR lpName,
    ENUMRESLANGPROC lpEnumFunc,
    LONG lParam
    );
#line 4070 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
HANDLE
 __stdcall 
BeginUpdateResourceA(
    LPCSTR pFileName,
    BOOL bDeleteExistingResources
    );
 __declspec(dllimport) 
HANDLE
 __stdcall 
BeginUpdateResourceW(
    LPCWSTR pFileName,
    BOOL bDeleteExistingResources
    );
#line 4090 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
UpdateResourceA(
    HANDLE      hUpdate,
    LPCSTR     lpType,
    LPCSTR     lpName,
    WORD        wLanguage,
    LPVOID      lpData,
    DWORD       cbData
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
UpdateResourceW(
    HANDLE      hUpdate,
    LPCWSTR     lpType,
    LPCWSTR     lpName,
    WORD        wLanguage,
    LPVOID      lpData,
    DWORD       cbData
    );
#line 4118 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
EndUpdateResourceA(
    HANDLE      hUpdate,
    BOOL        fDiscard
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
EndUpdateResourceW(
    HANDLE      hUpdate,
    BOOL        fDiscard
    );
#line 4138 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
ATOM
 __stdcall 
GlobalAddAtomA(
    LPCSTR lpString
    );
 __declspec(dllimport) 
ATOM
 __stdcall 
GlobalAddAtomW(
    LPCWSTR lpString
    );
#line 4156 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
ATOM
 __stdcall 
GlobalFindAtomA(
    LPCSTR lpString
    );
 __declspec(dllimport) 
ATOM
 __stdcall 
GlobalFindAtomW(
    LPCWSTR lpString
    );
#line 4174 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
UINT
 __stdcall 
GlobalGetAtomNameA(
    ATOM nAtom,
    LPSTR lpBuffer,
    int nSize
    );
 __declspec(dllimport) 
UINT
 __stdcall 
GlobalGetAtomNameW(
    ATOM nAtom,
    LPWSTR lpBuffer,
    int nSize
    );
#line 4196 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
ATOM
 __stdcall 
AddAtomA(
    LPCSTR lpString
    );
 __declspec(dllimport) 
ATOM
 __stdcall 
AddAtomW(
    LPCWSTR lpString
    );
#line 4214 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
ATOM
 __stdcall 
FindAtomA(
    LPCSTR lpString
    );
 __declspec(dllimport) 
ATOM
 __stdcall 
FindAtomW(
    LPCWSTR lpString
    );
#line 4232 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
UINT
 __stdcall 
GetAtomNameA(
    ATOM nAtom,
    LPSTR lpBuffer,
    int nSize
    );
 __declspec(dllimport) 
UINT
 __stdcall 
GetAtomNameW(
    ATOM nAtom,
    LPWSTR lpBuffer,
    int nSize
    );
#line 4254 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
UINT
 __stdcall 
GetProfileIntA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    INT nDefault
    );
 __declspec(dllimport) 
UINT
 __stdcall 
GetProfileIntW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT nDefault
    );
#line 4276 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
DWORD
 __stdcall 
GetProfileStringA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpDefault,
    LPSTR lpReturnedString,
    DWORD nSize
    );
 __declspec(dllimport) 
DWORD
 __stdcall 
GetProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR lpReturnedString,
    DWORD nSize
    );
#line 4302 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
WriteProfileStringA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpString
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
WriteProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpString
    );
#line 4324 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
DWORD
 __stdcall 
GetProfileSectionA(
    LPCSTR lpAppName,
    LPSTR lpReturnedString,
    DWORD nSize
    );
 __declspec(dllimport) 
DWORD
 __stdcall 
GetProfileSectionW(
    LPCWSTR lpAppName,
    LPWSTR lpReturnedString,
    DWORD nSize
    );
#line 4346 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
WriteProfileSectionA(
    LPCSTR lpAppName,
    LPCSTR lpString
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
WriteProfileSectionW(
    LPCWSTR lpAppName,
    LPCWSTR lpString
    );
#line 4366 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
UINT
 __stdcall 
GetPrivateProfileIntA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    INT nDefault,
    LPCSTR lpFileName
    );
 __declspec(dllimport) 
UINT
 __stdcall 
GetPrivateProfileIntW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT nDefault,
    LPCWSTR lpFileName
    );
#line 4390 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
DWORD
 __stdcall 
GetPrivateProfileStringA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpDefault,
    LPSTR lpReturnedString,
    DWORD nSize,
    LPCSTR lpFileName
    );
 __declspec(dllimport) 
DWORD
 __stdcall 
GetPrivateProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR lpReturnedString,
    DWORD nSize,
    LPCWSTR lpFileName
    );
#line 4418 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
WritePrivateProfileStringA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpString,
    LPCSTR lpFileName
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
WritePrivateProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    );
#line 4442 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
DWORD
 __stdcall 
GetPrivateProfileSectionA(
    LPCSTR lpAppName,
    LPSTR lpReturnedString,
    DWORD nSize,
    LPCSTR lpFileName
    );
 __declspec(dllimport) 
DWORD
 __stdcall 
GetPrivateProfileSectionW(
    LPCWSTR lpAppName,
    LPWSTR lpReturnedString,
    DWORD nSize,
    LPCWSTR lpFileName
    );
#line 4466 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
WritePrivateProfileSectionA(
    LPCSTR lpAppName,
    LPCSTR lpString,
    LPCSTR lpFileName
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
WritePrivateProfileSectionW(
    LPCWSTR lpAppName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    );
#line 4488 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE


 __declspec(dllimport) 
DWORD
 __stdcall 
GetPrivateProfileSectionNamesA(
    LPSTR lpszReturnBuffer,
    DWORD nSize,
    LPCSTR lpFileName
    );
 __declspec(dllimport) 
DWORD
 __stdcall 
GetPrivateProfileSectionNamesW(
    LPWSTR lpszReturnBuffer,
    DWORD nSize,
    LPCWSTR lpFileName
    );
#line 4511 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
GetPrivateProfileStructA(
    LPCSTR lpszSection,
    LPCSTR lpszKey,
    LPVOID   lpStruct,
    UINT     uSizeStruct,
    LPCSTR szFile
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
GetPrivateProfileStructW(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID   lpStruct,
    UINT     uSizeStruct,
    LPCWSTR szFile
    );
#line 4537 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
WritePrivateProfileStructA(
    LPCSTR lpszSection,
    LPCSTR lpszKey,
    LPVOID   lpStruct,
    UINT     uSizeStruct,
    LPCSTR szFile
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
WritePrivateProfileStructW(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID   lpStruct,
    UINT     uSizeStruct,
    LPCWSTR szFile
    );
#line 4563 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE


 __declspec(dllimport) 
UINT
 __stdcall 
GetDriveTypeA(
    LPCSTR lpRootPathName
    );
 __declspec(dllimport) 
UINT
 __stdcall 
GetDriveTypeW(
    LPCWSTR lpRootPathName
    );
#line 4582 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
UINT
 __stdcall 
GetSystemDirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    );
 __declspec(dllimport) 
UINT
 __stdcall 
GetSystemDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    );
#line 4602 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
DWORD
 __stdcall 
GetTempPathA(
    DWORD nBufferLength,
    LPSTR lpBuffer
    );
 __declspec(dllimport) 
DWORD
 __stdcall 
GetTempPathW(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    );
#line 4622 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
UINT
 __stdcall 
GetTempFileNameA(
    LPCSTR lpPathName,
    LPCSTR lpPrefixString,
    UINT uUnique,
    LPSTR lpTempFileName
    );
 __declspec(dllimport) 
UINT
 __stdcall 
GetTempFileNameW(
    LPCWSTR lpPathName,
    LPCWSTR lpPrefixString,
    UINT uUnique,
    LPWSTR lpTempFileName
    );
#line 4646 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
UINT
 __stdcall 
GetWindowsDirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    );
 __declspec(dllimport) 
UINT
 __stdcall 
GetWindowsDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    );
#line 4666 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
SetCurrentDirectoryA(
    LPCSTR lpPathName
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
SetCurrentDirectoryW(
    LPCWSTR lpPathName
    );
#line 4684 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
DWORD
 __stdcall 
GetCurrentDirectoryA(
    DWORD nBufferLength,
    LPSTR lpBuffer
    );
 __declspec(dllimport) 
DWORD
 __stdcall 
GetCurrentDirectoryW(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    );
#line 4704 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
GetDiskFreeSpaceA(
    LPCSTR lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
GetDiskFreeSpaceW(
    LPCWSTR lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    );
#line 4730 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
CreateDirectoryA(
    LPCSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
CreateDirectoryW(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
#line 4750 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
CreateDirectoryExA(
    LPCSTR lpTemplateDirectory,
    LPCSTR lpNewDirectory,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
CreateDirectoryExW(
    LPCWSTR lpTemplateDirectory,
    LPCWSTR lpNewDirectory,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
#line 4772 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
RemoveDirectoryA(
    LPCSTR lpPathName
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
RemoveDirectoryW(
    LPCWSTR lpPathName
    );
#line 4790 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
DWORD
 __stdcall 
GetFullPathNameA(
    LPCSTR lpFileName,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart
    );
 __declspec(dllimport) 
DWORD
 __stdcall 
GetFullPathNameW(
    LPCWSTR lpFileName,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    );
#line 4814 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE






 __declspec(dllimport) 
BOOL
 __stdcall 
DefineDosDeviceA(
    DWORD dwFlags,
    LPCSTR lpDeviceName,
    LPCSTR lpTargetPath
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
DefineDosDeviceW(
    DWORD dwFlags,
    LPCWSTR lpDeviceName,
    LPCWSTR lpTargetPath
    );
#line 4841 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
DWORD
 __stdcall 
QueryDosDeviceA(
    LPCSTR lpDeviceName,
    LPSTR lpTargetPath,
    DWORD ucchMax
    );
 __declspec(dllimport) 
DWORD
 __stdcall 
QueryDosDeviceW(
    LPCWSTR lpDeviceName,
    LPWSTR lpTargetPath,
    DWORD ucchMax
    );
#line 4863 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE



 __declspec(dllimport) 
HANDLE
 __stdcall 
CreateFileA(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );
 __declspec(dllimport) 
HANDLE
 __stdcall 
CreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );
#line 4895 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
SetFileAttributesA(
    LPCSTR lpFileName,
    DWORD dwFileAttributes
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
SetFileAttributesW(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    );
#line 4915 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
DWORD
 __stdcall 
GetFileAttributesA(
    LPCSTR lpFileName
    );
 __declspec(dllimport) 
DWORD
 __stdcall 
GetFileAttributesW(
    LPCWSTR lpFileName
    );
#line 4933 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
DWORD
 __stdcall 
GetCompressedFileSizeA(
    LPCSTR lpFileName,
    LPDWORD lpFileSizeHigh
    );
 __declspec(dllimport) 
DWORD
 __stdcall 
GetCompressedFileSizeW(
    LPCWSTR lpFileName,
    LPDWORD lpFileSizeHigh
    );
#line 4953 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
DeleteFileA(
    LPCSTR lpFileName
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
DeleteFileW(
    LPCWSTR lpFileName
    );
#line 4971 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
HANDLE
 __stdcall 
FindFirstFileA(
    LPCSTR lpFileName,
    LPWIN32_FIND_DATAA lpFindFileData
    );
 __declspec(dllimport) 
HANDLE
 __stdcall 
FindFirstFileW(
    LPCWSTR lpFileName,
    LPWIN32_FIND_DATAW lpFindFileData
    );
#line 4991 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
FindNextFileA(
    HANDLE hFindFile,
    LPWIN32_FIND_DATAA lpFindFileData
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
FindNextFileW(
    HANDLE hFindFile,
    LPWIN32_FIND_DATAW lpFindFileData
    );
#line 5011 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
DWORD
 __stdcall 
SearchPathA(
    LPCSTR lpPath,
    LPCSTR lpFileName,
    LPCSTR lpExtension,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart
    );
 __declspec(dllimport) 
DWORD
 __stdcall 
SearchPathW(
    LPCWSTR lpPath,
    LPCWSTR lpFileName,
    LPCWSTR lpExtension,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    );
#line 5039 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
CopyFileA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    BOOL bFailIfExists
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
CopyFileW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    BOOL bFailIfExists
    );
#line 5061 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
MoveFileA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
MoveFileW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName
    );
#line 5081 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
MoveFileExA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    DWORD dwFlags
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
MoveFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    DWORD dwFlags
    );
#line 5103 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE





 __declspec(dllimport) 
HANDLE
 __stdcall 
CreateNamedPipeA(
    LPCSTR lpName,
    DWORD dwOpenMode,
    DWORD dwPipeMode,
    DWORD nMaxInstances,
    DWORD nOutBufferSize,
    DWORD nInBufferSize,
    DWORD nDefaultTimeOut,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
 __declspec(dllimport) 
HANDLE
 __stdcall 
CreateNamedPipeW(
    LPCWSTR lpName,
    DWORD dwOpenMode,
    DWORD dwPipeMode,
    DWORD nMaxInstances,
    DWORD nOutBufferSize,
    DWORD nInBufferSize,
    DWORD nDefaultTimeOut,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
#line 5139 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
GetNamedPipeHandleStateA(
    HANDLE hNamedPipe,
    LPDWORD lpState,
    LPDWORD lpCurInstances,
    LPDWORD lpMaxCollectionCount,
    LPDWORD lpCollectDataTimeout,
    LPSTR lpUserName,
    DWORD nMaxUserNameSize
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
GetNamedPipeHandleStateW(
    HANDLE hNamedPipe,
    LPDWORD lpState,
    LPDWORD lpCurInstances,
    LPDWORD lpMaxCollectionCount,
    LPDWORD lpCollectDataTimeout,
    LPWSTR lpUserName,
    DWORD nMaxUserNameSize
    );
#line 5169 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
CallNamedPipeA(
    LPCSTR lpNamedPipeName,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesRead,
    DWORD nTimeOut
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
CallNamedPipeW(
    LPCWSTR lpNamedPipeName,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesRead,
    DWORD nTimeOut
    );
#line 5199 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
WaitNamedPipeA(
    LPCSTR lpNamedPipeName,
    DWORD nTimeOut
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
WaitNamedPipeW(
    LPCWSTR lpNamedPipeName,
    DWORD nTimeOut
    );
#line 5219 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
SetVolumeLabelA(
    LPCSTR lpRootPathName,
    LPCSTR lpVolumeName
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
SetVolumeLabelW(
    LPCWSTR lpRootPathName,
    LPCWSTR lpVolumeName
    );
#line 5239 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
 void 
 __stdcall 
SetFileApisToOEM(  void  );

 __declspec(dllimport) 
 void 
 __stdcall 
SetFileApisToANSI(  void  );

 __declspec(dllimport) 
BOOL
 __stdcall 
AreFileApisANSI(  void  );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetVolumeInformationA(
    LPCSTR lpRootPathName,
    LPSTR lpVolumeNameBuffer,
    DWORD nVolumeNameSize,
    LPDWORD lpVolumeSerialNumber,
    LPDWORD lpMaximumComponentLength,
    LPDWORD lpFileSystemFlags,
    LPSTR lpFileSystemNameBuffer,
    DWORD nFileSystemNameSize
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
GetVolumeInformationW(
    LPCWSTR lpRootPathName,
    LPWSTR lpVolumeNameBuffer,
    DWORD nVolumeNameSize,
    LPDWORD lpVolumeSerialNumber,
    LPDWORD lpMaximumComponentLength,
    LPDWORD lpFileSystemFlags,
    LPWSTR lpFileSystemNameBuffer,
    DWORD nFileSystemNameSize
    );
#line 5286 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

//
// Event logging APIs
//

 __declspec(dllimport) 
BOOL
 __stdcall 
ClearEventLogA (
    HANDLE hEventLog,
    LPCSTR lpBackupFileName
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
ClearEventLogW (
    HANDLE hEventLog,
    LPCWSTR lpBackupFileName
    );
#line 5310 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
BackupEventLogA (
    HANDLE hEventLog,
    LPCSTR lpBackupFileName
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
BackupEventLogW (
    HANDLE hEventLog,
    LPCWSTR lpBackupFileName
    );
#line 5330 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
CloseEventLog (
    HANDLE hEventLog
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
DeregisterEventSource (
    HANDLE hEventLog
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
NotifyChangeEventLog(
    HANDLE  hEventLog,
    HANDLE  hEvent
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetNumberOfEventLogRecords (
    HANDLE hEventLog,
    PDWORD NumberOfRecords
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetOldestEventLogRecord (
    HANDLE hEventLog,
    PDWORD OldestRecord
    );

 __declspec(dllimport) 
HANDLE
 __stdcall 
OpenEventLogA (
    LPCSTR lpUNCServerName,
    LPCSTR lpSourceName
    );
 __declspec(dllimport) 
HANDLE
 __stdcall 
OpenEventLogW (
    LPCWSTR lpUNCServerName,
    LPCWSTR lpSourceName
    );
#line 5388 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
HANDLE
 __stdcall 
RegisterEventSourceA (
    LPCSTR lpUNCServerName,
    LPCSTR lpSourceName
    );
 __declspec(dllimport) 
HANDLE
 __stdcall 
RegisterEventSourceW (
    LPCWSTR lpUNCServerName,
    LPCWSTR lpSourceName
    );
#line 5408 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
HANDLE
 __stdcall 
OpenBackupEventLogA (
    LPCSTR lpUNCServerName,
    LPCSTR lpFileName
    );
 __declspec(dllimport) 
HANDLE
 __stdcall 
OpenBackupEventLogW (
    LPCWSTR lpUNCServerName,
    LPCWSTR lpFileName
    );
#line 5428 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
ReadEventLogA (
     HANDLE     hEventLog,
     DWORD      dwReadFlags,
     DWORD      dwRecordOffset,
     LPVOID     lpBuffer,
     DWORD      nNumberOfBytesToRead,
     DWORD      *pnBytesRead,
     DWORD      *pnMinNumberOfBytesNeeded
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
ReadEventLogW (
     HANDLE     hEventLog,
     DWORD      dwReadFlags,
     DWORD      dwRecordOffset,
     LPVOID     lpBuffer,
     DWORD      nNumberOfBytesToRead,
     DWORD      *pnBytesRead,
     DWORD      *pnMinNumberOfBytesNeeded
    );
#line 5458 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
ReportEventA (
     HANDLE     hEventLog,
     WORD       wType,
     WORD       wCategory,
     DWORD      dwEventID,
     PSID       lpUserSid,
     WORD       wNumStrings,
     DWORD      dwDataSize,
     LPCSTR   *lpStrings,
     LPVOID     lpRawData
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
ReportEventW (
     HANDLE     hEventLog,
     WORD       wType,
     WORD       wCategory,
     DWORD      dwEventID,
     PSID       lpUserSid,
     WORD       wNumStrings,
     DWORD      dwDataSize,
     LPCWSTR   *lpStrings,
     LPVOID     lpRawData
    );
#line 5492 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

//
//
// Security APIs
//


 __declspec(dllimport) 
BOOL
 __stdcall 
DuplicateToken(
    HANDLE ExistingTokenHandle,
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    PHANDLE DuplicateTokenHandle
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetKernelObjectSecurity (
    HANDLE Handle,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthNeeded
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
ImpersonateNamedPipeClient(
    HANDLE hNamedPipe
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
ImpersonateSelf(
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
RevertToSelf (
     void 
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetThreadToken (
    PHANDLE Thread,
    HANDLE Token
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
AccessCheck (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    PGENERIC_MAPPING GenericMapping,
    PPRIVILEGE_SET PrivilegeSet,
    LPDWORD PrivilegeSetLength,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
OpenProcessToken (
    HANDLE ProcessHandle,
    DWORD DesiredAccess,
    PHANDLE TokenHandle
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
OpenThreadToken (
    HANDLE ThreadHandle,
    DWORD DesiredAccess,
    BOOL OpenAsSelf,
    PHANDLE TokenHandle
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
GetTokenInformation (
    HANDLE TokenHandle,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    LPVOID TokenInformation,
    DWORD TokenInformationLength,
    PDWORD ReturnLength
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
SetTokenInformation (
    HANDLE TokenHandle,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    LPVOID TokenInformation,
    DWORD TokenInformationLength
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
AdjustTokenPrivileges (
    HANDLE TokenHandle,
    BOOL DisableAllPrivileges,
    PTOKEN_PRIVILEGES NewState,
    DWORD BufferLength,
    PTOKEN_PRIVILEGES PreviousState,
    PDWORD ReturnLength
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
AdjustTokenGroups (
    HANDLE TokenHandle,
    BOOL ResetToDefault,
    PTOKEN_GROUPS NewState,
    DWORD BufferLength,
    PTOKEN_GROUPS PreviousState,
    PDWORD ReturnLength
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
PrivilegeCheck (
    HANDLE ClientToken,
    PPRIVILEGE_SET RequiredPrivileges,
    LPBOOL pfResult
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
AccessCheckAndAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    LPSTR ObjectTypeName,
    LPSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    DWORD DesiredAccess,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus,
    LPBOOL pfGenerateOnClose
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
AccessCheckAndAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    LPWSTR ObjectTypeName,
    LPWSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    DWORD DesiredAccess,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus,
    LPBOOL pfGenerateOnClose
    );
#line 5681 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE


 __declspec(dllimport) 
BOOL
 __stdcall 
ObjectOpenAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    LPSTR ObjectTypeName,
    LPSTR ObjectName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    DWORD GrantedAccess,
    PPRIVILEGE_SET Privileges,
    BOOL ObjectCreation,
    BOOL AccessGranted,
    LPBOOL GenerateOnClose
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
ObjectOpenAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    LPWSTR ObjectTypeName,
    LPWSTR ObjectName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    DWORD GrantedAccess,
    PPRIVILEGE_SET Privileges,
    BOOL ObjectCreation,
    BOOL AccessGranted,
    LPBOOL GenerateOnClose
    );
#line 5722 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE


 __declspec(dllimport) 
BOOL
 __stdcall 
ObjectPrivilegeAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
ObjectPrivilegeAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    );
#line 5751 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE


 __declspec(dllimport) 
BOOL
 __stdcall 
ObjectCloseAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    BOOL GenerateOnClose
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
ObjectCloseAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    BOOL GenerateOnClose
    );
#line 5774 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE


 __declspec(dllimport) 
BOOL
 __stdcall 
PrivilegedServiceAuditAlarmA (
    LPCSTR SubsystemName,
    LPCSTR ServiceName,
    HANDLE ClientToken,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
PrivilegedServiceAuditAlarmW (
    LPCWSTR SubsystemName,
    LPCWSTR ServiceName,
    HANDLE ClientToken,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    );
#line 5801 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE


 __declspec(dllimport) 
BOOL
 __stdcall 
IsValidSid (
    PSID pSid
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
EqualSid (
    PSID pSid1,
    PSID pSid2
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
EqualPrefixSid (
    PSID pSid1,
    PSID pSid2
    );


 __declspec(dllimport) 
DWORD
 __stdcall 
GetSidLengthRequired (
    UCHAR nSubAuthorityCount
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
AllocateAndInitializeSid (
    PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
    BYTE nSubAuthorityCount,
    DWORD nSubAuthority0,
    DWORD nSubAuthority1,
    DWORD nSubAuthority2,
    DWORD nSubAuthority3,
    DWORD nSubAuthority4,
    DWORD nSubAuthority5,
    DWORD nSubAuthority6,
    DWORD nSubAuthority7,
    PSID *pSid
    );

 __declspec(dllimport) 
PVOID
 __stdcall 
FreeSid(
    PSID pSid
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
InitializeSid (
    PSID Sid,
    PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
    BYTE nSubAuthorityCount
    );


 __declspec(dllimport) 
PSID_IDENTIFIER_AUTHORITY
 __stdcall 
GetSidIdentifierAuthority (
    PSID pSid
    );


 __declspec(dllimport) 
PDWORD
 __stdcall 
GetSidSubAuthority (
    PSID pSid,
    DWORD nSubAuthority
    );


 __declspec(dllimport) 
PUCHAR
 __stdcall 
GetSidSubAuthorityCount (
    PSID pSid
    );


 __declspec(dllimport) 
DWORD
 __stdcall 
GetLengthSid (
    PSID pSid
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
CopySid (
    DWORD nDestinationSidLength,
    PSID pDestinationSid,
    PSID pSourceSid
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
AreAllAccessesGranted (
    DWORD GrantedAccess,
    DWORD DesiredAccess
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
AreAnyAccessesGranted (
    DWORD GrantedAccess,
    DWORD DesiredAccess
    );


 __declspec(dllimport) 
 void 
 __stdcall 
MapGenericMask (
    PDWORD AccessMask,
    PGENERIC_MAPPING GenericMapping
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
IsValidAcl (
    PACL pAcl
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
InitializeAcl (
    PACL pAcl,
    DWORD nAclLength,
    DWORD dwAclRevision
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
GetAclInformation (
    PACL pAcl,
    LPVOID pAclInformation,
    DWORD nAclInformationLength,
    ACL_INFORMATION_CLASS dwAclInformationClass
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
SetAclInformation (
    PACL pAcl,
    LPVOID pAclInformation,
    DWORD nAclInformationLength,
    ACL_INFORMATION_CLASS dwAclInformationClass
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
AddAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD dwStartingAceIndex,
    LPVOID pAceList,
    DWORD nAceListLength
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
DeleteAce (
    PACL pAcl,
    DWORD dwAceIndex
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
GetAce (
    PACL pAcl,
    DWORD dwAceIndex,
    LPVOID *pAce
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
AddAccessAllowedAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AccessMask,
    PSID pSid
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
AddAccessDeniedAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AccessMask,
    PSID pSid
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
AddAuditAccessAce(
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD dwAccessMask,
    PSID pSid,
    BOOL bAuditSuccess,
    BOOL bAuditFailure
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
FindFirstFreeAce (
    PACL pAcl,
    LPVOID *pAce
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
InitializeSecurityDescriptor (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD dwRevision
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
IsValidSecurityDescriptor (
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


 __declspec(dllimport) 
DWORD
 __stdcall 
GetSecurityDescriptorLength (
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
GetSecurityDescriptorControl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSECURITY_DESCRIPTOR_CONTROL pControl,
    LPDWORD lpdwRevision
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
SetSecurityDescriptorDacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    BOOL bDaclPresent,
    PACL pDacl,
    BOOL bDaclDefaulted
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
GetSecurityDescriptorDacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPBOOL lpbDaclPresent,
    PACL *pDacl,
    LPBOOL lpbDaclDefaulted
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
SetSecurityDescriptorSacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    BOOL bSaclPresent,
    PACL pSacl,
    BOOL bSaclDefaulted
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
GetSecurityDescriptorSacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPBOOL lpbSaclPresent,
    PACL *pSacl,
    LPBOOL lpbSaclDefaulted
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
SetSecurityDescriptorOwner (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID pOwner,
    BOOL bOwnerDefaulted
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
GetSecurityDescriptorOwner (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID *pOwner,
    LPBOOL lpbOwnerDefaulted
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
SetSecurityDescriptorGroup (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID pGroup,
    BOOL bGroupDefaulted
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
GetSecurityDescriptorGroup (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID *pGroup,
    LPBOOL lpbGroupDefaulted
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
CreatePrivateObjectSecurity (
    PSECURITY_DESCRIPTOR ParentDescriptor,
    PSECURITY_DESCRIPTOR CreatorDescriptor,
    PSECURITY_DESCRIPTOR * NewDescriptor,
    BOOL IsDirectoryObject,
    HANDLE Token,
    PGENERIC_MAPPING GenericMapping
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
SetPrivateObjectSecurity (
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR ModificationDescriptor,
    PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    PGENERIC_MAPPING GenericMapping,
    HANDLE Token
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
GetPrivateObjectSecurity (
    PSECURITY_DESCRIPTOR ObjectDescriptor,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR ResultantDescriptor,
    DWORD DescriptorLength,
    PDWORD ReturnLength
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
DestroyPrivateObjectSecurity (
    PSECURITY_DESCRIPTOR * ObjectDescriptor
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
MakeSelfRelativeSD (
    PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    LPDWORD lpdwBufferLength
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
MakeAbsoluteSD (
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
    LPDWORD lpdwAbsoluteSecurityDescriptorSize,
    PACL pDacl,
    LPDWORD lpdwDaclSize,
    PACL pSacl,
    LPDWORD lpdwSaclSize,
    PSID pOwner,
    LPDWORD lpdwOwnerSize,
    PSID pPrimaryGroup,
    LPDWORD lpdwPrimaryGroupSize
    );


 __declspec(dllimport) 
BOOL
 __stdcall 
SetFileSecurityA (
    LPCSTR lpFileName,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
SetFileSecurityW (
    LPCWSTR lpFileName,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );
#line 6269 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE


 __declspec(dllimport) 
BOOL
 __stdcall 
GetFileSecurityA (
    LPCSTR lpFileName,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthNeeded
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
GetFileSecurityW (
    LPCWSTR lpFileName,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthNeeded
    );
#line 6296 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE


 __declspec(dllimport) 
BOOL
 __stdcall 
SetKernelObjectSecurity (
    HANDLE Handle,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );



 __declspec(dllimport) 
HANDLE
 __stdcall 
FindFirstChangeNotificationA(
    LPCSTR lpPathName,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter
    );
 __declspec(dllimport) 
HANDLE
 __stdcall 
FindFirstChangeNotificationW(
    LPCWSTR lpPathName,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter
    );
#line 6330 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
FindNextChangeNotification(
    HANDLE hChangeHandle
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
FindCloseChangeNotification(
    HANDLE hChangeHandle
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
VirtualLock(
    LPVOID lpAddress,
    DWORD dwSize
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
VirtualUnlock(
    LPVOID lpAddress,
    DWORD dwSize
    );

 __declspec(dllimport) 
LPVOID
 __stdcall 
MapViewOfFileEx(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    DWORD dwNumberOfBytesToMap,
    LPVOID lpBaseAddress
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetPriorityClass(
    HANDLE hProcess,
    DWORD dwPriorityClass
    );

 __declspec(dllimport) 
DWORD
 __stdcall 
GetPriorityClass(
    HANDLE hProcess
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
IsBadReadPtr(
     const   void  *lp,
    UINT ucb
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
IsBadWritePtr(
    LPVOID lp,
    UINT ucb
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
IsBadHugeReadPtr(
     const   void  *lp,
    UINT ucb
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
IsBadHugeWritePtr(
    LPVOID lp,
    UINT ucb
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
IsBadCodePtr(
    FARPROC lpfn
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
IsBadStringPtrA(
    LPCSTR lpsz,
    UINT ucchMax
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
IsBadStringPtrW(
    LPCWSTR lpsz,
    UINT ucchMax
    );
#line 6446 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
LookupAccountSidA(
    LPCSTR lpSystemName,
    PSID Sid,
    LPSTR Name,
    LPDWORD cbName,
    LPSTR ReferencedDomainName,
    LPDWORD cbReferencedDomainName,
    PSID_NAME_USE peUse
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
LookupAccountSidW(
    LPCWSTR lpSystemName,
    PSID Sid,
    LPWSTR Name,
    LPDWORD cbName,
    LPWSTR ReferencedDomainName,
    LPDWORD cbReferencedDomainName,
    PSID_NAME_USE peUse
    );
#line 6476 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
LookupAccountNameA(
    LPCSTR lpSystemName,
    LPCSTR lpAccountName,
    PSID Sid,
    LPDWORD cbSid,
    LPSTR ReferencedDomainName,
    LPDWORD cbReferencedDomainName,
    PSID_NAME_USE peUse
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
LookupAccountNameW(
    LPCWSTR lpSystemName,
    LPCWSTR lpAccountName,
    PSID Sid,
    LPDWORD cbSid,
    LPWSTR ReferencedDomainName,
    LPDWORD cbReferencedDomainName,
    PSID_NAME_USE peUse
    );
#line 6506 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
LookupPrivilegeValueA(
    LPCSTR lpSystemName,
    LPCSTR lpName,
    PLUID   lpLuid
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
LookupPrivilegeValueW(
    LPCWSTR lpSystemName,
    LPCWSTR lpName,
    PLUID   lpLuid
    );
#line 6528 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
LookupPrivilegeNameA(
    LPCSTR lpSystemName,
    PLUID   lpLuid,
    LPSTR lpName,
    LPDWORD cbName
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
LookupPrivilegeNameW(
    LPCWSTR lpSystemName,
    PLUID   lpLuid,
    LPWSTR lpName,
    LPDWORD cbName
    );
#line 6552 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
LookupPrivilegeDisplayNameA(
    LPCSTR lpSystemName,
    LPCSTR lpName,
    LPSTR lpDisplayName,
    LPDWORD cbDisplayName,
    LPDWORD lpLanguageId
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
LookupPrivilegeDisplayNameW(
    LPCWSTR lpSystemName,
    LPCWSTR lpName,
    LPWSTR lpDisplayName,
    LPDWORD cbDisplayName,
    LPDWORD lpLanguageId
    );
#line 6578 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
AllocateLocallyUniqueId(
    PLUID Luid
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
BuildCommDCBA(
    LPCSTR lpDef,
    LPDCB lpDCB
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
BuildCommDCBW(
    LPCWSTR lpDef,
    LPDCB lpDCB
    );
#line 6605 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
BuildCommDCBAndTimeoutsA(
    LPCSTR lpDef,
    LPDCB lpDCB,
    LPCOMMTIMEOUTS lpCommTimeouts
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
BuildCommDCBAndTimeoutsW(
    LPCWSTR lpDef,
    LPDCB lpDCB,
    LPCOMMTIMEOUTS lpCommTimeouts
    );
#line 6627 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
CommConfigDialogA(
    LPCSTR lpszName,
    HWND hWnd,
    LPCOMMCONFIG lpCC
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
CommConfigDialogW(
    LPCWSTR lpszName,
    HWND hWnd,
    LPCOMMCONFIG lpCC
    );
#line 6649 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
GetDefaultCommConfigA(
    LPCSTR lpszName,
    LPCOMMCONFIG lpCC,
    LPDWORD lpdwSize
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
GetDefaultCommConfigW(
    LPCWSTR lpszName,
    LPCOMMCONFIG lpCC,
    LPDWORD lpdwSize
    );
#line 6671 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
SetDefaultCommConfigA(
    LPCSTR lpszName,
    LPCOMMCONFIG lpCC,
    DWORD dwSize
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
SetDefaultCommConfigW(
    LPCWSTR lpszName,
    LPCOMMCONFIG lpCC,
    DWORD dwSize
    );
#line 6693 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE



 __declspec(dllimport) 
BOOL
 __stdcall 
GetComputerNameA (
    LPSTR lpBuffer,
    LPDWORD nSize
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
GetComputerNameW (
    LPWSTR lpBuffer,
    LPDWORD nSize
    );
#line 6715 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
SetComputerNameA (
    LPCSTR lpComputerName
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
SetComputerNameW (
    LPCWSTR lpComputerName
    );
#line 6733 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
GetUserNameA (
    LPSTR lpBuffer,
    LPDWORD nSize
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
GetUserNameW (
    LPWSTR lpBuffer,
    LPDWORD nSize
    );
#line 6753 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

//
// Logon Support APIs
//










 __declspec(dllimport) 
BOOL
 __stdcall 
LogonUserA (
    LPSTR lpszUsername,
    LPSTR lpszDomain,
    LPSTR lpszPassword,
    DWORD dwLogonType,
    DWORD dwLogonProvider,
    PHANDLE phToken
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
LogonUserW (
    LPWSTR lpszUsername,
    LPWSTR lpszDomain,
    LPWSTR lpszPassword,
    DWORD dwLogonType,
    DWORD dwLogonProvider,
    PHANDLE phToken
    );
#line 6794 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
ImpersonateLoggedOnUser(
    HANDLE  hToken
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
CreateProcessAsUserA (
    HANDLE hToken,
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
CreateProcessAsUserW (
    HANDLE hToken,
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );
#line 6839 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE


//
// Performance counter API's
//

 __declspec(dllimport) 
BOOL
 __stdcall 
QueryPerformanceCounter(
    LARGE_INTEGER *lpPerformanceCount
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
QueryPerformanceFrequency(
    LARGE_INTEGER *lpFrequency
    );

typedef struct _OSVERSIONINFOA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR   szCSDVersion[ 128 ];       // Maintenance string for PSS usage 
} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;
typedef struct _OSVERSIONINFOW {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR  szCSDVersion[ 128 ];       // Maintenance string for PSS usage 
} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW;
#line 6882 "C:\WATCOM\H\NT\winbase.h"
typedef OSVERSIONINFOA OSVERSIONINFO;
typedef POSVERSIONINFOA POSVERSIONINFO;
typedef LPOSVERSIONINFOA LPOSVERSIONINFO;
// UNICODE

//
// dwPlatformId defines:
//






 __declspec(dllimport) 
BOOL
 __stdcall 
GetVersionExA(
    LPOSVERSIONINFOA lpVersionInformation
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
GetVersionExW(
    LPOSVERSIONINFOW lpVersionInformation
    );
#line 6911 "C:\WATCOM\H\NT\winbase.h"

// !UNICODE


// DOS and OS/2 Compatible Error Code definitions returned by the Win32 Base
// API functions.
//

#line 1 "C:\WATCOM\H\NT\winerror.h"
/************************************************************************
*                                                                       *
*   winerror.h --  error code definitions for the Win32 API functions   *  
*                                                                       *
*   Copyright (c) 1991-1995, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/





//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//










//
// Define the severity codes
//


//
// MessageId: ERROR_SUCCESS
//
// MessageText:
//
//  The operation completed successfully.
//


// dderror

//
// MessageId: ERROR_INVALID_FUNCTION
//
// MessageText:
//
//  Incorrect function.
//
// dderror

//
// MessageId: ERROR_FILE_NOT_FOUND
//
// MessageText:
//
//  The system cannot find the file specified.
//


//
// MessageId: ERROR_PATH_NOT_FOUND
//
// MessageText:
//
//  The system cannot find the path specified.
//


//
// MessageId: ERROR_TOO_MANY_OPEN_FILES
//
// MessageText:
//
//  The system cannot open the file.
//


//
// MessageId: ERROR_ACCESS_DENIED
//
// MessageText:
//
//  Access is denied.
//


//
// MessageId: ERROR_INVALID_HANDLE
//
// MessageText:
//
//  The handle is invalid.
//


//
// MessageId: ERROR_ARENA_TRASHED
//
// MessageText:
//
//  The storage control blocks were destroyed.
//


//
// MessageId: ERROR_NOT_ENOUGH_MEMORY
//
// MessageText:
//
//  Not enough storage is available to process this command.
//
// dderror

//
// MessageId: ERROR_INVALID_BLOCK
//
// MessageText:
//
//  The storage control block address is invalid.
//


//
// MessageId: ERROR_BAD_ENVIRONMENT
//
// MessageText:
//
//  The environment is incorrect.
//


//
// MessageId: ERROR_BAD_FORMAT
//
// MessageText:
//
//  An attempt was made to load a program with an
//  incorrect format.
//


//
// MessageId: ERROR_INVALID_ACCESS
//
// MessageText:
//
//  The access code is invalid.
//


//
// MessageId: ERROR_INVALID_DATA
//
// MessageText:
//
//  The data is invalid.
//


//
// MessageId: ERROR_OUTOFMEMORY
//
// MessageText:
//
//  Not enough storage is available to complete this operation.
//


//
// MessageId: ERROR_INVALID_DRIVE
//
// MessageText:
//
//  The system cannot find the drive specified.
//


//
// MessageId: ERROR_CURRENT_DIRECTORY
//
// MessageText:
//
//  The directory cannot be removed.
//


//
// MessageId: ERROR_NOT_SAME_DEVICE
//
// MessageText:
//
//  The system cannot move the file
//  to a different disk drive.
//


//
// MessageId: ERROR_NO_MORE_FILES
//
// MessageText:
//
//  There are no more files.
//


//
// MessageId: ERROR_WRITE_PROTECT
//
// MessageText:
//
//  The media is write protected.
//


//
// MessageId: ERROR_BAD_UNIT
//
// MessageText:
//
//  The system cannot find the device specified.
//


//
// MessageId: ERROR_NOT_READY
//
// MessageText:
//
//  The device is not ready.
//


//
// MessageId: ERROR_BAD_COMMAND
//
// MessageText:
//
//  The device does not recognize the command.
//


//
// MessageId: ERROR_CRC
//
// MessageText:
//
//  Data error (cyclic redundancy check)
//


//
// MessageId: ERROR_BAD_LENGTH
//
// MessageText:
//
//  The program issued a command but the
//  command length is incorrect.
//


//
// MessageId: ERROR_SEEK
//
// MessageText:
//
//  The drive cannot locate a specific
//  area or track on the disk.
//


//
// MessageId: ERROR_NOT_DOS_DISK
//
// MessageText:
//
//  The specified disk or diskette cannot be accessed.
//


//
// MessageId: ERROR_SECTOR_NOT_FOUND
//
// MessageText:
//
//  The drive cannot find the sector requested.
//


//
// MessageId: ERROR_OUT_OF_PAPER
//
// MessageText:
//
//  The printer is out of paper.
//


//
// MessageId: ERROR_WRITE_FAULT
//
// MessageText:
//
//  The system cannot write to the specified device.
//


//
// MessageId: ERROR_READ_FAULT
//
// MessageText:
//
//  The system cannot read from the specified device.
//


//
// MessageId: ERROR_GEN_FAILURE
//
// MessageText:
//
//  A device attached to the system is not functioning.
//


//
// MessageId: ERROR_SHARING_VIOLATION
//
// MessageText:
//
//  The process cannot access the file because
//  it is being used by another process.
//


//
// MessageId: ERROR_LOCK_VIOLATION
//
// MessageText:
//
//  The process cannot access the file because
//  another process has locked a portion of the file.
//


//
// MessageId: ERROR_WRONG_DISK
//
// MessageText:
//
//  The wrong diskette is in the drive.
//  Insert %2 (Volume Serial Number: %3)
//  into drive %1.
//


//
// MessageId: ERROR_SHARING_BUFFER_EXCEEDED
//
// MessageText:
//
//  Too many files opened for sharing.
//


//
// MessageId: ERROR_HANDLE_EOF
//
// MessageText:
//
//  Reached end of file.
//


//
// MessageId: ERROR_HANDLE_DISK_FULL
//
// MessageText:
//
//  The disk is full.
//


//
// MessageId: ERROR_NOT_SUPPORTED
//
// MessageText:
//
//  The network request is not supported.
//


//
// MessageId: ERROR_REM_NOT_LIST
//
// MessageText:
//
//  The remote computer is not available.
//


//
// MessageId: ERROR_DUP_NAME
//
// MessageText:
//
//  A duplicate name exists on the network.
//


//
// MessageId: ERROR_BAD_NETPATH
//
// MessageText:
//
//  The network path was not found.
//


//
// MessageId: ERROR_NETWORK_BUSY
//
// MessageText:
//
//  The network is busy.
//


//
// MessageId: ERROR_DEV_NOT_EXIST
//
// MessageText:
//
//  The specified network resource or device is no longer
//  available.
//
// dderror

//
// MessageId: ERROR_TOO_MANY_CMDS
//
// MessageText:
//
//  The network BIOS command limit has been reached.
//


//
// MessageId: ERROR_ADAP_HDW_ERR
//
// MessageText:
//
//  A network adapter hardware error occurred.
//


//
// MessageId: ERROR_BAD_NET_RESP
//
// MessageText:
//
//  The specified server cannot perform the requested
//  operation.
//


//
// MessageId: ERROR_UNEXP_NET_ERR
//
// MessageText:
//
//  An unexpected network error occurred.
//


//
// MessageId: ERROR_BAD_REM_ADAP
//
// MessageText:
//
//  The remote adapter is not compatible.
//


//
// MessageId: ERROR_PRINTQ_FULL
//
// MessageText:
//
//  The printer queue is full.
//


//
// MessageId: ERROR_NO_SPOOL_SPACE
//
// MessageText:
//
//  Space to store the file waiting to be printed is
//  not available on the server.
//


//
// MessageId: ERROR_PRINT_CANCELLED
//
// MessageText:
//
//  Your file waiting to be printed was deleted.
//


//
// MessageId: ERROR_NETNAME_DELETED
//
// MessageText:
//
//  The specified network name is no longer available.
//


//
// MessageId: ERROR_NETWORK_ACCESS_DENIED
//
// MessageText:
//
//  Network access is denied.
//


//
// MessageId: ERROR_BAD_DEV_TYPE
//
// MessageText:
//
//  The network resource type is not correct.
//


//
// MessageId: ERROR_BAD_NET_NAME
//
// MessageText:
//
//  The network name cannot be found.
//


//
// MessageId: ERROR_TOO_MANY_NAMES
//
// MessageText:
//
//  The name limit for the local computer network
//  adapter card was exceeded.
//


//
// MessageId: ERROR_TOO_MANY_SESS
//
// MessageText:
//
//  The network BIOS session limit was exceeded.
//


//
// MessageId: ERROR_SHARING_PAUSED
//
// MessageText:
//
//  The remote server has been paused or is in the
//  process of being started.
//


//
// MessageId: ERROR_REQ_NOT_ACCEP
//
// MessageText:
//
//  No more connections can be made to this remote computer at this time
//  because there are already as many connections as the computer can accept.
//


//
// MessageId: ERROR_REDIR_PAUSED
//
// MessageText:
//
//  The specified printer or disk device has been paused.
//


//
// MessageId: ERROR_FILE_EXISTS
//
// MessageText:
//
//  The file exists.
//


//
// MessageId: ERROR_CANNOT_MAKE
//
// MessageText:
//
//  The directory or file cannot be created.
//


//
// MessageId: ERROR_FAIL_I24
//
// MessageText:
//
//  Fail on INT 24
//


//
// MessageId: ERROR_OUT_OF_STRUCTURES
//
// MessageText:
//
//  Storage to process this request is not available.
//


//
// MessageId: ERROR_ALREADY_ASSIGNED
//
// MessageText:
//
//  The local device name is already in use.
//


//
// MessageId: ERROR_INVALID_PASSWORD
//
// MessageText:
//
//  The specified network password is not correct.
//


//
// MessageId: ERROR_INVALID_PARAMETER
//
// MessageText:
//
//  The parameter is incorrect.
//
// dderror

//
// MessageId: ERROR_NET_WRITE_FAULT
//
// MessageText:
//
//  A write fault occurred on the network.
//


//
// MessageId: ERROR_NO_PROC_SLOTS
//
// MessageText:
//
//  The system cannot start another process at
//  this time.
//


//
// MessageId: ERROR_TOO_MANY_SEMAPHORES
//
// MessageText:
//
//  Cannot create another system semaphore.
//


//
// MessageId: ERROR_EXCL_SEM_ALREADY_OWNED
//
// MessageText:
//
//  The exclusive semaphore is owned by another process.
//


//
// MessageId: ERROR_SEM_IS_SET
//
// MessageText:
//
//  The semaphore is set and cannot be closed.
//


//
// MessageId: ERROR_TOO_MANY_SEM_REQUESTS
//
// MessageText:
//
//  The semaphore cannot be set again.
//


//
// MessageId: ERROR_INVALID_AT_INTERRUPT_TIME
//
// MessageText:
//
//  Cannot request exclusive semaphores at interrupt time.
//


//
// MessageId: ERROR_SEM_OWNER_DIED
//
// MessageText:
//
//  The previous ownership of this semaphore has ended.
//


//
// MessageId: ERROR_SEM_USER_LIMIT
//
// MessageText:
//
//  Insert the diskette for drive %1.
//


//
// MessageId: ERROR_DISK_CHANGE
//
// MessageText:
//
//  Program stopped because alternate diskette was not inserted.
//


//
// MessageId: ERROR_DRIVE_LOCKED
//
// MessageText:
//
//  The disk is in use or locked by
//  another process.
//


//
// MessageId: ERROR_BROKEN_PIPE
//
// MessageText:
//
//  The pipe has been ended.
//


//
// MessageId: ERROR_OPEN_FAILED
//
// MessageText:
//
//  The system cannot open the
//  device or file specified.
//


//
// MessageId: ERROR_BUFFER_OVERFLOW
//
// MessageText:
//
//  The file name is too long.
//


//
// MessageId: ERROR_DISK_FULL
//
// MessageText:
//
//  There is not enough space on the disk.
//


//
// MessageId: ERROR_NO_MORE_SEARCH_HANDLES
//
// MessageText:
//
//  No more internal file identifiers available.
//


//
// MessageId: ERROR_INVALID_TARGET_HANDLE
//
// MessageText:
//
//  The target internal file identifier is incorrect.
//


//
// MessageId: ERROR_INVALID_CATEGORY
//
// MessageText:
//
//  The IOCTL call made by the application program is
//  not correct.
//


//
// MessageId: ERROR_INVALID_VERIFY_SWITCH
//
// MessageText:
//
//  The verify-on-write switch parameter value is not
//  correct.
//


//
// MessageId: ERROR_BAD_DRIVER_LEVEL
//
// MessageText:
//
//  The system does not support the command requested.
//


//
// MessageId: ERROR_CALL_NOT_IMPLEMENTED
//
// MessageText:
//
//  This function is only valid in Win32 mode.
//


//
// MessageId: ERROR_SEM_TIMEOUT
//
// MessageText:
//
//  The semaphore timeout period has expired.
//


//
// MessageId: ERROR_INSUFFICIENT_BUFFER
//
// MessageText:
//
//  The data area passed to a system call is too
//  small.
//
// dderror

//
// MessageId: ERROR_INVALID_NAME
//
// MessageText:
//
//  The filename, directory name, or volume label syntax is incorrect.
//


//
// MessageId: ERROR_INVALID_LEVEL
//
// MessageText:
//
//  The system call level is not correct.
//


//
// MessageId: ERROR_NO_VOLUME_LABEL
//
// MessageText:
//
//  The disk has no volume label.
//


//
// MessageId: ERROR_MOD_NOT_FOUND
//
// MessageText:
//
//  The specified module could not be found.
//


//
// MessageId: ERROR_PROC_NOT_FOUND
//
// MessageText:
//
//  The specified procedure could not be found.
//


//
// MessageId: ERROR_WAIT_NO_CHILDREN
//
// MessageText:
//
//  There are no child processes to wait for.
//


//
// MessageId: ERROR_CHILD_NOT_COMPLETE
//
// MessageText:
//
//  The %1 application cannot be run in Win32 mode.
//


//
// MessageId: ERROR_DIRECT_ACCESS_HANDLE
//
// MessageText:
//
//  Attempt to use a file handle to an open disk partition for an
//  operation other than raw disk I/O.
//


//
// MessageId: ERROR_NEGATIVE_SEEK
//
// MessageText:
//
//  An attempt was made to move the file pointer before the beginning of the file.
//


//
// MessageId: ERROR_SEEK_ON_DEVICE
//
// MessageText:
//
//  The file pointer cannot be set on the specified device or file.
//


//
// MessageId: ERROR_IS_JOIN_TARGET
//
// MessageText:
//
//  A JOIN or SUBST command
//  cannot be used for a drive that
//  contains previously joined drives.
//


//
// MessageId: ERROR_IS_JOINED
//
// MessageText:
//
//  An attempt was made to use a
//  JOIN or SUBST command on a drive that has
//  already been joined.
//


//
// MessageId: ERROR_IS_SUBSTED
//
// MessageText:
//
//  An attempt was made to use a
//  JOIN or SUBST command on a drive that has
//  already been substituted.
//


//
// MessageId: ERROR_NOT_JOINED
//
// MessageText:
//
//  The system tried to delete
//  the JOIN of a drive that is not joined.
//


//
// MessageId: ERROR_NOT_SUBSTED
//
// MessageText:
//
//  The system tried to delete the
//  substitution of a drive that is not substituted.
//


//
// MessageId: ERROR_JOIN_TO_JOIN
//
// MessageText:
//
//  The system tried to join a drive
//  to a directory on a joined drive.
//


//
// MessageId: ERROR_SUBST_TO_SUBST
//
// MessageText:
//
//  The system tried to substitute a
//  drive to a directory on a substituted drive.
//


//
// MessageId: ERROR_JOIN_TO_SUBST
//
// MessageText:
//
//  The system tried to join a drive to
//  a directory on a substituted drive.
//


//
// MessageId: ERROR_SUBST_TO_JOIN
//
// MessageText:
//
//  The system tried to SUBST a drive
//  to a directory on a joined drive.
//


//
// MessageId: ERROR_BUSY_DRIVE
//
// MessageText:
//
//  The system cannot perform a JOIN or SUBST at this time.
//


//
// MessageId: ERROR_SAME_DRIVE
//
// MessageText:
//
//  The system cannot join or substitute a
//  drive to or for a directory on the same drive.
//


//
// MessageId: ERROR_DIR_NOT_ROOT
//
// MessageText:
//
//  The directory is not a subdirectory of the root directory.
//


//
// MessageId: ERROR_DIR_NOT_EMPTY
//
// MessageText:
//
//  The directory is not empty.
//


//
// MessageId: ERROR_IS_SUBST_PATH
//
// MessageText:
//
//  The path specified is being used in
//  a substitute.
//


//
// MessageId: ERROR_IS_JOIN_PATH
//
// MessageText:
//
//  Not enough resources are available to
//  process this command.
//


//
// MessageId: ERROR_PATH_BUSY
//
// MessageText:
//
//  The path specified cannot be used at this time.
//


//
// MessageId: ERROR_IS_SUBST_TARGET
//
// MessageText:
//
//  An attempt was made to join
//  or substitute a drive for which a directory
//  on the drive is the target of a previous
//  substitute.
//


//
// MessageId: ERROR_SYSTEM_TRACE
//
// MessageText:
//
//  System trace information was not specified in your
//  CONFIG.SYS file, or tracing is disallowed.
//


//
// MessageId: ERROR_INVALID_EVENT_COUNT
//
// MessageText:
//
//  The number of specified semaphore events for
//  DosMuxSemWait is not correct.
//


//
// MessageId: ERROR_TOO_MANY_MUXWAITERS
//
// MessageText:
//
//  DosMuxSemWait did not execute; too many semaphores
//  are already set.
//


//
// MessageId: ERROR_INVALID_LIST_FORMAT
//
// MessageText:
//
//  The DosMuxSemWait list is not correct.
//


//
// MessageId: ERROR_LABEL_TOO_LONG
//
// MessageText:
//
//  The volume label you entered exceeds the label character
//  limit of the target file system.
//


//
// MessageId: ERROR_TOO_MANY_TCBS
//
// MessageText:
//
//  Cannot create another thread.
//


//
// MessageId: ERROR_SIGNAL_REFUSED
//
// MessageText:
//
//  The recipient process has refused the signal.
//


//
// MessageId: ERROR_DISCARDED
//
// MessageText:
//
//  The segment is already discarded and cannot be locked.
//


//
// MessageId: ERROR_NOT_LOCKED
//
// MessageText:
//
//  The segment is already unlocked.
//


//
// MessageId: ERROR_BAD_THREADID_ADDR
//
// MessageText:
//
//  The address for the thread ID is not correct.
//


//
// MessageId: ERROR_BAD_ARGUMENTS
//
// MessageText:
//
//  The argument string passed to DosExecPgm is not correct.
//


//
// MessageId: ERROR_BAD_PATHNAME
//
// MessageText:
//
//  The specified path is invalid.
//


//
// MessageId: ERROR_SIGNAL_PENDING
//
// MessageText:
//
//  A signal is already pending.
//


//
// MessageId: ERROR_MAX_THRDS_REACHED
//
// MessageText:
//
//  No more threads can be created in the system.
//


//
// MessageId: ERROR_LOCK_FAILED
//
// MessageText:
//
//  Unable to lock a region of a file.
//


//
// MessageId: ERROR_BUSY
//
// MessageText:
//
//  The requested resource is in use.
//


//
// MessageId: ERROR_CANCEL_VIOLATION
//
// MessageText:
//
//  A lock request was not outstanding for the supplied cancel region.
//


//
// MessageId: ERROR_ATOMIC_LOCKS_NOT_SUPPORTED
//
// MessageText:
//
//  The file system does not support atomic changes to the lock type.
//


//
// MessageId: ERROR_INVALID_SEGMENT_NUMBER
//
// MessageText:
//
//  The system detected a segment number that was not correct.
//


//
// MessageId: ERROR_INVALID_ORDINAL
//
// MessageText:
//
//  The operating system cannot run %1.
//


//
// MessageId: ERROR_ALREADY_EXISTS
//
// MessageText:
//
//  Cannot create a file when that file already exists.
//


//
// MessageId: ERROR_INVALID_FLAG_NUMBER
//
// MessageText:
//
//  The flag passed is not correct.
//


//
// MessageId: ERROR_SEM_NOT_FOUND
//
// MessageText:
//
//  The specified system semaphore name was not found.
//


//
// MessageId: ERROR_INVALID_STARTING_CODESEG
//
// MessageText:
//
//  The operating system cannot run %1.
//


//
// MessageId: ERROR_INVALID_STACKSEG
//
// MessageText:
//
//  The operating system cannot run %1.
//


//
// MessageId: ERROR_INVALID_MODULETYPE
//
// MessageText:
//
//  The operating system cannot run %1.
//


//
// MessageId: ERROR_INVALID_EXE_SIGNATURE
//
// MessageText:
//
//  Cannot run %1 in Win32 mode.
//


//
// MessageId: ERROR_EXE_MARKED_INVALID
//
// MessageText:
//
//  The operating system cannot run %1.
//


//
// MessageId: ERROR_BAD_EXE_FORMAT
//
// MessageText:
//
//  %1 is not a valid Win32 application.
//


//
// MessageId: ERROR_ITERATED_DATA_EXCEEDS_64k
//
// MessageText:
//
//  The operating system cannot run %1.
//


//
// MessageId: ERROR_INVALID_MINALLOCSIZE
//
// MessageText:
//
//  The operating system cannot run %1.
//


//
// MessageId: ERROR_DYNLINK_FROM_INVALID_RING
//
// MessageText:
//
//  The operating system cannot run this
//  application program.
//


//
// MessageId: ERROR_IOPL_NOT_ENABLED
//
// MessageText:
//
//  The operating system is not presently
//  configured to run this application.
//


//
// MessageId: ERROR_INVALID_SEGDPL
//
// MessageText:
//
//  The operating system cannot run %1.
//


//
// MessageId: ERROR_AUTODATASEG_EXCEEDS_64k
//
// MessageText:
//
//  The operating system cannot run this
//  application program.
//


//
// MessageId: ERROR_RING2SEG_MUST_BE_MOVABLE
//
// MessageText:
//
//  The code segment cannot be greater than or equal to 64KB.
//


//
// MessageId: ERROR_RELOC_CHAIN_XEEDS_SEGLIM
//
// MessageText:
//
//  The operating system cannot run %1.
//


//
// MessageId: ERROR_INFLOOP_IN_RELOC_CHAIN
//
// MessageText:
//
//  The operating system cannot run %1.
//


//
// MessageId: ERROR_ENVVAR_NOT_FOUND
//
// MessageText:
//
//  The system could not find the environment
//  option that was entered.
//


//
// MessageId: ERROR_NO_SIGNAL_SENT
//
// MessageText:
//
//  No process in the command subtree has a
//  signal handler.
//


//
// MessageId: ERROR_FILENAME_EXCED_RANGE
//
// MessageText:
//
//  The filename or extension is too long.
//


//
// MessageId: ERROR_RING2_STACK_IN_USE
//
// MessageText:
//
//  The ring 2 stack is in use.
//


//
// MessageId: ERROR_META_EXPANSION_TOO_LONG
//
// MessageText:
//
//  The global filename characters, * or ?, are entered
//  incorrectly or too many global filename characters are specified.
//


//
// MessageId: ERROR_INVALID_SIGNAL_NUMBER
//
// MessageText:
//
//  The signal being posted is not correct.
//


//
// MessageId: ERROR_THREAD_1_INACTIVE
//
// MessageText:
//
//  The signal handler cannot be set.
//


//
// MessageId: ERROR_LOCKED
//
// MessageText:
//
//  The segment is locked and cannot be reallocated.
//


//
// MessageId: ERROR_TOO_MANY_MODULES
//
// MessageText:
//
//  Too many dynamic link modules are attached to this
//  program or dynamic link module.
//


//
// MessageId: ERROR_NESTING_NOT_ALLOWED
//
// MessageText:
//
//  Can't nest calls to LoadModule.
//


//
// MessageId: ERROR_BAD_PIPE
//
// MessageText:
//
//  The pipe state is invalid.
//


//
// MessageId: ERROR_PIPE_BUSY
//
// MessageText:
//
//  All pipe instances are busy.
//


//
// MessageId: ERROR_NO_DATA
//
// MessageText:
//
//  The pipe is being closed.
//


//
// MessageId: ERROR_PIPE_NOT_CONNECTED
//
// MessageText:
//
//  No process is on the other end of the pipe.
//


//
// MessageId: ERROR_MORE_DATA
//
// MessageText:
//
//  More data is available.
//
// dderror

//
// MessageId: ERROR_VC_DISCONNECTED
//
// MessageText:
//
//  The session was cancelled.
//


//
// MessageId: ERROR_INVALID_EA_NAME
//
// MessageText:
//
//  The specified extended attribute name was invalid.
//


//
// MessageId: ERROR_EA_LIST_INCONSISTENT
//
// MessageText:
//
//  The extended attributes are inconsistent.
//


//
// MessageId: ERROR_NO_MORE_ITEMS
//
// MessageText:
//
//  No more data is available.
//


//
// MessageId: ERROR_CANNOT_COPY
//
// MessageText:
//
//  The Copy API cannot be used.
//


//
// MessageId: ERROR_DIRECTORY
//
// MessageText:
//
//  The directory name is invalid.
//


//
// MessageId: ERROR_EAS_DIDNT_FIT
//
// MessageText:
//
//  The extended attributes did not fit in the buffer.
//


//
// MessageId: ERROR_EA_FILE_CORRUPT
//
// MessageText:
//
//  The extended attribute file on the mounted file system is corrupt.
//


//
// MessageId: ERROR_EA_TABLE_FULL
//
// MessageText:
//
//  The extended attribute table file is full.
//


//
// MessageId: ERROR_INVALID_EA_HANDLE
//
// MessageText:
//
//  The specified extended attribute handle is invalid.
//


//
// MessageId: ERROR_EAS_NOT_SUPPORTED
//
// MessageText:
//
//  The mounted file system does not support extended attributes.
//


//
// MessageId: ERROR_NOT_OWNER
//
// MessageText:
//
//  Attempt to release mutex not owned by caller.
//


//
// MessageId: ERROR_TOO_MANY_POSTS
//
// MessageText:
//
//  Too many posts were made to a semaphore.
//


//
// MessageId: ERROR_PARTIAL_COPY
//
// MessageText:
//
//  Only part of a Read/WriteProcessMemory request was completed.
//


//
// MessageId: ERROR_MR_MID_NOT_FOUND
//
// MessageText:
//
//  The system cannot find message for message number 0x%1
//  in message file for %2.
//


//
// MessageId: ERROR_INVALID_ADDRESS
//
// MessageText:
//
//  Attempt to access invalid address.
//


//
// MessageId: ERROR_ARITHMETIC_OVERFLOW
//
// MessageText:
//
//  Arithmetic result exceeded 32 bits.
//


//
// MessageId: ERROR_PIPE_CONNECTED
//
// MessageText:
//
//  There is a process on other end of the pipe.
//


//
// MessageId: ERROR_PIPE_LISTENING
//
// MessageText:
//
//  Waiting for a process to open the other end of the pipe.
//


//
// MessageId: ERROR_EA_ACCESS_DENIED
//
// MessageText:
//
//  Access to the extended attribute was denied.
//


//
// MessageId: ERROR_OPERATION_ABORTED
//
// MessageText:
//
//  The I/O operation has been aborted because of either a thread exit
//  or an application request.
//


//
// MessageId: ERROR_IO_INCOMPLETE
//
// MessageText:
//
//  Overlapped I/O event is not in a signalled state.
//


//
// MessageId: ERROR_IO_PENDING
//
// MessageText:
//
//  Overlapped I/O operation is in progress.
//
// dderror

//
// MessageId: ERROR_NOACCESS
//
// MessageText:
//
//  Invalid access to memory location.
//


//
// MessageId: ERROR_SWAPERROR
//
// MessageText:
//
//  Error performing inpage operation.
//


//
// MessageId: ERROR_STACK_OVERFLOW
//
// MessageText:
//
//  Recursion too deep, stack overflowed.
//


//
// MessageId: ERROR_INVALID_MESSAGE
//
// MessageText:
//
//  The window cannot act on the sent message.
//


//
// MessageId: ERROR_CAN_NOT_COMPLETE
//
// MessageText:
//
//  Cannot complete this function.
//


//
// MessageId: ERROR_INVALID_FLAGS
//
// MessageText:
//
//  Invalid flags.
//


//
// MessageId: ERROR_UNRECOGNIZED_VOLUME
//
// MessageText:
//
//  The volume does not contain a recognized file system.
//  Please make sure that all required file system drivers are loaded and that the
//  volume is not corrupt.
//


//
// MessageId: ERROR_FILE_INVALID
//
// MessageText:
//
//  The volume for a file has been externally altered such that the
//  opened file is no longer valid.
//


//
// MessageId: ERROR_FULLSCREEN_MODE
//
// MessageText:
//
//  The requested operation cannot be performed in full-screen mode.
//


//
// MessageId: ERROR_NO_TOKEN
//
// MessageText:
//
//  An attempt was made to reference a token that does not exist.
//


//
// MessageId: ERROR_BADDB
//
// MessageText:
//
//  The configuration registry database is corrupt.
//


//
// MessageId: ERROR_BADKEY
//
// MessageText:
//
//  The configuration registry key is invalid.
//


//
// MessageId: ERROR_CANTOPEN
//
// MessageText:
//
//  The configuration registry key could not be opened.
//


//
// MessageId: ERROR_CANTREAD
//
// MessageText:
//
//  The configuration registry key could not be read.
//


//
// MessageId: ERROR_CANTWRITE
//
// MessageText:
//
//  The configuration registry key could not be written.
//


//
// MessageId: ERROR_REGISTRY_RECOVERED
//
// MessageText:
//
//  One of the files in the Registry database had to be recovered
//  by use of a log or alternate copy.  The recovery was successful.
//


//
// MessageId: ERROR_REGISTRY_CORRUPT
//
// MessageText:
//
//  The Registry is corrupt. The structure of one of the files that contains
//  Registry data is corrupt, or the system's image of the file in memory
//  is corrupt, or the file could not be recovered because the alternate
//  copy or log was absent or corrupt.
//


//
// MessageId: ERROR_REGISTRY_IO_FAILED
//
// MessageText:
//
//  An I/O operation initiated by the Registry failed unrecoverably.
//  The Registry could not read in, or write out, or flush, one of the files
//  that contain the system's image of the Registry.
//


//
// MessageId: ERROR_NOT_REGISTRY_FILE
//
// MessageText:
//
//  The system has attempted to load or restore a file into the Registry, but the
//  specified file is not in a Registry file format.
//


//
// MessageId: ERROR_KEY_DELETED
//
// MessageText:
//
//  Illegal operation attempted on a Registry key which has been marked for deletion.
//


//
// MessageId: ERROR_NO_LOG_SPACE
//
// MessageText:
//
//  System could not allocate the required space in a Registry log.
//


//
// MessageId: ERROR_KEY_HAS_CHILDREN
//
// MessageText:
//
//  Cannot create a symbolic link in a Registry key that already
//  has subkeys or values.
//


//
// MessageId: ERROR_CHILD_MUST_BE_VOLATILE
//
// MessageText:
//
//  Cannot create a stable subkey under a volatile parent key.
//


//
// MessageId: ERROR_NOTIFY_ENUM_DIR
//
// MessageText:
//
//  A notify change request is being completed and the information
//  is not being returned in the caller's buffer. The caller now
//  needs to enumerate the files to find the changes.
//


//
// MessageId: ERROR_DEPENDENT_SERVICES_RUNNING
//
// MessageText:
//
//  A stop control has been sent to a service which other running services
//  are dependent on.
//


//
// MessageId: ERROR_INVALID_SERVICE_CONTROL
//
// MessageText:
//
//  The requested control is not valid for this service
//


//
// MessageId: ERROR_SERVICE_REQUEST_TIMEOUT
//
// MessageText:
//
//  The service did not respond to the start or control request in a timely
//  fashion.
//


//
// MessageId: ERROR_SERVICE_NO_THREAD
//
// MessageText:
//
//  A thread could not be created for the service.
//


//
// MessageId: ERROR_SERVICE_DATABASE_LOCKED
//
// MessageText:
//
//  The service database is locked.
//


//
// MessageId: ERROR_SERVICE_ALREADY_RUNNING
//
// MessageText:
//
//  An instance of the service is already running.
//


//
// MessageId: ERROR_INVALID_SERVICE_ACCOUNT
//
// MessageText:
//
//  The account name is invalid or does not exist.
//


//
// MessageId: ERROR_SERVICE_DISABLED
//
// MessageText:
//
//  The specified service is disabled and cannot be started.
//


//
// MessageId: ERROR_CIRCULAR_DEPENDENCY
//
// MessageText:
//
//  Circular service dependency was specified.
//


//
// MessageId: ERROR_SERVICE_DOES_NOT_EXIST
//
// MessageText:
//
//  The specified service does not exist as an installed service.
//


//
// MessageId: ERROR_SERVICE_CANNOT_ACCEPT_CTRL
//
// MessageText:
//
//  The service cannot accept control messages at this time.
//


//
// MessageId: ERROR_SERVICE_NOT_ACTIVE
//
// MessageText:
//
//  The service has not been started.
//


//
// MessageId: ERROR_FAILED_SERVICE_CONTROLLER_CONNECT
//
// MessageText:
//
//  The service process could not connect to the service controller.
//


//
// MessageId: ERROR_EXCEPTION_IN_SERVICE
//
// MessageText:
//
//  An exception occurred in the service when handling the control request.
//


//
// MessageId: ERROR_DATABASE_DOES_NOT_EXIST
//
// MessageText:
//
//  The database specified does not exist.
//


//
// MessageId: ERROR_SERVICE_SPECIFIC_ERROR
//
// MessageText:
//
//  The service has returned a service-specific error code.
//


//
// MessageId: ERROR_PROCESS_ABORTED
//
// MessageText:
//
//  The process terminated unexpectedly.
//


//
// MessageId: ERROR_SERVICE_DEPENDENCY_FAIL
//
// MessageText:
//
//  The dependency service or group failed to start.
//


//
// MessageId: ERROR_SERVICE_LOGON_FAILED
//
// MessageText:
//
//  The service did not start due to a logon failure.
//


//
// MessageId: ERROR_SERVICE_START_HANG
//
// MessageText:
//
//  After starting, the service hung in a start-pending state.
//


//
// MessageId: ERROR_INVALID_SERVICE_LOCK
//
// MessageText:
//
//  The specified service database lock is invalid.
//


//
// MessageId: ERROR_SERVICE_MARKED_FOR_DELETE
//
// MessageText:
//
//  The specified service has been marked for deletion.
//


//
// MessageId: ERROR_SERVICE_EXISTS
//
// MessageText:
//
//  The specified service already exists.
//


//
// MessageId: ERROR_ALREADY_RUNNING_LKG
//
// MessageText:
//
//  The system is currently running with the last-known-good configuration.
//


//
// MessageId: ERROR_SERVICE_DEPENDENCY_DELETED
//
// MessageText:
//
//  The dependency service does not exist or has been marked for
//  deletion.
//


//
// MessageId: ERROR_BOOT_ALREADY_ACCEPTED
//
// MessageText:
//
//  The current boot has already been accepted for use as the
//  last-known-good control set.
//


//
// MessageId: ERROR_SERVICE_NEVER_STARTED
//
// MessageText:
//
//  No attempts to start the service have been made since the last boot.
//


//
// MessageId: ERROR_DUPLICATE_SERVICE_NAME
//
// MessageText:
//
//  The name is already in use as either a service name or a service display
//  name.
//


//
// MessageId: ERROR_END_OF_MEDIA
//
// MessageText:
//
//  The physical end of the tape has been reached.
//


//
// MessageId: ERROR_FILEMARK_DETECTED
//
// MessageText:
//
//  A tape access reached a filemark.
//


//
// MessageId: ERROR_BEGINNING_OF_MEDIA
//
// MessageText:
//
//  Beginning of tape or partition was encountered.
//


//
// MessageId: ERROR_SETMARK_DETECTED
//
// MessageText:
//
//  A tape access reached the end of a set of files.
//


//
// MessageId: ERROR_NO_DATA_DETECTED
//
// MessageText:
//
//  No more data is on the tape.
//


//
// MessageId: ERROR_PARTITION_FAILURE
//
// MessageText:
//
//  Tape could not be partitioned.
//


//
// MessageId: ERROR_INVALID_BLOCK_LENGTH
//
// MessageText:
//
//  When accessing a new tape of a multivolume partition, the current
//  blocksize is incorrect.
//


//
// MessageId: ERROR_DEVICE_NOT_PARTITIONED
//
// MessageText:
//
//  Tape partition information could not be found when loading a tape.
//


//
// MessageId: ERROR_UNABLE_TO_LOCK_MEDIA
//
// MessageText:
//
//  Unable to lock the media eject mechanism.
//


//
// MessageId: ERROR_UNABLE_TO_UNLOAD_MEDIA
//
// MessageText:
//
//  Unable to unload the media.
//


//
// MessageId: ERROR_MEDIA_CHANGED
//
// MessageText:
//
//  Media in drive may have changed.
//


//
// MessageId: ERROR_BUS_RESET
//
// MessageText:
//
//  The I/O bus was reset.
//


//
// MessageId: ERROR_NO_MEDIA_IN_DRIVE
//
// MessageText:
//
//  No media in drive.
//


//
// MessageId: ERROR_NO_UNICODE_TRANSLATION
//
// MessageText:
//
//  No mapping for the Unicode character exists in the target multi-byte code page.
//


//
// MessageId: ERROR_DLL_INIT_FAILED
//
// MessageText:
//
//  A dynamic link library (DLL) initialization routine failed.
//


//
// MessageId: ERROR_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
//  A system shutdown is in progress.
//


//
// MessageId: ERROR_NO_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
//  Unable to abort the system shutdown because no shutdown was in progress.
//


//
// MessageId: ERROR_IO_DEVICE
//
// MessageText:
//
//  The request could not be performed because of an I/O device error.
//


//
// MessageId: ERROR_SERIAL_NO_DEVICE
//
// MessageText:
//
//  No serial device was successfully initialized.  The serial driver will unload.
//


//
// MessageId: ERROR_IRQ_BUSY
//
// MessageText:
//
//  Unable to open a device that was sharing an interrupt request (IRQ)
//  with other devices. At least one other device that uses that IRQ
//  was already opened.
//


//
// MessageId: ERROR_MORE_WRITES
//
// MessageText:
//
//  A serial I/O operation was completed by another write to the serial port.
//  (The IOCTL_SERIAL_XOFF_COUNTER reached zero.)
//


//
// MessageId: ERROR_COUNTER_TIMEOUT
//
// MessageText:
//
//  A serial I/O operation completed because the time-out period expired.
//  (The IOCTL_SERIAL_XOFF_COUNTER did not reach zero.)
//


//
// MessageId: ERROR_FLOPPY_ID_MARK_NOT_FOUND
//
// MessageText:
//
//  No ID address mark was found on the floppy disk.
//


//
// MessageId: ERROR_FLOPPY_WRONG_CYLINDER
//
// MessageText:
//
//  Mismatch between the floppy disk sector ID field and the floppy disk
//  controller track address.
//


//
// MessageId: ERROR_FLOPPY_UNKNOWN_ERROR
//
// MessageText:
//
//  The floppy disk controller reported an error that is not recognized
//  by the floppy disk driver.
//


//
// MessageId: ERROR_FLOPPY_BAD_REGISTERS
//
// MessageText:
//
//  The floppy disk controller returned inconsistent results in its registers.
//


//
// MessageId: ERROR_DISK_RECALIBRATE_FAILED
//
// MessageText:
//
//  While accessing the hard disk, a recalibrate operation failed, even after retries.
//


//
// MessageId: ERROR_DISK_OPERATION_FAILED
//
// MessageText:
//
//  While accessing the hard disk, a disk operation failed even after retries.
//


//
// MessageId: ERROR_DISK_RESET_FAILED
//
// MessageText:
//
//  While accessing the hard disk, a disk controller reset was needed, but
//  even that failed.
//


//
// MessageId: ERROR_EOM_OVERFLOW
//
// MessageText:
//
//  Physical end of tape encountered.
//


//
// MessageId: ERROR_NOT_ENOUGH_SERVER_MEMORY
//
// MessageText:
//
//  Not enough server storage is available to process this command.
//


//
// MessageId: ERROR_POSSIBLE_DEADLOCK
//
// MessageText:
//
//  A potential deadlock condition has been detected.
//


//
// MessageId: ERROR_MAPPED_ALIGNMENT
//
// MessageText:
//
//  The base address or the file offset specified does not have the proper
//  alignment.
//


//
// MessageId: ERROR_SET_POWER_STATE_VETOED
//
// MessageText:
//
//  An attempt to change the system power state was vetoed by another
//  application or driver.
//


//
// MessageId: ERROR_SET_POWER_STATE_FAILED
//
// MessageText:
//
//  The system BIOS failed an attempt to change the system power state.
//


//
// MessageId: ERROR_OLD_WIN_VERSION
//
// MessageText:
//
//  The specified program requires a newer version of Windows.
//


//
// MessageId: ERROR_APP_WRONG_OS
//
// MessageText:
//
//  The specified program is not a Windows or MS-DOS program.
//


//
// MessageId: ERROR_SINGLE_INSTANCE_APP
//
// MessageText:
//
//  Cannot start more than one instance of the specified program.
//


//
// MessageId: ERROR_RMODE_APP
//
// MessageText:
//
//  The specified program was written for an older version of Windows.
//


//
// MessageId: ERROR_INVALID_DLL
//
// MessageText:
//
//  One of the library files needed to run this application is damaged.
//


//
// MessageId: ERROR_NO_ASSOCIATION
//
// MessageText:
//
//  No application is associated with the specified file for this operation.
//


//
// MessageId: ERROR_DDE_FAIL
//
// MessageText:
//
//  An error occurred in sending the command to the application.
//


//
// MessageId: ERROR_DLL_NOT_FOUND
//
// MessageText:
//
//  One of the library files needed to run this application cannot be found.
//





///////////////////////////
//                       //
// Winnet32 Status Codes //
//                       //
///////////////////////////


//
// MessageId: ERROR_BAD_USERNAME
//
// MessageText:
//
//  The specified username is invalid.
//


//
// MessageId: ERROR_NOT_CONNECTED
//
// MessageText:
//
//  This network connection does not exist.
//


//
// MessageId: ERROR_OPEN_FILES
//
// MessageText:
//
//  This network connection has files open or requests pending.
//


//
// MessageId: ERROR_ACTIVE_CONNECTIONS
//
// MessageText:
//
//  Active connections still exist.
//


//
// MessageId: ERROR_DEVICE_IN_USE
//
// MessageText:
//
//  The device is in use by an active process and cannot be disconnected.
//


//
// MessageId: ERROR_BAD_DEVICE
//
// MessageText:
//
//  The specified device name is invalid.
//


//
// MessageId: ERROR_CONNECTION_UNAVAIL
//
// MessageText:
//
//  The device is not currently connected but it is a remembered connection.
//


//
// MessageId: ERROR_DEVICE_ALREADY_REMEMBERED
//
// MessageText:
//
//  An attempt was made to remember a device that had previously been remembered.
//


//
// MessageId: ERROR_NO_NET_OR_BAD_PATH
//
// MessageText:
//
//  No network provider accepted the given network path.
//


//
// MessageId: ERROR_BAD_PROVIDER
//
// MessageText:
//
//  The specified network provider name is invalid.
//


//
// MessageId: ERROR_CANNOT_OPEN_PROFILE
//
// MessageText:
//
//  Unable to open the network connection profile.
//


//
// MessageId: ERROR_BAD_PROFILE
//
// MessageText:
//
//  The network connection profile is corrupt.
//


//
// MessageId: ERROR_NOT_CONTAINER
//
// MessageText:
//
//  Cannot enumerate a non-container.
//


//
// MessageId: ERROR_EXTENDED_ERROR
//
// MessageText:
//
//  An extended error has occurred.
//


//
// MessageId: ERROR_INVALID_GROUPNAME
//
// MessageText:
//
//  The format of the specified group name is invalid.
//


//
// MessageId: ERROR_INVALID_COMPUTERNAME
//
// MessageText:
//
//  The format of the specified computer name is invalid.
//


//
// MessageId: ERROR_INVALID_EVENTNAME
//
// MessageText:
//
//  The format of the specified event name is invalid.
//


//
// MessageId: ERROR_INVALID_DOMAINNAME
//
// MessageText:
//
//  The format of the specified domain name is invalid.
//


//
// MessageId: ERROR_INVALID_SERVICENAME
//
// MessageText:
//
//  The format of the specified service name is invalid.
//


//
// MessageId: ERROR_INVALID_NETNAME
//
// MessageText:
//
//  The format of the specified network name is invalid.
//


//
// MessageId: ERROR_INVALID_SHARENAME
//
// MessageText:
//
//  The format of the specified share name is invalid.
//


//
// MessageId: ERROR_INVALID_PASSWORDNAME
//
// MessageText:
//
//  The format of the specified password is invalid.
//


//
// MessageId: ERROR_INVALID_MESSAGENAME
//
// MessageText:
//
//  The format of the specified message name is invalid.
//


//
// MessageId: ERROR_INVALID_MESSAGEDEST
//
// MessageText:
//
//  The format of the specified message destination is invalid.
//


//
// MessageId: ERROR_SESSION_CREDENTIAL_CONFLICT
//
// MessageText:
//
//  The credentials supplied conflict with an existing set of credentials.
//


//
// MessageId: ERROR_REMOTE_SESSION_LIMIT_EXCEEDED
//
// MessageText:
//
//  An attempt was made to establish a session to a network server, but there
//  are already too many sessions established to that server.
//


//
// MessageId: ERROR_DUP_DOMAINNAME
//
// MessageText:
//
//  The workgroup or domain name is already in use by another computer on the
//  network.
//


//
// MessageId: ERROR_NO_NETWORK
//
// MessageText:
//
//  The network is not present or not started.
//


//
// MessageId: ERROR_CANCELLED
//
// MessageText:
//
//  The operation was cancelled by the user.
//


//
// MessageId: ERROR_USER_MAPPED_FILE
//
// MessageText:
//
//  The requested operation cannot be performed on a file with a user mapped section open.
//


//
// MessageId: ERROR_CONNECTION_REFUSED
//
// MessageText:
//
//  The remote system refused the network connection.
//


//
// MessageId: ERROR_GRACEFUL_DISCONNECT
//
// MessageText:
//
//  The network connection was gracefully closed.
//


//
// MessageId: ERROR_ADDRESS_ALREADY_ASSOCIATED
//
// MessageText:
//
//  The network transport endpoint already has an address associated with it.
//


//
// MessageId: ERROR_ADDRESS_NOT_ASSOCIATED
//
// MessageText:
//
//  An address has not yet been associated with the network endpoint.
//


//
// MessageId: ERROR_CONNECTION_INVALID
//
// MessageText:
//
//  An operation was attempted on a non-existent network connection.
//


//
// MessageId: ERROR_CONNECTION_ACTIVE
//
// MessageText:
//
//  An invalid operation was attempted on an active network connection.
//


//
// MessageId: ERROR_NETWORK_UNREACHABLE
//
// MessageText:
//
//  The remote network is not reachable by the transport.
//


//
// MessageId: ERROR_HOST_UNREACHABLE
//
// MessageText:
//
//  The remote system is not reachable by the transport.
//


//
// MessageId: ERROR_PROTOCOL_UNREACHABLE
//
// MessageText:
//
//  The remote system does not support the transport protocol.
//


//
// MessageId: ERROR_PORT_UNREACHABLE
//
// MessageText:
//
//  No service is operating at the destination network endpoint
//  on the remote system.
//


//
// MessageId: ERROR_REQUEST_ABORTED
//
// MessageText:
//
//  The request was aborted.
//


//
// MessageId: ERROR_CONNECTION_ABORTED
//
// MessageText:
//
//  The network connection was aborted by the local system.
//


//
// MessageId: ERROR_RETRY
//
// MessageText:
//
//  The operation could not be completed.  A retry should be performed.
//


//
// MessageId: ERROR_CONNECTION_COUNT_LIMIT
//
// MessageText:
//
//  A connection to the server could not be made because the limit on the number of
//  concurrent connections for this account has been reached.
//


//
// MessageId: ERROR_LOGIN_TIME_RESTRICTION
//
// MessageText:
//
//  Attempting to login during an unauthorized time of day for this account.
//


//
// MessageId: ERROR_LOGIN_WKSTA_RESTRICTION
//
// MessageText:
//
//  The account is not authorized to login from this station.
//


//
// MessageId: ERROR_INCORRECT_ADDRESS
//
// MessageText:
//
//  The network address could not be used for the operation requested.
//


//
// MessageId: ERROR_ALREADY_REGISTERED
//
// MessageText:
//
//  The service is already registered.
//


//
// MessageId: ERROR_SERVICE_NOT_FOUND
//
// MessageText:
//
//  The specified service does not exist.
//


//
// MessageId: ERROR_NOT_AUTHENTICATED
//
// MessageText:
//
//  The operation being requested was not performed because the user
//  has not been authenticated.
//


//
// MessageId: ERROR_NOT_LOGGED_ON
//
// MessageText:
//
//  The operation being requested was not performed because the user
//  has not logged on to the network.
//  The specified service does not exist.
//


//
// MessageId: ERROR_CONTINUE
//
// MessageText:
//
//  Return that wants caller to continue with work in progress.
//


//
// MessageId: ERROR_ALREADY_INITIALIZED
//
// MessageText:
//
//  An attempt was made to perform an initialization operation when
//  initialization has already been completed.
//


//
// MessageId: ERROR_NO_MORE_DEVICES
//
// MessageText:
//
//  No more local devices.
//





///////////////////////////
//                       //
// Security Status Codes //
//                       //
///////////////////////////


//
// MessageId: ERROR_NOT_ALL_ASSIGNED
//
// MessageText:
//
//  Not all privileges referenced are assigned to the caller.
//


//
// MessageId: ERROR_SOME_NOT_MAPPED
//
// MessageText:
//
//  Some mapping between account names and security IDs was not done.
//


//
// MessageId: ERROR_NO_QUOTAS_FOR_ACCOUNT
//
// MessageText:
//
//  No system quota limits are specifically set for this account.
//


//
// MessageId: ERROR_LOCAL_USER_SESSION_KEY
//
// MessageText:
//
//  No encryption key is available.  A well-known encryption key was returned.
//


//
// MessageId: ERROR_NULL_LM_PASSWORD
//
// MessageText:
//
//  The NT password is too complex to be converted to a LAN Manager
//  password.  The LAN Manager password returned is a NULL string.
//


//
// MessageId: ERROR_UNKNOWN_REVISION
//
// MessageText:
//
//  The revision level is unknown.
//


//
// MessageId: ERROR_REVISION_MISMATCH
//
// MessageText:
//
//  Indicates two revision levels are incompatible.
//


//
// MessageId: ERROR_INVALID_OWNER
//
// MessageText:
//
//  This security ID may not be assigned as the owner of this object.
//


//
// MessageId: ERROR_INVALID_PRIMARY_GROUP
//
// MessageText:
//
//  This security ID may not be assigned as the primary group of an object.
//


//
// MessageId: ERROR_NO_IMPERSONATION_TOKEN
//
// MessageText:
//
//  An attempt has been made to operate on an impersonation token
//  by a thread that is not currently impersonating a client.
//


//
// MessageId: ERROR_CANT_DISABLE_MANDATORY
//
// MessageText:
//
//  The group may not be disabled.
//


//
// MessageId: ERROR_NO_LOGON_SERVERS
//
// MessageText:
//
//  There are currently no logon servers available to service the logon
//  request.
//


//
// MessageId: ERROR_NO_SUCH_LOGON_SESSION
//
// MessageText:
//
//   A specified logon session does not exist.  It may already have
//   been terminated.
//


//
// MessageId: ERROR_NO_SUCH_PRIVILEGE
//
// MessageText:
//
//   A specified privilege does not exist.
//


//
// MessageId: ERROR_PRIVILEGE_NOT_HELD
//
// MessageText:
//
//   A required privilege is not held by the client.
//


//
// MessageId: ERROR_INVALID_ACCOUNT_NAME
//
// MessageText:
//
//  The name provided is not a properly formed account name.
//


//
// MessageId: ERROR_USER_EXISTS
//
// MessageText:
//
//  The specified user already exists.
//


//
// MessageId: ERROR_NO_SUCH_USER
//
// MessageText:
//
//  The specified user does not exist.
//


//
// MessageId: ERROR_GROUP_EXISTS
//
// MessageText:
//
//  The specified group already exists.
//


//
// MessageId: ERROR_NO_SUCH_GROUP
//
// MessageText:
//
//  The specified group does not exist.
//


//
// MessageId: ERROR_MEMBER_IN_GROUP
//
// MessageText:
//
//  Either the specified user account is already a member of the specified
//  group, or the specified group cannot be deleted because it contains
//  a member.
//


//
// MessageId: ERROR_MEMBER_NOT_IN_GROUP
//
// MessageText:
//
//  The specified user account is not a member of the specified group account.
//


//
// MessageId: ERROR_LAST_ADMIN
//
// MessageText:
//
//  The last remaining administration account cannot be disabled
//  or deleted.
//


//
// MessageId: ERROR_WRONG_PASSWORD
//
// MessageText:
//
//  Unable to update the password.  The value provided as the current
//  password is incorrect.
//


//
// MessageId: ERROR_ILL_FORMED_PASSWORD
//
// MessageText:
//
//  Unable to update the password.  The value provided for the new password
//  contains values that are not allowed in passwords.
//


//
// MessageId: ERROR_PASSWORD_RESTRICTION
//
// MessageText:
//
//  Unable to update the password because a password update rule has been
//  violated.
//


//
// MessageId: ERROR_LOGON_FAILURE
//
// MessageText:
//
//  Logon failure: unknown user name or bad password.
//


//
// MessageId: ERROR_ACCOUNT_RESTRICTION
//
// MessageText:
//
//  Logon failure: user account restriction.
//


//
// MessageId: ERROR_INVALID_LOGON_HOURS
//
// MessageText:
//
//  Logon failure: account logon time restriction violation.
//


//
// MessageId: ERROR_INVALID_WORKSTATION
//
// MessageText:
//
//  Logon failure: user not allowed to log on to this computer.
//


//
// MessageId: ERROR_PASSWORD_EXPIRED
//
// MessageText:
//
//  Logon failure: the specified account password has expired.
//


//
// MessageId: ERROR_ACCOUNT_DISABLED
//
// MessageText:
//
//  Logon failure: account currently disabled.
//


//
// MessageId: ERROR_NONE_MAPPED
//
// MessageText:
//
//  No mapping between account names and security IDs was done.
//


//
// MessageId: ERROR_TOO_MANY_LUIDS_REQUESTED
//
// MessageText:
//
//  Too many local user identifiers (LUIDs) were requested at one time.
//


//
// MessageId: ERROR_LUIDS_EXHAUSTED
//
// MessageText:
//
//  No more local user identifiers (LUIDs) are available.
//


//
// MessageId: ERROR_INVALID_SUB_AUTHORITY
//
// MessageText:
//
//  The subauthority part of a security ID is invalid for this particular use.
//


//
// MessageId: ERROR_INVALID_ACL
//
// MessageText:
//
//  The access control list (ACL) structure is invalid.
//


//
// MessageId: ERROR_INVALID_SID
//
// MessageText:
//
//  The security ID structure is invalid.
//


//
// MessageId: ERROR_INVALID_SECURITY_DESCR
//
// MessageText:
//
//  The security descriptor structure is invalid.
//


//
// MessageId: ERROR_BAD_INHERITANCE_ACL
//
// MessageText:
//
//  The inherited access control list (ACL) or access control entry (ACE)
//  could not be built.
//


//
// MessageId: ERROR_SERVER_DISABLED
//
// MessageText:
//
//  The server is currently disabled.
//


//
// MessageId: ERROR_SERVER_NOT_DISABLED
//
// MessageText:
//
//  The server is currently enabled.
//


//
// MessageId: ERROR_INVALID_ID_AUTHORITY
//
// MessageText:
//
//  The value provided was an invalid value for an identifier authority.
//


//
// MessageId: ERROR_ALLOTTED_SPACE_EXCEEDED
//
// MessageText:
//
//  No more memory is available for security information updates.
//


//
// MessageId: ERROR_INVALID_GROUP_ATTRIBUTES
//
// MessageText:
//
//  The specified attributes are invalid, or incompatible with the
//  attributes for the group as a whole.
//


//
// MessageId: ERROR_BAD_IMPERSONATION_LEVEL
//
// MessageText:
//
//  Either a required impersonation level was not provided, or the
//  provided impersonation level is invalid.
//


//
// MessageId: ERROR_CANT_OPEN_ANONYMOUS
//
// MessageText:
//
//  Cannot open an anonymous level security token.
//


//
// MessageId: ERROR_BAD_VALIDATION_CLASS
//
// MessageText:
//
//  The validation information class requested was invalid.
//


//
// MessageId: ERROR_BAD_TOKEN_TYPE
//
// MessageText:
//
//  The type of the token is inappropriate for its attempted use.
//


//
// MessageId: ERROR_NO_SECURITY_ON_OBJECT
//
// MessageText:
//
//  Unable to perform a security operation on an object
//  which has no associated security.
//


//
// MessageId: ERROR_CANT_ACCESS_DOMAIN_INFO
//
// MessageText:
//
//  Indicates a Windows NT Server could not be contacted or that
//  objects within the domain are protected such that necessary
//  information could not be retrieved.
//


//
// MessageId: ERROR_INVALID_SERVER_STATE
//
// MessageText:
//
//  The security account manager (SAM) or local security
//  authority (LSA) server was in the wrong state to perform
//  the security operation.
//


//
// MessageId: ERROR_INVALID_DOMAIN_STATE
//
// MessageText:
//
//  The domain was in the wrong state to perform the security operation.
//


//
// MessageId: ERROR_INVALID_DOMAIN_ROLE
//
// MessageText:
//
//  This operation is only allowed for the Primary Domain Controller of the domain.
//


//
// MessageId: ERROR_NO_SUCH_DOMAIN
//
// MessageText:
//
//  The specified domain did not exist.
//


//
// MessageId: ERROR_DOMAIN_EXISTS
//
// MessageText:
//
//  The specified domain already exists.
//


//
// MessageId: ERROR_DOMAIN_LIMIT_EXCEEDED
//
// MessageText:
//
//  An attempt was made to exceed the limit on the number of domains per server.
//


//
// MessageId: ERROR_INTERNAL_DB_CORRUPTION
//
// MessageText:
//
//  Unable to complete the requested operation because of either a
//  catastrophic media failure or a data structure corruption on the disk.
//


//
// MessageId: ERROR_INTERNAL_ERROR
//
// MessageText:
//
//  The security account database contains an internal inconsistency.
//


//
// MessageId: ERROR_GENERIC_NOT_MAPPED
//
// MessageText:
//
//  Generic access types were contained in an access mask which should
//  already be mapped to non-generic types.
//


//
// MessageId: ERROR_BAD_DESCRIPTOR_FORMAT
//
// MessageText:
//
//  A security descriptor is not in the right format (absolute or self-relative).
//


//
// MessageId: ERROR_NOT_LOGON_PROCESS
//
// MessageText:
//
//  The requested action is restricted for use by logon processes
//  only.  The calling process has not registered as a logon process.
//


//
// MessageId: ERROR_LOGON_SESSION_EXISTS
//
// MessageText:
//
//  Cannot start a new logon session with an ID that is already in use.
//


//
// MessageId: ERROR_NO_SUCH_PACKAGE
//
// MessageText:
//
//  A specified authentication package is unknown.
//


//
// MessageId: ERROR_BAD_LOGON_SESSION_STATE
//
// MessageText:
//
//  The logon session is not in a state that is consistent with the
//  requested operation.
//


//
// MessageId: ERROR_LOGON_SESSION_COLLISION
//
// MessageText:
//
//  The logon session ID is already in use.
//


//
// MessageId: ERROR_INVALID_LOGON_TYPE
//
// MessageText:
//
//  A logon request contained an invalid logon type value.
//


//
// MessageId: ERROR_CANNOT_IMPERSONATE
//
// MessageText:
//
//  Unable to impersonate via a named pipe until data has been read
//  from that pipe.
//


//
// MessageId: ERROR_RXACT_INVALID_STATE
//
// MessageText:
//
//  The transaction state of a Registry subtree is incompatible with the
//  requested operation.
//


//
// MessageId: ERROR_RXACT_COMMIT_FAILURE
//
// MessageText:
//
//  An internal security database corruption has been encountered.
//


//
// MessageId: ERROR_SPECIAL_ACCOUNT
//
// MessageText:
//
//  Cannot perform this operation on built-in accounts.
//


//
// MessageId: ERROR_SPECIAL_GROUP
//
// MessageText:
//
//  Cannot perform this operation on this built-in special group.
//


//
// MessageId: ERROR_SPECIAL_USER
//
// MessageText:
//
//  Cannot perform this operation on this built-in special user.
//


//
// MessageId: ERROR_MEMBERS_PRIMARY_GROUP
//
// MessageText:
//
//  The user cannot be removed from a group because the group
//  is currently the user's primary group.
//


//
// MessageId: ERROR_TOKEN_ALREADY_IN_USE
//
// MessageText:
//
//  The token is already in use as a primary token.
//


//
// MessageId: ERROR_NO_SUCH_ALIAS
//
// MessageText:
//
//  The specified local group does not exist.
//


//
// MessageId: ERROR_MEMBER_NOT_IN_ALIAS
//
// MessageText:
//
//  The specified account name is not a member of the local group.
//


//
// MessageId: ERROR_MEMBER_IN_ALIAS
//
// MessageText:
//
//  The specified account name is already a member of the local group.
//


//
// MessageId: ERROR_ALIAS_EXISTS
//
// MessageText:
//
//  The specified local group already exists.
//


//
// MessageId: ERROR_LOGON_NOT_GRANTED
//
// MessageText:
//
//  Logon failure: the user has not been granted the requested
//  logon type at this computer.
//


//
// MessageId: ERROR_TOO_MANY_SECRETS
//
// MessageText:
//
//  The maximum number of secrets that may be stored in a single system has been
//  exceeded.
//


//
// MessageId: ERROR_SECRET_TOO_LONG
//
// MessageText:
//
//  The length of a secret exceeds the maximum length allowed.
//


//
// MessageId: ERROR_INTERNAL_DB_ERROR
//
// MessageText:
//
//  The local security authority database contains an internal inconsistency.
//


//
// MessageId: ERROR_TOO_MANY_CONTEXT_IDS
//
// MessageText:
//
//  During a logon attempt, the user's security context accumulated too many
//  security IDs.
//


//
// MessageId: ERROR_LOGON_TYPE_NOT_GRANTED
//
// MessageText:
//
//  Logon failure: the user has not been granted the requested logon type
//  at this computer.
//


//
// MessageId: ERROR_NT_CROSS_ENCRYPTION_REQUIRED
//
// MessageText:
//
//  A cross-encrypted password is necessary to change a user password.
//


//
// MessageId: ERROR_NO_SUCH_MEMBER
//
// MessageText:
//
//  A new member could not be added to a local group because the member does
//  not exist.
//


//
// MessageId: ERROR_INVALID_MEMBER
//
// MessageText:
//
//  A new member could not be added to a local group because the member has the
//  wrong account type.
//


//
// MessageId: ERROR_TOO_MANY_SIDS
//
// MessageText:
//
//  Too many security IDs have been specified.
//


//
// MessageId: ERROR_LM_CROSS_ENCRYPTION_REQUIRED
//
// MessageText:
//
//  A cross-encrypted password is necessary to change this user password.
//


//
// MessageId: ERROR_NO_INHERITANCE
//
// MessageText:
//
//  Indicates an ACL contains no inheritable components
//


//
// MessageId: ERROR_FILE_CORRUPT
//
// MessageText:
//
//  The file or directory is corrupt and non-readable.
//


//
// MessageId: ERROR_DISK_CORRUPT
//
// MessageText:
//
//  The disk structure is corrupt and non-readable.
//


//
// MessageId: ERROR_NO_USER_SESSION_KEY
//
// MessageText:
//
//  There is no user session key for the specified logon session.
//


//
// MessageId: ERROR_LICENSE_QUOTA_EXCEEDED
//
// MessageText:
//
//  The service being accessed is licensed for a particular number of
//  connections. No more connections can be made to the service at this time
//  because there are already as many connections as the service can accept.
//


// End of security error codes



///////////////////////////
//                       //
// WinUser Error Codes   //
//                       //
///////////////////////////


//
// MessageId: ERROR_INVALID_WINDOW_HANDLE
//
// MessageText:
//
//  Invalid window handle.
//


//
// MessageId: ERROR_INVALID_MENU_HANDLE
//
// MessageText:
//
//  Invalid menu handle.
//


//
// MessageId: ERROR_INVALID_CURSOR_HANDLE
//
// MessageText:
//
//  Invalid cursor handle.
//


//
// MessageId: ERROR_INVALID_ACCEL_HANDLE
//
// MessageText:
//
//  Invalid accelerator table handle.
//


//
// MessageId: ERROR_INVALID_HOOK_HANDLE
//
// MessageText:
//
//  Invalid hook handle.
//


//
// MessageId: ERROR_INVALID_DWP_HANDLE
//
// MessageText:
//
//  Invalid handle to a multiple-window position structure.
//


//
// MessageId: ERROR_TLW_WITH_WSCHILD
//
// MessageText:
//
//  Cannot create a top-level child window.
//


//
// MessageId: ERROR_CANNOT_FIND_WND_CLASS
//
// MessageText:
//
//  Cannot find window class.
//


//
// MessageId: ERROR_WINDOW_OF_OTHER_THREAD
//
// MessageText:
//
//  Invalid window, belongs to other thread.
//


//
// MessageId: ERROR_HOTKEY_ALREADY_REGISTERED
//
// MessageText:
//
//  Hot key is already registered.
//


//
// MessageId: ERROR_CLASS_ALREADY_EXISTS
//
// MessageText:
//
//  Class already exists.
//


//
// MessageId: ERROR_CLASS_DOES_NOT_EXIST
//
// MessageText:
//
//  Class does not exist.
//


//
// MessageId: ERROR_CLASS_HAS_WINDOWS
//
// MessageText:
//
//  Class still has open windows.
//


//
// MessageId: ERROR_INVALID_INDEX
//
// MessageText:
//
//  Invalid index.
//


//
// MessageId: ERROR_INVALID_ICON_HANDLE
//
// MessageText:
//
//  Invalid icon handle.
//


//
// MessageId: ERROR_PRIVATE_DIALOG_INDEX
//
// MessageText:
//
//  Using private DIALOG window words.
//


//
// MessageId: ERROR_LISTBOX_ID_NOT_FOUND
//
// MessageText:
//
//  The listbox identifier was not found.
//


//
// MessageId: ERROR_NO_WILDCARD_CHARACTERS
//
// MessageText:
//
//  No wildcards were found.
//


//
// MessageId: ERROR_CLIPBOARD_NOT_OPEN
//
// MessageText:
//
//  Thread does not have a clipboard open.
//


//
// MessageId: ERROR_HOTKEY_NOT_REGISTERED
//
// MessageText:
//
//  Hot key is not registered.
//


//
// MessageId: ERROR_WINDOW_NOT_DIALOG
//
// MessageText:
//
//  The window is not a valid dialog window.
//


//
// MessageId: ERROR_CONTROL_ID_NOT_FOUND
//
// MessageText:
//
//  Control ID not found.
//


//
// MessageId: ERROR_INVALID_COMBOBOX_MESSAGE
//
// MessageText:
//
//  Invalid message for a combo box because it does not have an edit control.
//


//
// MessageId: ERROR_WINDOW_NOT_COMBOBOX
//
// MessageText:
//
//  The window is not a combo box.
//


//
// MessageId: ERROR_INVALID_EDIT_HEIGHT
//
// MessageText:
//
//  Height must be less than 256.
//


//
// MessageId: ERROR_DC_NOT_FOUND
//
// MessageText:
//
//  Invalid device context (DC) handle.
//


//
// MessageId: ERROR_INVALID_HOOK_FILTER
//
// MessageText:
//
//  Invalid hook procedure type.
//


//
// MessageId: ERROR_INVALID_FILTER_PROC
//
// MessageText:
//
//  Invalid hook procedure.
//


//
// MessageId: ERROR_HOOK_NEEDS_HMOD
//
// MessageText:
//
//  Cannot set non-local hook without a module handle.
//


//
// MessageId: ERROR_GLOBAL_ONLY_HOOK
//
// MessageText:
//
//  This hook procedure can only be set globally.
//


//
// MessageId: ERROR_JOURNAL_HOOK_SET
//
// MessageText:
//
//  The journal hook procedure is already installed.
//


//
// MessageId: ERROR_HOOK_NOT_INSTALLED
//
// MessageText:
//
//  The hook procedure is not installed.
//


//
// MessageId: ERROR_INVALID_LB_MESSAGE
//
// MessageText:
//
//  Invalid message for single-selection listbox.
//


//
// MessageId: ERROR_SETCOUNT_ON_BAD_LB
//
// MessageText:
//
//  LB_SETCOUNT sent to non-lazy listbox.
//


//
// MessageId: ERROR_LB_WITHOUT_TABSTOPS
//
// MessageText:
//
//  This list box does not support tab stops.
//


//
// MessageId: ERROR_DESTROY_OBJECT_OF_OTHER_THREAD
//
// MessageText:
//
//  Cannot destroy object created by another thread.
//


//
// MessageId: ERROR_CHILD_WINDOW_MENU
//
// MessageText:
//
//  Child windows cannot have menus.
//


//
// MessageId: ERROR_NO_SYSTEM_MENU
//
// MessageText:
//
//  The window does not have a system menu.
//


//
// MessageId: ERROR_INVALID_MSGBOX_STYLE
//
// MessageText:
//
//  Invalid message box style.
//


//
// MessageId: ERROR_INVALID_SPI_VALUE
//
// MessageText:
//
//  Invalid system-wide (SPI_*) parameter.
//


//
// MessageId: ERROR_SCREEN_ALREADY_LOCKED
//
// MessageText:
//
//  Screen already locked.
//


//
// MessageId: ERROR_HWNDS_HAVE_DIFF_PARENT
//
// MessageText:
//
//  All handles to windows in a multiple-window position structure must
//  have the same parent.
//


//
// MessageId: ERROR_NOT_CHILD_WINDOW
//
// MessageText:
//
//  The window is not a child window.
//


//
// MessageId: ERROR_INVALID_GW_COMMAND
//
// MessageText:
//
//  Invalid GW_* command.
//


//
// MessageId: ERROR_INVALID_THREAD_ID
//
// MessageText:
//
//  Invalid thread identifier.
//


//
// MessageId: ERROR_NON_MDICHILD_WINDOW
//
// MessageText:
//
//  Cannot process a message from a window that is not a multiple document
//  interface (MDI) window.
//


//
// MessageId: ERROR_POPUP_ALREADY_ACTIVE
//
// MessageText:
//
//  Popup menu already active.
//


//
// MessageId: ERROR_NO_SCROLLBARS
//
// MessageText:
//
//  The window does not have scroll bars.
//


//
// MessageId: ERROR_INVALID_SCROLLBAR_RANGE
//
// MessageText:
//
//  Scroll bar range cannot be greater than 0x7FFF.
//


//
// MessageId: ERROR_INVALID_SHOWWIN_COMMAND
//
// MessageText:
//
//  Cannot show or remove the window in the way specified.
//


//
// MessageId: ERROR_NO_SYSTEM_RESOURCES
//
// MessageText:
//
//  Insufficient system resources exist to complete the requested service.
//


//
// MessageId: ERROR_NONPAGED_SYSTEM_RESOURCES
//
// MessageText:
//
//  Insufficient system resources exist to complete the requested service.
//


//
// MessageId: ERROR_PAGED_SYSTEM_RESOURCES
//
// MessageText:
//
//  Insufficient system resources exist to complete the requested service.
//


//
// MessageId: ERROR_WORKING_SET_QUOTA
//
// MessageText:
//
//  Insufficient quota to complete the requested service.
//


//
// MessageId: ERROR_PAGEFILE_QUOTA
//
// MessageText:
//
//  Insufficient quota to complete the requested service.
//


//
// MessageId: ERROR_COMMITMENT_LIMIT
//
// MessageText:
//
//  The paging file is too small for this operation to complete.
//


//
// MessageId: ERROR_MENU_ITEM_NOT_FOUND
//
// MessageText:
//
//  A menu item was not found.
//


// End of WinUser error codes



///////////////////////////
//                       //
// Eventlog Status Codes //
//                       //
///////////////////////////


//
// MessageId: ERROR_EVENTLOG_FILE_CORRUPT
//
// MessageText:
//
//  The event log file is corrupt.
//


//
// MessageId: ERROR_EVENTLOG_CANT_START
//
// MessageText:
//
//  No event log file could be opened, so the event logging service did not start.
//


//
// MessageId: ERROR_LOG_FILE_FULL
//
// MessageText:
//
//  The event log file is full.
//


//
// MessageId: ERROR_EVENTLOG_FILE_CHANGED
//
// MessageText:
//
//  The event log file has changed between reads.
//


// End of eventlog error codes



///////////////////////////
//                       //
//   RPC Status Codes    //
//                       //
///////////////////////////


//
// MessageId: RPC_S_INVALID_STRING_BINDING
//
// MessageText:
//
//  The string binding is invalid.
//


//
// MessageId: RPC_S_WRONG_KIND_OF_BINDING
//
// MessageText:
//
//  The binding handle is not the correct type.
//


//
// MessageId: RPC_S_INVALID_BINDING
//
// MessageText:
//
//  The binding handle is invalid.
//


//
// MessageId: RPC_S_PROTSEQ_NOT_SUPPORTED
//
// MessageText:
//
//  The RPC protocol sequence is not supported.
//


//
// MessageId: RPC_S_INVALID_RPC_PROTSEQ
//
// MessageText:
//
//  The RPC protocol sequence is invalid.
//


//
// MessageId: RPC_S_INVALID_STRING_UUID
//
// MessageText:
//
//  The string universal unique identifier (UUID) is invalid.
//


//
// MessageId: RPC_S_INVALID_ENDPOINT_FORMAT
//
// MessageText:
//
//  The endpoint format is invalid.
//


//
// MessageId: RPC_S_INVALID_NET_ADDR
//
// MessageText:
//
//  The network address is invalid.
//


//
// MessageId: RPC_S_NO_ENDPOINT_FOUND
//
// MessageText:
//
//  No endpoint was found.
//


//
// MessageId: RPC_S_INVALID_TIMEOUT
//
// MessageText:
//
//  The timeout value is invalid.
//


//
// MessageId: RPC_S_OBJECT_NOT_FOUND
//
// MessageText:
//
//  The object universal unique identifier (UUID) was not found.
//


//
// MessageId: RPC_S_ALREADY_REGISTERED
//
// MessageText:
//
//  The object universal unique identifier (UUID) has already been registered.
//


//
// MessageId: RPC_S_TYPE_ALREADY_REGISTERED
//
// MessageText:
//
//  The type universal unique identifier (UUID) has already been registered.
//


//
// MessageId: RPC_S_ALREADY_LISTENING
//
// MessageText:
//
//  The RPC server is already listening.
//


//
// MessageId: RPC_S_NO_PROTSEQS_REGISTERED
//
// MessageText:
//
//  No protocol sequences have been registered.
//


//
// MessageId: RPC_S_NOT_LISTENING
//
// MessageText:
//
//  The RPC server is not listening.
//


//
// MessageId: RPC_S_UNKNOWN_MGR_TYPE
//
// MessageText:
//
//  The manager type is unknown.
//


//
// MessageId: RPC_S_UNKNOWN_IF
//
// MessageText:
//
//  The interface is unknown.
//


//
// MessageId: RPC_S_NO_BINDINGS
//
// MessageText:
//
//  There are no bindings.
//


//
// MessageId: RPC_S_NO_PROTSEQS
//
// MessageText:
//
//  There are no protocol sequences.
//


//
// MessageId: RPC_S_CANT_CREATE_ENDPOINT
//
// MessageText:
//
//  The endpoint cannot be created.
//


//
// MessageId: RPC_S_OUT_OF_RESOURCES
//
// MessageText:
//
//  Not enough resources are available to complete this operation.
//


//
// MessageId: RPC_S_SERVER_UNAVAILABLE
//
// MessageText:
//
//  The RPC server is unavailable.
//


//
// MessageId: RPC_S_SERVER_TOO_BUSY
//
// MessageText:
//
//  The RPC server is too busy to complete this operation.
//


//
// MessageId: RPC_S_INVALID_NETWORK_OPTIONS
//
// MessageText:
//
//  The network options are invalid.
//


//
// MessageId: RPC_S_NO_CALL_ACTIVE
//
// MessageText:
//
//  There is not a remote procedure call active in this thread.
//


//
// MessageId: RPC_S_CALL_FAILED
//
// MessageText:
//
//  The remote procedure call failed.
//


//
// MessageId: RPC_S_CALL_FAILED_DNE
//
// MessageText:
//
//  The remote procedure call failed and did not execute.
//


//
// MessageId: RPC_S_PROTOCOL_ERROR
//
// MessageText:
//
//  A remote procedure call (RPC) protocol error occurred.
//


//
// MessageId: RPC_S_UNSUPPORTED_TRANS_SYN
//
// MessageText:
//
//  The transfer syntax is not supported by the RPC server.
//


//
// MessageId: RPC_S_UNSUPPORTED_TYPE
//
// MessageText:
//
//  The universal unique identifier (UUID) type is not supported.
//


//
// MessageId: RPC_S_INVALID_TAG
//
// MessageText:
//
//  The tag is invalid.
//


//
// MessageId: RPC_S_INVALID_BOUND
//
// MessageText:
//
//  The array bounds are invalid.
//


//
// MessageId: RPC_S_NO_ENTRY_NAME
//
// MessageText:
//
//  The binding does not contain an entry name.
//


//
// MessageId: RPC_S_INVALID_NAME_SYNTAX
//
// MessageText:
//
//  The name syntax is invalid.
//


//
// MessageId: RPC_S_UNSUPPORTED_NAME_SYNTAX
//
// MessageText:
//
//  The name syntax is not supported.
//


//
// MessageId: RPC_S_UUID_NO_ADDRESS
//
// MessageText:
//
//  No network address is available to use to construct a universal
//  unique identifier (UUID).
//


//
// MessageId: RPC_S_DUPLICATE_ENDPOINT
//
// MessageText:
//
//  The endpoint is a duplicate.
//


//
// MessageId: RPC_S_UNKNOWN_AUTHN_TYPE
//
// MessageText:
//
//  The authentication type is unknown.
//


//
// MessageId: RPC_S_MAX_CALLS_TOO_SMALL
//
// MessageText:
//
//  The maximum number of calls is too small.
//


//
// MessageId: RPC_S_STRING_TOO_LONG
//
// MessageText:
//
//  The string is too long.
//


//
// MessageId: RPC_S_PROTSEQ_NOT_FOUND
//
// MessageText:
//
//  The RPC protocol sequence was not found.
//


//
// MessageId: RPC_S_PROCNUM_OUT_OF_RANGE
//
// MessageText:
//
//  The procedure number is out of range.
//


//
// MessageId: RPC_S_BINDING_HAS_NO_AUTH
//
// MessageText:
//
//  The binding does not contain any authentication information.
//


//
// MessageId: RPC_S_UNKNOWN_AUTHN_SERVICE
//
// MessageText:
//
//  The authentication service is unknown.
//


//
// MessageId: RPC_S_UNKNOWN_AUTHN_LEVEL
//
// MessageText:
//
//  The authentication level is unknown.
//


//
// MessageId: RPC_S_INVALID_AUTH_IDENTITY
//
// MessageText:
//
//  The security context is invalid.
//


//
// MessageId: RPC_S_UNKNOWN_AUTHZ_SERVICE
//
// MessageText:
//
//  The authorization service is unknown.
//


//
// MessageId: EPT_S_INVALID_ENTRY
//
// MessageText:
//
//  The entry is invalid.
//


//
// MessageId: EPT_S_CANT_PERFORM_OP
//
// MessageText:
//
//  The server endpoint cannot perform the operation.
//


//
// MessageId: EPT_S_NOT_REGISTERED
//
// MessageText:
//
//  There are no more endpoints available from the endpoint mapper.
//


//
// MessageId: RPC_S_NOTHING_TO_EXPORT
//
// MessageText:
//
//  No interfaces have been exported.
//


//
// MessageId: RPC_S_INCOMPLETE_NAME
//
// MessageText:
//
//  The entry name is incomplete.
//


//
// MessageId: RPC_S_INVALID_VERS_OPTION
//
// MessageText:
//
//  The version option is invalid.
//


//
// MessageId: RPC_S_NO_MORE_MEMBERS
//
// MessageText:
//
//  There are no more members.
//


//
// MessageId: RPC_S_NOT_ALL_OBJS_UNEXPORTED
//
// MessageText:
//
//  There is nothing to unexport.
//


//
// MessageId: RPC_S_INTERFACE_NOT_FOUND
//
// MessageText:
//
//  The interface was not found.
//


//
// MessageId: RPC_S_ENTRY_ALREADY_EXISTS
//
// MessageText:
//
//  The entry already exists.
//


//
// MessageId: RPC_S_ENTRY_NOT_FOUND
//
// MessageText:
//
//  The entry is not found.
//


//
// MessageId: RPC_S_NAME_SERVICE_UNAVAILABLE
//
// MessageText:
//
//  The name service is unavailable.
//


//
// MessageId: RPC_S_INVALID_NAF_ID
//
// MessageText:
//
//  The network address family is invalid.
//


//
// MessageId: RPC_S_CANNOT_SUPPORT
//
// MessageText:
//
//  The requested operation is not supported.
//


//
// MessageId: RPC_S_NO_CONTEXT_AVAILABLE
//
// MessageText:
//
//  No security context is available to allow impersonation.
//


//
// MessageId: RPC_S_INTERNAL_ERROR
//
// MessageText:
//
//  An internal error occurred in a remote procedure call (RPC).
//


//
// MessageId: RPC_S_ZERO_DIVIDE
//
// MessageText:
//
//  The RPC server attempted an integer division by zero.
//


//
// MessageId: RPC_S_ADDRESS_ERROR
//
// MessageText:
//
//  An addressing error occurred in the RPC server.
//


//
// MessageId: RPC_S_FP_DIV_ZERO
//
// MessageText:
//
//  A floating-point operation at the RPC server caused a division by zero.
//


//
// MessageId: RPC_S_FP_UNDERFLOW
//
// MessageText:
//
//  A floating-point underflow occurred at the RPC server.
//


//
// MessageId: RPC_S_FP_OVERFLOW
//
// MessageText:
//
//  A floating-point overflow occurred at the RPC server.
//


//
// MessageId: RPC_X_NO_MORE_ENTRIES
//
// MessageText:
//
//  The list of RPC servers available for the binding of auto handles
//  has been exhausted.
//


//
// MessageId: RPC_X_SS_CHAR_TRANS_OPEN_FAIL
//
// MessageText:
//
//  Unable to open the character translation table file.
//


//
// MessageId: RPC_X_SS_CHAR_TRANS_SHORT_FILE
//
// MessageText:
//
//  The file containing the character translation table has fewer than
//  512 bytes.
//


//
// MessageId: RPC_X_SS_IN_NULL_CONTEXT
//
// MessageText:
//
//  A null context handle was passed from the client to the host during
//  a remote procedure call.
//


//
// MessageId: RPC_X_SS_CONTEXT_DAMAGED
//
// MessageText:
//
//  The context handle changed during a remote procedure call.
//


//
// MessageId: RPC_X_SS_HANDLES_MISMATCH
//
// MessageText:
//
//  The binding handles passed to a remote procedure call do not match.
//


//
// MessageId: RPC_X_SS_CANNOT_GET_CALL_HANDLE
//
// MessageText:
//
//  The stub is unable to get the remote procedure call handle.
//


//
// MessageId: RPC_X_NULL_REF_POINTER
//
// MessageText:
//
//  A null reference pointer was passed to the stub.
//


//
// MessageId: RPC_X_ENUM_VALUE_OUT_OF_RANGE
//
// MessageText:
//
//  The enumeration value is out of range.
//


//
// MessageId: RPC_X_BYTE_COUNT_TOO_SMALL
//
// MessageText:
//
//  The byte count is too small.
//


//
// MessageId: RPC_X_BAD_STUB_DATA
//
// MessageText:
//
//  The stub received bad data.
//


//
// MessageId: ERROR_INVALID_USER_BUFFER
//
// MessageText:
//
//  The supplied user buffer is not valid for the requested operation.
//


//
// MessageId: ERROR_UNRECOGNIZED_MEDIA
//
// MessageText:
//
//  The disk media is not recognized.  It may not be formatted.
//


//
// MessageId: ERROR_NO_TRUST_LSA_SECRET
//
// MessageText:
//
//  The workstation does not have a trust secret.
//


//
// MessageId: ERROR_NO_TRUST_SAM_ACCOUNT
//
// MessageText:
//
//  The SAM database on the Windows NT Server does not have a computer
//  account for this workstation trust relationship.
//


//
// MessageId: ERROR_TRUSTED_DOMAIN_FAILURE
//
// MessageText:
//
//  The trust relationship between the primary domain and the trusted
//  domain failed.
//


//
// MessageId: ERROR_TRUSTED_RELATIONSHIP_FAILURE
//
// MessageText:
//
//  The trust relationship between this workstation and the primary
//  domain failed.
//


//
// MessageId: ERROR_TRUST_FAILURE
//
// MessageText:
//
//  The network logon failed.
//


//
// MessageId: RPC_S_CALL_IN_PROGRESS
//
// MessageText:
//
//  A remote procedure call is already in progress for this thread.
//


//
// MessageId: ERROR_NETLOGON_NOT_STARTED
//
// MessageText:
//
//  An attempt was made to logon, but the network logon service was not started.
//


//
// MessageId: ERROR_ACCOUNT_EXPIRED
//
// MessageText:
//
//  The user's account has expired.
//


//
// MessageId: ERROR_REDIRECTOR_HAS_OPEN_HANDLES
//
// MessageText:
//
//  The redirector is in use and cannot be unloaded.
//


//
// MessageId: ERROR_PRINTER_DRIVER_ALREADY_INSTALLED
//
// MessageText:
//
//  The specified printer driver is already installed.
//


//
// MessageId: ERROR_UNKNOWN_PORT
//
// MessageText:
//
//  The specified port is unknown.
//


//
// MessageId: ERROR_UNKNOWN_PRINTER_DRIVER
//
// MessageText:
//
//  The printer driver is unknown.
//


//
// MessageId: ERROR_UNKNOWN_PRINTPROCESSOR
//
// MessageText:
//
//  The print processor is unknown.
//


//
// MessageId: ERROR_INVALID_SEPARATOR_FILE
//
// MessageText:
//
//  The specified separator file is invalid.
//


//
// MessageId: ERROR_INVALID_PRIORITY
//
// MessageText:
//
//  The specified priority is invalid.
//


//
// MessageId: ERROR_INVALID_PRINTER_NAME
//
// MessageText:
//
//  The printer name is invalid.
//


//
// MessageId: ERROR_PRINTER_ALREADY_EXISTS
//
// MessageText:
//
//  The printer already exists.
//


//
// MessageId: ERROR_INVALID_PRINTER_COMMAND
//
// MessageText:
//
//  The printer command is invalid.
//


//
// MessageId: ERROR_INVALID_DATATYPE
//
// MessageText:
//
//  The specified datatype is invalid.
//


//
// MessageId: ERROR_INVALID_ENVIRONMENT
//
// MessageText:
//
//  The Environment specified is invalid.
//


//
// MessageId: RPC_S_NO_MORE_BINDINGS
//
// MessageText:
//
//  There are no more bindings.
//


//
// MessageId: ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT
//
// MessageText:
//
//  The account used is an interdomain trust account.  Use your global user account or local user account to access this server.
//


//
// MessageId: ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT
//
// MessageText:
//
//  The account used is a Computer Account.  Use your global user account or local user account to access this server.
//


//
// MessageId: ERROR_NOLOGON_SERVER_TRUST_ACCOUNT
//
// MessageText:
//
//  The account used is an server trust account.  Use your global user account or local user account to access this server.
//


//
// MessageId: ERROR_DOMAIN_TRUST_INCONSISTENT
//
// MessageText:
//
//  The name or security ID (SID) of the domain specified is inconsistent
//  with the trust information for that domain.
//


//
// MessageId: ERROR_SERVER_HAS_OPEN_HANDLES
//
// MessageText:
//
//  The server is in use and cannot be unloaded.
//


//
// MessageId: ERROR_RESOURCE_DATA_NOT_FOUND
//
// MessageText:
//
//  The specified image file did not contain a resource section.
//


//
// MessageId: ERROR_RESOURCE_TYPE_NOT_FOUND
//
// MessageText:
//
//  The specified resource type can not be found in the image file.
//


//
// MessageId: ERROR_RESOURCE_NAME_NOT_FOUND
//
// MessageText:
//
//  The specified resource name can not be found in the image file.
//


//
// MessageId: ERROR_RESOURCE_LANG_NOT_FOUND
//
// MessageText:
//
//  The specified resource language ID cannot be found in the image file.
//


//
// MessageId: ERROR_NOT_ENOUGH_QUOTA
//
// MessageText:
//
//  Not enough quota is available to process this command.
//


//
// MessageId: RPC_S_NO_INTERFACES
//
// MessageText:
//
//  No interfaces have been registered.
//


//
// MessageId: RPC_S_CALL_CANCELLED
//
// MessageText:
//
//  The server was altered while processing this call.
//


//
// MessageId: RPC_S_BINDING_INCOMPLETE
//
// MessageText:
//
//  The binding handle does not contain all required information.
//


//
// MessageId: RPC_S_COMM_FAILURE
//
// MessageText:
//
//  Communications failure.
//


//
// MessageId: RPC_S_UNSUPPORTED_AUTHN_LEVEL
//
// MessageText:
//
//  The requested authentication level is not supported.
//


//
// MessageId: RPC_S_NO_PRINC_NAME
//
// MessageText:
//
//  No principal name registered.
//


//
// MessageId: RPC_S_NOT_RPC_ERROR
//
// MessageText:
//
//  The error specified is not a valid Windows RPC error code.
//


//
// MessageId: RPC_S_UUID_LOCAL_ONLY
//
// MessageText:
//
//  A UUID that is valid only on this computer has been allocated.
//


//
// MessageId: RPC_S_SEC_PKG_ERROR
//
// MessageText:
//
//  A security package specific error occurred.
//


//
// MessageId: RPC_S_NOT_CANCELLED
//
// MessageText:
//
//  Thread is not cancelled.
//


//
// MessageId: RPC_X_INVALID_ES_ACTION
//
// MessageText:
//
//  Invalid operation on the encoding/decoding handle.
//


//
// MessageId: RPC_X_WRONG_ES_VERSION
//
// MessageText:
//
//  Incompatible version of the serializing package.
//


//
// MessageId: RPC_X_WRONG_STUB_VERSION
//
// MessageText:
//
//  Incompatible version of the RPC stub.
//


//
// MessageId: RPC_S_GROUP_MEMBER_NOT_FOUND
//
// MessageText:
//
//  The group member was not found.
//


//
// MessageId: EPT_S_CANT_CREATE
//
// MessageText:
//
//  The endpoint mapper database could not be created.
//


//
// MessageId: RPC_S_INVALID_OBJECT
//
// MessageText:
//
//  The object universal unique identifier (UUID) is the nil UUID.
//


//
// MessageId: ERROR_INVALID_TIME
//
// MessageText:
//
//  The specified time is invalid.
//


//
// MessageId: ERROR_INVALID_FORM_NAME
//
// MessageText:
//
//  The specified Form name is invalid.
//


//
// MessageId: ERROR_INVALID_FORM_SIZE
//
// MessageText:
//
//  The specified Form size is invalid
//


//
// MessageId: ERROR_ALREADY_WAITING
//
// MessageText:
//
//  The specified Printer handle is already being waited on
//


//
// MessageId: ERROR_PRINTER_DELETED
//
// MessageText:
//
//  The specified Printer has been deleted
//


//
// MessageId: ERROR_INVALID_PRINTER_STATE
//
// MessageText:
//
//  The state of the Printer is invalid
//


//
// MessageId: ERROR_PASSWORD_MUST_CHANGE
//
// MessageText:
//
//  The user must change his password before he logs on the first time.
//


//
// MessageId: ERROR_DOMAIN_CONTROLLER_NOT_FOUND
//
// MessageText:
//
//  Could not find the domain controller for this domain.
//


//
// MessageId: ERROR_ACCOUNT_LOCKED_OUT
//
// MessageText:
//
//  The referenced account is currently locked out and may not be logged on to.
//


//
// MessageId: ERROR_NO_BROWSER_SERVERS_FOUND
//
// MessageText:
//
//  The list of servers for this workgroup is not currently available
//





///////////////////////////
//                       //
//   OpenGL Error Code   //
//                       //
///////////////////////////


//
// MessageId: ERROR_INVALID_PIXEL_FORMAT
//
// MessageText:
//
//  The pixel format is invalid.
//


//
// MessageId: ERROR_BAD_DRIVER
//
// MessageText:
//
//  The specified driver is invalid.
//


//
// MessageId: ERROR_INVALID_WINDOW_STYLE
//
// MessageText:
//
//  The window style or class attribute is invalid for this operation.
//


//
// MessageId: ERROR_METAFILE_NOT_SUPPORTED
//
// MessageText:
//
//  The requested metafile operation is not supported.
//


//
// MessageId: ERROR_TRANSFORM_NOT_SUPPORTED
//
// MessageText:
//
//  The requested transformation operation is not supported.
//


//
// MessageId: ERROR_CLIPPING_NOT_SUPPORTED
//
// MessageText:
//
//  The requested clipping operation is not supported.
//


// End of OpenGL error codes



////////////////////////////////////
//                                //
//     Win32 Spooler Error Codes  //
//                                //
////////////////////////////////////
//
// MessageId: ERROR_UNKNOWN_PRINT_MONITOR
//
// MessageText:
//
//  The specified print monitor is unknown.
//


//
// MessageId: ERROR_PRINTER_DRIVER_IN_USE
//
// MessageText:
//
//  The specified printer driver is currently in use.
//


//
// MessageId: ERROR_SPOOL_FILE_NOT_FOUND
//
// MessageText:
//
//  The spool file was not found.
//


//
// MessageId: ERROR_SPL_NO_STARTDOC
//
// MessageText:
//
//  A StartDocPrinter call was not issued.
//


//
// MessageId: ERROR_SPL_NO_ADDJOB
//
// MessageText:
//
//  An AddJob call was not issued.
//


//
// MessageId: ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED
//
// MessageText:
//
//  The specified print processor has already been installed.
//


//
// MessageId: ERROR_PRINT_MONITOR_ALREADY_INSTALLED
//
// MessageText:
//
//  The specified print monitor has already been installed.
//


////////////////////////////////////
//                                //
//     Wins Error Codes           //
//                                //
////////////////////////////////////
//
// MessageId: ERROR_WINS_INTERNAL
//
// MessageText:
//
//  WINS encountered an error while processing the command.
//


//
// MessageId: ERROR_CAN_NOT_DEL_LOCAL_WINS
//
// MessageText:
//
//  The local WINS can not be deleted.
//


//
// MessageId: ERROR_STATIC_INIT
//
// MessageText:
//
//  The importation from the file failed.
//


//
// MessageId: ERROR_INC_BACKUP
//
// MessageText:
//
//  The backup Failed.  Was a full backup done before ?
//


//
// MessageId: ERROR_FULL_BACKUP
//
// MessageText:
//
//  The backup Failed.  Check the directory that you are backing the database to.
//


//
// MessageId: ERROR_REC_NON_EXISTENT
//
// MessageText:
//
//  The name does not exist in the WINS database.
//


//
// MessageId: ERROR_RPL_NOT_ALLOWED
//
// MessageText:
//
//  Replication with a non-configured partner is not allowed.
//


////////////////////////////////////
//                                //
//     OLE Error Codes            //
//                                //
////////////////////////////////////

//
// OLE error definitions and values
//
// The return value of OLE APIs and methods is an HRESULT.
// This is not a handle to anything, but is merely a 32-bit value
// with several fields encoded in the value.  The parts of an 
// HRESULT are shown below.  
//
// Many of the macros and functions below were orginally defined to 
// operate on SCODEs.  SCODEs are no longer used.  The macros are 
// still present for compatibility and easy porting of Win16 code.
// Newly written code should use the HRESULT macros and functions.
//

//
//  HRESULTs are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-+---------------------+-------------------------------+
//  |S|R|C|N|r|    Facility         |               Code            |
//  +-+-+-+-+-+---------------------+-------------------------------+
//
//  where
//
//      S - Severity - indicates success/fail
//
//          0 - Success
//          1 - Fail (COERROR)
//
//      R - reserved portion of the facility code, corresponds to NT's
//              second severity bit.
//
//      C - reserved portion of the facility code, corresponds to NT's
//              C field.
//
//      N - reserved portion of the facility code. Used to indicate a
//              mapped NT status value.
//
//      r - reserved portion of the facility code. Reserved for internal
//              use. Used to indicate HRESULT values that are not status
//              values, but are instead message ids for display strings.
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
// Severity values
//





//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//



//
// and the inverse
//




//
// Generic test for error on any status value.
//



//
// Return the code
//




//
//  Return the facility
//




//
//  Return the severity
//




//
// Create an HRESULT value from component pieces
//







//
// Map a WIN32 error value into a HRESULT
// Note: This assumes that WIN32 errors fall in the range -32k to 32k.
//
// Define bits here so macros are guaranteed to work




//
// Map an NT status value into a HRESULT
//




// ****** OBSOLETE functions

// HRESULT functions
// As noted above, these functions are obsolete and should not be used.


// Extract the SCODE from a HRESULT



// Convert an SCODE into an HRESULT.




// PropagateResult is a noop



// ****** End of OBSOLETE functions.


// ---------------------- HRESULT value definitions -----------------
//
// HRESULT definitions
//



//
// Error definitions follow
//

//
// Codes 0x4000-0x40ff are reserved for OLE
//
//
// Error codes
//
//
// MessageId: E_UNEXPECTED
//
// MessageText:
//
//  Unexpected failure
//



//
// MessageId: E_NOTIMPL
//
// MessageText:
//
//  Not implemented
//


//
// MessageId: E_OUTOFMEMORY
//
// MessageText:
//
//  Ran out of memory
//


//
// MessageId: E_INVALIDARG
//
// MessageText:
//
//  One or more arguments are invalid
//


//
// MessageId: E_NOINTERFACE
//
// MessageText:
//
//  No such interface supported
//


//
// MessageId: E_POINTER
//
// MessageText:
//
//  Invalid pointer
//


//
// MessageId: E_HANDLE
//
// MessageText:
//
//  Invalid handle
//


//
// MessageId: E_ABORT
//
// MessageText:
//
//  Operation aborted
//


//
// MessageId: E_FAIL
//
// MessageText:
//
//  Unspecified error
//


//
// MessageId: E_ACCESSDENIED
//
// MessageText:
//
//  General access denied error
//


//_WIN32#line 6531 "C:\WATCOM\H\NT\winerror.h"
//
// MessageId: CO_E_INIT_TLS
//
// MessageText:
//
//  Thread local storage failure
//


//
// MessageId: CO_E_INIT_SHARED_ALLOCATOR
//
// MessageText:
//
//  Get shared memory allocator failure
//


//
// MessageId: CO_E_INIT_MEMORY_ALLOCATOR
//
// MessageText:
//
//  Get memory allocator failure
//


//
// MessageId: CO_E_INIT_CLASS_CACHE
//
// MessageText:
//
//  Unable to initialize class cache
//


//
// MessageId: CO_E_INIT_RPC_CHANNEL
//
// MessageText:
//
//  Unable to initialize RPC services
//


//
// MessageId: CO_E_INIT_TLS_SET_CHANNEL_CONTROL
//
// MessageText:
//
//  Cannot set thread local storage channel control
//


//
// MessageId: CO_E_INIT_TLS_CHANNEL_CONTROL
//
// MessageText:
//
//  Could not allocate thread local storage channel control
//


//
// MessageId: CO_E_INIT_UNACCEPTED_USER_ALLOCATOR
//
// MessageText:
//
//  The user supplied memory allocator is unacceptable
//


//
// MessageId: CO_E_INIT_SCM_MUTEX_EXISTS
//
// MessageText:
//
//  The OLE service mutex already exists
//


//
// MessageId: CO_E_INIT_SCM_FILE_MAPPING_EXISTS
//
// MessageText:
//
//  The OLE service file mapping already exists
//


//
// MessageId: CO_E_INIT_SCM_MAP_VIEW_OF_FILE
//
// MessageText:
//
//  Unable to map view of file for OLE service
//


//
// MessageId: CO_E_INIT_SCM_EXEC_FAILURE
//
// MessageText:
//
//  Failure attempting to launch OLE service
//


//
// MessageId: CO_E_INIT_ONLY_SINGLE_THREADED
//
// MessageText:
//
//  There was an attempt to call CoInitialize a second time while single threaded
//



//
// Success codes
//



// ******************
// FACILITY_ITF
// ******************

//
// Codes 0x0-0x01ff are reserved for the OLE group of
// interfaces.
//


//
// Generic OLE errors that may be returned by many inerfaces
//






//
// Old OLE errors
//
//
// MessageId: OLE_E_OLEVERB
//
// MessageText:
//
//  Invalid OLEVERB structure
//


//
// MessageId: OLE_E_ADVF
//
// MessageText:
//
//  Invalid advise flags
//


//
// MessageId: OLE_E_ENUM_NOMORE
//
// MessageText:
//
//  Can't enumerate any more, because the associated data is missing
//


//
// MessageId: OLE_E_ADVISENOTSUPPORTED
//
// MessageText:
//
//  This implementation doesn't take advises
//


//
// MessageId: OLE_E_NOCONNECTION
//
// MessageText:
//
//  There is no connection for this connection ID
//


//
// MessageId: OLE_E_NOTRUNNING
//
// MessageText:
//
//  Need to run the object to perform this operation
//


//
// MessageId: OLE_E_NOCACHE
//
// MessageText:
//
//  There is no cache to operate on
//


//
// MessageId: OLE_E_BLANK
//
// MessageText:
//
//  Uninitialized object
//


//
// MessageId: OLE_E_CLASSDIFF
//
// MessageText:
//
//  Linked object's source class has changed
//


//
// MessageId: OLE_E_CANT_GETMONIKER
//
// MessageText:
//
//  Not able to get the moniker of the object
//


//
// MessageId: OLE_E_CANT_BINDTOSOURCE
//
// MessageText:
//
//  Not able to bind to the source
//


//
// MessageId: OLE_E_STATIC
//
// MessageText:
//
//  Object is static; operation not allowed
//


//
// MessageId: OLE_E_PROMPTSAVECANCELLED
//
// MessageText:
//
//  User cancelled out of save dialog
//


//
// MessageId: OLE_E_INVALIDRECT
//
// MessageText:
//
//  Invalid rectangle
//


//
// MessageId: OLE_E_WRONGCOMPOBJ
//
// MessageText:
//
//  compobj.dll is too old for the ole2.dll initialized
//


//
// MessageId: OLE_E_INVALIDHWND
//
// MessageText:
//
//  Invalid window handle
//


//
// MessageId: OLE_E_NOT_INPLACEACTIVE
//
// MessageText:
//
//  Object is not in any of the inplace active states
//


//
// MessageId: OLE_E_CANTCONVERT
//
// MessageText:
//
//  Not able to convert object
//


//
// MessageId: OLE_E_NOSTORAGE
//
// MessageText:
//
//  Not able to perform the operation because object is not given storage yet
//  
//


//
// MessageId: DV_E_FORMATETC
//
// MessageText:
//
//  Invalid FORMATETC structure
//


//
// MessageId: DV_E_DVTARGETDEVICE
//
// MessageText:
//
//  Invalid DVTARGETDEVICE structure
//


//
// MessageId: DV_E_STGMEDIUM
//
// MessageText:
//
//  Invalid STDGMEDIUM structure
//


//
// MessageId: DV_E_STATDATA
//
// MessageText:
//
//  Invalid STATDATA structure
//


//
// MessageId: DV_E_LINDEX
//
// MessageText:
//
//  Invalid lindex
//


//
// MessageId: DV_E_TYMED
//
// MessageText:
//
//  Invalid tymed
//


//
// MessageId: DV_E_CLIPFORMAT
//
// MessageText:
//
//  Invalid clipboard format
//


//
// MessageId: DV_E_DVASPECT
//
// MessageText:
//
//  Invalid aspect(s)
//


//
// MessageId: DV_E_DVTARGETDEVICE_SIZE
//
// MessageText:
//
//  tdSize parameter of the DVTARGETDEVICE structure is invalid
//


//
// MessageId: DV_E_NOIVIEWOBJECT
//
// MessageText:
//
//  Object doesn't support IViewObject interface
//






//
// MessageId: DRAGDROP_E_NOTREGISTERED
//
// MessageText:
//
//  Trying to revoke a drop target that has not been registered
//


//
// MessageId: DRAGDROP_E_ALREADYREGISTERED
//
// MessageText:
//
//  This window has already been registered as a drop target
//


//
// MessageId: DRAGDROP_E_INVALIDHWND
//
// MessageText:
//
//  Invalid window handle
//






//
// MessageId: CLASS_E_NOAGGREGATION
//
// MessageText:
//
//  Class does not support aggregation (or class object is remote)
//


//
// MessageId: CLASS_E_CLASSNOTAVAILABLE
//
// MessageText:
//
//  ClassFactory cannot supply requested class
//














//
// MessageId: VIEW_E_DRAW
//
// MessageText:
//
//  Error drawing view
//






//
// MessageId: REGDB_E_READREGDB
//
// MessageText:
//
//  Could not read key from registry
//


//
// MessageId: REGDB_E_WRITEREGDB
//
// MessageText:
//
//  Could not write key to registry
//


//
// MessageId: REGDB_E_KEYMISSING
//
// MessageText:
//
//  Could not find the key in the registry
//


//
// MessageId: REGDB_E_INVALIDVALUE
//
// MessageText:
//
//  Invalid value for registry
//


//
// MessageId: REGDB_E_CLASSNOTREG
//
// MessageText:
//
//  Class not registered
//


//
// MessageId: REGDB_E_IIDNOTREG
//
// MessageText:
//
//  Interface not registered
//






//
// MessageId: CACHE_E_NOCACHE_UPDATED
//
// MessageText:
//
//  Cache not updated
//






//
// MessageId: OLEOBJ_E_NOVERBS
//
// MessageText:
//
//  No verbs for OLE object
//


//
// MessageId: OLEOBJ_E_INVALIDVERB
//
// MessageText:
//
//  Invalid verb for OLE object
//






//
// MessageId: INPLACE_E_NOTUNDOABLE
//
// MessageText:
//
//  Undo is not available
//


//
// MessageId: INPLACE_E_NOTOOLSPACE
//
// MessageText:
//
//  Space for tools is not available
//














//
// MessageId: CONVERT10_E_OLESTREAM_GET
//
// MessageText:
//
//  OLESTREAM Get method failed
//


//
// MessageId: CONVERT10_E_OLESTREAM_PUT
//
// MessageText:
//
//  OLESTREAM Put method failed
//


//
// MessageId: CONVERT10_E_OLESTREAM_FMT
//
// MessageText:
//
//  Contents of the OLESTREAM not in correct format
//


//
// MessageId: CONVERT10_E_OLESTREAM_BITMAP_TO_DIB
//
// MessageText:
//
//  There was an error in a Windows GDI call while converting the bitmap to a DIB
//


//
// MessageId: CONVERT10_E_STG_FMT
//
// MessageText:
//
//  Contents of the IStorage not in correct format
//


//
// MessageId: CONVERT10_E_STG_NO_STD_STREAM
//
// MessageText:
//
//  Contents of IStorage is missing one of the standard streams
//


//
// MessageId: CONVERT10_E_STG_DIB_TO_BITMAP
//
// MessageText:
//
//  There was an error in a Windows GDI call while converting the DIB to a bitmap.
//  
//






//
// MessageId: CLIPBRD_E_CANT_OPEN
//
// MessageText:
//
//  OpenClipboard Failed
//


//
// MessageId: CLIPBRD_E_CANT_EMPTY
//
// MessageText:
//
//  EmptyClipboard Failed
//


//
// MessageId: CLIPBRD_E_CANT_SET
//
// MessageText:
//
//  SetClipboard Failed
//


//
// MessageId: CLIPBRD_E_BAD_DATA
//
// MessageText:
//
//  Data on clipboard is invalid
//


//
// MessageId: CLIPBRD_E_CANT_CLOSE
//
// MessageText:
//
//  CloseClipboard Failed
//






//
// MessageId: MK_E_CONNECTMANUALLY
//
// MessageText:
//
//  Moniker needs to be connected manually
//


//
// MessageId: MK_E_EXCEEDEDDEADLINE
//
// MessageText:
//
//  Operation exceeded deadline
//


//
// MessageId: MK_E_NEEDGENERIC
//
// MessageText:
//
//  Moniker needs to be generic
//


//
// MessageId: MK_E_UNAVAILABLE
//
// MessageText:
//
//  Operation unavailable
//


//
// MessageId: MK_E_SYNTAX
//
// MessageText:
//
//  Invalid syntax
//


//
// MessageId: MK_E_NOOBJECT
//
// MessageText:
//
//  No object for moniker
//


//
// MessageId: MK_E_INVALIDEXTENSION
//
// MessageText:
//
//  Bad extension for file
//


//
// MessageId: MK_E_INTERMEDIATEINTERFACENOTSUPPORTED
//
// MessageText:
//
//  Intermediate operation failed
//


//
// MessageId: MK_E_NOTBINDABLE
//
// MessageText:
//
//  Moniker is not bindable
//


//
// MessageId: MK_E_NOTBOUND
//
// MessageText:
//
//  Moniker is not bound
//


//
// MessageId: MK_E_CANTOPENFILE
//
// MessageText:
//
//  Moniker cannot open file
//


//
// MessageId: MK_E_MUSTBOTHERUSER
//
// MessageText:
//
//  User input required for operation to succeed
//


//
// MessageId: MK_E_NOINVERSE
//
// MessageText:
//
//  Moniker class has no inverse
//


//
// MessageId: MK_E_NOSTORAGE
//
// MessageText:
//
//  Moniker does not refer to storage
//


//
// MessageId: MK_E_NOPREFIX
//
// MessageText:
//
//  No common prefix
//


//
// MessageId: MK_E_ENUMERATION_FAILED
//
// MessageText:
//
//  Moniker could not be enumerated
//






//
// MessageId: CO_E_NOTINITIALIZED
//
// MessageText:
//
//  CoInitialize has not been called.
//


//
// MessageId: CO_E_ALREADYINITIALIZED
//
// MessageText:
//
//  CoInitialize has already been called.
//


//
// MessageId: CO_E_CANTDETERMINECLASS
//
// MessageText:
//
//  Class of object cannot be determined
//


//
// MessageId: CO_E_CLASSSTRING
//
// MessageText:
//
//  Invalid class string
//


//
// MessageId: CO_E_IIDSTRING
//
// MessageText:
//
//  Invalid interface string
//


//
// MessageId: CO_E_APPNOTFOUND
//
// MessageText:
//
//  Application not found
//


//
// MessageId: CO_E_APPSINGLEUSE
//
// MessageText:
//
//  Application cannot be run more than once
//


//
// MessageId: CO_E_ERRORINAPP
//
// MessageText:
//
//  Some error in application program
//


//
// MessageId: CO_E_DLLNOTFOUND
//
// MessageText:
//
//  DLL for class not found
//


//
// MessageId: CO_E_ERRORINDLL
//
// MessageText:
//
//  Error in the DLL
//


//
// MessageId: CO_E_WRONGOSFORAPP
//
// MessageText:
//
//  Wrong OS or OS version for application
//


//
// MessageId: CO_E_OBJNOTREG
//
// MessageText:
//
//  Object is not registered
//


//
// MessageId: CO_E_OBJISREG
//
// MessageText:
//
//  Object is already registered
//


//
// MessageId: CO_E_OBJNOTCONNECTED
//
// MessageText:
//
//  Object is not connected to server
//


//
// MessageId: CO_E_APPDIDNTREG
//
// MessageText:
//
//  Application was launched but it didn't register a class factory
//


//
// MessageId: CO_E_RELEASED
//
// MessageText:
//
//  Object has been released
//


//
// Old OLE Success Codes
//
//
// MessageId: OLE_S_USEREG
//
// MessageText:
//
//  Use the registry database to provide the requested information
//


//
// MessageId: OLE_S_STATIC
//
// MessageText:
//
//  Success, but static
//


//
// MessageId: OLE_S_MAC_CLIPFORMAT
//
// MessageText:
//
//  Macintosh clipboard format
//


//
// MessageId: DRAGDROP_S_DROP
//
// MessageText:
//
//  Successful drop took place
//


//
// MessageId: DRAGDROP_S_CANCEL
//
// MessageText:
//
//  Drag-drop operation canceled
//


//
// MessageId: DRAGDROP_S_USEDEFAULTCURSORS
//
// MessageText:
//
//  Use the default cursor
//


//
// MessageId: DATA_S_SAMEFORMATETC
//
// MessageText:
//
//  Data has same FORMATETC
//


//
// MessageId: VIEW_S_ALREADY_FROZEN
//
// MessageText:
//
//  View is already frozen
//


//
// MessageId: CACHE_S_FORMATETC_NOTSUPPORTED
//
// MessageText:
//
//  FORMATETC not supported
//


//
// MessageId: CACHE_S_SAMECACHE
//
// MessageText:
//
//  Same cache
//


//
// MessageId: CACHE_S_SOMECACHES_NOTUPDATED
//
// MessageText:
//
//  Some cache(s) not updated
//


//
// MessageId: OLEOBJ_S_INVALIDVERB
//
// MessageText:
//
//  Invalid verb for OLE object
//


//
// MessageId: OLEOBJ_S_CANNOT_DOVERB_NOW
//
// MessageText:
//
//  Verb number is valid but verb cannot be done now
//


//
// MessageId: OLEOBJ_S_INVALIDHWND
//
// MessageText:
//
//  Invalid window handle passed
//


//
// MessageId: INPLACE_S_TRUNCATED
//
// MessageText:
//
//  Message is too long; some of it had to be truncated before displaying
//


//
// MessageId: CONVERT10_S_NO_PRESENTATION
//
// MessageText:
//
//  Unable to convert OLESTREAM to IStorage
//


//
// MessageId: MK_S_REDUCED_TO_SELF
//
// MessageText:
//
//  Moniker reduced to itself
//


//
// MessageId: MK_S_ME
//
// MessageText:
//
//  Common prefix is this moniker
//


//
// MessageId: MK_S_HIM
//
// MessageText:
//
//  Common prefix is input moniker
//


//
// MessageId: MK_S_US
//
// MessageText:
//
//  Common prefix is both monikers
//


//
// MessageId: MK_S_MONIKERALREADYREGISTERED
//
// MessageText:
//
//  Moniker is already registered in running object table
//


// ******************
// FACILITY_WINDOWS
// ******************
//
// Codes 0x0-0x01ff are reserved for the OLE group of
// interfaces.
//
//
// MessageId: CO_E_CLASS_CREATE_FAILED
//
// MessageText:
//
//  Attempt to create a class object failed
//


//
// MessageId: CO_E_SCM_ERROR
//
// MessageText:
//
//  OLE service could not bind object
//


//
// MessageId: CO_E_SCM_RPC_FAILURE
//
// MessageText:
//
//  RPC communication failed with OLE service
//


//
// MessageId: CO_E_BAD_PATH
//
// MessageText:
//
//  Bad path to object
//


//
// MessageId: CO_E_SERVER_EXEC_FAILURE
//
// MessageText:
//
//  Server execution failed
//


//
// MessageId: CO_E_OBJSRV_RPC_FAILURE
//
// MessageText:
//
//  OLE service could not communicate with the object server
//


//
// MessageId: MK_E_NO_NORMALIZED
//
// MessageText:
//
//  Moniker path could not be normalized
//


//
// MessageId: CO_E_SERVER_STOPPING
//
// MessageText:
//
//  Object server is stopping when OLE service contacts it
//


//
// MessageId: MEM_E_INVALID_ROOT
//
// MessageText:
//
//  An invalid root block pointer was specified
//


//
// MessageId: MEM_E_INVALID_LINK
//
// MessageText:
//
//  An allocation chain contained an invalid link pointer
//


//
// MessageId: MEM_E_INVALID_SIZE
//
// MessageText:
//
//  The requested allocation size was too large
//


// ******************
// FACILITY_DISPATCH
// ******************
//
// MessageId: DISP_E_UNKNOWNINTERFACE
//
// MessageText:
//
//  Unknown interface.
//


//
// MessageId: DISP_E_MEMBERNOTFOUND
//
// MessageText:
//
//  Member not found.
//


//
// MessageId: DISP_E_PARAMNOTFOUND
//
// MessageText:
//
//  Parameter not found.
//


//
// MessageId: DISP_E_TYPEMISMATCH
//
// MessageText:
//
//  Type mismatch.
//


//
// MessageId: DISP_E_UNKNOWNNAME
//
// MessageText:
//
//  Unknown name.
//


//
// MessageId: DISP_E_NONAMEDARGS
//
// MessageText:
//
//  No named arguments.
//


//
// MessageId: DISP_E_BADVARTYPE
//
// MessageText:
//
//  Bad variable type.
//


//
// MessageId: DISP_E_EXCEPTION
//
// MessageText:
//
//  Exception occurred.
//


//
// MessageId: DISP_E_OVERFLOW
//
// MessageText:
//
//  Out of present range.
//


//
// MessageId: DISP_E_BADINDEX
//
// MessageText:
//
//  Invalid index.
//


//
// MessageId: DISP_E_UNKNOWNLCID
//
// MessageText:
//
//  Unknown language.
//


//
// MessageId: DISP_E_ARRAYISLOCKED
//
// MessageText:
//
//  Memory is locked.
//


//
// MessageId: DISP_E_BADPARAMCOUNT
//
// MessageText:
//
//  Invalid number of parameters.
//


//
// MessageId: DISP_E_PARAMNOTOPTIONAL
//
// MessageText:
//
//  Parameter not optional.
//


//
// MessageId: DISP_E_BADCALLEE
//
// MessageText:
//
//  Invalid callee.
//


//
// MessageId: DISP_E_NOTACOLLECTION
//
// MessageText:
//
//  Does not support a collection.
//


//
// MessageId: TYPE_E_BUFFERTOOSMALL
//
// MessageText:
//
//  Buffer too small.
//


//
// MessageId: TYPE_E_INVDATAREAD
//
// MessageText:
//
//  Old format or invalid type library.
//


//
// MessageId: TYPE_E_UNSUPFORMAT
//
// MessageText:
//
//  Old format or invalid type library.
//


//
// MessageId: TYPE_E_REGISTRYACCESS
//
// MessageText:
//
//  Error accessing the OLE registry.
//


//
// MessageId: TYPE_E_LIBNOTREGISTERED
//
// MessageText:
//
//  Library not registered.
//


//
// MessageId: TYPE_E_UNDEFINEDTYPE
//
// MessageText:
//
//  Bound to unknown type.
//


//
// MessageId: TYPE_E_QUALIFIEDNAMEDISALLOWED
//
// MessageText:
//
//  Qualified name disallowed.
//


//
// MessageId: TYPE_E_INVALIDSTATE
//
// MessageText:
//
//  Invalid forward reference, or reference to uncompiled type.
//


//
// MessageId: TYPE_E_WRONGTYPEKIND
//
// MessageText:
//
//  Type mismatch.
//


//
// MessageId: TYPE_E_ELEMENTNOTFOUND
//
// MessageText:
//
//  Element not found.
//


//
// MessageId: TYPE_E_AMBIGUOUSNAME
//
// MessageText:
//
//  Ambiguous name.
//


//
// MessageId: TYPE_E_NAMECONFLICT
//
// MessageText:
//
//  Name already exists in the library.
//


//
// MessageId: TYPE_E_UNKNOWNLCID
//
// MessageText:
//
//  Unknown LCID.
//


//
// MessageId: TYPE_E_DLLFUNCTIONNOTFOUND
//
// MessageText:
//
//  Function not defined in specified DLL.
//


//
// MessageId: TYPE_E_BADMODULEKIND
//
// MessageText:
//
//  Wrong module kind for the operation.
//


//
// MessageId: TYPE_E_SIZETOOBIG
//
// MessageText:
//
//  Size may not exceed 64K.
//


//
// MessageId: TYPE_E_DUPLICATEID
//
// MessageText:
//
//  Duplicate ID in inheritance hierarchy.
//


//
// MessageId: TYPE_E_INVALIDID
//
// MessageText:
//
//  Incorrect inheritance depth in standard OLE hmember.
//


//
// MessageId: TYPE_E_TYPEMISMATCH
//
// MessageText:
//
//  Type mismatch.
//


//
// MessageId: TYPE_E_OUTOFBOUNDS
//
// MessageText:
//
//  Invalid number of arguments.
//


//
// MessageId: TYPE_E_IOERROR
//
// MessageText:
//
//  I/O Error.
//


//
// MessageId: TYPE_E_CANTCREATETMPFILE
//
// MessageText:
//
//  Error creating unique tmp file.
//


//
// MessageId: TYPE_E_CANTLOADLIBRARY
//
// MessageText:
//
//  Error loading type library/DLL.
//


//
// MessageId: TYPE_E_INCONSISTENTPROPFUNCS
//
// MessageText:
//
//  Inconsistent property functions.
//


//
// MessageId: TYPE_E_CIRCULARTYPE
//
// MessageText:
//
//  Circular dependency between types/modules.
//


// ******************
// FACILITY_STORAGE
// ******************
//
// MessageId: STG_E_INVALIDFUNCTION
//
// MessageText:
//
//  Unable to perform requested operation.
//


//
// MessageId: STG_E_FILENOTFOUND
//
// MessageText:
//
//  %1 could not be found.
//


//
// MessageId: STG_E_PATHNOTFOUND
//
// MessageText:
//
//  The path %1 could not be found.
//


//
// MessageId: STG_E_TOOMANYOPENFILES
//
// MessageText:
//
//  There are insufficient resources to open another file.
//


//
// MessageId: STG_E_ACCESSDENIED
//
// MessageText:
//
//  Access Denied.
//


//
// MessageId: STG_E_INVALIDHANDLE
//
// MessageText:
//
//  Attempted an operation on an invalid object.
//


//
// MessageId: STG_E_INSUFFICIENTMEMORY
//
// MessageText:
//
//  There is insufficient memory available to complete operation.
//


//
// MessageId: STG_E_INVALIDPOINTER
//
// MessageText:
//
//  Invalid pointer error.
//


//
// MessageId: STG_E_NOMOREFILES
//
// MessageText:
//
//  There are no more entries to return.
//


//
// MessageId: STG_E_DISKISWRITEPROTECTED
//
// MessageText:
//
//  Disk is write-protected.
//


//
// MessageId: STG_E_SEEKERROR
//
// MessageText:
//
//  An error occurred during a seek operation.
//


//
// MessageId: STG_E_WRITEFAULT
//
// MessageText:
//
//  A disk error occurred during a write operation.
//


//
// MessageId: STG_E_READFAULT
//
// MessageText:
//
//  A disk error occurred during a read operation.
//


//
// MessageId: STG_E_SHAREVIOLATION
//
// MessageText:
//
//  A share violation has occurred.
//


//
// MessageId: STG_E_LOCKVIOLATION
//
// MessageText:
//
//  A lock violation has occurred.
//


//
// MessageId: STG_E_FILEALREADYEXISTS
//
// MessageText:
//
//  %1 already exists.
//


//
// MessageId: STG_E_INVALIDPARAMETER
//
// MessageText:
//
//  Invalid parameter error.
//


//
// MessageId: STG_E_MEDIUMFULL
//
// MessageText:
//
//  There is insufficient disk space to complete operation.
//


//
// MessageId: STG_E_ABNORMALAPIEXIT
//
// MessageText:
//
//  An API call exited abnormally.
//


//
// MessageId: STG_E_INVALIDHEADER
//
// MessageText:
//
//  The file %1 is not a valid compound file.
//


//
// MessageId: STG_E_INVALIDNAME
//
// MessageText:
//
//  The name %1 is not valid.
//


//
// MessageId: STG_E_UNKNOWN
//
// MessageText:
//
//  An unexpected error occurred.
//


//
// MessageId: STG_E_UNIMPLEMENTEDFUNCTION
//
// MessageText:
//
//  That function is not implemented.
//


//
// MessageId: STG_E_INVALIDFLAG
//
// MessageText:
//
//  Invalid flag error.
//


//
// MessageId: STG_E_INUSE
//
// MessageText:
//
//  Attempted to use an object that is busy.
//


//
// MessageId: STG_E_NOTCURRENT
//
// MessageText:
//
//  The storage has been changed since the last commit.
//


//
// MessageId: STG_E_REVERTED
//
// MessageText:
//
//  Attempted to use an object that has ceased to exist.
//


//
// MessageId: STG_E_CANTSAVE
//
// MessageText:
//
//  Can't save.
//


//
// MessageId: STG_E_OLDFORMAT
//
// MessageText:
//
//  The compound file %1 was produced with an incompatible version of storage.
//


//
// MessageId: STG_E_OLDDLL
//
// MessageText:
//
//  The compound file %1 was produced with a newer version of storage.
//


//
// MessageId: STG_E_SHAREREQUIRED
//
// MessageText:
//
//  Share.exe or equivalent is required for operation.
//


//
// MessageId: STG_E_NOTFILEBASEDSTORAGE
//
// MessageText:
//
//  Illegal operation called on non-file based storage.
//


//
// MessageId: STG_E_EXTANTMARSHALLINGS
//
// MessageText:
//
//  Illegal operation called on object with extant marshallings.
//


//
// MessageId: STG_S_CONVERTED
//
// MessageText:
//
//  The underlying file was converted to compound file format.
//


// ******************
// FACILITY_RPC
// ******************
//
// Codes 0x0-0x11 are propogated from 16 bit OLE.
//
//
// MessageId: RPC_E_CALL_REJECTED
//
// MessageText:
//
//  Call was rejected by callee.
//


//
// MessageId: RPC_E_CALL_CANCELED
//
// MessageText:
//
//  Call was canceled by the message filter.
//


//
// MessageId: RPC_E_CANTPOST_INSENDCALL
//
// MessageText:
//
//  The caller is dispatching an intertask SendMessage call and
//  cannot call out via PostMessage.
//


//
// MessageId: RPC_E_CANTCALLOUT_INASYNCCALL
//
// MessageText:
//
//  The caller is dispatching an asynchronous call and cannot
//  make an outgoing call on behalf of this call.
//


//
// MessageId: RPC_E_CANTCALLOUT_INEXTERNALCALL
//
// MessageText:
//
//  It is illegal to call out while inside message filter.
//


//
// MessageId: RPC_E_CONNECTION_TERMINATED
//
// MessageText:
//
//  The connection terminated or is in a bogus state
//  and cannot be used any more. Other connections
//  are still valid.
//


//
// MessageId: RPC_E_SERVER_DIED
//
// MessageText:
//
//  The callee (server [not server application]) is not available
//  and disappeared; all connections are invalid.  The call may
//  have executed.
//


//
// MessageId: RPC_E_CLIENT_DIED
//
// MessageText:
//
//  The caller (client) disappeared while the callee (server) was
//  processing a call.
//


//
// MessageId: RPC_E_INVALID_DATAPACKET
//
// MessageText:
//
//  The data packet with the marshalled parameter data is incorrect.
//


//
// MessageId: RPC_E_CANTTRANSMIT_CALL
//
// MessageText:
//
//  The call was not transmitted properly; the message queue
//  was full and was not emptied after yielding.
//


//
// MessageId: RPC_E_CLIENT_CANTMARSHAL_DATA
//
// MessageText:
//
//  The client (caller) cannot marshall the parameter data - low memory, etc.
//


//
// MessageId: RPC_E_CLIENT_CANTUNMARSHAL_DATA
//
// MessageText:
//
//  The client (caller) cannot unmarshall the return data - low memory, etc.
//


//
// MessageId: RPC_E_SERVER_CANTMARSHAL_DATA
//
// MessageText:
//
//  The server (callee) cannot marshall the return data - low memory, etc.
//


//
// MessageId: RPC_E_SERVER_CANTUNMARSHAL_DATA
//
// MessageText:
//
//  The server (callee) cannot unmarshall the parameter data - low memory, etc.
//


//
// MessageId: RPC_E_INVALID_DATA
//
// MessageText:
//
//  Received data is invalid; could be server or client data.
//


//
// MessageId: RPC_E_INVALID_PARAMETER
//
// MessageText:
//
//  A particular parameter is invalid and cannot be (un)marshalled.
//


//
// MessageId: RPC_E_CANTCALLOUT_AGAIN
//
// MessageText:
//
//  There is no second outgoing call on same channel in DDE conversation.
//


//
// MessageId: RPC_E_SERVER_DIED_DNE
//
// MessageText:
//
//  The callee (server [not server application]) is not available
//  and disappeared; all connections are invalid.  The call did not execute.
//


//
// MessageId: RPC_E_SYS_CALL_FAILED
//
// MessageText:
//
//  System call failed.
//


//
// MessageId: RPC_E_OUT_OF_RESOURCES
//
// MessageText:
//
//  Could not allocate some required resource (memory, events, ...)
//


//
// MessageId: RPC_E_ATTEMPTED_MULTITHREAD
//
// MessageText:
//
//  Attempted to make calls on more than one thread in single threaded mode.
//


//
// MessageId: RPC_E_NOT_REGISTERED
//
// MessageText:
//
//  The requested interface is not registered on the server object.
//


//
// MessageId: RPC_E_FAULT
//
// MessageText:
//
//  RPC could not call the server or could not return the results of calling the server.
//


//
// MessageId: RPC_E_SERVERFAULT
//
// MessageText:
//
//  The server threw an exception.
//


//
// MessageId: RPC_E_CHANGED_MODE
//
// MessageText:
//
//  Cannot change thread mode after it is set.
//


//
// MessageId: RPC_E_INVALIDMETHOD
//
// MessageText:
//
//  The method called does not exist on the server.
//


//
// MessageId: RPC_E_DISCONNECTED
//
// MessageText:
//
//  The object invoked has disconnected from its clients.
//


//
// MessageId: RPC_E_RETRY
//
// MessageText:
//
//  The object invoked chose not to process the call now.  Try again later.
//


//
// MessageId: RPC_E_SERVERCALL_RETRYLATER
//
// MessageText:
//
//  The message filter indicated that the application is busy.
//


//
// MessageId: RPC_E_SERVERCALL_REJECTED
//
// MessageText:
//
//  The message filter rejected the call.
//


//
// MessageId: RPC_E_INVALID_CALLDATA
//
// MessageText:
//
//  A call control interfaces was called with invalid data.
//


//
// MessageId: RPC_E_CANTCALLOUT_ININPUTSYNCCALL
//
// MessageText:
//
//  An outgoing call cannot be made since the application is dispatching an input-synchronous call.
//


//
// MessageId: RPC_E_WRONG_THREAD
//
// MessageText:
//
//  The application called an interface that was marshalled for a different thread.
//


//
// MessageId: RPC_E_THREAD_NOT_INIT
//
// MessageText:
//
//  CoInitialize has not been called on the current thread.
//


//
// MessageId: RPC_E_UNEXPECTED
//
// MessageText:
//
//  An internal error occurred.
//


// _WINERROR_
#line 6919 "C:\WATCOM\H\NT\winbase.h"


/* Abnormal termination codes */






 
//
// Power Management APIs
//

















typedef struct _SYSTEM_POWER_STATUS {
    BYTE ACLineStatus;
    BYTE BatteryFlag;
    BYTE BatteryLifePercent;
    BYTE Reserved1;
    DWORD BatteryLifeTime;
    DWORD BatteryFullLifeTime;
}   SYSTEM_POWER_STATUS, *LPSYSTEM_POWER_STATUS;

BOOL
 __stdcall 
GetSystemPowerStatus(
    LPSYSTEM_POWER_STATUS lpSystemPowerStatus
    );

BOOL
 __stdcall 
SetSystemPowerState(
    BOOL fSuspend,
    BOOL fForce
    );
/* WINVER >= 0x0400 */



}




// _WINBASE_
#line 158 "C:\WATCOM\H\NT\windows.h"

#line 1 "C:\WATCOM\H\NT\wingdi.h"
/**************************************************************************
*                                                                         *
* wingdi.h -- GDI procedure declarations, constant definitions and macros *
*                                                                         *
* Copyright (c) 1985-1995, Microsoft Corp. All rights reserved.           *
*                                                                         *
**************************************************************************/





//
// Define API decoration for direct importing of DLL references.
//



#line 22 "C:\WATCOM\H\NT\wingdi.h"

//
// Define API decoration for direct importing of DLL references.
//



#line 32 "C:\WATCOM\H\NT\wingdi.h"


extern "C" {







/* Binary raster ops */
/*  0       */
/* DPon     */
/* DPna     */
/* PN       */
/* PDna     */
/* Dn       */
/* DPx      */
/* DPan     */
/* DPa      */
/* DPxn     */
/* D        */
/* DPno     */
/* P        */
/* PDno     */
/* DPo      */
/*  1       */


/* Ternary raster operations */
/* dest = source                   */
/* dest = source OR dest           */
/* dest = source AND dest          */
/* dest = source XOR dest          */
/* dest = source AND (NOT dest )   */
/* dest = (NOT source)             */
/* dest = (NOT src) AND (NOT dest) */
/* dest = (source AND pattern)     */
/* dest = (NOT source) OR dest     */
/* dest = pattern                  */
/* dest = DPSnoo                   */
/* dest = pattern XOR dest         */
/* dest = (NOT dest)               */
/* dest = BLACK                    */
/* dest = WHITE                    */

/* Quaternary raster codes */


/* NORASTEROPS */




/* Region Flags */






/* CombineRgn() Styles */








/* StretchBlt() Modes */






 
/* New StretchBlt() Modes */




/* WINVER >= 0x0400 */

/* PolyFill() Modes */




/* Text Alignment Options */










 


#line 139 "C:\WATCOM\H\NT\wingdi.h"










 


/* WINVER >= 0x0400 */



/* Bounds Accumulation APIs */










/* Metafile Functions */





































































/* NOMETAFILE */

/* GDI Escapes */















































































/* Flag returned from QUERYDIBSUPPORT */





/* Spooler Error Codes */









/* Object Definitions for EnumObjects() */














/* xform stuff */








typedef struct  tagXFORM
  {
    FLOAT   eM11;
    FLOAT   eM12;
    FLOAT   eM21;
    FLOAT   eM22;
    FLOAT   eDx;
    FLOAT   eDy;
  } XFORM, *PXFORM,    *LPXFORM;

/* Bitmap Header Definition */
typedef struct tagBITMAP
  {
    LONG        bmType;
    LONG        bmWidth;
    LONG        bmHeight;
    LONG        bmWidthBytes;
    WORD        bmPlanes;
    WORD        bmBitsPixel;
    LPVOID      bmBits;
  } BITMAP, *PBITMAP,    *NPBITMAP,    *LPBITMAP;

#line 1 "C:\WATCOM\H\NT\pshpack1.h"
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pshpack1.h

Abstract:

    This file turns 1 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push)

#pragma pack(1)
#line 32 "C:\WATCOM\H\NT\pshpack1.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 381 "C:\WATCOM\H\NT\wingdi.h"

typedef struct tagRGBTRIPLE {
        BYTE    rgbtBlue;
        BYTE    rgbtGreen;
        BYTE    rgbtRed;
} RGBTRIPLE;
#line 1 "C:\WATCOM\H\NT\poppack.h"
/*++

Copyright (c) 1990,95  Microsoft Corporation

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)
#line 33 "C:\WATCOM\H\NT\poppack.h"
#line 36 "C:\WATCOM\H\NT\poppack.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 387 "C:\WATCOM\H\NT\wingdi.h"


typedef struct tagRGBQUAD {
        BYTE    rgbBlue;
        BYTE    rgbGreen;
        BYTE    rgbRed;
        BYTE    rgbReserved;
} RGBQUAD;
typedef RGBQUAD   * LPRGBQUAD;

 

/* Image Color Matching color definitions */

typedef LONG	LCSCSTYPE;




typedef	LONG	LCSGAMUTMATCH;




/* ICM Defines for results from CheckColorInGamut() */



/* Macros to retrieve CMYK values from a COLORREF */







typedef long            FXPT16DOT16,    *LPFXPT16DOT16;
typedef long            FXPT2DOT30,    *LPFXPT2DOT30;

/* ICM Color Definitions */
// The following two structures are used for defining RGB's in terms of
// CIEXYZ. The values are fixed point 16.16.

typedef struct tagCIEXYZ
{
	FXPT2DOT30 ciexyzX;
	FXPT2DOT30 ciexyzY;
	FXPT2DOT30 ciexyzZ;
} CIEXYZ;
typedef CIEXYZ     *LPCIEXYZ;

typedef struct tagICEXYZTRIPLE
{
	CIEXYZ  ciexyzRed;
	CIEXYZ  ciexyzGreen;
	CIEXYZ  ciexyzBlue;
} CIEXYZTRIPLE;
typedef CIEXYZTRIPLE       *LPCIEXYZTRIPLE;

// The next structures the logical color space. Unlike pens and brushes,
// but like palettes, there is only one way to create a LogColorSpace.
// A pointer to it must be passed, its elements can't be pushed as
// arguments.

typedef struct tagLOGCOLORSPACEA {
    DWORD lcsSignature;
    DWORD lcsVersion;
    DWORD lcsSize;
    LCSCSTYPE lcsCSType;
    LCSGAMUTMATCH lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    DWORD lcsGammaRed;
    DWORD lcsGammaGreen;
    DWORD lcsGammaBlue;
    CHAR   lcsFilename[ 260 ];
} LOGCOLORSPACEA, *LPLOGCOLORSPACEA;
typedef struct tagLOGCOLORSPACEW {
    DWORD lcsSignature;
    DWORD lcsVersion;
    DWORD lcsSize;
    LCSCSTYPE lcsCSType;
    LCSGAMUTMATCH lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    DWORD lcsGammaRed;
    DWORD lcsGammaGreen;
    DWORD lcsGammaBlue;
    WCHAR  lcsFilename[ 260 ];
} LOGCOLORSPACEW, *LPLOGCOLORSPACEW;
#line 479 "C:\WATCOM\H\NT\wingdi.h"
typedef LOGCOLORSPACEA LOGCOLORSPACE;
typedef LPLOGCOLORSPACEA LPLOGCOLORSPACE;
// UNICODE

/* WINVER >= 0x0400 */


/* structures for defining DIBs */
typedef struct tagBITMAPCOREHEADER {
        DWORD   bcSize;                 /* used to get to color table */ 
        WORD    bcWidth;
        WORD    bcHeight;
        WORD    bcPlanes;
        WORD    bcBitCount;
} BITMAPCOREHEADER,    *LPBITMAPCOREHEADER, *PBITMAPCOREHEADER;


typedef struct tagBITMAPINFOHEADER{
        DWORD      biSize;
        LONG       biWidth;
        LONG       biHeight;
        WORD       biPlanes;
        WORD       biBitCount;
        DWORD      biCompression;
        DWORD      biSizeImage;
        LONG       biXPelsPerMeter;
        LONG       biYPelsPerMeter;
        DWORD      biClrUsed;
        DWORD      biClrImportant;
} BITMAPINFOHEADER,    *LPBITMAPINFOHEADER, *PBITMAPINFOHEADER;


 
typedef struct {
        DWORD        bV4Size;
        LONG         bV4Width;
        LONG         bV4Height;
        WORD         bV4Planes;
        WORD         bV4BitCount;
        DWORD        bV4V4Compression;
        DWORD        bV4SizeImage;
        LONG         bV4XPelsPerMeter;
        LONG         bV4YPelsPerMeter;
        DWORD        bV4ClrUsed;
        DWORD        bV4ClrImportant;
        DWORD        bV4RedMask;
        DWORD        bV4GreenMask;
        DWORD        bV4BlueMask;
        DWORD        bV4AlphaMask;
        DWORD        bV4CSType;
        CIEXYZTRIPLE bV4Endpoints;
        DWORD        bV4GammaRed;
        DWORD        bV4GammaGreen;
        DWORD        bV4GammaBlue;
} BITMAPV4HEADER,    *LPBITMAPV4HEADER, *PBITMAPV4HEADER;
/* WINVER >= 0x0400 */

/* constants for the biCompression field */





typedef struct tagBITMAPINFO {
    BITMAPINFOHEADER    bmiHeader;
    RGBQUAD             bmiColors[1];
} BITMAPINFO,    *LPBITMAPINFO, *PBITMAPINFO;

typedef struct tagBITMAPCOREINFO {
    BITMAPCOREHEADER    bmciHeader;
    RGBTRIPLE           bmciColors[1];
} BITMAPCOREINFO,    *LPBITMAPCOREINFO, *PBITMAPCOREINFO;

#line 1 "C:\WATCOM\H\NT\pshpack2.h"
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pshpack2.h

Abstract:

    This file turns 2 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push)

#pragma pack(2)
#line 32 "C:\WATCOM\H\NT\pshpack2.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 552 "C:\WATCOM\H\NT\wingdi.h"

typedef struct tagBITMAPFILEHEADER {
        WORD    bfType;
        DWORD   bfSize;
        WORD    bfReserved1;
        WORD    bfReserved2;
        DWORD   bfOffBits;
} BITMAPFILEHEADER,    *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;
#line 1 "C:\WATCOM\H\NT\poppack.h"
/*++

Copyright (c) 1990,95  Microsoft Corporation

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)
#line 33 "C:\WATCOM\H\NT\poppack.h"
#line 36 "C:\WATCOM\H\NT\poppack.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 560 "C:\WATCOM\H\NT\wingdi.h"




 

typedef struct tagFONTSIGNATURE
{
    DWORD fsUsb[4];
    DWORD fsCsb[2];
} FONTSIGNATURE, *PFONTSIGNATURE,   *LPFONTSIGNATURE;

typedef struct tagCHARSETINFO
{
    UINT ciCharset;
    UINT ciACP;
    FONTSIGNATURE fs;
} CHARSETINFO, *PCHARSETINFO,    *NPCHARSETINFO,    *LPCHARSETINFO;





typedef struct tagLOCALESIGNATURE
{
    DWORD lsUsb[4];
    DWORD lsCsbDefault[2];
    DWORD lsCsbSupported[2];
} LOCALESIGNATURE, *PLOCALESIGNATURE,   *LPLOCALESIGNATURE;


/* WINVER >= 0x0400 */


/* Clipboard Metafile Picture Structure */
typedef struct tagHANDLETABLE
  {
    HGDIOBJ     objectHandle[1];
  } HANDLETABLE, *PHANDLETABLE,    *LPHANDLETABLE;

typedef struct tagMETARECORD
  {
    DWORD       rdSize;
    WORD        rdFunction;
    WORD        rdParm[1];
  } METARECORD;
typedef struct tagMETARECORD    *PMETARECORD;
typedef struct tagMETARECORD       *LPMETARECORD;

typedef struct tagMETAFILEPICT
  {
    LONG        mm;
    LONG        xExt;
    LONG        yExt;
    HMETAFILE   hMF;
  } METAFILEPICT,    *LPMETAFILEPICT;

#line 1 "C:\WATCOM\H\NT\pshpack2.h"
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pshpack2.h

Abstract:

    This file turns 2 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push)

#pragma pack(2)
#line 32 "C:\WATCOM\H\NT\pshpack2.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 617 "C:\WATCOM\H\NT\wingdi.h"

typedef struct tagMETAHEADER
{
    WORD        mtType;
    WORD        mtHeaderSize;
    WORD        mtVersion;
    DWORD       mtSize;
    WORD        mtNoObjects;
    DWORD       mtMaxRecord;
    WORD        mtNoParameters;
} METAHEADER;
typedef struct tagMETAHEADER    *PMETAHEADER;
typedef struct tagMETAHEADER       *LPMETAHEADER;

#line 1 "C:\WATCOM\H\NT\poppack.h"
/*++

Copyright (c) 1990,95  Microsoft Corporation

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)
#line 33 "C:\WATCOM\H\NT\poppack.h"
#line 36 "C:\WATCOM\H\NT\poppack.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 631 "C:\WATCOM\H\NT\wingdi.h"


/* Enhanced Metafile structures */
typedef struct tagENHMETARECORD
{
    DWORD   iType;              // Record type EMR_XXX 
    DWORD   nSize;              // Record size in bytes 
    DWORD   dParm[1];           // Parameters 
} ENHMETARECORD, *PENHMETARECORD, *LPENHMETARECORD;

typedef struct tagENHMETAHEADER
{
    DWORD   iType;              // Record type EMR_HEADER 
    DWORD   nSize;              // Record size in bytes.  This may be greater 
                                // than the sizeof(ENHMETAHEADER).
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units 
    RECTL   rclFrame;           // Inclusive-inclusive Picture Frame of metafile in .01 mm units 
    DWORD   dSignature;         // Signature.  Must be ENHMETA_SIGNATURE. 
    DWORD   nVersion;           // Version number 
    DWORD   nBytes;             // Size of the metafile in bytes 
    DWORD   nRecords;           // Number of records in the metafile 
    WORD    nHandles;           // Number of handles in the handle table 
                                // Handle index zero is reserved.
    WORD    sReserved;          // Reserved.  Must be zero. 
    DWORD   nDescription;       // Number of chars in the unicode description string 
                                // This is 0 if there is no description string
    DWORD   offDescription;     // Offset to the metafile description record. 
                                // This is 0 if there is no description string
    DWORD   nPalEntries;        // Number of entries in the metafile palette. 
    SIZEL   szlDevice;          // Size of the reference device in pels 
    SIZEL   szlMillimeters;     // Size of the reference device in millimeters 
} ENHMETAHEADER, *PENHMETAHEADER, *LPENHMETAHEADER;

/* NOMETAFILE */



/* tmPitchAndFamily flags */





//
// BCHAR definition for APPs
//
#line 680 "C:\WATCOM\H\NT\wingdi.h"
    typedef BYTE BCHAR;



typedef struct tagTEXTMETRICA
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    BYTE        tmFirstChar;
    BYTE        tmLastChar;
    BYTE        tmDefaultChar;
    BYTE        tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
} TEXTMETRICA, *PTEXTMETRICA,    *NPTEXTMETRICA,    *LPTEXTMETRICA;
typedef struct tagTEXTMETRICW
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    WCHAR       tmFirstChar;
    WCHAR       tmLastChar;
    WCHAR       tmDefaultChar;
    WCHAR       tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
} TEXTMETRICW, *PTEXTMETRICW,    *NPTEXTMETRICW,    *LPTEXTMETRICW;
#line 736 "C:\WATCOM\H\NT\wingdi.h"
typedef TEXTMETRICA TEXTMETRIC;
typedef PTEXTMETRICA PTEXTMETRIC;
typedef NPTEXTMETRICA NPTEXTMETRIC;
typedef LPTEXTMETRICA LPTEXTMETRIC;
// UNICODE

/* ntmFlags field flags */




#line 1 "C:\WATCOM\H\NT\pshpack4.h"
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pshpack4.h

Abstract:

    This file turns 4 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push)

#pragma pack(4)
#line 32 "C:\WATCOM\H\NT\pshpack4.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 747 "C:\WATCOM\H\NT\wingdi.h"

typedef struct tagNEWTEXTMETRICA
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    BYTE        tmFirstChar;
    BYTE        tmLastChar;
    BYTE        tmDefaultChar;
    BYTE        tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRICA, *PNEWTEXTMETRICA,    *NPNEWTEXTMETRICA,    *LPNEWTEXTMETRICA;
typedef struct tagNEWTEXTMETRICW
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    WCHAR       tmFirstChar;
    WCHAR       tmLastChar;
    WCHAR       tmDefaultChar;
    WCHAR       tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRICW, *PNEWTEXTMETRICW,    *NPNEWTEXTMETRICW,    *LPNEWTEXTMETRICW;
#line 808 "C:\WATCOM\H\NT\wingdi.h"
typedef NEWTEXTMETRICA NEWTEXTMETRIC;
typedef PNEWTEXTMETRICA PNEWTEXTMETRIC;
typedef NPNEWTEXTMETRICA NPNEWTEXTMETRIC;
typedef LPNEWTEXTMETRICA LPNEWTEXTMETRIC;
// UNICODE
#line 1 "C:\WATCOM\H\NT\poppack.h"
/*++

Copyright (c) 1990,95  Microsoft Corporation

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)
#line 33 "C:\WATCOM\H\NT\poppack.h"
#line 36 "C:\WATCOM\H\NT\poppack.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 813 "C:\WATCOM\H\NT\wingdi.h"


 
typedef struct tagNEWTEXTMETRICEXA
{
    NEWTEXTMETRICA  ntmTm;
    FONTSIGNATURE   ntmFontSig;
}NEWTEXTMETRICEXA;
typedef struct tagNEWTEXTMETRICEXW
{
    NEWTEXTMETRICW  ntmTm;
    FONTSIGNATURE   ntmFontSig;
}NEWTEXTMETRICEXW;
#line 829 "C:\WATCOM\H\NT\wingdi.h"
typedef NEWTEXTMETRICEXA NEWTEXTMETRICEX;
// UNICODE
/* WINVER >= 0x0400 */

/* NOTEXTMETRIC */
/* GDI Logical Objects: */

/* Pel Array */
typedef struct tagPELARRAY
  {
    LONG        paXCount;
    LONG        paYCount;
    LONG        paXExt;
    LONG        paYExt;
    BYTE        paRGBs;
  } PELARRAY, *PPELARRAY,    *NPPELARRAY,    *LPPELARRAY;

/* Logical Brush (or Pattern) */
typedef struct tagLOGBRUSH
  {
    UINT        lbStyle;
    COLORREF    lbColor;
    LONG        lbHatch;
  } LOGBRUSH, *PLOGBRUSH,    *NPLOGBRUSH,    *LPLOGBRUSH;

typedef LOGBRUSH            PATTERN;
typedef PATTERN             *PPATTERN;
typedef PATTERN           *NPPATTERN;
typedef PATTERN            *LPPATTERN;

/* Logical Pen */
typedef struct tagLOGPEN
  {
    UINT        lopnStyle;
    POINT       lopnWidth;
    COLORREF    lopnColor;
  } LOGPEN, *PLOGPEN,    *NPLOGPEN,    *LPLOGPEN;

typedef struct tagEXTLOGPEN {
    DWORD       elpPenStyle;
    DWORD       elpWidth;
    UINT        elpBrushStyle;
    COLORREF    elpColor;
    LONG        elpHatch;
    DWORD       elpNumEntries;
    DWORD       elpStyleEntry[1];
} EXTLOGPEN, *PEXTLOGPEN,    *NPEXTLOGPEN,    *LPEXTLOGPEN;

typedef struct tagPALETTEENTRY {
    BYTE        peRed;
    BYTE        peGreen;
    BYTE        peBlue;
    BYTE        peFlags;
} PALETTEENTRY, *PPALETTEENTRY,    *LPPALETTEENTRY;

/* Logical Palette */
typedef struct tagLOGPALETTE {
    WORD        palVersion;
    WORD        palNumEntries;
    PALETTEENTRY        palPalEntry[1];
} LOGPALETTE, *PLOGPALETTE,    *NPLOGPALETTE,    *LPLOGPALETTE;


/* Logical Font */


typedef struct tagLOGFONTA
{
    LONG      lfHeight;
    LONG      lfWidth;
    LONG      lfEscapement;
    LONG      lfOrientation;
    LONG      lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    CHAR      lfFaceName[ 32 ];
} LOGFONTA, *PLOGFONTA,    *NPLOGFONTA,    *LPLOGFONTA;
typedef struct tagLOGFONTW
{
    LONG      lfHeight;
    LONG      lfWidth;
    LONG      lfEscapement;
    LONG      lfOrientation;
    LONG      lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    WCHAR     lfFaceName[ 32 ];
} LOGFONTW, *PLOGFONTW,    *NPLOGFONTW,    *LPLOGFONTW;
#line 935 "C:\WATCOM\H\NT\wingdi.h"
typedef LOGFONTA LOGFONT;
typedef PLOGFONTA PLOGFONT;
typedef NPLOGFONTA NPLOGFONT;
typedef LPLOGFONTA LPLOGFONT;
// UNICODE



/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONTA
{
    LOGFONTA elfLogFont;
    BYTE     elfFullName[ 64 ];
    BYTE     elfStyle[ 32 ];
} ENUMLOGFONTA,   * LPENUMLOGFONTA;
/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONTW
{
    LOGFONTW elfLogFont;
    WCHAR    elfFullName[ 64 ];
    WCHAR    elfStyle[ 32 ];
} ENUMLOGFONTW,   * LPENUMLOGFONTW;
#line 961 "C:\WATCOM\H\NT\wingdi.h"
typedef ENUMLOGFONTA ENUMLOGFONT;
typedef LPENUMLOGFONTA LPENUMLOGFONT;
// UNICODE

 
typedef struct tagENUMLOGFONTEXA
{
    LOGFONTA    elfLogFont;
    BYTE        elfFullName[ 64 ];
    BYTE        elfStyle[ 32 ];
    BYTE        elfScript[ 32 ];
} ENUMLOGFONTEXA,    *LPENUMLOGFONTEXA;
typedef struct tagENUMLOGFONTEXW
{
    LOGFONTW    elfLogFont;
    BYTE        elfFullName[ 64 ];
    BYTE        elfStyle[ 32 ];
    BYTE        elfScript[ 32 ];
} ENUMLOGFONTEXW,    *LPENUMLOGFONTEXW;
#line 984 "C:\WATCOM\H\NT\wingdi.h"
typedef ENUMLOGFONTEXA ENUMLOGFONTEX;
typedef LPENUMLOGFONTEXA LPENUMLOGFONTEX;
// UNICODE
/* WINVER >= 0x0400 */






















 


/* WINVER >= 0x0400 */




 

/* WINVER >= 0x0400 */









 



























/* WINVER >= 0x0400 */

/* Font Families */
/* Don't care or don't know. */
/* Variable stroke width, serifed. */
                                    /* Times Roman, Century Schoolbook, etc. */
/* Variable stroke width, sans-serifed. */
                                    /* Helvetica, Swiss, etc. */
/* Constant stroke width, serifed or sans-serifed. */
                                    /* Pica, Elite, Courier, etc. */
/* Cursive, etc. */
/* Old English, etc. */

/* Font Weights */































typedef struct tagPANOSE
{
    BYTE    bFamilyType;
    BYTE    bSerifStyle;
    BYTE    bWeight;
    BYTE    bProportion;
    BYTE    bContrast;
    BYTE    bStrokeVariation;
    BYTE    bArmStyle;
    BYTE    bLetterform;
    BYTE    bMidline;
    BYTE    bXHeight;
} PANOSE, * LPPANOSE;

/* Any                            */
/* No Fit                         */

/* Text and Display               */
/* Script                         */
/* Decorative                     */
/* Pictorial                      */

/* Cove                           */
/* Obtuse Cove                    */
/* Square Cove                    */
/* Obtuse Square Cove             */
/* Square                         */
/* Thin                           */
/* Bone                           */
/* Exaggerated                    */
/* Triangle                       */
/* Normal Sans                    */
/* Obtuse Sans                    */
/* Prep Sans                      */
/* Flared                         */
/* Rounded                        */

/* Very Light                     */
/* Light                          */
/* Thin                           */
/* Book                           */
/* Medium                         */
/* Demi                           */
/* Bold                           */
/* Heavy                          */
/* Black                          */
/* Nord                           */

/* Old Style                      */
/* Modern                         */
/* Even Width                     */
/* Expanded                       */
/* Condensed                      */
/* Very Expanded                  */
/* Very Condensed                 */
/* Monospaced                     */

/* None                           */
/* Very Low                       */
/* Low                            */
/* Medium Low                     */
/* Medium                         */
/* Mediim High                    */
/* High                           */
/* Very High                      */

/* Gradual/Diagonal               */
/* Gradual/Transitional           */
/* Gradual/Vertical               */
/* Gradual/Horizontal             */
/* Rapid/Vertical                 */
/* Rapid/Horizontal               */
/* Instant/Vertical               */

/* Straight Arms/Horizontal       */
/* Straight Arms/Wedge            */
/* Straight Arms/Vertical         */
/* Straight Arms/Single-Serif     */
/* Straight Arms/Double-Serif     */
/* Non-Straight Arms/Horizontal   */
/* Non-Straight Arms/Wedge        */
/* Non-Straight Arms/Vertical     */
/* Non-Straight Arms/Single-Serif */
/* Non-Straight Arms/Double-Serif */

/* Normal/Contact                 */
/* Normal/Weighted                */
/* Normal/Boxed                   */
/* Normal/Flattened               */
/* Normal/Rounded                 */
/* Normal/Off Center              */
/* Normal/Square                  */
/* Oblique/Contact                */
/* Oblique/Weighted               */
/* Oblique/Boxed                  */
/* Oblique/Flattened              */
/* Oblique/Rounded                */
/* Oblique/Off Center             */
/* Oblique/Square                 */

/* Standard/Trimmed               */
/* Standard/Pointed               */
/* Standard/Serifed               */
/* High/Trimmed                   */
/* High/Pointed                   */
/* High/Serifed                   */
/* Constant/Trimmed               */
/* Constant/Pointed               */
/* Constant/Serifed               */
/* Low/Trimmed                    */
/* Low/Pointed                    */
/* Low/Serifed                    */

/* Constant/Small                 */
/* Constant/Standard              */
/* Constant/Large                 */
/* Ducking/Small                  */
/* Ducking/Standard               */
/* Ducking/Large                  */




/* The extended logical font       */
/* An extension of the ENUMLOGFONT */

typedef struct tagEXTLOGFONTA {
    LOGFONTA    elfLogFont;
    BYTE        elfFullName[ 64 ];
    BYTE        elfStyle[ 32 ];
    DWORD       elfVersion;     /* 0 for the first release of NT */ 
    DWORD       elfStyleSize;
    DWORD       elfMatch;
    DWORD       elfReserved;
    BYTE        elfVendorId[ 4 ];
    DWORD       elfCulture;     /* 0 for Latin                   */ 
    PANOSE      elfPanose;
} EXTLOGFONTA, *PEXTLOGFONTA,    *NPEXTLOGFONTA,    *LPEXTLOGFONTA;
typedef struct tagEXTLOGFONTW {
    LOGFONTW    elfLogFont;
    WCHAR       elfFullName[ 64 ];
    WCHAR       elfStyle[ 32 ];
    DWORD       elfVersion;     /* 0 for the first release of NT */ 
    DWORD       elfStyleSize;
    DWORD       elfMatch;
    DWORD       elfReserved;
    BYTE        elfVendorId[ 4 ];
    DWORD       elfCulture;     /* 0 for Latin                   */ 
    PANOSE      elfPanose;
} EXTLOGFONTW, *PEXTLOGFONTW,    *NPEXTLOGFONTW,    *LPEXTLOGFONTW;
#line 1259 "C:\WATCOM\H\NT\wingdi.h"
typedef EXTLOGFONTA EXTLOGFONT;
typedef PEXTLOGFONTA PEXTLOGFONT;
typedef NPEXTLOGFONTA NPEXTLOGFONT;
typedef LPEXTLOGFONTA LPEXTLOGFONT;
// UNICODE





/* EnumFonts Masks */








/* palette entry flags */

/* palette index used for animation */
/* palette index is explicit to device */
/* do not match color to system palette */





/* Background Modes */




/* Graphics Modes */





/* PolyDraw and GetPath point types */





/* Mapping Modes */









/* Min and Max Mapping Mode values */




/* Coordinate Modes */



/* Stock Logical Objects */

















 

/* WINVER >= 0x0400 */

 

#line 1351 "C:\WATCOM\H\NT\wingdi.h"



/* Brush Styles */











/* Hatch Styles */
/* ----- */
/* ||||| */
/* \\\\\ */
/* ///// */
/* +++++ */
/* xxxxx */

/* Pen Styles */

/* -------  */
/* .......  */
/* _._._._  */
/* _.._.._  */























/* Device Parameters for GetDeviceCaps() */
/* Device driver version                    */
/* Device classification                    */
/* Horizontal size in millimeters           */
/* Vertical size in millimeters             */
/* Horizontal width in pixels               */
/* Vertical height in pixels                */
/* Number of bits per pixel                 */
/* Number of planes                         */
/* Number of brushes the device has         */
/* Number of pens the device has            */
/* Number of markers the device has         */
/* Number of fonts the device has           */
/* Number of colors the device supports     */
/* Size required for device descriptor      */
/* Curve capabilities                       */
/* Line capabilities                        */
/* Polygonal capabilities                   */
/* Text capabilities                        */
/* Clipping capabilities                    */
/* Bitblt capabilities                      */
/* Length of the X leg                      */
/* Length of the Y leg                      */
/* Length of the hypotenuse                 */

/* Logical pixels/inch in X                 */
/* Logical pixels/inch in Y                 */

/* Number of entries in physical palette    */
/* Number of reserved entries in palette    */
/* Actual color resolution                  */


// Printing related DeviceCaps. These replace the appropriate Escapes

/* Physical Width in device units           */
/* Physical Height in device units          */
/* Physical Printable Area x margin         */
/* Physical Printable Area y margin         */
/* Scaling factor x                         */
/* Scaling factor y                         */

// Display driver specific

/* Current vertical refresh rate of the    */
                             /* display device (for displays only) in Hz*/
/* Horizontal width of entire desktop in   */
                             /* pixels                                  */
/* Vertical height of entire desktop in    */
                             /* pixels                                  */
/* Preferred blt alignment                 */



/* Device Capability Masks: */

/* Device Technologies */
/* Vector plotter                   */
/* Raster display                   */
/* Raster printer                   */
/* Raster camera                    */
/* Character-stream, PLP            */
/* Metafile, VDM                    */
/* Display-file                     */

/* Curve Capabilities */
/* Curves not supported             */
/* Can do circles                   */
/* Can do pie wedges                */
/* Can do chord arcs                */
/* Can do ellipese                  */
/* Can do wide lines                */
/* Can do styled lines              */
/* Can do wide styled lines         */
/* Can do interiors                 */
/*                                  */

/* Line Capabilities */
/* Lines not supported              */
/* Can do polylines                 */
/* Can do markers                   */
/* Can do polymarkers               */
/* Can do wide lines                */
/* Can do styled lines              */
/* Can do wide styled lines         */
/* Can do interiors                 */

/* Polygonal Capabilities */
/* Polygonals not supported         */
/* Can do polygons                  */
/* Can do rectangles                */
/* Can do winding polygons          */
/* Can do trapezoids                */
/* Can do scanlines                 */
/* Can do wide borders              */
/* Can do styled borders            */
/* Can do wide styled borders       */
/* Can do interiors                 */
/* Can do polypolygons              */
/* Can do paths                     */

/* Clipping Capabilities */
/* No clipping of output            */
/* Output clipped to rects          */
/* obsolete                         */

/* Text Capabilities */
/* Can do OutputPrecision   CHARACTER      */
/* Can do OutputPrecision   STROKE         */
/* Can do ClipPrecision     STROKE         */
/* Can do CharRotAbility    90             */
/* Can do CharRotAbility    ANY            */
/* Can do ScaleFreedom      X_YINDEPENDENT */
/* Can do ScaleAbility      DOUBLE         */
/* Can do ScaleAbility      INTEGER        */
/* Can do ScaleAbility      CONTINUOUS     */
/* Can do EmboldenAbility   DOUBLE         */
/* Can do ItalisizeAbility  ABLE           */
/* Can do UnderlineAbility  ABLE           */
/* Can do StrikeOutAbility  ABLE           */
/* Can do RasterFontAble    ABLE           */
/* Can do VectorFontAble    ABLE           */

/* Don't do text scroll with blt           */

/* NOGDICAPMASKS */

/* Raster Capabilities */

/* Can do standard BLT.             */
/* Device requires banding support  */
/* Device requires scaling support  */
/* Device can support >64K bitmap   */
/* has 2.0 output calls         */


/* supports DIB to memory       */
/* supports a palette           */
/* supports DIBitsToDevice      */
/* supports >64K fonts          */
/* supports StretchBlt          */
/* supports FloodFill           */
/* supports StretchDIBits       */




/* DIB color table identifiers */

/* color table in RGBs */
/* color table in palette indices */

/* constants for Get/SetSystemPaletteUse() */





/* constants for CreateDIBitmap */
/* initialize bitmap */

/* ExtFloodFill style flags */



/* size of a device name string */


/* size of a form name string */


typedef struct _devicemodeA {
    BYTE   dmDeviceName[ 32 ];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    short dmOrientation;
    short dmPaperSize;
    short dmPaperLength;
    short dmPaperWidth;
    short dmScale;
    short dmCopies;
    short dmDefaultSource;
    short dmPrintQuality;
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    BYTE   dmFormName[ 32 ];
    WORD   dmLogPixels;
    DWORD  dmBitsPerPel;
    DWORD  dmPelsWidth;
    DWORD  dmPelsHeight;
    DWORD  dmDisplayFlags;
    DWORD  dmDisplayFrequency;
 
    DWORD  dmICMMethod;
    DWORD  dmICMIntent;
    DWORD  dmMediaType;
    DWORD  dmDitherType;
    DWORD  dmReserved1;
    DWORD  dmReserved2;
/* WINVER */
} DEVMODEA, *PDEVMODEA, *NPDEVMODEA, *LPDEVMODEA;
typedef struct _devicemodeW {
    WCHAR  dmDeviceName[ 32 ];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    short dmOrientation;
    short dmPaperSize;
    short dmPaperLength;
    short dmPaperWidth;
    short dmScale;
    short dmCopies;
    short dmDefaultSource;
    short dmPrintQuality;
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    WCHAR  dmFormName[ 32 ];
    WORD   dmLogPixels;
    DWORD  dmBitsPerPel;
    DWORD  dmPelsWidth;
    DWORD  dmPelsHeight;
    DWORD  dmDisplayFlags;
    DWORD  dmDisplayFrequency;
 
    DWORD  dmICMMethod;
    DWORD  dmICMIntent;
    DWORD  dmMediaType;
    DWORD  dmDitherType;
    DWORD  dmReserved1;
    DWORD  dmReserved2;
/* WINVER */
} DEVMODEW, *PDEVMODEW, *NPDEVMODEW, *LPDEVMODEW;
#line 1652 "C:\WATCOM\H\NT\wingdi.h"
typedef DEVMODEA DEVMODE;
typedef PDEVMODEA PDEVMODE;
typedef NPDEVMODEA NPDEVMODE;
typedef LPDEVMODEA LPDEVMODE;
// UNICODE

/* current version of specification */
 

/* WINVER */#line 1664 "C:\WATCOM\H\NT\wingdi.h"

/* field selection bits */




















 




/* WINVER >= 0x0400 */

/* orientation selections */



/* paper selections */

/* Letter 8 1/2 x 11 in               */
/* Letter Small 8 1/2 x 11 in         */
/* Tabloid 11 x 17 in                 */
/* Ledger 17 x 11 in                  */
/* Legal 8 1/2 x 14 in                */
/* Statement 5 1/2 x 8 1/2 in         */
/* Executive 7 1/4 x 10 1/2 in        */
/* A3 297 x 420 mm                    */
/* A4 210 x 297 mm                    */
/* A4 Small 210 x 297 mm              */
/* A5 148 x 210 mm                    */
/* B4 (JIS) 250 x 354                 */
/* B5 (JIS) 182 x 257 mm              */
/* Folio 8 1/2 x 13 in                */
/* Quarto 215 x 275 mm                */
/* 10x14 in                           */
/* 11x17 in                           */
/* Note 8 1/2 x 11 in                 */
/* Envelope #9 3 7/8 x 8 7/8          */
/* Envelope #10 4 1/8 x 9 1/2         */
/* Envelope #11 4 1/2 x 10 3/8        */
/* Envelope #12 4 \276 x 11           */
/* Envelope #14 5 x 11 1/2            */
/* C size sheet                       */
/* D size sheet                       */
/* E size sheet                       */
/* Envelope DL 110 x 220mm            */
/* Envelope C5 162 x 229 mm           */
/* Envelope C3  324 x 458 mm          */
/* Envelope C4  229 x 324 mm          */
/* Envelope C6  114 x 162 mm          */
/* Envelope C65 114 x 229 mm          */
/* Envelope B4  250 x 353 mm          */
/* Envelope B5  176 x 250 mm          */
/* Envelope B6  176 x 125 mm          */
/* Envelope 110 x 230 mm              */
/* Envelope Monarch 3.875 x 7.5 in    */
/* 6 3/4 Envelope 3 5/8 x 6 1/2 in    */
/* US Std Fanfold 14 7/8 x 11 in      */
/* German Std Fanfold 8 1/2 x 12 in   */
/* German Legal Fanfold 8 1/2 x 13 in */
 
/* B4 (ISO) 250 x 353 mm              */
/* Japanese Postcard 100 x 148 mm     */
/* 9 x 11 in                          */
/* 10 x 11 in                         */
/* 15 x 11 in                         */
/* Envelope Invite 220 x 220 mm       */
/* RESERVED--DO NOT USE               */
/* RESERVED--DO NOT USE               */
/* Letter Extra 9 \275 x 12 in        */
/* Legal Extra 9 \275 x 15 in         */
/* Tabloid Extra 11.69 x 18 in        */
/* A4 Extra 9.27 x 12.69 in           */
/* Letter Transverse 8 \275 x 11 in   */
/* A4 Transverse 210 x 297 mm         */
/* Letter Extra Transverse 9\275 x 12 in */
/* SuperA/SuperA/A4 227 x 356 mm      */
/* SuperB/SuperB/A3 305 x 487 mm      */
/* Letter Plus 8.5 x 12.69 in         */
/* A4 Plus 210 x 330 mm               */
/* A5 Transverse 148 x 210 mm         */
/* B5 (JIS) Transverse 182 x 257 mm   */
/* A3 Extra 322 x 445 mm              */
/* A5 Extra 174 x 235 mm              */
/* B5 (ISO) Extra 201 x 276 mm        */
/* A2 420 x 594 mm                    */
/* A3 Transverse 297 x 420 mm         */
/* A3 Extra Transverse 322 x 445 mm   */
/* WINVER >= 0x0400 */

 

#line 1775 "C:\WATCOM\H\NT\wingdi.h"



/* bin selections */

















/* device specific bins start here */

/* print qualities */





/* color enable/disable for color printers */



/* duplex enable */




/* TrueType options */
/* print TT fonts as graphics */
/* download TT fonts as soft fonts */
/* substitute device fonts for TT fonts */
 
/* download TT fonts as outline soft fonts */
/* WINVER >= 0x0400 */

/* Collation selections */



/* DEVMODE dmDisplayFlags flags */




 
/* ICM methods */
/* ICM disabled */
/* ICM handled by system */
/* ICM handled by driver */
/* ICM handled by device */

/* Device-specific methods start here */

/* ICM Intents */
/* Maximize color saturation */
/* Maximize color contrast */
/* Use specific color metric */

/* Device-specific intents start here */

/* Media types */

/* Standard paper */
/* Transparency */
/* Glossy paper */

/* Device-specific media start here */

/* Dither types */
/* No dithering */
/* Dither with a coarse brush */
/* Dither with a fine brush */
/* LineArt dithering */

/* LineArt dithering */
/* LineArt dithering */
/* LineArt dithering */
/* LineArt dithering */
/* LineArt dithering */

/* Device does grayscaling */

/* Device-specific dithers start here */
/* WINVER >= 0x0400 */

/* GetRegionData/ExtCreateRegion */



typedef struct _RGNDATAHEADER {
    DWORD   dwSize;
    DWORD   iType;
    DWORD   nCount;
    DWORD   nRgnSize;
    RECT    rcBound;
} RGNDATAHEADER, *PRGNDATAHEADER;

typedef struct _RGNDATA {
    RGNDATAHEADER   rdh;
    char            Buffer[1];
} RGNDATA, *PRGNDATA,    *NPRGNDATA,    *LPRGNDATA;


typedef struct _ABC {
    int     abcA;
    UINT    abcB;
    int     abcC;
} ABC, *PABC,    *NPABC,    *LPABC;

typedef struct _ABCFLOAT {
    FLOAT   abcfA;
    FLOAT   abcfB;
    FLOAT   abcfC;
} ABCFLOAT, *PABCFLOAT,    *NPABCFLOAT,    *LPABCFLOAT;



typedef struct _OUTLINETEXTMETRICA {
    UINT    otmSize;
    TEXTMETRICA otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
     int    otmsCharSlopeRise;
     int    otmsCharSlopeRun;
     int    otmItalicAngle;
    UINT    otmEMSquare;
     int    otmAscent;
     int    otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
     int    otmMacAscent;
     int    otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
     int    otmsStrikeoutPosition;
     int    otmsUnderscoreSize;
     int    otmsUnderscorePosition;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRICA, *POUTLINETEXTMETRICA,    *NPOUTLINETEXTMETRICA,    *LPOUTLINETEXTMETRICA;
typedef struct _OUTLINETEXTMETRICW {
    UINT    otmSize;
    TEXTMETRICW otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
     int    otmsCharSlopeRise;
     int    otmsCharSlopeRun;
     int    otmItalicAngle;
    UINT    otmEMSquare;
     int    otmAscent;
     int    otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
     int    otmMacAscent;
     int    otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
     int    otmsStrikeoutPosition;
     int    otmsUnderscoreSize;
     int    otmsUnderscorePosition;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRICW, *POUTLINETEXTMETRICW,    *NPOUTLINETEXTMETRICW,    *LPOUTLINETEXTMETRICW;
#line 1977 "C:\WATCOM\H\NT\wingdi.h"
typedef OUTLINETEXTMETRICA OUTLINETEXTMETRIC;
typedef POUTLINETEXTMETRICA POUTLINETEXTMETRIC;
typedef NPOUTLINETEXTMETRICA NPOUTLINETEXTMETRIC;
typedef LPOUTLINETEXTMETRICA LPOUTLINETEXTMETRIC;
// UNICODE

/* NOTEXTMETRIC */


typedef struct tagPOLYTEXTA
{
    int       x;
    int       y;
    UINT      n;
    LPCSTR    lpstr;
    UINT      uiFlags;
    RECT      rcl;
    int      *pdx;
} POLYTEXTA, *PPOLYTEXTA,    *NPPOLYTEXTA,    *LPPOLYTEXTA;
typedef struct tagPOLYTEXTW
{
    int       x;
    int       y;
    UINT      n;
    LPCWSTR   lpstr;
    UINT      uiFlags;
    RECT      rcl;
    int      *pdx;
} POLYTEXTW, *PPOLYTEXTW,    *NPPOLYTEXTW,    *LPPOLYTEXTW;
#line 2012 "C:\WATCOM\H\NT\wingdi.h"
typedef POLYTEXTA POLYTEXT;
typedef PPOLYTEXTA PPOLYTEXT;
typedef NPPOLYTEXTA NPPOLYTEXT;
typedef LPPOLYTEXTA LPPOLYTEXT;
// UNICODE

typedef struct _FIXED {
    WORD    fract;
    short   value;
} FIXED;


typedef struct _MAT2 {
     FIXED  eM11;
     FIXED  eM12;
     FIXED  eM21;
     FIXED  eM22;
} MAT2,    *LPMAT2;



typedef struct _GLYPHMETRICS {
    UINT    gmBlackBoxX;
    UINT    gmBlackBoxY;
    POINT   gmptGlyphOrigin;
    short   gmCellIncX;
    short   gmCellIncY;
} GLYPHMETRICS,    *LPGLYPHMETRICS;

//  GetGlyphOutline constants





 




/* WINVER >= 0x0400 */






typedef struct tagPOINTFX
{
    FIXED x;
    FIXED y;
} POINTFX,   * LPPOINTFX;

typedef struct tagTTPOLYCURVE
{
    WORD    wType;
    WORD    cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE,   * LPTTPOLYCURVE;

typedef struct tagTTPOLYGONHEADER
{
    DWORD   cb;
    DWORD   dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER,   * LPTTPOLYGONHEADER;


 





////#define GCP_GLYPHINDEXING  0x0080






////#define GCP_NODIACRITICS   0x00020000L





























typedef struct tagGCP_RESULTSA
    {
    DWORD   lStructSize;
    LPSTR     lpOutString;
    UINT    *lpOrder;
    int     *lpDx;
    int     *lpCaretPos;
    LPSTR     lpClass;
    LPWSTR  lpGlyphs;
    UINT    nGlyphs;
    int     nMaxFit;
    } GCP_RESULTSA,   * LPGCP_RESULTSA;
typedef struct tagGCP_RESULTSW
    {
    DWORD   lStructSize;
    LPWSTR    lpOutString;
    UINT    *lpOrder;
    int     *lpDx;
    int     *lpCaretPos;
    LPWSTR    lpClass;
    LPWSTR  lpGlyphs;
    UINT    nGlyphs;
    int     nMaxFit;
    } GCP_RESULTSW,   * LPGCP_RESULTSW;
#line 2151 "C:\WATCOM\H\NT\wingdi.h"
typedef GCP_RESULTSA GCP_RESULTS;
typedef LPGCP_RESULTSA LPGCP_RESULTS;
// UNICODE
/* WINVER >= 0x0400 */

typedef struct _RASTERIZER_STATUS {
    short   nSize;
    short   wFlags;
    short   nLanguageID;
} RASTERIZER_STATUS,    *LPRASTERIZER_STATUS;

/* bits defined in wFlags of RASTERIZER_STATUS */



/* Pixel format descriptor */
typedef struct tagPIXELFORMATDESCRIPTOR
{
    WORD  nSize;
    WORD  nVersion;
    DWORD dwFlags;
    BYTE  iPixelType;
    BYTE  cColorBits;
    BYTE  cRedBits;
    BYTE  cRedShift;
    BYTE  cGreenBits;
    BYTE  cGreenShift;
    BYTE  cBlueBits;
    BYTE  cBlueShift;
    BYTE  cAlphaBits;
    BYTE  cAlphaShift;
    BYTE  cAccumBits;
    BYTE  cAccumRedBits;
    BYTE  cAccumGreenBits;
    BYTE  cAccumBlueBits;
    BYTE  cAccumAlphaBits;
    BYTE  cDepthBits;
    BYTE  cStencilBits;
    BYTE  cAuxBuffers;
    BYTE  iLayerType;
    BYTE  bReserved;
    DWORD dwLayerMask;
    DWORD dwVisibleMask;
    DWORD dwDamageMask;
} PIXELFORMATDESCRIPTOR, *PPIXELFORMATDESCRIPTOR,    *LPPIXELFORMATDESCRIPTOR;

/* pixel types */



/* layer types */




/* PIXELFORMATDESCRIPTOR flags */












/* PIXELFORMATDESCRIPTOR flags for use in ChoosePixelFormat only */



#line 2253 "C:\WATCOM\H\NT\wingdi.h"
typedef FARPROC OLDFONTENUMPROC;
typedef FARPROC FONTENUMPROCA;
typedef FARPROC FONTENUMPROCW;
#line 2259 "C:\WATCOM\H\NT\wingdi.h"
typedef FONTENUMPROCA FONTENUMPROC;
// UNICODE
typedef FARPROC GOBJENUMPROC;
typedef FARPROC LINEDDAPROC;


 __declspec(dllimport)  int  __stdcall  AddFontResourceA(LPCSTR);
 __declspec(dllimport)  int  __stdcall  AddFontResourceW(LPCWSTR);
#line 2270 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE

 __declspec(dllimport)  BOOL   __stdcall  AnimatePalette(HPALETTE, UINT, UINT,  const  PALETTEENTRY *);
 __declspec(dllimport)  BOOL   __stdcall  Arc(HDC, int, int, int, int, int, int, int, int);
 __declspec(dllimport)  BOOL   __stdcall  BitBlt(HDC, int, int, int, int, HDC, int, int, DWORD);
 __declspec(dllimport)  BOOL   __stdcall  CancelDC(HDC);
 __declspec(dllimport)  BOOL   __stdcall  Chord(HDC, int, int, int, int, int, int, int, int);
 __declspec(dllimport)  int    __stdcall  ChoosePixelFormat(HDC,  const  PIXELFORMATDESCRIPTOR *);
 __declspec(dllimport)  HMETAFILE   __stdcall  CloseMetaFile(HDC);
 __declspec(dllimport)  int      __stdcall  CombineRgn(HRGN, HRGN, HRGN, int);
 __declspec(dllimport)  HMETAFILE  __stdcall  CopyMetaFileA(HMETAFILE, LPCSTR);
 __declspec(dllimport)  HMETAFILE  __stdcall  CopyMetaFileW(HMETAFILE, LPCWSTR);
#line 2286 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
 __declspec(dllimport)  HBITMAP  __stdcall  CreateBitmap(int, int, UINT, UINT,  const   void  *);
 __declspec(dllimport)  HBITMAP  __stdcall  CreateBitmapIndirect( const  BITMAP *);
 __declspec(dllimport)  HBRUSH   __stdcall  CreateBrushIndirect( const  LOGBRUSH *);
 __declspec(dllimport)  HBITMAP  __stdcall  CreateCompatibleBitmap(HDC, int, int);
 __declspec(dllimport)  HBITMAP  __stdcall  CreateDiscardableBitmap(HDC, int, int);
 __declspec(dllimport)  HDC      __stdcall  CreateCompatibleDC(HDC);
 __declspec(dllimport)  HDC      __stdcall  CreateDCA(LPCSTR, LPCSTR , LPCSTR ,  const  DEVMODEA *);
 __declspec(dllimport)  HDC      __stdcall  CreateDCW(LPCWSTR, LPCWSTR , LPCWSTR ,  const  DEVMODEW *);
#line 2299 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
 __declspec(dllimport)  HBITMAP  __stdcall  CreateDIBitmap(HDC,  const  BITMAPINFOHEADER *, DWORD,  const   void  *,  const  BITMAPINFO *, UINT);
 __declspec(dllimport)  HBRUSH   __stdcall  CreateDIBPatternBrush(HGLOBAL, UINT);
 __declspec(dllimport)  HBRUSH   __stdcall  CreateDIBPatternBrushPt( const   void  *, UINT);
 __declspec(dllimport)  HRGN     __stdcall  CreateEllipticRgn(int, int, int, int);
 __declspec(dllimport)  HRGN     __stdcall  CreateEllipticRgnIndirect( const  RECT *);
 __declspec(dllimport)  HFONT    __stdcall  CreateFontIndirectA( const  LOGFONTA *);
 __declspec(dllimport)  HFONT    __stdcall  CreateFontIndirectW( const  LOGFONTW *);
#line 2311 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
 __declspec(dllimport)  HFONT    __stdcall  CreateFontA(int, int, int, int, int, DWORD,
                             DWORD, DWORD, DWORD, DWORD, DWORD,
                             DWORD, DWORD, LPCSTR);
 __declspec(dllimport)  HFONT    __stdcall  CreateFontW(int, int, int, int, int, DWORD,
                             DWORD, DWORD, DWORD, DWORD, DWORD,
                             DWORD, DWORD, LPCWSTR);
#line 2322 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE

 __declspec(dllimport)  HBRUSH   __stdcall  CreateHatchBrush(int, COLORREF);
 __declspec(dllimport)  HDC      __stdcall  CreateICA(LPCSTR, LPCSTR , LPCSTR ,  const  DEVMODEA *);
 __declspec(dllimport)  HDC      __stdcall  CreateICW(LPCWSTR, LPCWSTR , LPCWSTR ,  const  DEVMODEW *);
#line 2331 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
 __declspec(dllimport)  HDC      __stdcall  CreateMetaFileA(LPCSTR);
 __declspec(dllimport)  HDC      __stdcall  CreateMetaFileW(LPCWSTR);
#line 2338 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
 __declspec(dllimport)  HPALETTE  __stdcall  CreatePalette( const  LOGPALETTE *);
 __declspec(dllimport)  HPEN     __stdcall  CreatePen(int, int, COLORREF);
 __declspec(dllimport)  HPEN     __stdcall  CreatePenIndirect( const  LOGPEN *);
 __declspec(dllimport)  HRGN     __stdcall  CreatePolyPolygonRgn( const  POINT *,  const  INT *, int, int);
 __declspec(dllimport)  HBRUSH   __stdcall  CreatePatternBrush(HBITMAP);
 __declspec(dllimport)  HRGN     __stdcall  CreateRectRgn(int, int, int, int);
 __declspec(dllimport)  HRGN     __stdcall  CreateRectRgnIndirect( const  RECT *);
 __declspec(dllimport)  HRGN     __stdcall  CreateRoundRectRgn(int, int, int, int, int, int);
 __declspec(dllimport)  BOOL     __stdcall  CreateScalableFontResourceA(DWORD, LPCSTR, LPCSTR, LPCSTR);
 __declspec(dllimport)  BOOL     __stdcall  CreateScalableFontResourceW(DWORD, LPCWSTR, LPCWSTR, LPCWSTR);
#line 2353 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
 __declspec(dllimport)  HBRUSH   __stdcall  CreateSolidBrush(COLORREF);

 __declspec(dllimport)  BOOL  __stdcall  DeleteDC(HDC);
 __declspec(dllimport)  BOOL  __stdcall  DeleteMetaFile(HMETAFILE);
 __declspec(dllimport)  BOOL  __stdcall  DeleteObject(HGDIOBJ);
 __declspec(dllimport)  int   __stdcall  DescribePixelFormat(HDC, int, UINT, LPPIXELFORMATDESCRIPTOR);

/* define types of pointers to ExtDeviceMode() and DeviceCapabilities()
 * functions for Win 3.1 compatibility
 */

typedef UINT   ( __stdcall * LPFNDEVMODE)(HWND, HMODULE, LPDEVMODE, LPSTR, LPSTR, LPDEVMODE, LPSTR, UINT);

typedef DWORD  ( __stdcall * LPFNDEVCAPS)(LPSTR, LPSTR, UINT, LPSTR, LPDEVMODE);

/* mode selections for the device mode function */










/* device capabilities indices */


















 





/* WINVER >= 0x0400 */

/* bit fields of the return value (DWORD) for DC_TRUETYPE */



 


/* return values for DC_BINADJUST */








/* WINVER >= 0x0400 */

 __declspec(dllimport)  int   __stdcall  DeviceCapabilitiesA(LPCSTR, LPCSTR, WORD,
                                LPSTR,  const  DEVMODEA *);
 __declspec(dllimport)  int   __stdcall  DeviceCapabilitiesW(LPCWSTR, LPCWSTR, WORD,
                                LPWSTR,  const  DEVMODEW *);
#line 2433 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE

 __declspec(dllimport)  int   __stdcall  DrawEscape(HDC, int, int, LPCSTR);
 __declspec(dllimport)  BOOL  __stdcall  Ellipse(HDC, int, int, int, int);

 
 __declspec(dllimport)  int   __stdcall  EnumFontFamiliesExA(HDC, LPLOGFONTA,FONTENUMPROCA, LPARAM,DWORD);
 __declspec(dllimport)  int   __stdcall  EnumFontFamiliesExW(HDC, LPLOGFONTW,FONTENUMPROCW, LPARAM,DWORD);
#line 2445 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
/* WINVER >= 0x0400 */

 __declspec(dllimport)  int   __stdcall  EnumFontFamiliesA(HDC, LPCSTR, FONTENUMPROCA, LPARAM);
 __declspec(dllimport)  int   __stdcall  EnumFontFamiliesW(HDC, LPCWSTR, FONTENUMPROCW, LPARAM);
#line 2454 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
 __declspec(dllimport)  int   __stdcall  EnumFontsA(HDC, LPCSTR,  FONTENUMPROCA, LPARAM);
 __declspec(dllimport)  int   __stdcall  EnumFontsW(HDC, LPCWSTR,  FONTENUMPROCW, LPARAM);
#line 2461 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE

#line 2467 "C:\WATCOM\H\NT\wingdi.h"
 __declspec(dllimport)  int   __stdcall  EnumObjects(HDC, int, GOBJENUMPROC, LPVOID);



 __declspec(dllimport)  BOOL  __stdcall  EqualRgn(HRGN, HRGN);
 __declspec(dllimport)  int   __stdcall  Escape(HDC, int, int, LPCSTR, LPVOID);
 __declspec(dllimport)  int   __stdcall  ExtEscape(HDC, int, int, LPCSTR, int, LPSTR);
 __declspec(dllimport)  int   __stdcall  ExcludeClipRect(HDC, int, int, int, int);
 __declspec(dllimport)  HRGN  __stdcall  ExtCreateRegion( const  XFORM *, DWORD,  const  RGNDATA *);
 __declspec(dllimport)  BOOL   __stdcall  ExtFloodFill(HDC, int, int, COLORREF, UINT);
 __declspec(dllimport)  BOOL    __stdcall  FillRgn(HDC, HRGN, HBRUSH);
 __declspec(dllimport)  BOOL    __stdcall  FloodFill(HDC, int, int, COLORREF);
 __declspec(dllimport)  BOOL    __stdcall  FrameRgn(HDC, HRGN, HBRUSH, int, int);
 __declspec(dllimport)  int    __stdcall  GetROP2(HDC);
 __declspec(dllimport)  BOOL   __stdcall  GetAspectRatioFilterEx(HDC, LPSIZE);
 __declspec(dllimport)  COLORREF  __stdcall  GetBkColor(HDC);
 __declspec(dllimport)  int    __stdcall  GetBkMode(HDC);
 __declspec(dllimport)  LONG   __stdcall  GetBitmapBits(HBITMAP, LONG, LPVOID);
 __declspec(dllimport)  BOOL   __stdcall  GetBitmapDimensionEx(HBITMAP, LPSIZE);
 __declspec(dllimport)  UINT   __stdcall  GetBoundsRect(HDC, LPRECT, UINT);

 __declspec(dllimport)  BOOL   __stdcall  GetBrushOrgEx(HDC, LPPOINT);

 __declspec(dllimport)  BOOL   __stdcall  GetCharWidthA(HDC, UINT, UINT, LPINT);
 __declspec(dllimport)  BOOL   __stdcall  GetCharWidthW(HDC, UINT, UINT, LPINT);
#line 2495 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
 __declspec(dllimport)  BOOL   __stdcall  GetCharWidth32A(HDC, UINT, UINT, LPINT);
 __declspec(dllimport)  BOOL   __stdcall  GetCharWidth32W(HDC, UINT, UINT, LPINT);
#line 2502 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
 __declspec(dllimport)  BOOL   __stdcall  GetCharWidthFloatA(HDC, UINT, UINT, PFLOAT);
 __declspec(dllimport)  BOOL   __stdcall  GetCharWidthFloatW(HDC, UINT, UINT, PFLOAT);
#line 2509 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE

 __declspec(dllimport)  BOOL   __stdcall  GetCharABCWidthsA(HDC, UINT, UINT, LPABC);
 __declspec(dllimport)  BOOL   __stdcall  GetCharABCWidthsW(HDC, UINT, UINT, LPABC);
#line 2517 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
 __declspec(dllimport)  BOOL   __stdcall  GetCharABCWidthsFloatA(HDC, UINT, UINT, LPABCFLOAT);
 __declspec(dllimport)  BOOL   __stdcall  GetCharABCWidthsFloatW(HDC, UINT, UINT, LPABCFLOAT);
#line 2524 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE

 __declspec(dllimport)  int    __stdcall  GetClipBox(HDC, LPRECT);
 __declspec(dllimport)  int    __stdcall  GetClipRgn(HDC, HRGN);
 __declspec(dllimport)  int    __stdcall  GetMetaRgn(HDC, HRGN);
 __declspec(dllimport)  HGDIOBJ  __stdcall  GetCurrentObject(HDC, UINT);
 __declspec(dllimport)  BOOL   __stdcall  GetCurrentPositionEx(HDC, LPPOINT);
 __declspec(dllimport)  int    __stdcall  GetDeviceCaps(HDC, int);
 __declspec(dllimport)  int    __stdcall  GetDIBits(HDC, HBITMAP, UINT, UINT, LPVOID, LPBITMAPINFO, UINT);
 __declspec(dllimport)  DWORD  __stdcall  GetFontData(HDC, DWORD, DWORD, LPVOID, DWORD);
 __declspec(dllimport)  DWORD  __stdcall  GetGlyphOutlineA(HDC, UINT, UINT, LPGLYPHMETRICS, DWORD, LPVOID,  const  MAT2 *);
 __declspec(dllimport)  DWORD  __stdcall  GetGlyphOutlineW(HDC, UINT, UINT, LPGLYPHMETRICS, DWORD, LPVOID,  const  MAT2 *);
#line 2540 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
 __declspec(dllimport)  int    __stdcall  GetGraphicsMode(HDC);
 __declspec(dllimport)  int    __stdcall  GetMapMode(HDC);
 __declspec(dllimport)  UINT   __stdcall  GetMetaFileBitsEx(HMETAFILE, UINT, LPVOID);
 __declspec(dllimport)  HMETAFILE    __stdcall  GetMetaFileA(LPCSTR);
 __declspec(dllimport)  HMETAFILE    __stdcall  GetMetaFileW(LPCWSTR);
#line 2550 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
 __declspec(dllimport)  COLORREF  __stdcall  GetNearestColor(HDC, COLORREF);
 __declspec(dllimport)  UINT   __stdcall  GetNearestPaletteIndex(HPALETTE, COLORREF);
 __declspec(dllimport)  DWORD  __stdcall  GetObjectType(HGDIOBJ h);



 __declspec(dllimport)  UINT  __stdcall  GetOutlineTextMetricsA(HDC, UINT, LPOUTLINETEXTMETRICA);
 __declspec(dllimport)  UINT  __stdcall  GetOutlineTextMetricsW(HDC, UINT, LPOUTLINETEXTMETRICW);
#line 2563 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE

/* NOTEXTMETRIC */

 __declspec(dllimport)  UINT   __stdcall  GetPaletteEntries(HPALETTE, UINT, UINT, LPPALETTEENTRY);
 __declspec(dllimport)  COLORREF  __stdcall  GetPixel(HDC, int, int);
 __declspec(dllimport)  int    __stdcall  GetPixelFormat(HDC);
 __declspec(dllimport)  int    __stdcall  GetPolyFillMode(HDC);
 __declspec(dllimport)  BOOL   __stdcall  GetRasterizerCaps(LPRASTERIZER_STATUS, UINT);
 __declspec(dllimport)  DWORD  __stdcall  GetRegionData(HRGN, DWORD, LPRGNDATA);
 __declspec(dllimport)  int    __stdcall  GetRgnBox(HRGN, LPRECT);
 __declspec(dllimport)  HGDIOBJ  __stdcall  GetStockObject(int);
 __declspec(dllimport)  int    __stdcall  GetStretchBltMode(HDC);
 __declspec(dllimport)  UINT   __stdcall  GetSystemPaletteEntries(HDC, UINT, UINT, LPPALETTEENTRY);
 __declspec(dllimport)  UINT   __stdcall  GetSystemPaletteUse(HDC);
 __declspec(dllimport)  int    __stdcall  GetTextCharacterExtra(HDC);
 __declspec(dllimport)  UINT   __stdcall  GetTextAlign(HDC);
 __declspec(dllimport)  COLORREF  __stdcall  GetTextColor(HDC);

 __declspec(dllimport)  BOOL   __stdcall  GetTextExtentPointA(
                    HDC,
                    LPCSTR,
                    int,
                    LPSIZE
                    );
 __declspec(dllimport)  BOOL   __stdcall  GetTextExtentPointW(
                    HDC,
                    LPCWSTR,
                    int,
                    LPSIZE
                    );
#line 2598 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE

 __declspec(dllimport)  BOOL   __stdcall  GetTextExtentPoint32A(
                    HDC,
                    LPCSTR,
                    int,
                    LPSIZE
                    );
 __declspec(dllimport)  BOOL   __stdcall  GetTextExtentPoint32W(
                    HDC,
                    LPCWSTR,
                    int,
                    LPSIZE
                    );
#line 2616 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE

 __declspec(dllimport)  BOOL   __stdcall  GetTextExtentExPointA(
                    HDC,
                    LPCSTR,
                    int,
                    int,
                    LPINT,
                    LPINT,
                    LPSIZE
                    );
 __declspec(dllimport)  BOOL   __stdcall  GetTextExtentExPointW(
                    HDC,
                    LPCWSTR,
                    int,
                    int,
                    LPINT,
                    LPINT,
                    LPSIZE
                    );
#line 2640 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE

 
 __declspec(dllimport)  int  __stdcall  GetTextCharset(HDC hdc);
 __declspec(dllimport)  int  __stdcall  GetTextCharsetInfo(HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags);
 __declspec(dllimport)  BOOL  __stdcall  TranslateCharsetInfo( DWORD    *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags);
 __declspec(dllimport)  DWORD  __stdcall  GetFontLanguageInfo( HDC );
 __declspec(dllimport)  DWORD  __stdcall  GetCharacterPlacementA(HDC, LPCSTR, int, int, LPGCP_RESULTSA, DWORD);
 __declspec(dllimport)  DWORD  __stdcall  GetCharacterPlacementW(HDC, LPCWSTR, int, int, LPGCP_RESULTSW, DWORD);
#line 2653 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
/* WINVER >= 0x0400 */

 __declspec(dllimport)  BOOL   __stdcall  GetViewportExtEx(HDC, LPSIZE);
 __declspec(dllimport)  BOOL   __stdcall  GetViewportOrgEx(HDC, LPPOINT);
 __declspec(dllimport)  BOOL   __stdcall  GetWindowExtEx(HDC, LPSIZE);
 __declspec(dllimport)  BOOL   __stdcall  GetWindowOrgEx(HDC, LPPOINT);

 __declspec(dllimport)  int   __stdcall  IntersectClipRect(HDC, int, int, int, int);
 __declspec(dllimport)  BOOL  __stdcall  InvertRgn(HDC, HRGN);
 __declspec(dllimport)  BOOL  __stdcall  LineDDA(int, int, int, int, LINEDDAPROC, LPARAM);
 __declspec(dllimport)  BOOL  __stdcall  LineTo(HDC, int, int);
 __declspec(dllimport)  BOOL  __stdcall  MaskBlt(HDC, int, int, int, int,
              HDC, int, int, HBITMAP, int, int, DWORD);
 __declspec(dllimport)  BOOL  __stdcall  PlgBlt(HDC,  const  POINT *, HDC, int, int, int,
                     int, HBITMAP, int, int);

 __declspec(dllimport)  int   __stdcall  OffsetClipRgn(HDC, int, int);
 __declspec(dllimport)  int   __stdcall  OffsetRgn(HRGN, int, int);
 __declspec(dllimport)  BOOL  __stdcall  PatBlt(HDC, int, int, int, int, DWORD);
 __declspec(dllimport)  BOOL  __stdcall  Pie(HDC, int, int, int, int, int, int, int, int);
 __declspec(dllimport)  BOOL  __stdcall  PlayMetaFile(HDC, HMETAFILE);
 __declspec(dllimport)  BOOL  __stdcall  PaintRgn(HDC, HRGN);
 __declspec(dllimport)  BOOL  __stdcall  PolyPolygon(HDC,  const  POINT *,  const  INT *, int);
 __declspec(dllimport)  BOOL  __stdcall  PtInRegion(HRGN, int, int);
 __declspec(dllimport)  BOOL  __stdcall  PtVisible(HDC, int, int);
 __declspec(dllimport)  BOOL  __stdcall  RectInRegion(HRGN,  const  RECT *);
 __declspec(dllimport)  BOOL  __stdcall  RectVisible(HDC,  const  RECT *);
 __declspec(dllimport)  BOOL  __stdcall  Rectangle(HDC, int, int, int, int);
 __declspec(dllimport)  BOOL  __stdcall  RestoreDC(HDC, int);
 __declspec(dllimport)  HDC   __stdcall  ResetDCA(HDC,  const  DEVMODEA *);
 __declspec(dllimport)  HDC   __stdcall  ResetDCW(HDC,  const  DEVMODEW *);
#line 2689 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
 __declspec(dllimport)  UINT  __stdcall  RealizePalette(HDC);
 __declspec(dllimport)  BOOL  __stdcall  RemoveFontResourceA(LPCSTR);
 __declspec(dllimport)  BOOL  __stdcall  RemoveFontResourceW(LPCWSTR);
#line 2697 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
 __declspec(dllimport)  BOOL   __stdcall  RoundRect(HDC, int, int, int, int, int, int);
 __declspec(dllimport)  BOOL  __stdcall  ResizePalette(HPALETTE, UINT);

 __declspec(dllimport)  int   __stdcall  SaveDC(HDC);
 __declspec(dllimport)  int   __stdcall  SelectClipRgn(HDC, HRGN);
 __declspec(dllimport)  int   __stdcall  ExtSelectClipRgn(HDC, HRGN, int);
 __declspec(dllimport)  int   __stdcall  SetMetaRgn(HDC);
 __declspec(dllimport)  HGDIOBJ  __stdcall  SelectObject(HDC, HGDIOBJ);
 __declspec(dllimport)  HPALETTE  __stdcall  SelectPalette(HDC, HPALETTE, BOOL);
 __declspec(dllimport)  COLORREF  __stdcall  SetBkColor(HDC, COLORREF);
 __declspec(dllimport)  int    __stdcall  SetBkMode(HDC, int);
 __declspec(dllimport)  LONG   __stdcall  SetBitmapBits(HBITMAP, DWORD,  const   void  *);

 __declspec(dllimport)  UINT   __stdcall  SetBoundsRect(HDC,  const  RECT *, UINT);
 __declspec(dllimport)  int    __stdcall  SetDIBits(HDC, HBITMAP, UINT, UINT,  const   void  *,  const  BITMAPINFO *, UINT);
 __declspec(dllimport)  int    __stdcall  SetDIBitsToDevice(HDC, int, int, DWORD, DWORD, int,
        int, UINT, UINT,  const   void  *,  const  BITMAPINFO *, UINT);
 __declspec(dllimport)  DWORD  __stdcall  SetMapperFlags(HDC, DWORD);
 __declspec(dllimport)  int    __stdcall  SetGraphicsMode(HDC hdc, int iMode);
 __declspec(dllimport)  int    __stdcall  SetMapMode(HDC, int);
 __declspec(dllimport)  HMETAFILE    __stdcall  SetMetaFileBitsEx(UINT,  const  BYTE *);
 __declspec(dllimport)  UINT   __stdcall  SetPaletteEntries(HPALETTE, UINT, UINT,  const  PALETTEENTRY *);
 __declspec(dllimport)  COLORREF  __stdcall  SetPixel(HDC, int, int, COLORREF);
 __declspec(dllimport)  BOOL    __stdcall  SetPixelV(HDC, int, int, COLORREF);
 __declspec(dllimport)  BOOL   __stdcall  SetPixelFormat(HDC, int,  const  PIXELFORMATDESCRIPTOR *);
 __declspec(dllimport)  int    __stdcall  SetPolyFillMode(HDC, int);
 __declspec(dllimport)  BOOL    __stdcall  StretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD);
 __declspec(dllimport)  BOOL    __stdcall  SetRectRgn(HRGN, int, int, int, int);
 __declspec(dllimport)  int    __stdcall  StretchDIBits(HDC, int, int, int, int, int, int, int, int,  const 
         void  *,  const  BITMAPINFO *, UINT, DWORD);
 __declspec(dllimport)  int    __stdcall  SetROP2(HDC, int);
 __declspec(dllimport)  int    __stdcall  SetStretchBltMode(HDC, int);
 __declspec(dllimport)  UINT   __stdcall  SetSystemPaletteUse(HDC, UINT);
 __declspec(dllimport)  int    __stdcall  SetTextCharacterExtra(HDC, int);
 __declspec(dllimport)  COLORREF  __stdcall  SetTextColor(HDC, COLORREF);
 __declspec(dllimport)  UINT   __stdcall  SetTextAlign(HDC, UINT);
 __declspec(dllimport)  BOOL   __stdcall  SetTextJustification(HDC, int, int);
 __declspec(dllimport)  BOOL   __stdcall  UpdateColors(HDC);



 __declspec(dllimport)  BOOL   __stdcall  PlayMetaFileRecord(HDC, LPHANDLETABLE, LPMETARECORD, UINT);
typedef int ( __stdcall * MFENUMPROC)(HDC, HANDLETABLE   *, METARECORD   *, int, LPARAM);
 __declspec(dllimport)  BOOL   __stdcall  EnumMetaFile(HDC, HMETAFILE, MFENUMPROC, LPARAM);

typedef int ( __stdcall * ENHMFENUMPROC)(HDC, HANDLETABLE   *,  const  ENHMETARECORD *, int, LPARAM);

// Enhanced Metafile Function Declarations

 __declspec(dllimport)  HENHMETAFILE  __stdcall  CloseEnhMetaFile(HDC);
 __declspec(dllimport)  HENHMETAFILE  __stdcall  CopyEnhMetaFileA(HENHMETAFILE, LPCSTR);
 __declspec(dllimport)  HENHMETAFILE  __stdcall  CopyEnhMetaFileW(HENHMETAFILE, LPCWSTR);
#line 2754 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
 __declspec(dllimport)  HDC    __stdcall  CreateEnhMetaFileA(HDC, LPCSTR,  const  RECT *, LPCSTR);
 __declspec(dllimport)  HDC    __stdcall  CreateEnhMetaFileW(HDC, LPCWSTR,  const  RECT *, LPCWSTR);
#line 2761 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
 __declspec(dllimport)  BOOL   __stdcall  DeleteEnhMetaFile(HENHMETAFILE);
 __declspec(dllimport)  BOOL   __stdcall  EnumEnhMetaFile(HDC, HENHMETAFILE, ENHMFENUMPROC,
        LPVOID,  const  RECT *);
 __declspec(dllimport)  HENHMETAFILE   __stdcall  GetEnhMetaFileA(LPCSTR);
 __declspec(dllimport)  HENHMETAFILE   __stdcall  GetEnhMetaFileW(LPCWSTR);
#line 2771 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
 __declspec(dllimport)  UINT   __stdcall  GetEnhMetaFileBits(HENHMETAFILE, UINT, LPBYTE);
 __declspec(dllimport)  UINT   __stdcall  GetEnhMetaFileDescriptionA(HENHMETAFILE, UINT, LPSTR );
 __declspec(dllimport)  UINT   __stdcall  GetEnhMetaFileDescriptionW(HENHMETAFILE, UINT, LPWSTR );
#line 2779 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
 __declspec(dllimport)  UINT   __stdcall  GetEnhMetaFileHeader(HENHMETAFILE, UINT, LPENHMETAHEADER );
 __declspec(dllimport)  UINT   __stdcall  GetEnhMetaFilePaletteEntries(HENHMETAFILE, UINT, LPPALETTEENTRY );
 __declspec(dllimport)  UINT   __stdcall  GetWinMetaFileBits(HENHMETAFILE, UINT, LPBYTE, INT, HDC);
 __declspec(dllimport)  BOOL   __stdcall  PlayEnhMetaFile(HDC, HENHMETAFILE,  const  RECT *);
 __declspec(dllimport)  BOOL   __stdcall  PlayEnhMetaFileRecord(HDC, LPHANDLETABLE,  const  ENHMETARECORD *, UINT);
 __declspec(dllimport)  HENHMETAFILE   __stdcall  SetEnhMetaFileBits(UINT,  const  BYTE *);
 __declspec(dllimport)  HENHMETAFILE   __stdcall  SetWinMetaFileBits(UINT,  const  BYTE *, HDC,  const  METAFILEPICT *);
 __declspec(dllimport)  BOOL   __stdcall  GdiComment(HDC, UINT,  const  BYTE *);

/* NOMETAFILE */



 __declspec(dllimport)  BOOL  __stdcall  GetTextMetricsA(HDC, LPTEXTMETRICA);
 __declspec(dllimport)  BOOL  __stdcall  GetTextMetricsW(HDC, LPTEXTMETRICW);
#line 2799 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE



/* new GDI */

typedef struct tagDIBSECTION {
    BITMAP              dsBm;
    BITMAPINFOHEADER    dsBmih;
    DWORD               dsBitfields[3];
    HANDLE              dshSection;
    DWORD               dsOffset;
} DIBSECTION,    *LPDIBSECTION, *PDIBSECTION;

 __declspec(dllimport)  BOOL  __stdcall  AngleArc(HDC, int, int, DWORD, FLOAT, FLOAT);
 __declspec(dllimport)  BOOL  __stdcall  PolyPolyline(HDC,  const  POINT *,  const  DWORD *, DWORD);
 __declspec(dllimport)  BOOL  __stdcall  GetWorldTransform(HDC, LPXFORM);
 __declspec(dllimport)  BOOL  __stdcall  SetWorldTransform(HDC,  const  XFORM *);
 __declspec(dllimport)  BOOL  __stdcall  ModifyWorldTransform(HDC,  const  XFORM *, DWORD);
 __declspec(dllimport)  BOOL  __stdcall  CombineTransform(LPXFORM,  const  XFORM *,  const  XFORM *);
 __declspec(dllimport)  HBITMAP  __stdcall  CreateDIBSection(HDC,  const  BITMAPINFO *, UINT,  void  **, HANDLE, DWORD);
 __declspec(dllimport)  UINT  __stdcall  GetDIBColorTable(HDC, UINT, UINT, RGBQUAD *);
 __declspec(dllimport)  UINT  __stdcall  SetDIBColorTable(HDC, UINT, UINT,  const  RGBQUAD *);

/* Flags value for COLORADJUSTMENT */



/* IlluminantIndex values */
















/* Min and max for RedGamma, GreenGamma, BlueGamma */



/* Min and max for ReferenceBlack and ReferenceWhite */





/* Min and max for Contrast, Brightness, Colorfulness, RedGreenTint */



typedef struct  tagCOLORADJUSTMENT {
    WORD   caSize;
    WORD   caFlags;
    WORD   caIlluminantIndex;
    WORD   caRedGamma;
    WORD   caGreenGamma;
    WORD   caBlueGamma;
    WORD   caReferenceBlack;
    WORD   caReferenceWhite;
    SHORT  caContrast;
    SHORT  caBrightness;
    SHORT  caColorfulness;
    SHORT  caRedGreenTint;
} COLORADJUSTMENT, *PCOLORADJUSTMENT,    *LPCOLORADJUSTMENT;

 __declspec(dllimport)  BOOL  __stdcall  SetColorAdjustment(HDC,  const  COLORADJUSTMENT *);
 __declspec(dllimport)  BOOL  __stdcall  GetColorAdjustment(HDC, LPCOLORADJUSTMENT);
 __declspec(dllimport)  HPALETTE  __stdcall  CreateHalftonePalette(HDC);

#line 2881 "C:\WATCOM\H\NT\wingdi.h"
typedef FARPROC ABORTPROC;


typedef struct _DOCINFOA {
    int     cbSize;
    LPCSTR   lpszDocName;
    LPCSTR   lpszOutput;
 
    LPCSTR   lpszDatatype;
    DWORD    fwType;
/* WINVER */
} DOCINFOA, *LPDOCINFOA;
typedef struct _DOCINFOW {
    int     cbSize;
    LPCWSTR  lpszDocName;
    LPCWSTR  lpszOutput;
 
    LPCWSTR  lpszDatatype;
    DWORD    fwType;
/* WINVER */
} DOCINFOW, *LPDOCINFOW;
#line 2906 "C:\WATCOM\H\NT\wingdi.h"
typedef DOCINFOA DOCINFO;
typedef LPDOCINFOA LPDOCINFO;
// UNICODE

 

/* WINVER >= 0x0400 */

 __declspec(dllimport)  int  __stdcall  StartDocA(HDC,  const  DOCINFOA *);
 __declspec(dllimport)  int  __stdcall  StartDocW(HDC,  const  DOCINFOW *);
#line 2919 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
 __declspec(dllimport)  int  __stdcall  EndDoc(HDC);
 __declspec(dllimport)  int  __stdcall  StartPage(HDC);
 __declspec(dllimport)  int  __stdcall  EndPage(HDC);
 __declspec(dllimport)  int  __stdcall  AbortDoc(HDC);
 __declspec(dllimport)  int  __stdcall  SetAbortProc(HDC, ABORTPROC);

 __declspec(dllimport)  BOOL  __stdcall  AbortPath(HDC);
 __declspec(dllimport)  BOOL  __stdcall  ArcTo(HDC, int, int, int, int, int, int,int, int);
 __declspec(dllimport)  BOOL  __stdcall  BeginPath(HDC);
 __declspec(dllimport)  BOOL  __stdcall  CloseFigure(HDC);
 __declspec(dllimport)  BOOL  __stdcall  EndPath(HDC);
 __declspec(dllimport)  BOOL  __stdcall  FillPath(HDC);
 __declspec(dllimport)  BOOL  __stdcall  FlattenPath(HDC);
 __declspec(dllimport)  int   __stdcall  GetPath(HDC, LPPOINT, LPBYTE, int);
 __declspec(dllimport)  HRGN  __stdcall  PathToRegion(HDC);
 __declspec(dllimport)  BOOL  __stdcall  PolyDraw(HDC,  const  POINT *,  const  BYTE *, int);
 __declspec(dllimport)  BOOL  __stdcall  SelectClipPath(HDC, int);
 __declspec(dllimport)  int   __stdcall  SetArcDirection(HDC, int);
 __declspec(dllimport)  BOOL  __stdcall  SetMiterLimit(HDC, FLOAT, PFLOAT);
 __declspec(dllimport)  BOOL  __stdcall  StrokeAndFillPath(HDC);
 __declspec(dllimport)  BOOL  __stdcall  StrokePath(HDC);
 __declspec(dllimport)  BOOL  __stdcall  WidenPath(HDC);
 __declspec(dllimport)  HPEN  __stdcall  ExtCreatePen(DWORD, DWORD,  const  LOGBRUSH *, DWORD,  const  DWORD *);
 __declspec(dllimport)  BOOL  __stdcall  GetMiterLimit(HDC, PFLOAT);
 __declspec(dllimport)  int   __stdcall  GetArcDirection(HDC);

 __declspec(dllimport)  int    __stdcall  GetObjectA(HGDIOBJ, int, LPVOID);
 __declspec(dllimport)  int    __stdcall  GetObjectW(HGDIOBJ, int, LPVOID);
#line 2952 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
 __declspec(dllimport)  BOOL   __stdcall  MoveToEx(HDC, int, int, LPPOINT);
 __declspec(dllimport)  BOOL   __stdcall  TextOutA(HDC, int, int, LPCSTR, int);
 __declspec(dllimport)  BOOL   __stdcall  TextOutW(HDC, int, int, LPCWSTR, int);
#line 2960 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
 __declspec(dllimport)  BOOL   __stdcall  ExtTextOutA(HDC, int, int, UINT,  const  RECT *,LPCSTR, UINT,  const  INT *);
 __declspec(dllimport)  BOOL   __stdcall  ExtTextOutW(HDC, int, int, UINT,  const  RECT *,LPCWSTR, UINT,  const  INT *);
#line 2967 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
 __declspec(dllimport)  BOOL   __stdcall  PolyTextOutA(HDC,  const  POLYTEXTA *, int);
 __declspec(dllimport)  BOOL   __stdcall  PolyTextOutW(HDC,  const  POLYTEXTW *, int);
#line 2974 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE

 __declspec(dllimport)  HRGN   __stdcall  CreatePolygonRgn( const  POINT *, int, int);
 __declspec(dllimport)  BOOL   __stdcall  DPtoLP(HDC, LPPOINT, int);
 __declspec(dllimport)  BOOL   __stdcall  LPtoDP(HDC, LPPOINT, int);
 __declspec(dllimport)  BOOL   __stdcall  Polygon(HDC,  const  POINT *, int);
 __declspec(dllimport)  BOOL   __stdcall  Polyline(HDC,  const  POINT *, int);

 __declspec(dllimport)  BOOL   __stdcall  PolyBezier(HDC,  const  POINT *, DWORD);
 __declspec(dllimport)  BOOL   __stdcall  PolyBezierTo(HDC,  const  POINT *, DWORD);
 __declspec(dllimport)  BOOL   __stdcall  PolylineTo(HDC,  const  POINT *, DWORD);

 __declspec(dllimport)  BOOL   __stdcall  SetViewportExtEx(HDC, int, int, LPSIZE);
 __declspec(dllimport)  BOOL   __stdcall  SetViewportOrgEx(HDC, int, int, LPPOINT);
 __declspec(dllimport)  BOOL   __stdcall  SetWindowExtEx(HDC, int, int, LPSIZE);
 __declspec(dllimport)  BOOL   __stdcall  SetWindowOrgEx(HDC, int, int, LPPOINT);

 __declspec(dllimport)  BOOL   __stdcall  OffsetViewportOrgEx(HDC, int, int, LPPOINT);
 __declspec(dllimport)  BOOL   __stdcall  OffsetWindowOrgEx(HDC, int, int, LPPOINT);
 __declspec(dllimport)  BOOL   __stdcall  ScaleViewportExtEx(HDC, int, int, int, int, LPSIZE);
 __declspec(dllimport)  BOOL   __stdcall  ScaleWindowExtEx(HDC, int, int, int, int, LPSIZE);
 __declspec(dllimport)  BOOL   __stdcall  SetBitmapDimensionEx(HBITMAP, int, int, LPSIZE);
 __declspec(dllimport)  BOOL   __stdcall  SetBrushOrgEx(HDC, int, int, LPPOINT);

 __declspec(dllimport)  int    __stdcall  GetTextFaceA(HDC, int, LPSTR);
 __declspec(dllimport)  int    __stdcall  GetTextFaceW(HDC, int, LPWSTR);
#line 3004 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE



typedef struct tagKERNINGPAIR {
   WORD wFirst;
   WORD wSecond;
   int  iKernAmount;
} KERNINGPAIR, *LPKERNINGPAIR;

 __declspec(dllimport)  DWORD  __stdcall  GetKerningPairsA(HDC, DWORD, LPKERNINGPAIR);
 __declspec(dllimport)  DWORD  __stdcall  GetKerningPairsW(HDC, DWORD, LPKERNINGPAIR);
#line 3020 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE

 __declspec(dllimport)  BOOL   __stdcall  GetDCOrgEx(HDC,LPPOINT);
 __declspec(dllimport)  BOOL   __stdcall  FixBrushOrgEx(HDC,int,int,LPPOINT);
 __declspec(dllimport)  BOOL   __stdcall  UnrealizeObject(HGDIOBJ);

 __declspec(dllimport)  BOOL   __stdcall  GdiFlush();
 __declspec(dllimport)  DWORD  __stdcall  GdiSetBatchLimit(DWORD);
 __declspec(dllimport)  DWORD  __stdcall  GdiGetBatchLimit();

 





int  __stdcall  SetICMMode(HDC, int);
BOOL  __stdcall  CheckColorsInGamut(HDC,LPVOID,LPVOID,DWORD);
HANDLE  __stdcall  GetColorSpace(HDC);
BOOL  __stdcall  GetLogColorSpaceA(HCOLORSPACE,LPLOGCOLORSPACEA,DWORD);
BOOL  __stdcall  GetLogColorSpaceW(HCOLORSPACE,LPLOGCOLORSPACEW,DWORD);
#line 3045 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
HCOLORSPACE  __stdcall  CreateColorSpaceA(LPLOGCOLORSPACEA);
HCOLORSPACE  __stdcall  CreateColorSpaceW(LPLOGCOLORSPACEW);
#line 3052 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
BOOL  __stdcall  SetColorSpace(HDC,HCOLORSPACE);
BOOL  __stdcall  DeleteColorSpace(HCOLORSPACE);
BOOL  __stdcall  GetICMProfileA(HDC,LPDWORD,LPSTR);
BOOL  __stdcall  GetICMProfileW(HDC,LPDWORD,LPWSTR);
#line 3061 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
BOOL  __stdcall  SetICMProfileA(HDC,LPSTR);
BOOL  __stdcall  SetICMProfileW(HDC,LPWSTR);
#line 3068 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
BOOL  __stdcall  GetDeviceGammaRamp(HDC,LPVOID);
BOOL  __stdcall  SetDeviceGammaRamp(HDC,LPVOID);
BOOL  __stdcall  ColorMatchToTarget(HDC,HDC,DWORD);
BOOL  __stdcall  UpdateICMRegKeyA(DWORD, DWORD, LPSTR, UINT);
BOOL  __stdcall  UpdateICMRegKeyW(DWORD, DWORD, LPWSTR, UINT);
#line 3078 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
typedef int ( __stdcall * ICMENUMPROCA)(LPSTR, LPARAM);
typedef int ( __stdcall * ICMENUMPROCW)(LPWSTR, LPARAM);
#line 3085 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
int  __stdcall  EnumICMProfilesA(HDC,ICMENUMPROCA,LPARAM);
int  __stdcall  EnumICMProfilesW(HDC,ICMENUMPROCW,LPARAM);
#line 3092 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE

/* WINVER >= 0x0400 */


// Enhanced metafile constants.



// Stock object flag used in the object handle index in the enhanced
// metafile records.
// E.g. The object handle index (META_STOCK_OBJECT | BLACK_BRUSH)
// represents the stock object BLACK_BRUSH.



// Enhanced metafile record types.


































































































 




/* WINVER >= 0x0400 */



 

#line 3222 "C:\WATCOM\H\NT\wingdi.h"

// Base record type for the enhanced metafile.

typedef struct tagEMR
{
    DWORD   iType;              // Enhanced metafile record type 
    DWORD   nSize;              // Length of the record in bytes. 
                                // This must be a multiple of 4.
} EMR, *PEMR;

// Base text record type for the enhanced metafile.

typedef struct tagEMRTEXT
{
    POINTL  ptlReference;
    DWORD   nChars;
    DWORD   offString;          // Offset to the string 
    DWORD   fOptions;
    RECTL   rcl;
    DWORD   offDx;              // Offset to the inter-character spacing array. 
                                // This is always given.
} EMRTEXT, *PEMRTEXT;

// Record structures for the enhanced metafile.

typedef struct tagABORTPATH
{
    EMR     emr;
} EMRABORTPATH,      *PEMRABORTPATH,
  EMRBEGINPATH,      *PEMRBEGINPATH,
  EMRENDPATH,        *PEMRENDPATH,
  EMRCLOSEFIGURE,    *PEMRCLOSEFIGURE,
  EMRFLATTENPATH,    *PEMRFLATTENPATH,
  EMRWIDENPATH,      *PEMRWIDENPATH,
  EMRSETMETARGN,     *PEMRSETMETARGN,
  EMRSAVEDC,         *PEMRSAVEDC,
  EMRREALIZEPALETTE, *PEMRREALIZEPALETTE;

typedef struct tagEMRSELECTCLIPPATH
{
    EMR     emr;
    DWORD   iMode;
} EMRSELECTCLIPPATH,    *PEMRSELECTCLIPPATH,
  EMRSETBKMODE,         *PEMRSETBKMODE,
  EMRSETMAPMODE,        *PEMRSETMAPMODE,
  EMRSETPOLYFILLMODE,   *PEMRSETPOLYFILLMODE,
  EMRSETROP2,           *PEMRSETROP2,
  EMRSETSTRETCHBLTMODE, *PEMRSETSTRETCHBLTMODE,
  EMRSETICMMODE,	*PEMRSETICMMODE,
  EMRSETTEXTALIGN,      *PEMRSETTEXTALIGN;

typedef struct tagEMRSETMITERLIMIT
{
    EMR     emr;
    FLOAT   eMiterLimit;
} EMRSETMITERLIMIT, *PEMRSETMITERLIMIT;

typedef struct tagEMRRESTOREDC
{
    EMR     emr;
    LONG    iRelative;          // Specifies a relative instance 
} EMRRESTOREDC, *PEMRRESTOREDC;

typedef struct tagEMRSETARCDIRECTION
{
    EMR     emr;
    DWORD   iArcDirection;      // Specifies the arc direction in the 
                                // advanced graphics mode.
} EMRSETARCDIRECTION, *PEMRSETARCDIRECTION;

typedef struct tagEMRSETMAPPERFLAGS
{
    EMR     emr;
    DWORD   dwFlags;
} EMRSETMAPPERFLAGS, *PEMRSETMAPPERFLAGS;

typedef struct tagEMRSETTEXTCOLOR
{
    EMR     emr;
    COLORREF crColor;
} EMRSETBKCOLOR,   *PEMRSETBKCOLOR,
  EMRSETTEXTCOLOR, *PEMRSETTEXTCOLOR;

typedef struct tagEMRSELECTOBJECT
{
    EMR     emr;
    DWORD   ihObject;           // Object handle index 
} EMRSELECTOBJECT, *PEMRSELECTOBJECT,
  EMRDELETEOBJECT, *PEMRDELETEOBJECT;

 
typedef struct tagEMRSELECTCOLORSPACE
{
    EMR     emr;
    DWORD   ihCS;               // ColorSpace handle index 
} EMRSELECTCOLORSPACE, *PEMRSELECTCOLORSPACE,
  EMRDELETECOLORSPACE, *PEMRDELETECOLORSPACE;
/* WINVER >= 0x0400 */

typedef struct tagEMRSELECTPALETTE
{
    EMR     emr;
    DWORD   ihPal;              // Palette handle index, background mode only 
} EMRSELECTPALETTE, *PEMRSELECTPALETTE;

typedef struct tagEMRRESIZEPALETTE
{
    EMR     emr;
    DWORD   ihPal;              // Palette handle index 
    DWORD   cEntries;
} EMRRESIZEPALETTE, *PEMRRESIZEPALETTE;

typedef struct tagEMRSETPALETTEENTRIES
{
    EMR     emr;
    DWORD   ihPal;              // Palette handle index 
    DWORD   iStart;
    DWORD   cEntries;
    PALETTEENTRY aPalEntries[1];// The peFlags fields do not contain any flags 
} EMRSETPALETTEENTRIES, *PEMRSETPALETTEENTRIES;

typedef struct tagEMRSETCOLORADJUSTMENT
{
    EMR     emr;
    COLORADJUSTMENT ColorAdjustment;
} EMRSETCOLORADJUSTMENT, *PEMRSETCOLORADJUSTMENT;

typedef struct tagEMRGDICOMMENT
{
    EMR     emr;
    DWORD   cbData;             // Size of data in bytes 
    BYTE    Data[1];
} EMRGDICOMMENT, *PEMRGDICOMMENT;

typedef struct tagEMREOF
{
    EMR     emr;
    DWORD   nPalEntries;        // Number of palette entries 
    DWORD   offPalEntries;      // Offset to the palette entries 
    DWORD   nSizeLast;          // Same as nSize and must be the last DWORD 
                                // of the record.  The palette entries,
                                // if exist, precede this field.
} EMREOF, *PEMREOF;

typedef struct tagEMRLINETO
{
    EMR     emr;
    POINTL  ptl;
} EMRLINETO,   *PEMRLINETO,
  EMRMOVETOEX, *PEMRMOVETOEX;

typedef struct tagEMROFFSETCLIPRGN
{
    EMR     emr;
    POINTL  ptlOffset;
} EMROFFSETCLIPRGN, *PEMROFFSETCLIPRGN;

typedef struct tagEMRFILLPATH
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units 
} EMRFILLPATH,          *PEMRFILLPATH,
  EMRSTROKEANDFILLPATH, *PEMRSTROKEANDFILLPATH,
  EMRSTROKEPATH,        *PEMRSTROKEPATH;

typedef struct tagEMREXCLUDECLIPRECT
{
    EMR     emr;
    RECTL   rclClip;
} EMREXCLUDECLIPRECT,   *PEMREXCLUDECLIPRECT,
  EMRINTERSECTCLIPRECT, *PEMRINTERSECTCLIPRECT;

typedef struct tagEMRSETVIEWPORTORGEX
{
    EMR     emr;
    POINTL  ptlOrigin;
} EMRSETVIEWPORTORGEX, *PEMRSETVIEWPORTORGEX,
  EMRSETWINDOWORGEX,   *PEMRSETWINDOWORGEX,
  EMRSETBRUSHORGEX,    *PEMRSETBRUSHORGEX;

typedef struct tagEMRSETVIEWPORTEXTEX
{
    EMR     emr;
    SIZEL   szlExtent;
} EMRSETVIEWPORTEXTEX, *PEMRSETVIEWPORTEXTEX,
  EMRSETWINDOWEXTEX,   *PEMRSETWINDOWEXTEX;

typedef struct tagEMRSCALEVIEWPORTEXTEX
{
    EMR     emr;
    LONG    xNum;
    LONG    xDenom;
    LONG    yNum;
    LONG    yDenom;
} EMRSCALEVIEWPORTEXTEX, *PEMRSCALEVIEWPORTEXTEX,
  EMRSCALEWINDOWEXTEX,   *PEMRSCALEWINDOWEXTEX;

typedef struct tagEMRSETWORLDTRANSFORM
{
    EMR     emr;
    XFORM   xform;
} EMRSETWORLDTRANSFORM, *PEMRSETWORLDTRANSFORM;

typedef struct tagEMRMODIFYWORLDTRANSFORM
{
    EMR     emr;
    XFORM   xform;
    DWORD   iMode;
} EMRMODIFYWORLDTRANSFORM, *PEMRMODIFYWORLDTRANSFORM;

typedef struct tagEMRSETPIXELV
{
    EMR     emr;
    POINTL  ptlPixel;
    COLORREF crColor;
} EMRSETPIXELV, *PEMRSETPIXELV;

typedef struct tagEMREXTFLOODFILL
{
    EMR     emr;
    POINTL  ptlStart;
    COLORREF crColor;
    DWORD   iMode;
} EMREXTFLOODFILL, *PEMREXTFLOODFILL;

typedef struct tagEMRELLIPSE
{
    EMR     emr;
    RECTL   rclBox;             // Inclusive-inclusive bounding rectangle 
} EMRELLIPSE,  *PEMRELLIPSE,
  EMRRECTANGLE, *PEMRRECTANGLE;

typedef struct tagEMRROUNDRECT
{
    EMR     emr;
    RECTL   rclBox;             // Inclusive-inclusive bounding rectangle 
    SIZEL   szlCorner;
} EMRROUNDRECT, *PEMRROUNDRECT;

typedef struct tagEMRARC
{
    EMR     emr;
    RECTL   rclBox;             // Inclusive-inclusive bounding rectangle 
    POINTL  ptlStart;
    POINTL  ptlEnd;
} EMRARC,   *PEMRARC,
  EMRARCTO, *PEMRARCTO,
  EMRCHORD, *PEMRCHORD,
  EMRPIE,   *PEMRPIE;

typedef struct tagEMRANGLEARC
{
    EMR     emr;
    POINTL  ptlCenter;
    DWORD   nRadius;
    FLOAT   eStartAngle;
    FLOAT   eSweepAngle;
} EMRANGLEARC, *PEMRANGLEARC;

typedef struct tagEMRPOLYLINE
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units 
    DWORD   cptl;
    POINTL  aptl[1];
} EMRPOLYLINE,     *PEMRPOLYLINE,
  EMRPOLYBEZIER,   *PEMRPOLYBEZIER,
  EMRPOLYGON,      *PEMRPOLYGON,
  EMRPOLYBEZIERTO, *PEMRPOLYBEZIERTO,
  EMRPOLYLINETO,   *PEMRPOLYLINETO;

typedef struct tagEMRPOLYLINE16
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units 
    DWORD   cpts;
    POINTS  apts[1];
} EMRPOLYLINE16,     *PEMRPOLYLINE16,
  EMRPOLYBEZIER16,   *PEMRPOLYBEZIER16,
  EMRPOLYGON16,      *PEMRPOLYGON16,
  EMRPOLYBEZIERTO16, *PEMRPOLYBEZIERTO16,
  EMRPOLYLINETO16,   *PEMRPOLYLINETO16;

typedef struct tagEMRPOLYDRAW
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units 
    DWORD   cptl;               // Number of points 
    POINTL  aptl[1];            // Array of points 
    BYTE    abTypes[1];         // Array of point types 
} EMRPOLYDRAW, *PEMRPOLYDRAW;

typedef struct tagEMRPOLYDRAW16
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units 
    DWORD   cpts;               // Number of points 
    POINTS  apts[1];            // Array of points 
    BYTE    abTypes[1];         // Array of point types 
} EMRPOLYDRAW16, *PEMRPOLYDRAW16;

typedef struct tagEMRPOLYPOLYLINE
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units 
    DWORD   nPolys;             // Number of polys 
    DWORD   cptl;               // Total number of points in all polys 
    DWORD   aPolyCounts[1];     // Array of point counts for each poly 
    POINTL  aptl[1];            // Array of points 
} EMRPOLYPOLYLINE, *PEMRPOLYPOLYLINE,
  EMRPOLYPOLYGON,  *PEMRPOLYPOLYGON;

typedef struct tagEMRPOLYPOLYLINE16
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units 
    DWORD   nPolys;             // Number of polys 
    DWORD   cpts;               // Total number of points in all polys 
    DWORD   aPolyCounts[1];     // Array of point counts for each poly 
    POINTS  apts[1];            // Array of points 
} EMRPOLYPOLYLINE16, *PEMRPOLYPOLYLINE16,
  EMRPOLYPOLYGON16,  *PEMRPOLYPOLYGON16;

typedef struct tagEMRINVERTRGN
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units 
    DWORD   cbRgnData;          // Size of region data in bytes 
    BYTE    RgnData[1];
} EMRINVERTRGN, *PEMRINVERTRGN,
  EMRPAINTRGN,  *PEMRPAINTRGN;

typedef struct tagEMRFILLRGN
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units 
    DWORD   cbRgnData;          // Size of region data in bytes 
    DWORD   ihBrush;            // Brush handle index 
    BYTE    RgnData[1];
} EMRFILLRGN, *PEMRFILLRGN;

typedef struct tagEMRFRAMERGN
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units 
    DWORD   cbRgnData;          // Size of region data in bytes 
    DWORD   ihBrush;            // Brush handle index 
    SIZEL   szlStroke;
    BYTE    RgnData[1];
} EMRFRAMERGN, *PEMRFRAMERGN;

typedef struct tagEMREXTSELECTCLIPRGN
{
    EMR     emr;
    DWORD   cbRgnData;          // Size of region data in bytes 
    DWORD   iMode;
    BYTE    RgnData[1];
} EMREXTSELECTCLIPRGN, *PEMREXTSELECTCLIPRGN;

typedef struct tagEMREXTTEXTOUTA
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units 
    DWORD   iGraphicsMode;      // Current graphics mode 
    FLOAT   exScale;            // X and Y scales from Page units to .01mm units 
    FLOAT   eyScale;            //   if graphics mode is GM_COMPATIBLE. 
    EMRTEXT emrtext;            // This is followed by the string and spacing 
                                // array
} EMREXTTEXTOUTA, *PEMREXTTEXTOUTA,
  EMREXTTEXTOUTW, *PEMREXTTEXTOUTW;

typedef struct tagEMRPOLYTEXTOUTA
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units 
    DWORD   iGraphicsMode;      // Current graphics mode 
    FLOAT   exScale;            // X and Y scales from Page units to .01mm units 
    FLOAT   eyScale;            //   if graphics mode is GM_COMPATIBLE. 
    LONG    cStrings;
    EMRTEXT aemrtext[1];        // Array of EMRTEXT structures.  This is 
                                // followed by the strings and spacing arrays.
} EMRPOLYTEXTOUTA, *PEMRPOLYTEXTOUTA,
  EMRPOLYTEXTOUTW, *PEMRPOLYTEXTOUTW;

typedef struct tagEMRBITBLT
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units 
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           // Source DC transform 
    COLORREF crBkColorSrc;      // Source DC BkColor in RGB 
    DWORD   iUsageSrc;          // Source bitmap info color table usage 
                                // (DIB_RGB_COLORS)
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure 
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure 
    DWORD   offBitsSrc;         // Offset to the source bitmap bits 
    DWORD   cbBitsSrc;          // Size of the source bitmap bits 
} EMRBITBLT, *PEMRBITBLT;

typedef struct tagEMRSTRETCHBLT
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units 
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           // Source DC transform 
    COLORREF crBkColorSrc;      // Source DC BkColor in RGB 
    DWORD   iUsageSrc;          // Source bitmap info color table usage 
                                // (DIB_RGB_COLORS)
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure 
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure 
    DWORD   offBitsSrc;         // Offset to the source bitmap bits 
    DWORD   cbBitsSrc;          // Size of the source bitmap bits 
    LONG    cxSrc;
    LONG    cySrc;
} EMRSTRETCHBLT, *PEMRSTRETCHBLT;

typedef struct tagEMRMASKBLT
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units 
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           // Source DC transform 
    COLORREF crBkColorSrc;      // Source DC BkColor in RGB 
    DWORD   iUsageSrc;          // Source bitmap info color table usage 
                                // (DIB_RGB_COLORS)
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure 
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure 
    DWORD   offBitsSrc;         // Offset to the source bitmap bits 
    DWORD   cbBitsSrc;          // Size of the source bitmap bits 
    LONG    xMask;
    LONG    yMask;
    DWORD   iUsageMask;         // Mask bitmap info color table usage 
    DWORD   offBmiMask;         // Offset to the mask BITMAPINFO structure if any 
    DWORD   cbBmiMask;          // Size of the mask BITMAPINFO structure if any 
    DWORD   offBitsMask;        // Offset to the mask bitmap bits if any 
    DWORD   cbBitsMask;         // Size of the mask bitmap bits if any 
} EMRMASKBLT, *PEMRMASKBLT;

typedef struct tagEMRPLGBLT
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units 
    POINTL  aptlDest[3];
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    XFORM   xformSrc;           // Source DC transform 
    COLORREF crBkColorSrc;      // Source DC BkColor in RGB 
    DWORD   iUsageSrc;          // Source bitmap info color table usage 
                                // (DIB_RGB_COLORS)
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure 
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure 
    DWORD   offBitsSrc;         // Offset to the source bitmap bits 
    DWORD   cbBitsSrc;          // Size of the source bitmap bits 
    LONG    xMask;
    LONG    yMask;
    DWORD   iUsageMask;         // Mask bitmap info color table usage 
    DWORD   offBmiMask;         // Offset to the mask BITMAPINFO structure if any 
    DWORD   cbBmiMask;          // Size of the mask BITMAPINFO structure if any 
    DWORD   offBitsMask;        // Offset to the mask bitmap bits if any 
    DWORD   cbBitsMask;         // Size of the mask bitmap bits if any 
} EMRPLGBLT, *PEMRPLGBLT;

typedef struct tagEMRSETDIBITSTODEVICE
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units 
    LONG    xDest;
    LONG    yDest;
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure 
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure 
    DWORD   offBitsSrc;         // Offset to the source bitmap bits 
    DWORD   cbBitsSrc;          // Size of the source bitmap bits 
    DWORD   iUsageSrc;          // Source bitmap info color table usage 
    DWORD   iStartScan;
    DWORD   cScans;
} EMRSETDIBITSTODEVICE, *PEMRSETDIBITSTODEVICE;

typedef struct tagEMRSTRETCHDIBITS
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units 
    LONG    xDest;
    LONG    yDest;
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure 
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure 
    DWORD   offBitsSrc;         // Offset to the source bitmap bits 
    DWORD   cbBitsSrc;          // Size of the source bitmap bits 
    DWORD   iUsageSrc;          // Source bitmap info color table usage 
    DWORD   dwRop;
    LONG    cxDest;
    LONG    cyDest;
} EMRSTRETCHDIBITS, *PEMRSTRETCHDIBITS;

typedef struct tagEMREXTCREATEFONTINDIRECTW
{
    EMR     emr;
    DWORD   ihFont;             // Font handle index 
    EXTLOGFONTW elfw;
} EMREXTCREATEFONTINDIRECTW, *PEMREXTCREATEFONTINDIRECTW;

typedef struct tagEMRCREATEPALETTE
{
    EMR     emr;
    DWORD   ihPal;              // Palette handle index 
    LOGPALETTE lgpl;            // The peFlags fields in the palette entries 
                                // do not contain any flags
} EMRCREATEPALETTE, *PEMRCREATEPALETTE;

 

typedef struct tagEMRCREATECOLORSPACE
{
    EMR 	    emr;
    DWORD	    ihCS;	// ColorSpace handle index 
    LOGCOLORSPACEW  lcs;
} EMRCREATECOLORSPACE, *PEMRCREATECOLORSPACE;

/* WINVER >= 0x0400 */

typedef struct tagEMRCREATEPEN
{
    EMR     emr;
    DWORD   ihPen;              // Pen handle index 
    LOGPEN  lopn;
} EMRCREATEPEN, *PEMRCREATEPEN;

typedef struct tagEMREXTCREATEPEN
{
    EMR     emr;
    DWORD   ihPen;              // Pen handle index 
    DWORD   offBmi;             // Offset to the BITMAPINFO structure if any 
    DWORD   cbBmi;              // Size of the BITMAPINFO structure if any 
                                // The bitmap info is followed by the bitmap
                                // bits to form a packed DIB.
    DWORD   offBits;            // Offset to the brush bitmap bits if any 
    DWORD   cbBits;             // Size of the brush bitmap bits if any 
    EXTLOGPEN elp;              // The extended pen with the style array. 
} EMREXTCREATEPEN, *PEMREXTCREATEPEN;

typedef struct tagEMRCREATEBRUSHINDIRECT
{
    EMR     emr;
    DWORD   ihBrush;            // Brush handle index 
    LOGBRUSH lb;                // The style must be BS_SOLID, BS_HOLLOW, 
                                // BS_NULL or BS_HATCHED.
} EMRCREATEBRUSHINDIRECT, *PEMRCREATEBRUSHINDIRECT;

typedef struct tagEMRCREATEMONOBRUSH
{
    EMR     emr;
    DWORD   ihBrush;            // Brush handle index 
    DWORD   iUsage;             // Bitmap info color table usage 
    DWORD   offBmi;             // Offset to the BITMAPINFO structure 
    DWORD   cbBmi;              // Size of the BITMAPINFO structure 
    DWORD   offBits;            // Offset to the bitmap bits 
    DWORD   cbBits;             // Size of the bitmap bits 
} EMRCREATEMONOBRUSH, *PEMRCREATEMONOBRUSH;

typedef struct tagEMRCREATEDIBPATTERNBRUSHPT
{
    EMR     emr;
    DWORD   ihBrush;            // Brush handle index 
    DWORD   iUsage;             // Bitmap info color table usage 
    DWORD   offBmi;             // Offset to the BITMAPINFO structure 
    DWORD   cbBmi;              // Size of the BITMAPINFO structure 
                                // The bitmap info is followed by the bitmap
                                // bits to form a packed DIB.
    DWORD   offBits;            // Offset to the bitmap bits 
    DWORD   cbBits;             // Size of the bitmap bits 
} EMRCREATEDIBPATTERNBRUSHPT, *PEMRCREATEDIBPATTERNBRUSHPT;

typedef struct tagEMRFORMAT
{
    DWORD   dSignature;         // Format signature, e.g. ENHMETA_SIGNATURE. 
    DWORD   nVersion;           // Format version number. 
    DWORD   cbData;             // Size of data in bytes. 
    DWORD   offData;            // Offset to data from GDICOMMENT_IDENTIFIER. 
                                // It must begin at a DWORD offset.
} EMRFORMAT, *PEMRFORMAT;









/* NOMETAFILE */


// OpenGL wgl prototypes

 __declspec(dllimport)  HGLRC  __stdcall  wglCreateContext(HDC);
 __declspec(dllimport)  BOOL   __stdcall  wglDeleteContext(HGLRC);
 __declspec(dllimport)  HGLRC  __stdcall  wglGetCurrentContext( void );
 __declspec(dllimport)  HDC    __stdcall  wglGetCurrentDC( void );
 __declspec(dllimport)  PROC   __stdcall  wglGetProcAddress(LPCSTR);
 __declspec(dllimport)  BOOL   __stdcall  wglMakeCurrent(HDC, HGLRC);
 __declspec(dllimport)  BOOL   __stdcall  wglShareLists(HGLRC, HGLRC);
 __declspec(dllimport)  BOOL   __stdcall  wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD);
 __declspec(dllimport)  BOOL   __stdcall  wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD);
#line 3855 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE
 __declspec(dllimport)  BOOL   __stdcall  SwapBuffers(HDC);

typedef struct _POINTFLOAT {
    FLOAT   x;
    FLOAT   y;
} POINTFLOAT, *PPOINTFLOAT;

typedef struct _GLYPHMETRICSFLOAT {
    FLOAT       gmfBlackBoxX;
    FLOAT       gmfBlackBoxY;
    POINTFLOAT  gmfptGlyphOrigin;
    FLOAT       gmfCellIncX;
    FLOAT       gmfCellIncY;
} GLYPHMETRICSFLOAT, *PGLYPHMETRICSFLOAT,    *LPGLYPHMETRICSFLOAT;



 __declspec(dllimport)  BOOL   __stdcall  wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT,
                                           FLOAT, int, LPGLYPHMETRICSFLOAT);
 __declspec(dllimport)  BOOL   __stdcall  wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT,
                                           FLOAT, int, LPGLYPHMETRICSFLOAT);
#line 3881 "C:\WATCOM\H\NT\wingdi.h"

// !UNICODE


/* NOGDI */


}





/* _WINGDI_ */
#line 159 "C:\WATCOM\H\NT\windows.h"

#line 1 "C:\WATCOM\H\NT\winuser.h"
/****************************************************************************
*                                                                           *
* winuser.h -- USER procedure declarations, constant definitions and macros *
*                                                                           *
* Copyright (c) 1985-1995, Microsoft Corp. All rights reserved.             *
*                                                                           *
****************************************************************************/




//
// Define API decoration for direct importing of DLL references.
//



#line 21 "C:\WATCOM\H\NT\winuser.h"


extern "C" {
/* __cplusplus */

/* !WINVER */#line 29 "C:\WATCOM\H\NT\winuser.h"

#line 1 "C:\WATCOM\H\stdarg.h"
/*
 *  stdarg.h	Variable argument macros
 *		definitions for use with variable argument lists
 *
 *  Copyright by WATCOM International Corp. 1988-1996.  All rights reserved.
 */
#line 48 "C:\WATCOM\H\stdarg.h"
#line 30 "C:\WATCOM\H\NT\winuser.h"




typedef HANDLE HDWP;
typedef  void  MENUTEMPLATEA;
typedef  void  MENUTEMPLATEW;
#line 40 "C:\WATCOM\H\NT\winuser.h"
typedef MENUTEMPLATEA MENUTEMPLATE;
// UNICODE
typedef PVOID LPMENUTEMPLATEA;
typedef PVOID LPMENUTEMPLATEW;
#line 47 "C:\WATCOM\H\NT\winuser.h"
typedef LPMENUTEMPLATEA LPMENUTEMPLATE;
// UNICODE

typedef LRESULT ( __stdcall * WNDPROC)(HWND, UINT, WPARAM, LPARAM);

/* !STRICT */#line 74 "C:\WATCOM\H\NT\winuser.h"

typedef FARPROC DLGPROC;
typedef FARPROC TIMERPROC;
typedef FARPROC GRAYSTRINGPROC;
typedef FARPROC WNDENUMPROC;
typedef FARPROC HOOKPROC;
typedef FARPROC SENDASYNCPROC;

typedef FARPROC EDITWORDBREAKPROCA;
typedef FARPROC EDITWORDBREAKPROCW;

typedef FARPROC PROPENUMPROCA;
typedef FARPROC PROPENUMPROCW;

typedef FARPROC PROPENUMPROCEXA;
typedef FARPROC PROPENUMPROCEXW;

 
typedef FARPROC DRAWSTATEPROC;
/* WINVER >= 0x0400 */
/* !STRICT */

/* !UNICODE */#line 101 "C:\WATCOM\H\NT\winuser.h"
typedef PROPENUMPROCA        PROPENUMPROC;
typedef PROPENUMPROCEXA      PROPENUMPROCEX;
typedef EDITWORDBREAKPROCA   EDITWORDBREAKPROC;
/* UNICODE */

/* !STRICT */#line 117 "C:\WATCOM\H\NT\winuser.h"

typedef FARPROC NAMEENUMPROCA;
typedef FARPROC NAMEENUMPROCW;
typedef FARPROC WINSTAENUMPROCA;
typedef FARPROC DESKTOPENUMPROCA;
typedef FARPROC WINSTAENUMPROCW;
typedef FARPROC DESKTOPENUMPROCW;

/* !STRICT */

/* !UNICODE */#line 131 "C:\WATCOM\H\NT\winuser.h"
typedef WINSTAENUMPROCA     WINSTAENUMPROC;
typedef DESKTOPENUMPROCA    DESKTOPENUMPROC;
/* UNICODE */



#line 140 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE



/*
 * Predefined Resource Types
 */

















 


/* WINVER >= 0x0400 */

/* !NORESOURCE */


 __declspec(dllimport) 
int
 __stdcall 
wvsprintfA(
    LPSTR,
    LPCSTR,
    /*va_list*/ char * arglist);
 __declspec(dllimport) 
int
 __stdcall 
wvsprintfW(
    LPWSTR,
    LPCWSTR,
    /*va_list*/ char * arglist);
#line 196 "C:\WATCOM\H\NT\winuser.h"

inline int wvsprintf( LPSTR __a, LPCSTR __b, va_list __c ) {
    return wvsprintfA(__a,__b,__c[0]);
}
#line 203 "C:\WATCOM\H\NT\winuser.h"
// !UNICODE
// !_M_IX86#line 225 "C:\WATCOM\H\NT\winuser.h"

 __declspec(dllimport)  int  __cdecl  wsprintfA(LPSTR, LPCSTR, ...);
 __declspec(dllimport)  int  __cdecl  wsprintfW(LPWSTR, LPCWSTR, ...);
#line 231 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE



/*
 * Scroll Bar Constants
 */





/*
 * Scroll Bar Commands
 */
















/* !NOSCROLL */



/*
 * ShowWindow() Commands
 */















/*
 * Old ShowWindow() Commands
 */






/*
 * Identifiers for the WM_SHOWWINDOW message
 */





/* !NOSHOWWINDOW */

/*
 * WM_KEYUP/DOWN/CHAR HIWORD(lParam) flags
 */









/*
 * Virtual Keys, Standard Set
 */



/* NOT contiguous with L & RBUTTON */
































/* VK_0 thru VK_9 are the same as ASCII '0' thru '9' (0x30 - 0x39) */
/* VK_A thru VK_Z are the same as ASCII 'A' thru 'Z' (0x41 - 0x5A) */

















































/*
 * VK_L* & VK_R* - left and right Alt, Ctrl and Shift virtual keys.
 * Used only as parameters to GetAsyncKeyState() and GetKeyState().
 * No other API or message will distinguish left and right keys in this way.
 */







 

/* WINVER >= 0x0400 */











/* !NOVIRTUALKEYCODES */



/*
 * SetWindowsHook() codes
 */














 

/* WINVER >= 0x0400 */
 

#line 461 "C:\WATCOM\H\NT\winuser.h"



/*
 * Hook Codes
 */








/*
 * CBT Hook Codes
 */











/*
 * HCBT_CREATEWND parameters pointed to by lParam
 */
typedef struct tagCBT_CREATEWNDA
{
    struct tagCREATESTRUCTA *lpcs;
    HWND           hwndInsertAfter;
} CBT_CREATEWNDA, *LPCBT_CREATEWNDA;
/*
 * HCBT_CREATEWND parameters pointed to by lParam
 */
typedef struct tagCBT_CREATEWNDW
{
    struct tagCREATESTRUCTW *lpcs;
    HWND           hwndInsertAfter;
} CBT_CREATEWNDW, *LPCBT_CREATEWNDW;
#line 509 "C:\WATCOM\H\NT\winuser.h"
typedef CBT_CREATEWNDA CBT_CREATEWND;
typedef LPCBT_CREATEWNDA LPCBT_CREATEWND;
// UNICODE

/*
 * HCBT_ACTIVATE structure pointed to by lParam
 */
typedef struct tagCBTACTIVATESTRUCT
{
    BOOL    fMouse;
    HWND    hWndActive;
} CBTACTIVATESTRUCT, *LPCBTACTIVATESTRUCT;

/*
 * WH_MSGFILTER Filter Proc Codes
 */











/*
 * Shell support
 */




 





/* WINVER >= 0x0400 */

/*
 * Message Structure used in Journaling
 */
typedef struct tagEVENTMSG {
    UINT    message;
    UINT    paramL;
    UINT    paramH;
    DWORD    time;
    HWND     hwnd;
} EVENTMSG, *PEVENTMSGMSG,    *NPEVENTMSGMSG,    *LPEVENTMSGMSG;

typedef struct tagEVENTMSG *PEVENTMSG,    *NPEVENTMSG,    *LPEVENTMSG;

/*
 * Message structure used by WH_CALLWNDPROC
 */
typedef struct tagCWPSTRUCT {
    LPARAM  lParam;
    WPARAM  wParam;
    UINT    message;
    HWND    hwnd;
} CWPSTRUCT, *PCWPSTRUCT,    *NPCWPSTRUCT,    *LPCWPSTRUCT;

 
/*
 * Message structure used by WH_CALLWNDPROCRET
 */
typedef struct tagCWPRETSTRUCT {
    LRESULT lResult;
    LPARAM  lParam;
    WPARAM  wParam;
    UINT    message;
    HWND    hwnd;
} CWPRETSTRUCT, *PCWPRETSTRUCT,    *NPCWPRETSTRUCT,    *LPCWPRETSTRUCT;
/* WINVER >= 0x0400 */

/*
 * Structure used by WH_DEBUG
 */
typedef struct tagDEBUGHOOKINFO
{
    DWORD   idThread;
    DWORD   idThreadInstaller;
    LPARAM  lParam;
    WPARAM  wParam;
    int     code;
} DEBUGHOOKINFO, *PDEBUGHOOKINFO,    *NPDEBUGHOOKINFO,   * LPDEBUGHOOKINFO;

/*
 * Structure used by WH_MOUSE
 */
typedef struct tagMOUSEHOOKSTRUCT {
    POINT   pt;
    HWND    hwnd;
    UINT    wHitTestCode;
    DWORD   dwExtraInfo;
} MOUSEHOOKSTRUCT,    *LPMOUSEHOOKSTRUCT, *PMOUSEHOOKSTRUCT;
 
/*
 * Structure used by WH_HARDWARE
 */
typedef struct tagHARDWAREHOOKSTRUCT {
    HWND    hwnd;
    UINT    message;
    WPARAM  wParam;
    LPARAM  lParam;
} HARDWAREHOOKSTRUCT,    *LPHARDWAREHOOKSTRUCT, *PHARDWAREHOOKSTRUCT;
/* WINVER >= 0x0400 */
/* !NOWH */

/*
 * Keyboard Layout API
 */







 


/* WINVER >= 0x0400 */

/*
 * Size of KeyboardLayoutName (number of characters), including nul terminator
 */


 __declspec(dllimport) 
HKL
 __stdcall 
LoadKeyboardLayoutA(
    LPCSTR pwszKLID,
    UINT Flags);
 __declspec(dllimport) 
HKL
 __stdcall 
LoadKeyboardLayoutW(
    LPCWSTR pwszKLID,
    UINT Flags);
#line 656 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 
 __declspec(dllimport) 
HKL
 __stdcall 
ActivateKeyboardLayout(
    HKL hkl,
    UINT Flags);
/* WINVER >= 0x0400 */#line 674 "C:\WATCOM\H\NT\winuser.h"

 
 __declspec(dllimport) 
int
 __stdcall 
ToUnicodeEx(
    UINT wVirtKey,
    UINT wScanCode,
    PBYTE lpKeyState,
    LPWSTR pwszBuff,
    int cchBuff,
    UINT wFlags,
    HKL dwhkl);
/* WINVER >= 0x0400 */

 __declspec(dllimport) 
BOOL
 __stdcall 
UnloadKeyboardLayout(
    HKL hkl);

 __declspec(dllimport) 
BOOL
 __stdcall 
GetKeyboardLayoutNameA(
    LPSTR pwszKLID);
 __declspec(dllimport) 
BOOL
 __stdcall 
GetKeyboardLayoutNameW(
    LPWSTR pwszKLID);
#line 708 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 
 __declspec(dllimport) 
int
 __stdcall 
GetKeyboardLayoutList(
	int nBuff,
	HKL    *lpList);

 __declspec(dllimport) 
HKL
 __stdcall 
GetKeyboardLayout(
    DWORD dwLayout
);
/* WINVER >= 0x0400 */


/*
 * Desktop-specific access flags
 */










/*
 * Desktop-specific control flags
 */





 __declspec(dllimport) 
HDESK
 __stdcall 
CreateDesktopA(
    LPSTR lpszDesktop,
    LPSTR lpszDevice,
    LPDEVMODEA pDevmode,
    DWORD dwFlags,
    DWORD dwDesiredAccess,
    LPSECURITY_ATTRIBUTES lpsa);
 __declspec(dllimport) 
HDESK
 __stdcall 
CreateDesktopW(
    LPWSTR lpszDesktop,
    LPWSTR lpszDevice,
    LPDEVMODEW pDevmode,
    DWORD dwFlags,
    DWORD dwDesiredAccess,
    LPSECURITY_ATTRIBUTES lpsa);
#line 772 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

/* NOGDI */
/* _WINGDI_ */

 __declspec(dllimport) 
HDESK
 __stdcall 
OpenDesktopA(
    LPSTR lpszDesktop,
    DWORD dwFlags,
    BOOL fInherit,
    DWORD dwDesiredAccess);
 __declspec(dllimport) 
HDESK
 __stdcall 
OpenDesktopW(
    LPWSTR lpszDesktop,
    DWORD dwFlags,
    BOOL fInherit,
    DWORD dwDesiredAccess);
#line 797 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
HDESK
 __stdcall 
OpenInputDesktop(
    DWORD dwFlags,
    BOOL fInherit,
    DWORD dwDesiredAccess);

 __declspec(dllimport) 
BOOL
 __stdcall 
EnumDesktopsA(
    HWINSTA hwinsta,
    DESKTOPENUMPROCA lpEnumFunc,
    LPARAM lParam);
 __declspec(dllimport) 
BOOL
 __stdcall 
EnumDesktopsW(
    HWINSTA hwinsta,
    DESKTOPENUMPROCW lpEnumFunc,
    LPARAM lParam);
#line 825 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
EnumDesktopWindows(
    HDESK hDesktop,
    WNDENUMPROC lpfn,
    LPARAM lParam);

 __declspec(dllimport) 
BOOL
 __stdcall 
SwitchDesktop(
    HDESK hDesktop);

 __declspec(dllimport) 
BOOL
 __stdcall 
SetThreadDesktop(
    HDESK hDesktop);

 __declspec(dllimport) 
BOOL
 __stdcall 
CloseDesktop(
    HDESK hDesktop);

 __declspec(dllimport) 
HDESK
 __stdcall 
GetThreadDesktop(
    DWORD dwThreadId);

/* !NODESKTOP */


/*
 * Windowstation-specific access flags
 */










/*
 * Windowstation-specific attribute flags
 */


 __declspec(dllimport) 
HWINSTA
 __stdcall 
CreateWindowStationA(
    LPSTR lpwinsta,
    DWORD dwReserved,
    DWORD dwDesiredAccess,
    LPSECURITY_ATTRIBUTES lpsa);
 __declspec(dllimport) 
HWINSTA
 __stdcall 
CreateWindowStationW(
    LPWSTR lpwinsta,
    DWORD dwReserved,
    DWORD dwDesiredAccess,
    LPSECURITY_ATTRIBUTES lpsa);
#line 900 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
HWINSTA
 __stdcall 
OpenWindowStationA(
    LPSTR lpszWinSta,
    BOOL fInherit,
    DWORD dwDesiredAccess);
 __declspec(dllimport) 
HWINSTA
 __stdcall 
OpenWindowStationW(
    LPWSTR lpszWinSta,
    BOOL fInherit,
    DWORD dwDesiredAccess);
#line 920 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
EnumWindowStationsA(
    WINSTAENUMPROCA lpEnumFunc,
    LPARAM lParam);
 __declspec(dllimport) 
BOOL
 __stdcall 
EnumWindowStationsW(
    WINSTAENUMPROCW lpEnumFunc,
    LPARAM lParam);
#line 938 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
CloseWindowStation(
    HWINSTA hWinSta);

 __declspec(dllimport) 
BOOL
 __stdcall 
SetProcessWindowStation(
    HWINSTA hWinSta);

 __declspec(dllimport) 
HWINSTA
 __stdcall 
GetProcessWindowStation(
     void );
/* !NOWINDOWSTATION */



 __declspec(dllimport) 
BOOL
 __stdcall 
SetUserObjectSecurity(
    HANDLE hObj,
    PSECURITY_INFORMATION pSIRequested,
    PSECURITY_DESCRIPTOR pSID);

 __declspec(dllimport) 
BOOL
 __stdcall 
GetUserObjectSecurity(
    HANDLE hObj,
    PSECURITY_INFORMATION pSIRequested,
    PSECURITY_DESCRIPTOR pSID,
    DWORD nLength,
    LPDWORD lpnLengthNeeded);





typedef struct tagUSEROBJECTFLAGS {
    BOOL fInherit;
    BOOL fReserved;
    DWORD dwFlags;
} USEROBJECTFLAGS, *PUSEROBJECTFLAGS;

 __declspec(dllimport) 
BOOL
 __stdcall 
GetUserObjectInformationA(
    HANDLE hObj,
    int nIndex,
    PVOID pvInfo,
    DWORD nLength,
    LPDWORD lpnLengthNeeded);
 __declspec(dllimport) 
BOOL
 __stdcall 
GetUserObjectInformationW(
    HANDLE hObj,
    int nIndex,
    PVOID pvInfo,
    DWORD nLength,
    LPDWORD lpnLengthNeeded);
#line 1011 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
SetUserObjectInformationA(
    HANDLE hObj,
    int nIndex,
    PVOID pvInfo,
    DWORD nLength);
 __declspec(dllimport) 
BOOL
 __stdcall 
SetUserObjectInformationW(
    HANDLE hObj,
    int nIndex,
    PVOID pvInfo,
    DWORD nLength);
#line 1033 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

/* !NOSECURITY */

 
typedef struct tagWNDCLASSEXA {
    UINT        cbSize;
    /* Win 3.x */
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
    /* Win 4.0 */
    HICON       hIconSm;
} WNDCLASSEXA, *PWNDCLASSEXA,    *NPWNDCLASSEXA,    *LPWNDCLASSEXA;
typedef struct tagWNDCLASSEXW {
    UINT        cbSize;
    /* Win 3.x */
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCWSTR     lpszMenuName;
    LPCWSTR     lpszClassName;
    /* Win 4.0 */
    HICON       hIconSm;
} WNDCLASSEXW, *PWNDCLASSEXW,    *NPWNDCLASSEXW,    *LPWNDCLASSEXW;
#line 1077 "C:\WATCOM\H\NT\winuser.h"
typedef WNDCLASSEXA WNDCLASSEX;
typedef PWNDCLASSEXA PWNDCLASSEX;
typedef NPWNDCLASSEXA NPWNDCLASSEX;
typedef LPWNDCLASSEXA LPWNDCLASSEX;
// UNICODE
/* WINVER >= 0x0400 */

typedef struct tagWNDCLASSA {
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
} WNDCLASSA, *PWNDCLASSA,    *NPWNDCLASSA,    *LPWNDCLASSA;
typedef struct tagWNDCLASSW {
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCWSTR     lpszMenuName;
    LPCWSTR     lpszClassName;
} WNDCLASSW, *PWNDCLASSW,    *NPWNDCLASSW,    *LPWNDCLASSW;
#line 1114 "C:\WATCOM\H\NT\winuser.h"
typedef WNDCLASSA WNDCLASS;
typedef PWNDCLASSA PWNDCLASS;
typedef NPWNDCLASSA NPWNDCLASS;
typedef LPWNDCLASSA LPWNDCLASS;
// UNICODE



/*
 * Message structure
 */
typedef struct tagMSG {
    HWND        hwnd;
    UINT        message;
    WPARAM      wParam;
    LPARAM      lParam;
    DWORD       time;
    POINT       pt;
} MSG, *PMSG,    *NPMSG,    *LPMSG;










/* !NOMSG */



/*
 * Window field offsets for GetWindowLong()
 */








/*
 * Class field offsets for GetClassLong()
 */











 

/* WINVER >= 0x0400 */

/* !NOWINOFFSETS */



/*
 * Window Messages
 */








/*
 * WM_ACTIVATE state values
 */





















 

/* WINVER >= 0x0400 */












/*
 * Struct pointed to by WM_GETMINMAXINFO lParam
 */
typedef struct tagMINMAXINFO {
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO, *PMINMAXINFO, *LPMINMAXINFO;


















/* no longer suported */




/*
 * wParam for WM_POWER window message and DRV_POWER driver notification
 */








/*
 * lParam of WM_COPYDATA message points to...
 */
typedef struct tagCOPYDATASTRUCT {
    DWORD dwData;
    DWORD cbData;
    PVOID lpData;
} COPYDATASTRUCT, *PCOPYDATASTRUCT;

 



















/* WINVER >= 0x0400 */































 




/* WINVER >= 0x0400 */








































 


typedef struct tagMDINEXTMENU
{
    HMENU   hmenuIn;
    HMENU   hmenuNext;
    HWND    hwndNext;
} MDINEXTMENU, * PMDINEXTMENU,    * LPMDINEXTMENU;















/* WINVER >= 0x0400 */






































 








/* WINVER >= 0x0400 */




 

/* WINVER >= 0x0400 */

/*
 * NOTE: All Message Numbers below 0x0400 are RESERVED.
 *
 * Private Window Messages Start Here:
 */


 
/*  wParam for WM_SIZING message  */








/* WINVER >= 0x0400 */



/*
 * WM_SYNCTASK Commands
 */



/*
 * WM_NCHITTEST and MOUSEHOOKSTRUCT Mouse Position Codes
 */


























 



/* WINVER >= 0x0400 */

/*
 * SendMessageTimeout values
 */




/* !NONCMESSAGES */

/*
 * WM_MOUSEACTIVATE Return Codes
 */





 __declspec(dllimport) 
UINT
 __stdcall 
RegisterWindowMessageA(
    LPCSTR lpString);
 __declspec(dllimport) 
UINT
 __stdcall 
RegisterWindowMessageW(
    LPCWSTR lpString);
#line 1554 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

/*
 * WM_SIZE message wParam values
 */






/*
 * Obsolete constant names
 */






/*
 * WM_WINDOWPOSCHANGING/CHANGED struct pointed to by lParam
 */
typedef struct tagWINDOWPOS {
    HWND    hwnd;
    HWND    hwndInsertAfter;
    int     x;
    int     y;
    int     cx;
    int     cy;
    UINT    flags;
} WINDOWPOS, *LPWINDOWPOS, *PWINDOWPOS;

/*
 * WM_NCCALCSIZE parameter structure
 */
typedef struct tagNCCALCSIZE_PARAMS {
    RECT       rgrc[3];
    PWINDOWPOS lppos;
} NCCALCSIZE_PARAMS, *LPNCCALCSIZE_PARAMS;

/*
 * WM_NCCALCSIZE "window valid rect" return values
 */












/*
 * Key State Masks for Mouse Messages
 */






/* !NOKEYSTATES */

/* !NOWINMESSAGES */



/*
 * Window Styles
 */









/* WS_BORDER | WS_DLGFRAME  */

















/*
 * Common Window Styles
 */













/*
 * Extended Window Styles
 */





 




















/* WINVER >= 0x0400 */

/*
 * Class styles
 */














 

/* WINVER >= 0x0400 */

/* !NOWINSTYLES */
 
/* WM_PRINT flags */







/* 3D border styles */















/* Border flags */













// For diagonal lines, the BF_RECT flags specify the end point of the
// vector bounded by the rectangle parameter.





/* Fill in the middle */
/* For softer buttons */
/* Calculate the space left over */
/* For flat rather than 3D borders */
/* For monochrome borders */

 __declspec(dllimport)  BOOL  __stdcall  DrawEdge(HDC hdc, LPRECT qrc, UINT edge, UINT grfFlags);

/* flags for DrawFrameControl */







































 __declspec(dllimport)  BOOL     __stdcall  DrawFrameControl(HDC, LPRECT, UINT, UINT);

/* flags for DrawCaption */








 __declspec(dllimport)  BOOL     __stdcall  DrawCaption(HWND, HDC,  const  RECT *, UINT);




 __declspec(dllimport)  BOOL     __stdcall  DrawAnimatedRects(HWND hwnd, int idAni,  const  RECT * lprcFrom,  const  RECT * lprcTo);

/* WINVER >= 0x0400 */



/*
 * Predefined Clipboard Formats
 */














 



/* WINVER >= 0x0400 */







/*
 * "Private" formats don't get GlobalFree()'d
 */



/*
 * "GDIOBJ" formats do get DeleteObject()'d
 */



/* !NOCLIPBOARD */

/*
 * Defines for the fVirt field of the Accelerator table structure.
 */
/* Assumed to be == TRUE */





typedef struct tagACCEL {
    BYTE   fVirt;               /* Also called the flags field */ 
    WORD   key;
    WORD   cmd;
} ACCEL, *LPACCEL;

typedef struct tagPAINTSTRUCT {
    HDC         hdc;
    BOOL        fErase;
    RECT        rcPaint;
    BOOL        fRestore;
    BOOL        fIncUpdate;
    BYTE        rgbReserved[32];
} PAINTSTRUCT, *PPAINTSTRUCT, *NPPAINTSTRUCT, *LPPAINTSTRUCT;

typedef struct tagCREATESTRUCTA {
    LPVOID      lpCreateParams;
    HINSTANCE   hInstance;
    HMENU       hMenu;
    HWND        hwndParent;
    int         cy;
    int         cx;
    int         y;
    int         x;
    LONG        style;
    LPCSTR      lpszName;
    LPCSTR      lpszClass;
    DWORD       dwExStyle;
} CREATESTRUCTA, *LPCREATESTRUCTA;
typedef struct tagCREATESTRUCTW {
    LPVOID      lpCreateParams;
    HINSTANCE   hInstance;
    HMENU       hMenu;
    HWND        hwndParent;
    int         cy;
    int         cx;
    int         y;
    int         x;
    LONG        style;
    LPCWSTR     lpszName;
    LPCWSTR     lpszClass;
    DWORD       dwExStyle;
} CREATESTRUCTW, *LPCREATESTRUCTW;
#line 1940 "C:\WATCOM\H\NT\winuser.h"
typedef CREATESTRUCTA CREATESTRUCT;
typedef LPCREATESTRUCTA LPCREATESTRUCT;
// UNICODE

typedef struct tagWINDOWPLACEMENT {
    UINT  length;
    UINT  flags;
    UINT  showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT  rcNormalPosition;
} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT *PWINDOWPLACEMENT, *LPWINDOWPLACEMENT;



 
typedef struct tagNMHDR
{
    HWND  hwndFrom;
    UINT  idFrom;
    UINT  code;         // NM_ code 
}   NMHDR;
typedef NMHDR    * LPNMHDR;

typedef struct tagSTYLESTRUCT
{
    DWORD   styleOld;
    DWORD   styleNew;
} STYLESTRUCT, * LPSTYLESTRUCT;
/* WINVER >= 0x0400 */

/*
 * Owner draw control types
 */




 

/* WINVER >= 0x0400 */

/*
 * Owner draw actions
 */




/*
 * Owner draw state
 */





 


/* WINVER >= 0x0400 */

/*
 * MEASUREITEMSTRUCT for ownerdraw
 */
typedef struct tagMEASUREITEMSTRUCT {
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    UINT       itemWidth;
    UINT       itemHeight;
    DWORD      itemData;
} MEASUREITEMSTRUCT,    *PMEASUREITEMSTRUCT,    *LPMEASUREITEMSTRUCT;

/*
 * DRAWITEMSTRUCT for ownerdraw
 */
typedef struct tagDRAWITEMSTRUCT {
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemAction;
    UINT        itemState;
    HWND        hwndItem;
    HDC         hDC;
    RECT        rcItem;
    DWORD       itemData;
} DRAWITEMSTRUCT,    *PDRAWITEMSTRUCT,    *LPDRAWITEMSTRUCT;

/*
 * DELETEITEMSTRUCT for ownerdraw
 */
typedef struct tagDELETEITEMSTRUCT {
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    HWND       hwndItem;
    UINT       itemData;
} DELETEITEMSTRUCT,    *PDELETEITEMSTRUCT,    *LPDELETEITEMSTRUCT;

/*
 * COMPAREITEMSTUCT for ownerdraw sorting
 */
typedef struct tagCOMPAREITEMSTRUCT {
    UINT        CtlType;
    UINT        CtlID;
    HWND        hwndItem;
    UINT        itemID1;
    DWORD       itemData1;
    UINT        itemID2;
    DWORD       itemData2;
    DWORD       dwLocaleId;
} COMPAREITEMSTRUCT,    *PCOMPAREITEMSTRUCT,    *LPCOMPAREITEMSTRUCT;



/*
 * Message Function Templates
 */

 __declspec(dllimport) 
BOOL
 __stdcall 
GetMessageA(
    LPMSG lpMsg,
    HWND hWnd ,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax);
 __declspec(dllimport) 
BOOL
 __stdcall 
GetMessageW(
    LPMSG lpMsg,
    HWND hWnd ,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax);
#line 2080 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
TranslateMessage(
     const  MSG *lpMsg);

 __declspec(dllimport) 
LONG
 __stdcall 
DispatchMessageA(
     const  MSG *lpMsg);
 __declspec(dllimport) 
LONG
 __stdcall 
DispatchMessageW(
     const  MSG *lpMsg);
#line 2102 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
SetMessageQueue(
    int cMessagesMax);

 __declspec(dllimport) 
BOOL
 __stdcall 
PeekMessageA(
    LPMSG lpMsg,
    HWND hWnd ,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax,
    UINT wRemoveMsg);
 __declspec(dllimport) 
BOOL
 __stdcall 
PeekMessageW(
    LPMSG lpMsg,
    HWND hWnd ,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax,
    UINT wRemoveMsg);
#line 2132 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

/*
 * PeekMessage() Options
 */




/* !NOMSG */

 __declspec(dllimport) 
BOOL
 __stdcall 
RegisterHotKey(
    HWND hWnd ,
    int id,
    UINT fsModifiers,
    UINT vk);

 __declspec(dllimport) 
BOOL
 __stdcall 
UnregisterHotKey(
    HWND hWnd,
    int id);






/* SHIFT-PRINTSCRN  */
/* PRINTSCRN        */

/* WIN_INTERNAL */#line 2176 "C:\WATCOM\H\NT\winuser.h"

 



/* WINVER >= 0x0400 */









 __declspec(dllimport) 
BOOL
 __stdcall 
ExitWindowsEx(
    UINT uFlags,
    DWORD dwReserved);

 __declspec(dllimport) 
BOOL
 __stdcall 
SwapMouseButton(
    BOOL fSwap);

 __declspec(dllimport) 
DWORD
 __stdcall 
GetMessagePos(
     void );

 __declspec(dllimport) 
LONG
 __stdcall 
GetMessageTime(
     void );

 __declspec(dllimport) 
LONG
 __stdcall 
GetMessageExtraInfo(
     void );

 
 __declspec(dllimport) 
LPARAM
 __stdcall 
SetMessageExtraInfo(
    LPARAM lParam);
/* WINVER >= 0x0400 */

 __declspec(dllimport) 
LRESULT
 __stdcall 
SendMessageA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
 __declspec(dllimport) 
LRESULT
 __stdcall 
SendMessageW(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
#line 2249 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
LRESULT
 __stdcall 
SendMessageTimeoutA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    UINT fuFlags,
    UINT uTimeout,
    LPDWORD lpdwResult);
 __declspec(dllimport) 
LRESULT
 __stdcall 
SendMessageTimeoutW(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    UINT fuFlags,
    UINT uTimeout,
    LPDWORD lpdwResult);
#line 2277 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
SendNotifyMessageA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
 __declspec(dllimport) 
BOOL
 __stdcall 
SendNotifyMessageW(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
#line 2299 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
SendMessageCallbackA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    SENDASYNCPROC lpResultCallBack,
    DWORD dwData);
 __declspec(dllimport) 
BOOL
 __stdcall 
SendMessageCallbackW(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    SENDASYNCPROC lpResultCallBack,
    DWORD dwData);
#line 2325 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 
 __declspec(dllimport)  long   __stdcall   BroadcastSystemMessage(DWORD, LPDWORD, UINT, WPARAM, LPARAM);
//Broadcast Special Message Recipient list






//Broadcast Special Message Flags








typedef struct tagBROADCASTSYSMSG
{
    UINT    uiMessage;
    WPARAM  wParam;
    LPARAM  lParam;
} BROADCASTSYSMSG;
typedef BROADCASTSYSMSG     *LPBROADCASTSYSMSG;



// Return this value to deny a query.
/* WINVER >= 0x0400 */

 __declspec(dllimport) 
BOOL
 __stdcall 
PostMessageA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
 __declspec(dllimport) 
BOOL
 __stdcall 
PostMessageW(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
#line 2378 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
PostThreadMessageA(
    DWORD idThread,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
 __declspec(dllimport) 
BOOL
 __stdcall 
PostThreadMessageW(
    DWORD idThread,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
#line 2400 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE





#line 2410 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

/*
 * Special HWND value for use with PostMessage() and SendMessage()
 */


 __declspec(dllimport) 
BOOL
 __stdcall 
AttachThreadInput(
    DWORD idAttach,
    DWORD idAttachTo,
    BOOL fAttach);

 __declspec(dllimport) 
BOOL
 __stdcall 
ReplyMessage(
    LRESULT lResult);

 __declspec(dllimport) 
BOOL
 __stdcall 
WaitMessage(
     void );

 __declspec(dllimport) 
DWORD
 __stdcall 
WaitForInputIdle(
    HANDLE hProcess,
    DWORD dwMilliseconds);

 __declspec(dllimport) 
LRESULT
 __stdcall 
DefWindowProcA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
 __declspec(dllimport) 
LRESULT
 __stdcall 
DefWindowProcW(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
#line 2464 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
 void 
 __stdcall 
PostQuitMessage(
    int nExitCode);

/* !STRICT */#line 2500 "C:\WATCOM\H\NT\winuser.h"

 __declspec(dllimport) 
LRESULT
 __stdcall 
CallWindowProcA(
    FARPROC lpPrevWndFunc,
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
 __declspec(dllimport) 
LRESULT
 __stdcall 
CallWindowProcW(
    FARPROC lpPrevWndFunc,
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
#line 2522 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

/* !STRICT */

 __declspec(dllimport) 
BOOL
 __stdcall 
InSendMessage(
     void );

 __declspec(dllimport) 
UINT
 __stdcall 
GetDoubleClickTime(
     void );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetDoubleClickTime(
    UINT);

 __declspec(dllimport) 
ATOM
 __stdcall 
RegisterClassA(
     const  WNDCLASSA *lpWndClass);
 __declspec(dllimport) 
ATOM
 __stdcall 
RegisterClassW(
     const  WNDCLASSW *lpWndClass);
#line 2558 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
UnregisterClassA(
    LPCSTR lpClassName,
    HINSTANCE hInstance);
 __declspec(dllimport) 
BOOL
 __stdcall 
UnregisterClassW(
    LPCWSTR lpClassName,
    HINSTANCE hInstance);
#line 2576 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
GetClassInfoA(
    HINSTANCE hInstance ,
    LPCSTR lpClassName,
    LPWNDCLASSA lpWndClass);
 __declspec(dllimport) 
BOOL
 __stdcall 
GetClassInfoW(
    HINSTANCE hInstance ,
    LPCWSTR lpClassName,
    LPWNDCLASSW lpWndClass);
#line 2596 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 
 __declspec(dllimport) 
ATOM
 __stdcall 
RegisterClassExA( const  WNDCLASSEXA *);
 __declspec(dllimport) 
ATOM
 __stdcall 
RegisterClassExW( const  WNDCLASSEXW *);
#line 2611 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
GetClassInfoExA(HINSTANCE, LPCSTR, LPWNDCLASSEXA);
 __declspec(dllimport) 
BOOL
 __stdcall 
GetClassInfoExW(HINSTANCE, LPCWSTR, LPWNDCLASSEXW);
#line 2625 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

/* WINVER >= 0x0400 */



/*
 * Special value for CreateWindow, et al.
 */


 __declspec(dllimport) 
HWND
 __stdcall 
CreateWindowExA(
    DWORD dwExStyle,
    LPCSTR lpClassName,
    LPCSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent ,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam);
 __declspec(dllimport) 
HWND
 __stdcall 
CreateWindowExW(
    DWORD dwExStyle,
    LPCWSTR lpClassName,
    LPCWSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent ,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam);
#line 2672 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE









#line 2686 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
IsWindow(
    HWND hWnd);

 __declspec(dllimport) 
BOOL
 __stdcall 
IsMenu(
    HMENU hMenu);

 __declspec(dllimport) 
BOOL
 __stdcall 
IsChild(
    HWND hWndParent,
    HWND hWnd);

 __declspec(dllimport) 
BOOL
 __stdcall 
DestroyWindow(
    HWND hWnd);

 __declspec(dllimport) 
BOOL
 __stdcall 
ShowWindow(
    HWND hWnd,
    int nCmdShow);

 
 __declspec(dllimport) 
BOOL
 __stdcall 
ShowWindowAsync(
    HWND hWnd,
    int nCmdShow);
/* WINVER >= 0x0400 */

 __declspec(dllimport) 
BOOL
 __stdcall 
FlashWindow(
    HWND hWnd,
    BOOL bInvert);

 __declspec(dllimport) 
BOOL
 __stdcall 
ShowOwnedPopups(
    HWND hWnd,
    BOOL fShow);

 __declspec(dllimport) 
BOOL
 __stdcall 
OpenIcon(
    HWND hWnd);

 __declspec(dllimport) 
BOOL
 __stdcall 
CloseWindow(
    HWND hWnd);

 __declspec(dllimport) 
BOOL
 __stdcall 
MoveWindow(
    HWND hWnd,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    BOOL bRepaint);

 __declspec(dllimport) 
BOOL
 __stdcall 
SetWindowPos(
    HWND hWnd,
    HWND hWndInsertAfter ,
    int X,
    int Y,
    int cx,
    int cy,
    UINT uFlags);

 __declspec(dllimport) 
BOOL
 __stdcall 
GetWindowPlacement(
    HWND hWnd,
    WINDOWPLACEMENT *lpwndpl);

 __declspec(dllimport) 
BOOL
 __stdcall 
SetWindowPlacement(
    HWND hWnd,
     const  WINDOWPLACEMENT *lpwndpl);



 __declspec(dllimport) 
HDWP
 __stdcall 
BeginDeferWindowPos(
    int nNumWindows);

 __declspec(dllimport) 
HDWP
 __stdcall 
DeferWindowPos(
    HDWP hWinPosInfo,
    HWND hWnd,
    HWND hWndInsertAfter ,
    int x,
    int y,
    int cx,
    int cy,
    UINT uFlags);

 __declspec(dllimport) 
BOOL
 __stdcall 
EndDeferWindowPos(
    HDWP hWinPosInfo);

/* !NODEFERWINDOWPOS */

 __declspec(dllimport) 
BOOL
 __stdcall 
IsWindowVisible(
    HWND hWnd);

 __declspec(dllimport) 
BOOL
 __stdcall 
IsIconic(
    HWND hWnd);

 __declspec(dllimport) 
BOOL
 __stdcall 
AnyPopup(
     void );

 __declspec(dllimport) 
BOOL
 __stdcall 
BringWindowToTop(
    HWND hWnd);

 __declspec(dllimport) 
BOOL
 __stdcall 
IsZoomed(
    HWND hWnd);

/*
 * SetWindowPos Flags
 */





/* The frame changed: send WM_NCCALCSIZE */



/* Don't do owner Z ordering */
/* Don't send WM_WINDOWPOSCHANGING */




 


/* WINVER >= 0x0400 */








/*
 * WARNING:
 * The following structures must NOT be DWORD padded because they are
 * followed by strings, etc that do not have to be DWORD aligned.
 */
#line 1 "C:\WATCOM\H\NT\pshpack2.h"
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pshpack2.h

Abstract:

    This file turns 2 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push)

#pragma pack(2)
#line 32 "C:\WATCOM\H\NT\pshpack2.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 2887 "C:\WATCOM\H\NT\winuser.h"


/*
 * original NT 32 bit dialog template:
 */
typedef struct {
    DWORD style;
    DWORD dwExtendedStyle;
    WORD cdit;
    short x;
    short y;
    short cx;
    short cy;
} DLGTEMPLATE;
typedef DLGTEMPLATE *LPDLGTEMPLATEA;
typedef DLGTEMPLATE *LPDLGTEMPLATEW;
#line 2906 "C:\WATCOM\H\NT\winuser.h"
typedef LPDLGTEMPLATEA LPDLGTEMPLATE;
// UNICODE
typedef  const  DLGTEMPLATE *LPCDLGTEMPLATEA;
typedef  const  DLGTEMPLATE *LPCDLGTEMPLATEW;
#line 2913 "C:\WATCOM\H\NT\winuser.h"
typedef LPCDLGTEMPLATEA LPCDLGTEMPLATE;
// UNICODE

/*
 * 32 bit Dialog item template.
 */
typedef struct {
    DWORD style;
    DWORD dwExtendedStyle;
    short x;
    short y;
    short cx;
    short cy;
    WORD id;
} DLGITEMTEMPLATE;
typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEA;
typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEW;
#line 2933 "C:\WATCOM\H\NT\winuser.h"
typedef PDLGITEMTEMPLATEA PDLGITEMTEMPLATE;
// UNICODE
typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEA;
typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEW;
#line 2940 "C:\WATCOM\H\NT\winuser.h"
typedef LPDLGITEMTEMPLATEA LPDLGITEMTEMPLATE;
// UNICODE

#line 1 "C:\WATCOM\H\NT\poppack.h"
/*++

Copyright (c) 1990,95  Microsoft Corporation

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)
#line 33 "C:\WATCOM\H\NT\poppack.h"
#line 36 "C:\WATCOM\H\NT\poppack.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 2943 "C:\WATCOM\H\NT\winuser.h"
 /* Resume normal packing */

 __declspec(dllimport) 
HWND
 __stdcall 
CreateDialogParamA(
    HINSTANCE hInstance,
    LPCSTR lpTemplateName,
    HWND hWndParent ,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);
 __declspec(dllimport) 
HWND
 __stdcall 
CreateDialogParamW(
    HINSTANCE hInstance,
    LPCWSTR lpTemplateName,
    HWND hWndParent ,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);
#line 2966 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
HWND
 __stdcall 
CreateDialogIndirectParamA(
    HINSTANCE hInstance,
    LPCDLGTEMPLATEA lpTemplate,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);
 __declspec(dllimport) 
HWND
 __stdcall 
CreateDialogIndirectParamW(
    HINSTANCE hInstance,
    LPCDLGTEMPLATEW lpTemplate,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);
#line 2990 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE





#line 3000 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE





#line 3010 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
int
 __stdcall 
DialogBoxParamA(
    HINSTANCE hInstance,
    LPCSTR lpTemplateName,
    HWND hWndParent ,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);
 __declspec(dllimport) 
int
 __stdcall 
DialogBoxParamW(
    HINSTANCE hInstance,
    LPCWSTR lpTemplateName,
    HWND hWndParent ,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);
#line 3034 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
int
 __stdcall 
DialogBoxIndirectParamA(
    HINSTANCE hInstance,
    LPCDLGTEMPLATEA hDialogTemplate,
    HWND hWndParent ,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);
 __declspec(dllimport) 
int
 __stdcall 
DialogBoxIndirectParamW(
    HINSTANCE hInstance,
    LPCDLGTEMPLATEW hDialogTemplate,
    HWND hWndParent ,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);
#line 3058 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE





#line 3068 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE





#line 3078 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
EndDialog(
    HWND hDlg,
    int nResult);

 __declspec(dllimport) 
HWND
 __stdcall 
GetDlgItem(
    HWND hDlg,
    int nIDDlgItem);

 __declspec(dllimport) 
BOOL
 __stdcall 
SetDlgItemInt(
    HWND hDlg,
    int nIDDlgItem,
    UINT uValue,
    BOOL bSigned);

 __declspec(dllimport) 
UINT
 __stdcall 
GetDlgItemInt(
    HWND hDlg,
    int nIDDlgItem,
    BOOL *lpTranslated,
    BOOL bSigned);

 __declspec(dllimport) 
BOOL
 __stdcall 
SetDlgItemTextA(
    HWND hDlg,
    int nIDDlgItem,
    LPCSTR lpString);
 __declspec(dllimport) 
BOOL
 __stdcall 
SetDlgItemTextW(
    HWND hDlg,
    int nIDDlgItem,
    LPCWSTR lpString);
#line 3130 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
UINT
 __stdcall 
GetDlgItemTextA(
    HWND hDlg,
    int nIDDlgItem,
    LPSTR lpString,
    int nMaxCount);
 __declspec(dllimport) 
UINT
 __stdcall 
GetDlgItemTextW(
    HWND hDlg,
    int nIDDlgItem,
    LPWSTR lpString,
    int nMaxCount);
#line 3152 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
CheckDlgButton(
    HWND hDlg,
    int nIDButton,
    UINT uCheck);

 __declspec(dllimport) 
BOOL
 __stdcall 
CheckRadioButton(
    HWND hDlg,
    int nIDFirstButton,
    int nIDLastButton,
    int nIDCheckButton);

 __declspec(dllimport) 
UINT
 __stdcall 
IsDlgButtonChecked(
    HWND hDlg,
    int nIDButton);

 __declspec(dllimport) 
LONG
 __stdcall 
SendDlgItemMessageA(
    HWND hDlg,
    int nIDDlgItem,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
 __declspec(dllimport) 
LONG
 __stdcall 
SendDlgItemMessageW(
    HWND hDlg,
    int nIDDlgItem,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
#line 3200 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
HWND
 __stdcall 
GetNextDlgGroupItem(
    HWND hDlg,
    HWND hCtl,
    BOOL bPrevious);

 __declspec(dllimport) 
HWND
 __stdcall 
GetNextDlgTabItem(
    HWND hDlg,
    HWND hCtl,
    BOOL bPrevious);

 __declspec(dllimport) 
int
 __stdcall 
GetDlgCtrlID(
    HWND hWnd);

 __declspec(dllimport) 
long
 __stdcall 
GetDialogBaseUnits( void );

 __declspec(dllimport) 
LRESULT
 __stdcall 
DefDlgProcA(
    HWND hDlg,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
 __declspec(dllimport) 
LRESULT
 __stdcall 
DefDlgProcW(
    HWND hDlg,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
#line 3249 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

/*
 * Window extra byted needed for private dialog classes.
 */


/* !NOCTLMGR */



 __declspec(dllimport) 
BOOL
 __stdcall 
CallMsgFilterA(
    LPMSG lpMsg,
    int nCode);
 __declspec(dllimport) 
BOOL
 __stdcall 
CallMsgFilterW(
    LPMSG lpMsg,
    int nCode);
#line 3276 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

/* !NOMSG */



/*
 * Clipboard Manager Functions
 */

 __declspec(dllimport) 
BOOL
 __stdcall 
OpenClipboard(
    HWND hWndNewOwner);

 __declspec(dllimport) 
BOOL
 __stdcall 
CloseClipboard(
     void );

 __declspec(dllimport) 
HWND
 __stdcall 
GetClipboardOwner(
     void );

 __declspec(dllimport) 
HWND
 __stdcall 
SetClipboardViewer(
    HWND hWndNewViewer);

 __declspec(dllimport) 
HWND
 __stdcall 
GetClipboardViewer(
     void );

 __declspec(dllimport) 
BOOL
 __stdcall 
ChangeClipboardChain(
    HWND hWndRemove,
    HWND hWndNewNext);

 __declspec(dllimport) 
HANDLE
 __stdcall 
SetClipboardData(
    UINT uFormat,
    HANDLE hMem);

 __declspec(dllimport) 
HANDLE
 __stdcall 
    GetClipboardData(
    UINT uFormat);

 __declspec(dllimport) 
UINT
 __stdcall 
RegisterClipboardFormatA(
    LPCSTR lpszFormat);
 __declspec(dllimport) 
UINT
 __stdcall 
RegisterClipboardFormatW(
    LPCWSTR lpszFormat);
#line 3350 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
int
 __stdcall 
CountClipboardFormats(
     void );

 __declspec(dllimport) 
UINT
 __stdcall 
EnumClipboardFormats(
    UINT format);

 __declspec(dllimport) 
int
 __stdcall 
GetClipboardFormatNameA(
    UINT format,
    LPSTR lpszFormatName,
    int cchMaxCount);
 __declspec(dllimport) 
int
 __stdcall 
GetClipboardFormatNameW(
    UINT format,
    LPWSTR lpszFormatName,
    int cchMaxCount);
#line 3382 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
EmptyClipboard(
     void );

 __declspec(dllimport) 
BOOL
 __stdcall 
IsClipboardFormatAvailable(
    UINT format);

 __declspec(dllimport) 
int
 __stdcall 
GetPriorityClipboardFormat(
    UINT *paFormatPriorityList,
    int cFormats);

 __declspec(dllimport) 
HWND
 __stdcall 
GetOpenClipboardWindow(
     void );

/* !NOCLIPBOARD */

/*
 * Character Translation Routines
 */

 __declspec(dllimport) 
BOOL
 __stdcall 
CharToOemA(
    LPCSTR lpszSrc,
    LPSTR lpszDst);
 __declspec(dllimport) 
BOOL
 __stdcall 
CharToOemW(
    LPCWSTR lpszSrc,
    LPSTR lpszDst);
#line 3431 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
OemToCharA(
    LPCSTR lpszSrc,
    LPSTR lpszDst);
 __declspec(dllimport) 
BOOL
 __stdcall 
OemToCharW(
    LPCSTR lpszSrc,
    LPWSTR lpszDst);
#line 3449 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
CharToOemBuffA(
    LPCSTR lpszSrc,
    LPSTR lpszDst,
    DWORD cchDstLength);
 __declspec(dllimport) 
BOOL
 __stdcall 
CharToOemBuffW(
    LPCWSTR lpszSrc,
    LPSTR lpszDst,
    DWORD cchDstLength);
#line 3469 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
OemToCharBuffA(
    LPCSTR lpszSrc,
    LPSTR lpszDst,
    DWORD cchDstLength);
 __declspec(dllimport) 
BOOL
 __stdcall 
OemToCharBuffW(
    LPCSTR lpszSrc,
    LPWSTR lpszDst,
    DWORD cchDstLength);
#line 3489 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
LPSTR
 __stdcall 
CharUpperA(
    LPSTR lpsz);
 __declspec(dllimport) 
LPWSTR
 __stdcall 
CharUpperW(
    LPWSTR lpsz);
#line 3505 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
DWORD
 __stdcall 
CharUpperBuffA(
    LPSTR lpsz,
    DWORD cchLength);
 __declspec(dllimport) 
DWORD
 __stdcall 
CharUpperBuffW(
    LPWSTR lpsz,
    DWORD cchLength);
#line 3523 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
LPSTR
 __stdcall 
CharLowerA(
    LPSTR lpsz);
 __declspec(dllimport) 
LPWSTR
 __stdcall 
CharLowerW(
    LPWSTR lpsz);
#line 3539 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
DWORD
 __stdcall 
CharLowerBuffA(
    LPSTR lpsz,
    DWORD cchLength);
 __declspec(dllimport) 
DWORD
 __stdcall 
CharLowerBuffW(
    LPWSTR lpsz,
    DWORD cchLength);
#line 3557 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
LPSTR
 __stdcall 
CharNextA(
    LPCSTR lpsz);
 __declspec(dllimport) 
LPWSTR
 __stdcall 
CharNextW(
    LPCWSTR lpsz);
#line 3573 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
LPSTR
 __stdcall 
CharPrevA(
    LPCSTR lpszStart,
    LPCSTR lpszCurrent);
 __declspec(dllimport) 
LPWSTR
 __stdcall 
CharPrevW(
    LPCWSTR lpszStart,
    LPCWSTR lpszCurrent);
#line 3591 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 
 __declspec(dllimport) 
LPSTR
 __stdcall 
CharNextExA(
     WORD CodePage,
     LPCSTR lpCurrentChar,
     DWORD dwFlags);

 __declspec(dllimport) 
LPSTR
 __stdcall 
CharPrevExA(
     WORD CodePage,
     LPCSTR lpStart,
     LPCSTR lpCurrentChar,
     DWORD dwFlags);
/* WINVER >= 0x0400 */

/*
 * Compatibility defines for character translation routines
 */












/*
 * Language dependent Routines
 */

 __declspec(dllimport) 
BOOL
 __stdcall 
IsCharAlphaA(
    CHAR ch);
 __declspec(dllimport) 
BOOL
 __stdcall 
IsCharAlphaW(
    WCHAR ch);
#line 3645 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
IsCharAlphaNumericA(
    CHAR ch);
 __declspec(dllimport) 
BOOL
 __stdcall 
IsCharAlphaNumericW(
    WCHAR ch);
#line 3661 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
IsCharUpperA(
    CHAR ch);
 __declspec(dllimport) 
BOOL
 __stdcall 
IsCharUpperW(
    WCHAR ch);
#line 3677 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
IsCharLowerA(
    CHAR ch);
 __declspec(dllimport) 
BOOL
 __stdcall 
IsCharLowerW(
    WCHAR ch);
#line 3693 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

/* !NOLANGUAGE */

 __declspec(dllimport) 
HWND
 __stdcall 
SetFocus(
    HWND hWnd);

 __declspec(dllimport) 
HWND
 __stdcall 
GetActiveWindow(
     void );

 __declspec(dllimport) 
HWND
 __stdcall 
GetFocus(
     void );

 __declspec(dllimport) 
UINT
 __stdcall 
GetKBCodePage(
     void );

 __declspec(dllimport) 
SHORT
 __stdcall 
GetKeyState(
    int nVirtKey);

 __declspec(dllimport) 
SHORT
 __stdcall 
GetAsyncKeyState(
    int vKey);

 __declspec(dllimport) 
BOOL
 __stdcall 
GetKeyboardState(
    PBYTE lpKeyState);

 __declspec(dllimport) 
BOOL
 __stdcall 
SetKeyboardState(
    LPBYTE lpKeyState);

 __declspec(dllimport) 
int
 __stdcall 
GetKeyNameTextA(
    LONG lParam,
    LPSTR lpString,
    int nSize
    );
 __declspec(dllimport) 
int
 __stdcall 
GetKeyNameTextW(
    LONG lParam,
    LPWSTR lpString,
    int nSize
    );
#line 3765 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
int
 __stdcall 
GetKeyboardType(
    int nTypeFlag);

 __declspec(dllimport) 
int
 __stdcall 
ToAscii(
    UINT uVirtKey,
    UINT uScanCode,
    PBYTE lpKeyState,
    LPWORD lpChar,
    UINT uFlags);

 
 __declspec(dllimport) 
int
 __stdcall 
ToAsciiEx(
    UINT uVirtKey,
    UINT uScanCode,
    PBYTE lpKeyState,
    LPWORD lpChar,
    UINT uFlags,
    HKL dwhkl);
/* WINVER >= 0x0400 */

 __declspec(dllimport) 
int
 __stdcall 
ToUnicode(
    UINT wVirtKey,
    UINT wScanCode,
    PBYTE lpKeyState,
    LPWSTR pwszBuff,
    int cchBuff,
    UINT wFlags);

 __declspec(dllimport) 
DWORD
 __stdcall 
OemKeyScan(
    WORD wOemChar);

 __declspec(dllimport) 
SHORT
 __stdcall 
VkKeyScanA(
    CHAR ch);
 __declspec(dllimport) 
SHORT
 __stdcall 
VkKeyScanW(
    WCHAR ch);
#line 3827 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 
 __declspec(dllimport) 
SHORT
 __stdcall  VkKeyScanExA(
    CHAR  ch,
    HKL   dwhkl);
 __declspec(dllimport) 
SHORT
 __stdcall  VkKeyScanExW(
    WCHAR  ch,
    HKL   dwhkl);
#line 3844 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE
/* WINVER >= 0x0400 */



 __declspec(dllimport) 
 void 
 __stdcall 
keybd_event(
    BYTE bVk,
    BYTE bScan,
    DWORD dwFlags,
    DWORD dwExtraInfo);

/* mouse move */
/* left button down */
/* left button up */
/* right button down */
/* right button up */
/* middle button down */
/* middle button up */
/* absolute move */

 __declspec(dllimport) 
 void 
 __stdcall 
mouse_event(
    DWORD dwFlags,
    DWORD dx,
    DWORD dy,
    DWORD cButtons,
    DWORD dwExtraInfo);

 __declspec(dllimport) 
UINT
 __stdcall 
MapVirtualKeyA(
    UINT uCode,
    UINT uMapType);
 __declspec(dllimport) 
UINT
 __stdcall 
MapVirtualKeyW(
    UINT uCode,
    UINT uMapType);
#line 3893 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 
 __declspec(dllimport) 
UINT
 __stdcall 
MapVirtualKeyExA(
    UINT uCode,
    UINT uMapType,
    HKL dwhkl);
 __declspec(dllimport) 
UINT
 __stdcall 
MapVirtualKeyExW(
    UINT uCode,
    UINT uMapType,
    HKL dwhkl);
#line 3914 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE
/* WINVER >= 0x0400 */

 __declspec(dllimport) 
BOOL
 __stdcall 
GetInputState(
     void );

 __declspec(dllimport) 
DWORD
 __stdcall 
GetQueueStatus(
    UINT flags);

 __declspec(dllimport) 
HWND
 __stdcall 
GetCapture(
     void );

 __declspec(dllimport) 
HWND
 __stdcall 
SetCapture(
    HWND hWnd);

 __declspec(dllimport) 
BOOL
 __stdcall 
ReleaseCapture(
     void );

 __declspec(dllimport) 
DWORD
 __stdcall 
MsgWaitForMultipleObjects(
    DWORD nCount,
    LPHANDLE pHandles,
    BOOL fWaitAll,
    DWORD dwMilliseconds,
    DWORD dwWakeMask);

/*
 * Queue status flags for GetQueueStatus() and MsgWaitForMultipleObjects()
 */




























/*
 * Windows Functions
 */

 __declspec(dllimport) 
UINT
 __stdcall 
SetTimer(
    HWND hWnd ,
    UINT nIDEvent,
    UINT uElapse,
    TIMERPROC lpTimerFunc);

 __declspec(dllimport) 
BOOL
 __stdcall 
KillTimer(
    HWND hWnd,
    UINT uIDEvent);

 __declspec(dllimport) 
BOOL
 __stdcall 
IsWindowUnicode(
    HWND hWnd);

 __declspec(dllimport) 
BOOL
 __stdcall 
EnableWindow(
    HWND hWnd,
    BOOL bEnable);

 __declspec(dllimport) 
BOOL
 __stdcall 
IsWindowEnabled(
    HWND hWnd);

 __declspec(dllimport) 
HACCEL
 __stdcall 
LoadAcceleratorsA(
    HINSTANCE hInstance,
    LPCSTR lpTableName);
 __declspec(dllimport) 
HACCEL
 __stdcall 
LoadAcceleratorsW(
    HINSTANCE hInstance,
    LPCWSTR lpTableName);
#line 4043 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
HACCEL
 __stdcall 
CreateAcceleratorTableA(
    LPACCEL, int);
 __declspec(dllimport) 
HACCEL
 __stdcall 
CreateAcceleratorTableW(
    LPACCEL, int);
#line 4059 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
DestroyAcceleratorTable(
    HACCEL hAccel);

 __declspec(dllimport) 
int
 __stdcall 
CopyAcceleratorTableA(
    HACCEL hAccelSrc,
    LPACCEL lpAccelDst,
    int cAccelEntries);
 __declspec(dllimport) 
int
 __stdcall 
CopyAcceleratorTableW(
    HACCEL hAccelSrc,
    LPACCEL lpAccelDst,
    int cAccelEntries);
#line 4085 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE



 __declspec(dllimport) 
int
 __stdcall 
TranslateAcceleratorA(
    HWND hWnd,
    HACCEL hAccTable,
    LPMSG lpMsg);
 __declspec(dllimport) 
int
 __stdcall 
TranslateAcceleratorW(
    HWND hWnd,
    HACCEL hAccTable,
    LPMSG lpMsg);
#line 4107 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

/* !NOMSG */



/*
 * GetSystemMetrics() codes
 */













































 
/* ;win40 name change */
/* ;win40 name change */
/* ;win40 name change */
/* ;win40 name change */
























/* WINVER >= 0x0400 */

 
/* Use instead of GetMenuCheckMarkDimensions()! */



/* WINVER >= 0x0400 */


 __declspec(dllimport) 
int
 __stdcall 
GetSystemMetrics(
    int nIndex);

/* !NOSYSMETRICS */



 __declspec(dllimport) 
HMENU
 __stdcall 
LoadMenuA(
    HINSTANCE hInstance,
    LPCSTR lpMenuName);
 __declspec(dllimport) 
HMENU
 __stdcall 
LoadMenuW(
    HINSTANCE hInstance,
    LPCWSTR lpMenuName);
#line 4226 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
HMENU
 __stdcall 
LoadMenuIndirectA(
     const  MENUTEMPLATEA *lpMenuTemplate);
 __declspec(dllimport) 
HMENU
 __stdcall 
LoadMenuIndirectW(
     const  MENUTEMPLATEW *lpMenuTemplate);
#line 4242 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
HMENU
 __stdcall 
GetMenu(
    HWND hWnd);

 __declspec(dllimport) 
BOOL
 __stdcall 
SetMenu(
    HWND hWnd,
    HMENU hMenu);

 __declspec(dllimport) 
BOOL
 __stdcall 
ChangeMenuA(
    HMENU hMenu,
    UINT cmd,
    LPCSTR lpszNewItem,
    UINT cmdInsert,
    UINT flags);
 __declspec(dllimport) 
BOOL
 __stdcall 
ChangeMenuW(
    HMENU hMenu,
    UINT cmd,
    LPCWSTR lpszNewItem,
    UINT cmdInsert,
    UINT flags);
#line 4279 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
HiliteMenuItem(
    HWND hWnd,
    HMENU hMenu,
    UINT uIDHiliteItem,
    UINT uHilite);

 __declspec(dllimport) 
int
 __stdcall 
GetMenuStringA(
    HMENU hMenu,
    UINT uIDItem,
    LPSTR lpString,
    int nMaxCount,
    UINT uFlag);
 __declspec(dllimport) 
int
 __stdcall 
GetMenuStringW(
    HMENU hMenu,
    UINT uIDItem,
    LPWSTR lpString,
    int nMaxCount,
    UINT uFlag);
#line 4312 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
UINT
 __stdcall 
GetMenuState(
    HMENU hMenu,
    UINT uId,
    UINT uFlags);

 __declspec(dllimport) 
BOOL
 __stdcall 
DrawMenuBar(
    HWND hWnd);

 __declspec(dllimport) 
HMENU
 __stdcall 
GetSystemMenu(
    HWND hWnd,
    BOOL bRevert);

 __declspec(dllimport) 
HMENU
 __stdcall 
CreateMenu(
     void );

 __declspec(dllimport) 
HMENU
 __stdcall 
CreatePopupMenu(
     void );

 __declspec(dllimport) 
BOOL
 __stdcall 
DestroyMenu(
    HMENU hMenu);

 __declspec(dllimport) 
DWORD
 __stdcall 
CheckMenuItem(
    HMENU hMenu,
    UINT uIDCheckItem,
    UINT uCheck);

 __declspec(dllimport) 
BOOL
 __stdcall 
EnableMenuItem(
    HMENU hMenu,
    UINT uIDEnableItem,
    UINT uEnable);

 __declspec(dllimport) 
HMENU
 __stdcall 
GetSubMenu(
    HMENU hMenu,
    int nPos);

 __declspec(dllimport) 
UINT
 __stdcall 
GetMenuItemID(
    HMENU hMenu,
    int nPos);

 __declspec(dllimport) 
int
 __stdcall 
GetMenuItemCount(
    HMENU hMenu);

 __declspec(dllimport) 
BOOL
 __stdcall 
InsertMenuA(
    HMENU hMenu,
    UINT uPosition,
    UINT uFlags,
    UINT uIDNewItem,
    LPCSTR lpNewItem
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
InsertMenuW(
    HMENU hMenu,
    UINT uPosition,
    UINT uFlags,
    UINT uIDNewItem,
    LPCWSTR lpNewItem
    );
#line 4413 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
AppendMenuA(
    HMENU hMenu,
    UINT uFlags,
    UINT uIDNewItem,
    LPCSTR lpNewItem
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
AppendMenuW(
    HMENU hMenu,
    UINT uFlags,
    UINT uIDNewItem,
    LPCWSTR lpNewItem
    );
#line 4437 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
ModifyMenuA(
    HMENU hMnu,
    UINT uPosition,
    UINT uFlags,
    UINT uIDNewItem,
    LPCSTR lpNewItem
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
ModifyMenuW(
    HMENU hMnu,
    UINT uPosition,
    UINT uFlags,
    UINT uIDNewItem,
    LPCWSTR lpNewItem
    );
#line 4463 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall  RemoveMenu(
    HMENU hMenu,
    UINT uPosition,
    UINT uFlags);

 __declspec(dllimport) 
BOOL
 __stdcall 
DeleteMenu(
    HMENU hMenu,
    UINT uPosition,
    UINT uFlags);

 __declspec(dllimport) 
BOOL
 __stdcall 
SetMenuItemBitmaps(
    HMENU hMenu,
    UINT uPosition,
    UINT uFlags,
    HBITMAP hBitmapUnchecked,
    HBITMAP hBitmapChecked);

 __declspec(dllimport) 
LONG
 __stdcall 
GetMenuCheckMarkDimensions(
     void );

 __declspec(dllimport) 
BOOL
 __stdcall 
TrackPopupMenu(
    HMENU hMenu,
    UINT uFlags,
    int x,
    int y,
    int nReserved,
    HWND hWnd,
     const  RECT *prcRect);

 
/* return codes for WM_MENUCHAR */





typedef struct tagTPMPARAMS
{
    UINT    cbSize;     /* Size of structure */ 
    RECT    rcExclude;  /* Screen coordinates of rectangle to exclude when positioning */ 
}   TPMPARAMS;
typedef TPMPARAMS    *LPTPMPARAMS;

 __declspec(dllimport)  BOOL     __stdcall  TrackPopupMenuEx(HMENU, UINT, int, int, HWND, LPTPMPARAMS);








typedef struct tagMENUITEMINFOA
{
    UINT    cbSize;
    UINT    fMask;
    UINT    fType;          // used if MIIM_TYPE 
    UINT    fState;         // used if MIIM_STATE 
    UINT    wID;            // used if MIIM_ID 
    HMENU   hSubMenu;       // used if MIIM_SUBMENU 
    HBITMAP hbmpChecked;    // used if MIIM_CHECKMARKS 
    HBITMAP hbmpUnchecked;  // used if MIIM_CHECKMARKS 
    DWORD   dwItemData;     // used if MIIM_DATA 
    LPSTR   dwTypeData;     // used if MIIM_TYPE 
    UINT    cch;            // used if MIIM_TYPE 
}   MENUITEMINFOA,    *LPMENUITEMINFOA;
typedef struct tagMENUITEMINFOW
{
    UINT    cbSize;
    UINT    fMask;
    UINT    fType;          // used if MIIM_TYPE 
    UINT    fState;         // used if MIIM_STATE 
    UINT    wID;            // used if MIIM_ID 
    HMENU   hSubMenu;       // used if MIIM_SUBMENU 
    HBITMAP hbmpChecked;    // used if MIIM_CHECKMARKS 
    HBITMAP hbmpUnchecked;  // used if MIIM_CHECKMARKS 
    DWORD   dwItemData;     // used if MIIM_DATA 
    LPWSTR  dwTypeData;     // used if MIIM_TYPE 
    UINT    cch;            // used if MIIM_TYPE 
}   MENUITEMINFOW,    *LPMENUITEMINFOW;
#line 4564 "C:\WATCOM\H\NT\winuser.h"
typedef MENUITEMINFOA MENUITEMINFO;
typedef LPMENUITEMINFOA LPMENUITEMINFO;
// UNICODE
typedef MENUITEMINFOA  const     *LPCMENUITEMINFOA;
typedef MENUITEMINFOW  const     *LPCMENUITEMINFOW;
#line 4572 "C:\WATCOM\H\NT\winuser.h"
typedef LPCMENUITEMINFOA LPCMENUITEMINFO;
// UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
InsertMenuItemA(
    HMENU,
    UINT,
    BOOL,
    LPCMENUITEMINFOA
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
InsertMenuItemW(
    HMENU,
    UINT,
    BOOL,
    LPCMENUITEMINFOW
    );
#line 4596 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
GetMenuItemInfoA(
    HMENU,
    UINT,
    BOOL,
    LPMENUITEMINFOA
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
GetMenuItemInfoW(
    HMENU,
    UINT,
    BOOL,
    LPMENUITEMINFOW
    );
#line 4620 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
SetMenuItemInfoA(
    HMENU,
    UINT,
    BOOL,
    LPCMENUITEMINFOA
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
SetMenuItemInfoW(
    HMENU,
    UINT,
    BOOL,
    LPCMENUITEMINFOW
    );
#line 4644 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE




 __declspec(dllimport)  UINT     __stdcall  GetMenuDefaultItem(HMENU hMenu, UINT fByPos, UINT gmdiFlags);
 __declspec(dllimport)  BOOL     __stdcall  SetMenuDefaultItem(HMENU hMenu, UINT uItem, UINT fByPos);

 __declspec(dllimport)  BOOL     __stdcall  GetMenuItemRect(HWND hWnd, HMENU hMenu, UINT uItem, LPRECT lprcItem);
 __declspec(dllimport)  int      __stdcall  MenuItemFromPoint(HWND hWnd, HMENU hMenu, POINT ptScreen);

/* WINVER >= 0x0400 */
/*
 * Flags for TrackPopupMenu
 */





 




/* Horz alignment matters more */
/* Vert alignment matters more */
/* Don't send any notification msgs */

/* WINVER >= 0x0400 */

/* !NOMENUS */

 
//
// Drag-and-drop support
//

typedef struct tagDROPSTRUCT
{
    HWND    hwndSource;
    HWND    hwndSink;
    DWORD   wFmt;
    DWORD   dwData;
    POINT   ptDrop;
    DWORD   dwControlData;
} DROPSTRUCT, *PDROPSTRUCT, *LPDROPSTRUCT;











 __declspec(dllimport) 
DWORD
 __stdcall 
DragObject(HWND, HWND, UINT, DWORD, HCURSOR);

 __declspec(dllimport) 
BOOL
 __stdcall 
DragDetect(HWND, POINT);
/* WINVER >= 0x0400 */

 __declspec(dllimport) 
BOOL
 __stdcall 
DrawIcon(
    HDC hDC,
    int X,
    int Y,
    HICON hIcon);



/*
 * DrawText() Format Flags
 */
















 







typedef struct tagDRAWTEXTPARAMS
{
    UINT    cbSize;
    int     iTabLength;
    int     iLeftMargin;
    int     iRightMargin;
    UINT    uiLengthDrawn;
} DRAWTEXTPARAMS,    *LPDRAWTEXTPARAMS;
/* WINVER >= 0x0400 */

 __declspec(dllimport) 
int
 __stdcall 
DrawTextA(
    HDC hDC,
    LPCSTR lpString,
    int nCount,
    LPRECT lpRect,
    UINT uFormat);
 __declspec(dllimport) 
int
 __stdcall 
DrawTextW(
    HDC hDC,
    LPCWSTR lpString,
    int nCount,
    LPRECT lpRect,
    UINT uFormat);
#line 4783 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 
 __declspec(dllimport) 
int
 __stdcall 
DrawTextExA(HDC, LPSTR, int, LPRECT, UINT, LPDRAWTEXTPARAMS);
 __declspec(dllimport) 
int
 __stdcall 
DrawTextExW(HDC, LPWSTR, int, LPRECT, UINT, LPDRAWTEXTPARAMS);
#line 4798 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE
/* WINVER >= 0x0400 */

/* !NODRAWTEXT */

 __declspec(dllimport) 
BOOL
 __stdcall 
GrayStringA(
    HDC hDC,
    HBRUSH hBrush,
    GRAYSTRINGPROC lpOutputFunc,
    LPARAM lpData,
    int nCount,
    int X,
    int Y,
    int nWidth,
    int nHeight);
 __declspec(dllimport) 
BOOL
 __stdcall 
GrayStringW(
    HDC hDC,
    HBRUSH hBrush,
    GRAYSTRINGPROC lpOutputFunc,
    LPARAM lpData,
    int nCount,
    int X,
    int Y,
    int nWidth,
    int nHeight);
#line 4833 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 
/* Monolithic state-drawing routine */
/* Image type */






/* State type */

/* Gray string appearance */




 __declspec(dllimport)  BOOL  __stdcall  DrawStateA(HDC, HBRUSH, DRAWSTATEPROC, LPARAM, WPARAM, int, int, int, int, UINT);
 __declspec(dllimport)  BOOL  __stdcall  DrawStateW(HDC, HBRUSH, DRAWSTATEPROC, LPARAM, WPARAM, int, int, int, int, UINT);
#line 4857 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE
/* WINVER >= 0x0400 */

 __declspec(dllimport) 
LONG
 __stdcall 
TabbedTextOutA(
    HDC hDC,
    int X,
    int Y,
    LPCSTR lpString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
 __declspec(dllimport) 
LONG
 __stdcall 
TabbedTextOutW(
    HDC hDC,
    int X,
    int Y,
    LPCWSTR lpString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
#line 4888 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
DWORD
 __stdcall 
GetTabbedTextExtentA(
    HDC hDC,
    LPCSTR lpString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions);
 __declspec(dllimport) 
DWORD
 __stdcall 
GetTabbedTextExtentW(
    HDC hDC,
    LPCWSTR lpString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions);
#line 4912 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
UpdateWindow(
    HWND hWnd);

 __declspec(dllimport) 
HWND
 __stdcall 
SetActiveWindow(
    HWND hWnd);

 __declspec(dllimport) 
HWND
 __stdcall 
GetForegroundWindow(
     void );

 
 __declspec(dllimport)  BOOL  __stdcall  PaintDesktop(HDC hdc);

/* WINVER >= 0x0400 */

 __declspec(dllimport) 
BOOL
 __stdcall 
SetForegroundWindow(
    HWND hWnd);

 __declspec(dllimport) 
HWND
 __stdcall 
WindowFromDC(
    HDC hDC);

 __declspec(dllimport) 
HDC
 __stdcall 
GetDC(
    HWND hWnd);

 __declspec(dllimport) 
HDC
 __stdcall 
GetDCEx(
    HWND hWnd ,
    HRGN hrgnClip,
    DWORD flags);

/*
 * GetDCEx() flags
 */

















 __declspec(dllimport) 
HDC
 __stdcall 
GetWindowDC(
    HWND hWnd);

 __declspec(dllimport) 
int
 __stdcall 
ReleaseDC(
    HWND hWnd,
    HDC hDC);

 __declspec(dllimport) 
HDC
 __stdcall 
BeginPaint(
    HWND hWnd,
    LPPAINTSTRUCT lpPaint);

 __declspec(dllimport) 
BOOL
 __stdcall 
EndPaint(
    HWND hWnd,
     const  PAINTSTRUCT *lpPaint);

 __declspec(dllimport) 
BOOL
 __stdcall 
GetUpdateRect(
    HWND hWnd,
    LPRECT lpRect,
    BOOL bErase);

 __declspec(dllimport) 
int
 __stdcall 
GetUpdateRgn(
    HWND hWnd,
    HRGN hRgn,
    BOOL bErase);

 __declspec(dllimport) 
int
 __stdcall 
SetWindowRgn(
    HWND hWnd,
    HRGN hRgn,
    BOOL bRedraw);

 __declspec(dllimport) 
int
 __stdcall 
GetWindowRgn(
    HWND hWnd,
    HRGN hRgn);

 __declspec(dllimport) 
int
 __stdcall 
ExcludeUpdateRgn(
    HDC hDC,
    HWND hWnd);

 __declspec(dllimport) 
BOOL
 __stdcall 
InvalidateRect(
    HWND hWnd ,
     const  RECT *lpRect,
    BOOL bErase);

 __declspec(dllimport) 
BOOL
 __stdcall 
ValidateRect(
    HWND hWnd ,
     const  RECT *lpRect);

 __declspec(dllimport) 
BOOL
 __stdcall 
InvalidateRgn(
    HWND hWnd,
    HRGN hRgn,
    BOOL bErase);

 __declspec(dllimport) 
BOOL
 __stdcall 
ValidateRgn(
    HWND hWnd,
    HRGN hRgn);

 __declspec(dllimport) 
BOOL
 __stdcall 
RedrawWindow(
    HWND hWnd,
     const  RECT *lprcUpdate,
    HRGN hrgnUpdate,
    UINT flags);

/*
 * RedrawWindow() flags
 */

















/*
 * LockWindowUpdate API
 */

 __declspec(dllimport) 
BOOL
 __stdcall 
LockWindowUpdate(
    HWND hWndLock);

 __declspec(dllimport) 
BOOL
 __stdcall 
ScrollWindow(
    HWND hWnd,
    int XAmount,
    int YAmount,
     const  RECT *lpRect,
     const  RECT *lpClipRect);

 __declspec(dllimport) 
BOOL
 __stdcall 
ScrollDC(
    HDC hDC,
    int dx,
    int dy,
     const  RECT *lprcScroll,
     const  RECT *lprcClip ,
    HRGN hrgnUpdate,
    LPRECT lprcUpdate);

 __declspec(dllimport) 
int
 __stdcall 
ScrollWindowEx(
    HWND hWnd,
    int dx,
    int dy,
     const  RECT *prcScroll,
     const  RECT *prcClip ,
    HRGN hrgnUpdate,
    LPRECT prcUpdate,
    UINT flags);

/* Scroll children within *lprcScroll. */
/* Invalidate after scrolling */
/* If SW_INVALIDATE, don't send WM_ERASEBACKGROUND */



 __declspec(dllimport) 
int
 __stdcall 
SetScrollPos(
    HWND hWnd,
    int nBar,
    int nPos,
    BOOL bRedraw);

 __declspec(dllimport) 
int
 __stdcall 
GetScrollPos(
    HWND hWnd,
    int nBar);

 __declspec(dllimport) 
BOOL
 __stdcall 
SetScrollRange(
    HWND hWnd,
    int nBar,
    int nMinPos,
    int nMaxPos,
    BOOL bRedraw);

 __declspec(dllimport) 
BOOL
 __stdcall 
GetScrollRange(
    HWND hWnd,
    int nBar,
    LPINT lpMinPos,
    LPINT lpMaxPos);

 __declspec(dllimport) 
BOOL
 __stdcall 
ShowScrollBar(
    HWND hWnd,
    int wBar,
    BOOL bShow);

 __declspec(dllimport) 
BOOL
 __stdcall 
EnableScrollBar(
    HWND hWnd,
    UINT wSBflags,
    UINT wArrows);

/*
 * EnableScrollBar() flags
 */












/* !NOSCROLL */

 __declspec(dllimport) 
BOOL
 __stdcall 
SetPropA(
    HWND hWnd,
    LPCSTR lpString,
    HANDLE hData);
 __declspec(dllimport) 
BOOL
 __stdcall 
SetPropW(
    HWND hWnd,
    LPCWSTR lpString,
    HANDLE hData);
#line 5244 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
HANDLE
 __stdcall 
GetPropA(
    HWND hWnd,
    LPCSTR lpString);
 __declspec(dllimport) 
HANDLE
 __stdcall 
GetPropW(
    HWND hWnd,
    LPCWSTR lpString);
#line 5262 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
HANDLE
 __stdcall 
RemovePropA(
    HWND hWnd,
    LPCSTR lpString);
 __declspec(dllimport) 
HANDLE
 __stdcall 
RemovePropW(
    HWND hWnd,
    LPCWSTR lpString);
#line 5280 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
int
 __stdcall 
EnumPropsExA(
    HWND hWnd,
    PROPENUMPROCEXA lpEnumFunc,
    LPARAM lParam);
 __declspec(dllimport) 
int
 __stdcall 
EnumPropsExW(
    HWND hWnd,
    PROPENUMPROCEXW lpEnumFunc,
    LPARAM lParam);
#line 5300 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
int
 __stdcall 
EnumPropsA(
    HWND hWnd,
    PROPENUMPROCA lpEnumFunc);
 __declspec(dllimport) 
int
 __stdcall 
EnumPropsW(
    HWND hWnd,
    PROPENUMPROCW lpEnumFunc);
#line 5318 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
SetWindowTextA(
    HWND hWnd,
    LPCSTR lpString);
 __declspec(dllimport) 
BOOL
 __stdcall 
SetWindowTextW(
    HWND hWnd,
    LPCWSTR lpString);
#line 5336 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
int
 __stdcall 
GetWindowTextA(
    HWND hWnd,
    LPSTR lpString,
    int nMaxCount);
 __declspec(dllimport) 
int
 __stdcall 
GetWindowTextW(
    HWND hWnd,
    LPWSTR lpString,
    int nMaxCount);
#line 5356 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
int
 __stdcall 
GetWindowTextLengthA(
    HWND hWnd);
 __declspec(dllimport) 
int
 __stdcall 
GetWindowTextLengthW(
    HWND hWnd);
#line 5372 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
GetClientRect(
    HWND hWnd,
    LPRECT lpRect);

 __declspec(dllimport) 
BOOL
 __stdcall 
GetWindowRect(
    HWND hWnd,
    LPRECT lpRect);

 __declspec(dllimport) 
BOOL
 __stdcall 
AdjustWindowRect(
    LPRECT lpRect,
    DWORD dwStyle,
    BOOL bMenu);

 __declspec(dllimport) 
BOOL
 __stdcall 
AdjustWindowRectEx(
    LPRECT lpRect,
    DWORD dwStyle,
    BOOL bMenu,
    DWORD dwExStyle);

 


typedef struct tagHELPINFO      /* Structure pointed to by lParam of WM_HELP */ 
{
    UINT    cbSize;             /* Size in bytes of this struct  */ 
    int     iContextType;       /* Either HELPINFO_WINDOW or HELPINFO_MENUITEM */ 
    int     iCtrlId;            /* Control Id or a Menu item Id. */ 
    HANDLE  hItemHandle;        /* hWnd of control or hMenu.     */ 
    DWORD   dwContextId;        /* Context Id associated with this item */ 
    POINT   MousePos;           /* Mouse Position in screen co-ordinates */ 
}  HELPINFO,    *LPHELPINFO;

 __declspec(dllimport)  BOOL   __stdcall   SetWindowContextHelpId(HWND, DWORD);
 __declspec(dllimport)  DWORD  __stdcall   GetWindowContextHelpId(HWND);
 __declspec(dllimport)  BOOL   __stdcall   SetMenuContextHelpId(HMENU, DWORD);
 __declspec(dllimport)  DWORD  __stdcall   GetMenuContextHelpId(HMENU);

/* WINVER >= 0x0400 */



/*
 * MessageBox() Flags
 */












 


/* WINVER >= 0x0400 */







 

/* WINVER >= 0x0400 */




 
// Help Button


/* WINVER >= 0x0400 */







 

/* WINVER >= 0x0400 */





 __declspec(dllimport) 
int
 __stdcall 
MessageBoxA(
    HWND hWnd ,
    LPCSTR lpText,
    LPCSTR lpCaption,
    UINT uType);
 __declspec(dllimport) 
int
 __stdcall 
MessageBoxW(
    HWND hWnd ,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType);
#line 5500 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
int
 __stdcall 
MessageBoxExA(
    HWND hWnd ,
    LPCSTR lpText,
    LPCSTR lpCaption,
    UINT uType,
    WORD wLanguageId);
 __declspec(dllimport) 
int
 __stdcall 
MessageBoxExW(
    HWND hWnd ,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType,
    WORD wLanguageId);
#line 5524 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 


typedef void ( __stdcall  *MSGBOXCALLBACK)(LPHELPINFO lpHelpInfo);

typedef struct tagMSGBOXPARAMSA
{
    UINT        cbSize;
    HWND        hwndOwner;
    HINSTANCE   hInstance;
    LPCSTR      lpszText;
    LPCSTR      lpszCaption;
    DWORD       dwStyle;
    LPCSTR      lpszIcon;
    DWORD       dwContextHelpId;
    MSGBOXCALLBACK      lpfnMsgBoxCallback;
    DWORD   dwLanguageId;
} MSGBOXPARAMSA, *PMSGBOXPARAMSA, *LPMSGBOXPARAMSA;
typedef struct tagMSGBOXPARAMSW
{
    UINT        cbSize;
    HWND        hwndOwner;
    HINSTANCE   hInstance;
    LPCWSTR     lpszText;
    LPCWSTR     lpszCaption;
    DWORD       dwStyle;
    LPCWSTR     lpszIcon;
    DWORD       dwContextHelpId;
    MSGBOXCALLBACK      lpfnMsgBoxCallback;
    DWORD   dwLanguageId;
} MSGBOXPARAMSW, *PMSGBOXPARAMSW, *LPMSGBOXPARAMSW;
#line 5563 "C:\WATCOM\H\NT\winuser.h"
typedef MSGBOXPARAMSA MSGBOXPARAMS;
typedef PMSGBOXPARAMSA PMSGBOXPARAMS;
typedef LPMSGBOXPARAMSA LPMSGBOXPARAMS;
// UNICODE

 __declspec(dllimport)  int      __stdcall  MessageBoxIndirectA(LPMSGBOXPARAMSA);
 __declspec(dllimport)  int      __stdcall  MessageBoxIndirectW(LPMSGBOXPARAMSW);
#line 5573 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE
/* WINVER >= 0x0400 */

 __declspec(dllimport) 
BOOL
 __stdcall 
MessageBeep(
    UINT uType);

/* !NOMB */

 __declspec(dllimport) 
int
 __stdcall 
ShowCursor(
    BOOL bShow);

 __declspec(dllimport) 
BOOL
 __stdcall 
SetCursorPos(
    int X,
    int Y);

 __declspec(dllimport) 
HCURSOR
 __stdcall 
SetCursor(
    HCURSOR hCursor);

 __declspec(dllimport) 
BOOL
 __stdcall 
GetCursorPos(
    LPPOINT lpPoint);

 __declspec(dllimport) 
BOOL
 __stdcall 
ClipCursor(
     const  RECT *lpRect);

 __declspec(dllimport) 
BOOL
 __stdcall 
GetClipCursor(
    LPRECT lpRect);

 __declspec(dllimport) 
HCURSOR
 __stdcall 
GetCursor(
     void );

 __declspec(dllimport) 
BOOL
 __stdcall 
CreateCaret(
    HWND hWnd,
    HBITMAP hBitmap ,
    int nWidth,
    int nHeight);

 __declspec(dllimport) 
UINT
 __stdcall 
GetCaretBlinkTime(
     void );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetCaretBlinkTime(
    UINT uMSeconds);

 __declspec(dllimport) 
BOOL
 __stdcall 
DestroyCaret(
     void );

 __declspec(dllimport) 
BOOL
 __stdcall 
HideCaret(
    HWND hWnd);

 __declspec(dllimport) 
BOOL
 __stdcall 
ShowCaret(
    HWND hWnd);

 __declspec(dllimport) 
BOOL
 __stdcall 
SetCaretPos(
    int X,
    int Y);

 __declspec(dllimport) 
BOOL
 __stdcall 
GetCaretPos(
    LPPOINT lpPoint);

 __declspec(dllimport) 
BOOL
 __stdcall 
ClientToScreen(
    HWND hWnd,
    LPPOINT lpPoint);

 __declspec(dllimport) 
BOOL
 __stdcall 
ScreenToClient(
    HWND hWnd,
    LPPOINT lpPoint);

 __declspec(dllimport) 
int
 __stdcall 
MapWindowPoints(
    HWND hWndFrom,
    HWND hWndTo,
    LPPOINT lpPoints,
    UINT cPoints);

 __declspec(dllimport) 
HWND
 __stdcall 
WindowFromPoint(
    POINT Point);

 __declspec(dllimport) 
HWND
 __stdcall 
ChildWindowFromPoint(
    HWND hWndParent,
    POINT Point);

 





 __declspec(dllimport)  HWND     __stdcall  ChildWindowFromPointEx(HWND, POINT, UINT);
/* WINVER >= 0x0400 */



/*
 * Color Types
 */































 











/* WINVER >= 0x0400 */

 __declspec(dllimport) 
DWORD
 __stdcall 
GetSysColor(
    int nIndex);

 
 __declspec(dllimport) 
HBRUSH
 __stdcall 
GetSysColorBrush(
    int nIndex);

/* WINVER >= 0x0400 */

 __declspec(dllimport) 
BOOL
 __stdcall 
SetSysColors(
    int cElements,
     const  INT * lpaElements,
     const  COLORREF * lpaRgbValues);

/* !NOCOLOR */

 __declspec(dllimport) 
BOOL
 __stdcall 
DrawFocusRect(
    HDC hDC,
     const  RECT * lprc);

 __declspec(dllimport) 
int
 __stdcall 
FillRect(
    HDC hDC,
     const  RECT *lprc,
    HBRUSH hbr);

 __declspec(dllimport) 
int
 __stdcall 
FrameRect(
    HDC hDC,
     const  RECT *lprc,
    HBRUSH hbr);

 __declspec(dllimport) 
BOOL
 __stdcall 
InvertRect(
    HDC hDC,
     const  RECT *lprc);

 __declspec(dllimport) 
BOOL
 __stdcall 
SetRect(
    LPRECT lprc,
    int xLeft,
    int yTop,
    int xRight,
    int yBottom);

 __declspec(dllimport) 
BOOL
 __stdcall 
    SetRectEmpty(
    LPRECT lprc);

 __declspec(dllimport) 
BOOL
 __stdcall 
CopyRect(
    LPRECT lprcDst,
     const  RECT *lprcSrc);

 __declspec(dllimport) 
BOOL
 __stdcall 
InflateRect(
    LPRECT lprc,
    int dx,
    int dy);

 __declspec(dllimport) 
BOOL
 __stdcall 
IntersectRect(
    LPRECT lprcDst,
     const  RECT *lprcSrc1,
     const  RECT *lprcSrc2);

 __declspec(dllimport) 
BOOL
 __stdcall 
UnionRect(
    LPRECT lprcDst,
     const  RECT *lprcSrc1,
     const  RECT *lprcSrc2);

 __declspec(dllimport) 
BOOL
 __stdcall 
SubtractRect(
    LPRECT lprcDst,
     const  RECT *lprcSrc1,
     const  RECT *lprcSrc2);

 __declspec(dllimport) 
BOOL
 __stdcall 
OffsetRect(
    LPRECT lprc,
    int dx,
    int dy);

 __declspec(dllimport) 
BOOL
 __stdcall 
IsRectEmpty(
     const  RECT *lprc);

 __declspec(dllimport) 
BOOL
 __stdcall 
EqualRect(
     const  RECT *lprc1,
     const  RECT *lprc2);

 __declspec(dllimport) 
BOOL
 __stdcall 
PtInRect(
     const  RECT *lprc,
    POINT pt);



 __declspec(dllimport) 
WORD
 __stdcall 
GetWindowWord(
    HWND hWnd,
    int nIndex);

 __declspec(dllimport) 
WORD
 __stdcall 
SetWindowWord(
    HWND hWnd,
    int nIndex,
    WORD wNewWord);

 __declspec(dllimport) 
LONG
 __stdcall 
GetWindowLongA(
    HWND hWnd,
    int nIndex);
 __declspec(dllimport) 
LONG
 __stdcall 
GetWindowLongW(
    HWND hWnd,
    int nIndex);
#line 5945 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
LONG
 __stdcall 
SetWindowLongA(
    HWND hWnd,
    int nIndex,
    LONG dwNewLong);
 __declspec(dllimport) 
LONG
 __stdcall 
SetWindowLongW(
    HWND hWnd,
    int nIndex,
    LONG dwNewLong);
#line 5965 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
WORD
 __stdcall 
GetClassWord(
    HWND hWnd,
    int nIndex);

 __declspec(dllimport) 
WORD
 __stdcall 
SetClassWord(
    HWND hWnd,
    int nIndex,
    WORD wNewWord);

 __declspec(dllimport) 
DWORD
 __stdcall 
GetClassLongA(
    HWND hWnd,
    int nIndex);
 __declspec(dllimport) 
DWORD
 __stdcall 
GetClassLongW(
    HWND hWnd,
    int nIndex);
#line 5998 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
DWORD
 __stdcall 
SetClassLongA(
    HWND hWnd,
    int nIndex,
    LONG dwNewLong);
 __declspec(dllimport) 
DWORD
 __stdcall 
SetClassLongW(
    HWND hWnd,
    int nIndex,
    LONG dwNewLong);
#line 6018 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

/* !NOWINOFFSETS */

 __declspec(dllimport) 
HWND
 __stdcall 
GetDesktopWindow(
     void );

 __declspec(dllimport) 
HWND
 __stdcall 
GetParent(
    HWND hWnd);

 __declspec(dllimport) 
HWND
 __stdcall 
SetParent(
    HWND hWndChild,
    HWND hWndNewParent);

 __declspec(dllimport) 
BOOL
 __stdcall 
EnumChildWindows(
    HWND hWndParent,
    WNDENUMPROC lpEnumFunc,
    LPARAM lParam);

 __declspec(dllimport) 
HWND
 __stdcall 
FindWindowA(
    LPCSTR lpClassName ,
    LPCSTR lpWindowName);
 __declspec(dllimport) 
HWND
 __stdcall 
FindWindowW(
    LPCWSTR lpClassName ,
    LPCWSTR lpWindowName);
#line 6065 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 
 __declspec(dllimport)  HWND     __stdcall  FindWindowExA(HWND, HWND, LPCSTR, LPCSTR);
 __declspec(dllimport)  HWND     __stdcall  FindWindowExW(HWND, HWND, LPCWSTR, LPCWSTR);
#line 6074 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

/* WINVER >= 0x0400 */

 __declspec(dllimport) 
BOOL
 __stdcall 
EnumWindows(
    WNDENUMPROC lpEnumFunc,
    LPARAM lParam);

 __declspec(dllimport) 
BOOL
 __stdcall 
EnumThreadWindows(
    DWORD dwThreadId,
    WNDENUMPROC lpfn,
    LPARAM lParam);



 __declspec(dllimport) 
int
 __stdcall 
GetClassNameA(
    HWND hWnd,
    LPSTR lpClassName,
    int nMaxCount);
 __declspec(dllimport) 
int
 __stdcall 
GetClassNameW(
    HWND hWnd,
    LPWSTR lpClassName,
    int nMaxCount);
#line 6113 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
HWND
 __stdcall 
GetTopWindow(
    HWND hWnd);





 __declspec(dllimport) 
DWORD
 __stdcall 
GetWindowThreadProcessId(
    HWND hWnd,
    LPDWORD lpdwProcessId);




 __declspec(dllimport) 
HWND
 __stdcall 
GetLastActivePopup(
    HWND hWnd);

/*
 * GetWindow() Constants
 */








 __declspec(dllimport) 
HWND
 __stdcall 
GetWindow(
    HWND hWnd,
    UINT uCmd);



/* !STRICT */#line 6183 "C:\WATCOM\H\NT\winuser.h"

 __declspec(dllimport) 
HOOKPROC
 __stdcall 
SetWindowsHookA(
    int nFilterType,
    HOOKPROC pfnFilterProc);
 __declspec(dllimport) 
HOOKPROC
 __stdcall 
SetWindowsHookW(
    int nFilterType,
    HOOKPROC pfnFilterProc);
#line 6199 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

/* !STRICT */

 __declspec(dllimport) 
BOOL
 __stdcall 
UnhookWindowsHook(
    int nCode,
    HOOKPROC pfnFilterProc);

 __declspec(dllimport) 
HHOOK
 __stdcall 
SetWindowsHookExA(
    int idHook,
    HOOKPROC lpfn,
    HINSTANCE hmod,
    DWORD dwThreadId);
 __declspec(dllimport) 
HHOOK
 __stdcall 
SetWindowsHookExW(
    int idHook,
    HOOKPROC lpfn,
    HINSTANCE hmod,
    DWORD dwThreadId);
#line 6230 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
UnhookWindowsHookEx(
    HHOOK hhk);

 __declspec(dllimport) 
LRESULT
 __stdcall 
CallNextHookEx(
    HHOOK hhk,
    int nCode,
    WPARAM wParam,
    LPARAM lParam);

/*
 * Macros for source-level compatibility with old functions.
 */
#line 6255 "C:\WATCOM\H\NT\winuser.h"


/* STRICT */

/* !NOWH */



/* ;win40  -- A lot of MF_* flags have been renamed as MFT_* and MFS_* flags */
/*
 * Menu flags for Add/Check/EnableMenuItem()
 */






























 

/* WINVER >= 0x0400 */


 

/* WINVER >= 0x0400 */


 
/* Obsolete -- only used by old RES files */
/* WINVER >= 0x0400 */

 










/* Menu flags for Add/Check/EnableMenuItem() */









 __declspec(dllimport) 
BOOL
 __stdcall 
CheckMenuRadioItem(HMENU, UINT, UINT, UINT, UINT);
/* WINVER >= 0x0400 */

/*
 * Menu item resource format
 */
typedef struct {
    WORD versionNumber;
    WORD offset;
} MENUITEMTEMPLATEHEADER, *PMENUITEMTEMPLATEHEADER;

typedef struct {        // version 0 
    WORD mtOption;
    WORD mtID;
    WCHAR mtString[1];
} MENUITEMTEMPLATE, *PMENUITEMTEMPLATE;


/* !NOMENUS */



/*
 * System Menu Command Values
 */
















 




/* WINVER >= 0x0400 */
/*
 * Obsolete names
 */



/* !NOSYSCOMMANDS */

/*
 * Resource Loading Routines
 */

 __declspec(dllimport) 
HBITMAP
 __stdcall 
LoadBitmapA(
    HINSTANCE hInstance,
    LPCSTR lpBitmapName);
 __declspec(dllimport) 
HBITMAP
 __stdcall 
LoadBitmapW(
    HINSTANCE hInstance,
    LPCWSTR lpBitmapName);
#line 6409 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
HCURSOR
 __stdcall 
LoadCursorA(
    HINSTANCE hInstance,
    LPCSTR lpCursorName);
 __declspec(dllimport) 
HCURSOR
 __stdcall 
LoadCursorW(
    HINSTANCE hInstance,
    LPCWSTR lpCursorName);
#line 6427 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
HCURSOR
 __stdcall 
LoadCursorFromFileA(
    LPCSTR    lpFileName);
 __declspec(dllimport) 
HCURSOR
 __stdcall 
LoadCursorFromFileW(
    LPCWSTR    lpFileName);
#line 6443 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
HCURSOR
 __stdcall 
CreateCursor(
    HINSTANCE hInst,
    int xHotSpot,
    int yHotSpot,
    int nWidth,
    int nHeight,
     const   void  *pvANDPlane,
     const   void  *pvXORPlane);

 __declspec(dllimport) 
BOOL
 __stdcall 
DestroyCursor(
    HCURSOR hCursor);



/*
 * Standard Cursor IDs
 */





/* OBSOLETE: use IDC_SIZEALL */
/* OBSOLETE: use IDC_ARROW */





/*not in win3.1 */
/*not in win3.1 */
 

/* WINVER >= 0x0400 */

 __declspec(dllimport) 
BOOL
 __stdcall 
SetSystemCursor(
    HCURSOR hcur,
    DWORD   id);

typedef struct _ICONINFO {
    BOOL    fIcon;
    DWORD   xHotspot;
    DWORD   yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
} ICONINFO;
typedef ICONINFO *PICONINFO;

 __declspec(dllimport) 
HICON
 __stdcall 
LoadIconA(
    HINSTANCE hInstance,
    LPCSTR lpIconName);
 __declspec(dllimport) 
HICON
 __stdcall 
LoadIconW(
    HINSTANCE hInstance,
    LPCWSTR lpIconName);
#line 6518 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
HICON
 __stdcall 
CreateIcon(
    HINSTANCE hInstance,
    int nWidth,
    int nHeight,
    BYTE cPlanes,
    BYTE cBitsPixel,
     const  BYTE *lpbANDbits,
     const  BYTE *lpbXORbits);

 __declspec(dllimport) 
BOOL
 __stdcall 
DestroyIcon(
    HICON hIcon);

 __declspec(dllimport) 
int
 __stdcall 
LookupIconIdFromDirectory(
    PBYTE presbits,
    BOOL fIcon);

 
 __declspec(dllimport) 
int
 __stdcall 
LookupIconIdFromDirectoryEx(
    PBYTE presbits,
    BOOL  fIcon,
    int   cxDesired,
    int   cyDesired,
    UINT  Flags);
/* WINVER >= 0x0400 */

 __declspec(dllimport) 
HICON
 __stdcall 
CreateIconFromResource(
    PBYTE presbits,
    DWORD dwResSize,
    BOOL fIcon,
    DWORD dwVer);

 
 __declspec(dllimport) 
HICON
 __stdcall 
CreateIconFromResourceEx(
    PBYTE presbits,
    DWORD dwResSize,
    BOOL  fIcon,
    DWORD dwVer,
    int   cxDesired,
    int   cyDesired,
    UINT  Flags);

/* Icon/Cursor header */
typedef struct tagCURSORSHAPE
{
    int     xHotSpot;
    int     yHotSpot;
    int     cx;
    int     cy;
    int     cbWidth;
    BYTE    Planes;
    BYTE    BitsPixel;
} CURSORSHAPE,    *LPCURSORSHAPE;
/* WINVER >= 0x0400 */




 















 __declspec(dllimport) 
HANDLE
 __stdcall 
LoadImageA(
    HINSTANCE,
    LPCSTR,
    UINT,
    int,
    int,
    UINT);
 __declspec(dllimport) 
HANDLE
 __stdcall 
LoadImageW(
    HINSTANCE,
    LPCWSTR,
    UINT,
    int,
    int,
    UINT);
#line 6635 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
HICON
 __stdcall 
CopyImage(
    HANDLE,
    UINT,
    int,
    int,
    UINT);







 __declspec(dllimport)  BOOL  __stdcall  DrawIconEx(HDC hdc, int xLeft, int yTop,
              HICON hIcon, int cxWidth, int cyWidth,
              UINT istepIfAniCur, HBRUSH hbrFlickerFreeDraw, UINT diFlags);
/* WINVER >= 0x0400 */

 __declspec(dllimport) 
HICON
 __stdcall 
CreateIconIndirect(
    PICONINFO piconinfo);

 __declspec(dllimport) 
HICON
 __stdcall 
CopyIcon(
    HICON hIcon);

 __declspec(dllimport) 
BOOL
 __stdcall 
GetIconInfo(
    HICON hIcon,
    PICONINFO piconinfo);

 


/* WINVER >= 0x0400 */

/* OEMRESOURCE */#line 6755 "C:\WATCOM\H\NT\winuser.h"

/* The ordinal number for the entry point of
                                ** language drivers.
                                */



/*
 * Standard Icon IDs
 */
#line 6775 "C:\WATCOM\H\NT\winuser.h"





 

/* WINVER >= 0x0400 */
/* RC_INVOKED */

 



/* WINVER >= 0x0400 */

/* !NOICONS */

 __declspec(dllimport) 
int
 __stdcall 
LoadStringA(
    HINSTANCE hInstance,
    UINT uID,
    LPSTR lpBuffer,
    int nBufferMax);
 __declspec(dllimport) 
int
 __stdcall 
LoadStringW(
    HINSTANCE hInstance,
    UINT uID,
    LPWSTR lpBuffer,
    int nBufferMax);
#line 6812 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

/*
 * Dialog Box Command IDs
 */







 


/* WINVER >= 0x0400 */



/*
 * Control Manager Structures and Definitions
 */



/*
 * Edit Control Styles
 */













 

/* WINVER >= 0x0400 */

/* !NOWINSTYLES */

/*
 * Edit Control Notification Codes
 */









 
/* Edit control EM_SETMARGIN parameters */



/* WINVER >= 0x0400 */



/*
 * Edit Control Messages
 */































 


/* ;win40 Name change */



/* WINVER >= 0x0400 */

/* !NOWINMESSAGES */

/*
 * EDITWORDBREAKPROC code values
 */




/*
 * Button Control Styles
 */












 














/* WINVER >= 0x0400 */

/*
 * User Button Notification Codes
 */






 





/* WINVER >= 0x0400 */

/*
 * Button Control Messages
 */





 









/* WINVER >= 0x0400 */

/*
 * Static Control Constants
 */














 






/* WINVER >= 0x0400 */
/* Don't do "&" character translation */
 

/* WINVER >= 0x0400 */

 



/* WINVER >= 0x0400 */


/*
 * Static Control Mesages
 */




 




/* WINVER >= 0x0400 */

/* !NOWINMESSAGES */

/*
 * Dialog window class
 */


/*
 * Get/SetWindowWord/Long offsets for use with WC_DIALOG windows
 */




/*
 * Dialog Manager Routines
 */



 __declspec(dllimport) 
BOOL
 __stdcall 
IsDialogMessageA(
    HWND hDlg,
    LPMSG lpMsg);
 __declspec(dllimport) 
BOOL
 __stdcall 
IsDialogMessageW(
    HWND hDlg,
    LPMSG lpMsg);
#line 7088 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

/* !NOMSG */

 __declspec(dllimport) 
BOOL
 __stdcall 
MapDialogRect(
    HWND hDlg,
    LPRECT lpRect);

 __declspec(dllimport) 
int
 __stdcall 
DlgDirListA(
    HWND hDlg,
    LPSTR lpPathSpec,
    int nIDListBox,
    int nIDStaticPath,
    UINT uFileType);
 __declspec(dllimport) 
int
 __stdcall 
DlgDirListW(
    HWND hDlg,
    LPWSTR lpPathSpec,
    int nIDListBox,
    int nIDStaticPath,
    UINT uFileType);
#line 7121 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

/*
 * DlgDirList, DlgDirListComboBox flags values
 */











 __declspec(dllimport) 
BOOL
 __stdcall 
DlgDirSelectExA(
    HWND hDlg,
    LPSTR lpString,
    int nCount,
    int nIDListBox);
 __declspec(dllimport) 
BOOL
 __stdcall 
DlgDirSelectExW(
    HWND hDlg,
    LPWSTR lpString,
    int nCount,
    int nIDListBox);
#line 7157 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
int
 __stdcall 
DlgDirListComboBoxA(
    HWND hDlg,
    LPSTR lpPathSpec,
    int nIDComboBox,
    int nIDStaticPath,
    UINT uFiletype);
 __declspec(dllimport) 
int
 __stdcall 
DlgDirListComboBoxW(
    HWND hDlg,
    LPWSTR lpPathSpec,
    int nIDComboBox,
    int nIDStaticPath,
    UINT uFiletype);
#line 7181 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
DlgDirSelectComboBoxExA(
    HWND hDlg,
    LPSTR lpString,
    int nCount,
    int nIDComboBox);
 __declspec(dllimport) 
BOOL
 __stdcall 
DlgDirSelectComboBoxExW(
    HWND hDlg,
    LPWSTR lpString,
    int nCount,
    int nIDComboBox);
#line 7203 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

/*
 * Dialog Styles
 */


/* Edit items get Local storage. */
/* User specified font for Dlg controls */
/* Can be combined with WS_CAPTION  */
/* WM_ENTERIDLE message will not be sent */
/* not in win3.1 */

 








/* WINVER >= 0x0400 */




 
















/* WINVER >= 0x0400 */
/*
 * Returned in HIWORD() of DM_GETDEFID result if msg is supported
 */


/*
 * Dialog Codes
 */
/* Control wants arrow keys         */
/* Control wants tab keys           */
/* Control wants all keys           */
/* Pass message to control          */
/* Understands EM_SETSEL message    */
/* Default pushbutton               */
/* Non-default pushbutton           */
/* Radio button                     */
/* Want WM_CHAR messages            */
/* Static item: don't include       */
/* Button item: can be checked      */



/*
 * Listbox Return Values
 */




/*
**  The idStaticPath parameter to DlgDirList can have the following values
**  ORed if the list box should show other details of the files along with
**  the name of the files;
*/
                                  /* all other details also will be returned */

/*
 * Listbox Notification Codes
 */









/*
 * Listbox messages
 */






































 


/* WINVER >= 0x0400 */
 

#line 7347 "C:\WATCOM\H\NT\winuser.h"

/* !NOWINMESSAGES */



/*
 * Listbox Styles
 */














 

/* WINVER >= 0x0400 */


/* !NOWINSTYLES */

/*
 * Combo Box return Values
 */




/*
 * Combo Box Notification Codes
 */












/*
 * Combo Box styles
 */












 


/* WINVER >= 0x0400 */
/* !NOWINSTYLES */

/*
 * Combo Box messages
 */




























 







/* WINVER >= 0x0400 */
 

#line 7464 "C:\WATCOM\H\NT\winuser.h"
/* !NOWINMESSAGES */



/*
 * Scroll Bar Styles
 */









 

/* WINVER >= 0x0400 */
/* !NOWINSTYLES */

/*
 * Scroll bar messages
 */

/*not in win3.1 */
/*not in win3.1 */
/*not in win3.1 */
/*not in win3.1 */
/*not in win3.1 */
/*not in win3.1 */
 










typedef struct tagSCROLLINFO
{
    UINT    cbSize;
    UINT    fMask;
    int     nMin;
    int     nMax;
    UINT    nPage;
    int     nPos;
    int     nTrackPos;
}   SCROLLINFO,    *LPSCROLLINFO;
typedef SCROLLINFO  const     *LPCSCROLLINFO;

 __declspec(dllimport)  int      __stdcall  SetScrollInfo(HWND, int, LPCSCROLLINFO, BOOL);
 __declspec(dllimport)  BOOL     __stdcall  GetScrollInfo(HWND, int, LPSCROLLINFO);
/* WINVER >= 0x0400 */
/* !NOWINMESSAGES */
/* !NOCTLMGR */



/*
 * MDI client style bits
 */


/*
 * wParam Flags for WM_MDITILE and WM_MDICASCADE messages.
 */
/*not in win3.1 */
/*not in win3.1 */
/*not in win3.1 */

typedef struct tagMDICREATESTRUCTA {
    LPCSTR   szClass;
    LPCSTR   szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    DWORD style;
    LPARAM lParam;        /* app-defined stuff */ 
} MDICREATESTRUCTA, *LPMDICREATESTRUCTA;
typedef struct tagMDICREATESTRUCTW {
    LPCWSTR  szClass;
    LPCWSTR  szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    DWORD style;
    LPARAM lParam;        /* app-defined stuff */ 
} MDICREATESTRUCTW, *LPMDICREATESTRUCTW;
#line 7564 "C:\WATCOM\H\NT\winuser.h"
typedef MDICREATESTRUCTA MDICREATESTRUCT;
typedef LPMDICREATESTRUCTA LPMDICREATESTRUCT;
// UNICODE

typedef struct tagCLIENTCREATESTRUCT {
    HANDLE hWindowMenu;
    UINT idFirstChild;
} CLIENTCREATESTRUCT, *LPCLIENTCREATESTRUCT;

 __declspec(dllimport) 
LRESULT
 __stdcall 
DefFrameProcA(
    HWND hWnd,
    HWND hWndMDIClient ,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);
 __declspec(dllimport) 
LRESULT
 __stdcall 
DefFrameProcW(
    HWND hWnd,
    HWND hWndMDIClient ,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);
#line 7594 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
LRESULT
 __stdcall 
DefMDIChildProcA(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);
 __declspec(dllimport) 
LRESULT
 __stdcall 
DefMDIChildProcW(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);
#line 7616 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE



 __declspec(dllimport) 
BOOL
 __stdcall 
TranslateMDISysAccel(
    HWND hWndClient,
    LPMSG lpMsg);

/* !NOMSG */

 __declspec(dllimport) 
UINT
 __stdcall 
ArrangeIconicWindows(
    HWND hWnd);

 __declspec(dllimport) 
HWND
 __stdcall 
CreateMDIWindowA(
    LPSTR lpClassName,
    LPSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HINSTANCE hInstance,
    LPARAM lParam
    );
 __declspec(dllimport) 
HWND
 __stdcall 
CreateMDIWindowW(
    LPWSTR lpClassName,
    LPWSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HINSTANCE hInstance,
    LPARAM lParam
    );
#line 7669 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 
 __declspec(dllimport)  WORD     __stdcall  TileWindows(HWND hwndParent, UINT wHow,  const  RECT * lpRect, UINT cKids, const HWND    * lpKids);
 __declspec(dllimport)  WORD     __stdcall  CascadeWindows(HWND hwndParent, UINT wHow,  const  RECT * lpRect, UINT cKids,  const HWND    * lpKids);
/* WINVER >= 0x0400 */
/* !NOMDI */

 


/*
 *  IME class support
 */

// wParam for WM_IME_CONTROL











// wParam of report message WM_IME_NOTIFY















/* !NOIME */
/* WINVER >= 0x0400 */
/* !NOUSER */

/****** Help support ********************************************************/



typedef DWORD HELPPOLY;
typedef struct tagMULTIKEYHELPA {
    DWORD  mkSize;
    CHAR   mkKeylist;
    CHAR   szKeyphrase[1];
} MULTIKEYHELPA, *PMULTIKEYHELPA, *LPMULTIKEYHELPA;
typedef struct tagMULTIKEYHELPW {
    DWORD  mkSize;
    WCHAR  mkKeylist;
    WCHAR  szKeyphrase[1];
} MULTIKEYHELPW, *PMULTIKEYHELPW, *LPMULTIKEYHELPW;
#line 7737 "C:\WATCOM\H\NT\winuser.h"
typedef MULTIKEYHELPA MULTIKEYHELP;
typedef PMULTIKEYHELPA PMULTIKEYHELP;
typedef LPMULTIKEYHELPA LPMULTIKEYHELP;
// UNICODE

typedef struct tagHELPWININFOA {
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    CHAR   rgchMember[2];
} HELPWININFOA, *PHELPWININFOA, *LPHELPWININFOA;
typedef struct tagHELPWININFOW {
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    WCHAR  rgchMember[2];
} HELPWININFOW, *PHELPWININFOW, *LPHELPWININFOW;
#line 7765 "C:\WATCOM\H\NT\winuser.h"
typedef HELPWININFOA HELPWININFO;
typedef PHELPWININFOA PHELPWININFO;
typedef LPHELPWININFOA LPHELPWININFO;
// UNICODE

/*
 * Commands to pass to WinHelp()
 */
/* Display topic in ulTopic */
/* Terminate help */
/* Display index */

/* Display help on using help */
/* Set current Index for multi index help */



/* Display topic for keyword in offabData */




 









// These are in winhelp.h in Win95.

// Control doesn't have matching help context
// Property sheet help button




/* WINVER >= 0x0400 */

 __declspec(dllimport) 
BOOL
 __stdcall 
WinHelpA(
    HWND hWndMain,
    LPCSTR lpszHelp,
    UINT uCommand,
    DWORD dwData
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
WinHelpW(
    HWND hWndMain,
    LPCWSTR lpszHelp,
    UINT uCommand,
    DWORD dwData
    );
#line 7828 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

/* !NOHELP */



/*
 * Parameter for SystemParametersInfo()
 */


































 










































/* WINVER >= 0x0400 */












 


/* WINVER >= 0x0400 */



/*
 * Flags
 */




 



typedef struct tagNONCLIENTMETRICSA
{
    UINT    cbSize;
    int     iBorderWidth;
    int     iScrollWidth;
    int     iScrollHeight;
    int     iCaptionWidth;
    int     iCaptionHeight;
    LOGFONTA lfCaptionFont;
    int     iSmCaptionWidth;
    int     iSmCaptionHeight;
    LOGFONTA lfSmCaptionFont;
    int     iMenuWidth;
    int     iMenuHeight;
    LOGFONTA lfMenuFont;
    LOGFONTA lfStatusFont;
    LOGFONTA lfMessageFont;
}   NONCLIENTMETRICSA, *PNONCLIENTMETRICSA,   * LPNONCLIENTMETRICSA;
typedef struct tagNONCLIENTMETRICSW
{
    UINT    cbSize;
    int     iBorderWidth;
    int     iScrollWidth;
    int     iScrollHeight;
    int     iCaptionWidth;
    int     iCaptionHeight;
    LOGFONTW lfCaptionFont;
    int     iSmCaptionWidth;
    int     iSmCaptionHeight;
    LOGFONTW lfSmCaptionFont;
    int     iMenuWidth;
    int     iMenuHeight;
    LOGFONTW lfMenuFont;
    LOGFONTW lfStatusFont;
    LOGFONTW lfMessageFont;
}   NONCLIENTMETRICSW, *PNONCLIENTMETRICSW,   * LPNONCLIENTMETRICSW;
#line 7987 "C:\WATCOM\H\NT\winuser.h"
typedef NONCLIENTMETRICSA NONCLIENTMETRICS;
typedef PNONCLIENTMETRICSA PNONCLIENTMETRICS;
typedef LPNONCLIENTMETRICSA LPNONCLIENTMETRICS;
// UNICODE
/* NOGDI */
/* _WINGDI_ */
















typedef struct tagMINIMIZEDMETRICS
{
    UINT    cbSize;
    int     iWidth;
    int     iHorzGap;
    int     iVertGap;
    int     iArrange;
}   MINIMIZEDMETRICS, *PMINIMIZEDMETRICS, *LPMINIMIZEDMETRICS;

typedef struct tagICONMETRICSA
{
    UINT    cbSize;
    int     iHorzSpacing;
    int     iVertSpacing;
    int     iTitleWrap;
    LOGFONTA lfFont;
}   ICONMETRICSA, *PICONMETRICSA, *LPICONMETRICSA;
typedef struct tagICONMETRICSW
{
    UINT    cbSize;
    int     iHorzSpacing;
    int     iVertSpacing;
    int     iTitleWrap;
    LOGFONTW lfFont;
}   ICONMETRICSW, *PICONMETRICSW, *LPICONMETRICSW;
#line 8039 "C:\WATCOM\H\NT\winuser.h"
typedef ICONMETRICSA ICONMETRICS;
typedef PICONMETRICSA PICONMETRICS;
typedef LPICONMETRICSA LPICONMETRICS;
// UNICODE

typedef struct tagANIMATIONINFO
{
    UINT    cbSize;
    int     iMinAnimate;
}   ANIMATIONINFO, *LPANIMATIONINFO;

typedef struct tagSERIALKEYSA
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPSTR     lpszActivePort;
    LPSTR     lpszPort;
    UINT    iBaudRate;
    UINT    iPortState;
    UINT    iActive;
}   SERIALKEYSA, *LPSERIALKEYSA;
typedef struct tagSERIALKEYSW
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPWSTR    lpszActivePort;
    LPWSTR    lpszPort;
    UINT    iBaudRate;
    UINT    iPortState;
    UINT    iActive;
}   SERIALKEYSW, *LPSERIALKEYSW;
#line 8074 "C:\WATCOM\H\NT\winuser.h"
typedef SERIALKEYSA SERIALKEYS;
typedef LPSERIALKEYSA LPSERIALKEYS;
// UNICODE

/* flags for SERIALKEYS dwFlags field */




typedef struct tagHIGHCONTRASTA
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPSTR   lpszDefaultScheme;
}   HIGHCONTRASTA, *LPHIGHCONTRASTA;
typedef struct tagHIGHCONTRASTW
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPWSTR  lpszDefaultScheme;
}   HIGHCONTRASTW, *LPHIGHCONTRASTW;
#line 8099 "C:\WATCOM\H\NT\winuser.h"
typedef HIGHCONTRASTA HIGHCONTRAST;
typedef LPHIGHCONTRASTA LPHIGHCONTRAST;
// UNICODE

/* flags for HIGHCONTRAST dwFlags field */








/* Flags for ChangeDisplaySettings */




/* Return values */







 __declspec(dllimport) 
LONG
 __stdcall 
ChangeDisplaySettingsA(
    LPDEVMODEA lpDevMode,
    DWORD dwFlags);
 __declspec(dllimport) 
LONG
 __stdcall 
ChangeDisplaySettingsW(
    LPDEVMODEW lpDevMode,
    DWORD dwFlags);
#line 8140 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
EnumDisplaySettingsA(
    LPCSTR lpszDeviceName,
    DWORD iModeNum,
    LPDEVMODEA lpDevMode);
 __declspec(dllimport) 
BOOL
 __stdcall 
EnumDisplaySettingsW(
    LPCWSTR lpszDeviceName,
    DWORD iModeNum,
    LPDEVMODEW lpDevMode);
#line 8160 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

/* WINVER >= 0x0400 */

 __declspec(dllimport) 
BOOL
 __stdcall 
SystemParametersInfoA(
    UINT uiAction,
    UINT uiParam,
    PVOID pvParam,
    UINT fWinIni);
 __declspec(dllimport) 
BOOL
 __stdcall 
SystemParametersInfoW(
    UINT uiAction,
    UINT uiParam,
    PVOID pvParam,
    UINT fWinIni);
#line 8184 "C:\WATCOM\H\NT\winuser.h"

// !UNICODE

/* !NOSYSPARAMSINFO  */

/*
 * Accessibility support
 */
typedef struct tagFILTERKEYS
{
    UINT  cbSize;
    DWORD dwFlags;
    DWORD iWaitMSec;            // Acceptance Delay 
    DWORD iDelayMSec;           // Delay Until Repeat 
    DWORD iRepeatMSec;          // Repeat Rate 
    DWORD iBounceMSec;          // Debounce Time 
} FILTERKEYS, *LPFILTERKEYS;

/*
 * FILTERKEYS dwFlags field
 */








typedef struct tagSTICKYKEYS
{
    UINT  cbSize;
    DWORD dwFlags;
} STICKYKEYS, *LPSTICKYKEYS;

/*
 * STICKYKEYS dwFlags field
 */










typedef struct tagMOUSEKEYS
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iMaxSpeed;
    DWORD iTimeToMaxSpeed;
    DWORD iCtrlSpeed;
    DWORD dwReserved1;
    DWORD dwReserved2;
} MOUSEKEYS, *LPMOUSEKEYS;

/*
 * MOUSEKEYS dwFlags field
 */









typedef struct tagACCESSTIMEOUT
{
    UINT  cbSize;
    DWORD dwFlags;
    DWORD iTimeOutMSec;
} ACCESSTIMEOUT, *LPACCESSTIMEOUT;

/*
 * ACCESSTIMEOUT dwFlags field
 */



/* values for SOUNDSENTRY iFSGrafEffect field */



/* values for SOUNDSENTRY iFSTextEffect field */





/* values for SOUNDSENTRY iWindowsEffect field */






typedef struct tagSOUNDSENTRYA
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iFSTextEffect;
    DWORD iFSTextEffectMSec;
    DWORD iFSTextEffectColorBits;
    DWORD iFSGrafEffect;
    DWORD iFSGrafEffectMSec;
    DWORD iFSGrafEffectColor;
    DWORD iWindowsEffect;
    DWORD iWindowsEffectMSec;
    LPSTR   lpszWindowsEffectDLL;
    DWORD iWindowsEffectOrdinal;
} SOUNDSENTRYA, *LPSOUNDSENTRYA;
typedef struct tagSOUNDSENTRYW
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iFSTextEffect;
    DWORD iFSTextEffectMSec;
    DWORD iFSTextEffectColorBits;
    DWORD iFSGrafEffect;
    DWORD iFSGrafEffectMSec;
    DWORD iFSGrafEffectColor;
    DWORD iWindowsEffect;
    DWORD iWindowsEffectMSec;
    LPWSTR  lpszWindowsEffectDLL;
    DWORD iWindowsEffectOrdinal;
} SOUNDSENTRYW, *LPSOUNDSENTRYW;
#line 8319 "C:\WATCOM\H\NT\winuser.h"
typedef SOUNDSENTRYA SOUNDSENTRY;
typedef LPSOUNDSENTRYA LPSOUNDSENTRY;
// UNICODE

/*
 * SOUNDSENTRY dwFlags field
 */




typedef struct tagTOGGLEKEYS
{
    UINT cbSize;
    DWORD dwFlags;
} TOGGLEKEYS, *LPTOGGLEKEYS;

/*
 * TOGGLEKEYS dwFlags field
 */







/*
 * Set debug level
 */

 __declspec(dllimport) 
 void 
 __stdcall 
SetDebugErrorLevel(
    DWORD dwLevel
    );

/*
 * SetLastErrorEx() types.
 */





 __declspec(dllimport) 
 void 
 __stdcall 
SetLastErrorEx(
    DWORD dwErrCode,
    DWORD dwType
    );


}
/* __cplusplus */

/* !_WINUSER_ */
#line 160 "C:\WATCOM\H\NT\windows.h"

#line 1 "C:\WATCOM\H\NT\winnls.h"
/**************************************************************************
*                                                                         *
* winnls.h -- NLS procedure declarations, constant definitions and macros *
*                                                                         *
* Copyright (c) 1991-1995, Microsoft Corp. All rights reserved.           *
*                                                                         *
**************************************************************************/







extern "C" {





/***************************************************************************
* Constants
*
* Define all constants for the NLS component here.
\***************************************************************************/


/*
 *  String Length Maximums.
 */
/* 5 ranges, 2 bytes ea., 0 term. */
/* single or double byte */


/*
 *  MBCS and Unicode Translation Flags.
 */
/* use precomposed chars */
/* use composite chars */
/* use glyph chars, not ctrl chars */
/* error for invalid chars */

/* check for default char */
/* convert composite to precomposed */
/* discard non-spacing chars */
/* generate separate chars */
/* replace w/ default char */



/*
 *  Character Type Flags.
 */
/* ctype 1 information */
/* ctype 2 information */
/* ctype 3 information */

/*
 *  CType 1 Flag Bits.
 */
/* upper case */
/* lower case */
/* decimal digits */
/* spacing characters */
/* punctuation characters */
/* control characters */
/* blank characters */
/* other digits */
/* any linguistic character */

/*
 *  CType 2 Flag Bits.
 */
/* left to right */
/* right to left */

/* European number, digit */
/* European numeric separator */
/* European numeric terminator */
/* Arabic number */
/* common numeric separator */

/* block separator */
/* segment separator */
/* white space */
/* other neutrals */

/* no implicit directionality */

/*
 *  CType 3 Flag Bits.
 */
/* nonspacing character */
/* diacritic mark */
/* vowel mark */
/* symbols */

/* katakana character */
/* hiragana character */
/* half width character */
/* full width character */
/* ideographic character */
/* Arabic kashida character */
/* lexical character */

/* any linguistic char (C1_ALPHA) */

/* ctype 3 is not applicable */


/*
 *  String Flags.
 */
/* ignore case */
/* ignore nonspacing chars */
/* ignore symbols */

/* ignore kanatype */
/* ignore width */


/*
 *  Locale Independent Mapping Flags.
 */
/* fold compatibility zone chars */
/* convert to precomposed chars */
/* convert to composite chars */
/* all digits to ASCII 0-9 */


/*
 *  Locale Dependent Mapping Flags.
 */
/* lower case letters */
/* upper case letters */
/* WC sort key (normalize) */
/* byte reversal */

/* map katakana to hiragana */
/* map hiragana to katakana */
/* map double byte to single byte */
/* map single byte to double byte */



/*
 *  Locale Enumeration Flags.
 */
/* installed locale ids */
/* supported locale ids */

/*
 *  Code Page Enumeration Flags.
 */
/* installed code page ids */
/* supported code page ids */


/*
 *  Sorting Flags.
 *
 *    WORD Sort:    culturally correct sort
 *                  hyphen and apostrophe are special cased
 *                  example: "coop" and "co-op" will sort together in a list
 *
 *                        co_op     <-------  underscore (symbol)
 *                        coat
 *                        comb
 *                        coop
 *                        co-op     <-------  hyphen (punctuation)
 *                        cork
 *                        went
 *                        were
 *                        we're     <-------  apostrophe (punctuation)
 *
 *
 *    STRING Sort:  hyphen and apostrophe will sort with all other symbols
 *
 *                        co-op     <-------  hyphen (punctuation)
 *                        co_op     <-------  underscore (symbol)
 *                        coat
 *                        comb
 *                        coop
 *                        cork
 *                        we're     <-------  apostrophe (punctuation)
 *                        went
 *                        were
 */
/* use string sort method */


/*
 *  Code Page Default Values.
 */
/* default to ANSI code page */
/* default to OEM  code page */
/* default to MAC  code page */


/*
 *  Country Codes.
 */


/* Australia */
/* Austria */
/* Belgium */
/* Brazil */
/* Bulgaria */
/* Canada */
/* Croatia */
/* Czech Republic */
/* Denmark */
/* Finland */
/* France */
/* Germany */
/* Greece */
/* Hong Kong */
/* Hungary */
/* Iceland */
/* Ireland */
/* Italy */
/* Japan */
/* Mexico */
/* Netherlands */
/* New Zealand */
/* Norway */
/* Poland */
/* Portugal */
/* Peoples' Republic of China */
/* Romania */
/* Russia */
/* Singapore */
/* Slovak Republic */
/* Slovenia */
/* South Korea */
/* Spain */
/* Sweden */
/* Switzerland */
/* Taiwan */
/* Turkey */
/* United Kingdom */
/* United States */


/*
 *  Locale Types.
 *
 *  These types are used for the GetLocaleInfoW NLS API routine.
 *
 *  LOCALE_NOUSEROVERRIDE is also used in GetTimeFormatW and GetDateFormatW.
 *
 *  LOCALE_USE_CP_ACP is used in many of the A (Ansi) apis that need to do 
 *  string translation.
 */
/* do not use user overrides */
/* use the system ACP */

/* language id */
/* localized name of language */
/* English name of language */
/* abbreviated language name */
/* native name of language */
/* country code */
/* localized name of country */
/* English name of country */
/* abbreviated country name */
/* native name of country */
/* default language id */
/* default country code */
/* default oem code page */
/* default ansi code page */

/* list item separator */
/* 0 = metric, 1 = US */

/* decimal separator */
/* thousand separator */
/* digit grouping */
/* number of fractional digits */
/* leading zeros for decimal */
/* negative number mode */
/* native ascii 0-9 */

/* local monetary symbol */
/* intl monetary symbol */
/* monetary decimal separator */
/* monetary thousand separator */
/* monetary grouping */
/* # local monetary digits */
/* # intl monetary digits */
/* positive currency mode */
/* negative currency mode */

/* date separator */
/* time separator */
/* short date format string */
/* long date format string */
/* time format string */
/* short date format ordering */
/* long date format ordering */
/* time format specifier */
/* time marker position */
/* century format specifier (short date) */
/* leading zeros in time field */
/* leading zeros in day field (short date) */
/* leading zeros in month field (short date) */
/* AM designator */
/* PM designator */

/* type of calendar specifier */
/* additional calendar types specifier */
/* first day of week specifier */
/* first week of year specifier */

/* long name for Monday */
/* long name for Tuesday */
/* long name for Wednesday */
/* long name for Thursday */
/* long name for Friday */
/* long name for Saturday */
/* long name for Sunday */
/* abbreviated name for Monday */
/* abbreviated name for Tuesday */
/* abbreviated name for Wednesday */
/* abbreviated name for Thursday */
/* abbreviated name for Friday */
/* abbreviated name for Saturday */
/* abbreviated name for Sunday */
/* long name for January */
/* long name for February */
/* long name for March */
/* long name for April */
/* long name for May */
/* long name for June */
/* long name for July */
/* long name for August */
/* long name for September */
/* long name for October */
/* long name for November */
/* long name for December */
/* long name for 13th month (if exists) */
/* abbreviated name for January */
/* abbreviated name for February */
/* abbreviated name for March */
/* abbreviated name for April */
/* abbreviated name for May */
/* abbreviated name for June */
/* abbreviated name for July */
/* abbreviated name for August */
/* abbreviated name for September */
/* abbreviated name for October */
/* abbreviated name for November */
/* abbreviated name for December */
/* abbreviated name for 13th month (if exists) */

/* positive sign */
/* negative sign */
/* positive sign position */
/* negative sign position */
/* mon sym precedes pos amt */
/* mon sym sep by space from pos amt */
/* mon sym precedes neg amt */
/* mon sym sep by space from neg amt */

 
/* font signature */
/* WINVER >= 0x0400 */

/*
 *  Time Flags for GetTimeFormatW.
 */
/* do not use minutes or seconds */
/* do not use seconds */
/* do not use time marker */
/* always use 24 hour format */


/*
 *  Date Flags for GetDateFormatW.
 */
/* use short date picture */
/* use long date picture */
/* use alternate calendar (if any) */


/*
 *  Calendar Types.
 *
 *  These types are used for the GetALTCalendarInfoW NLS API routine.
 */
/* calendar type */
/* native name of calendar */
/* starting years of eras */
/* era name for IYearOffsetRanges */
/* short date format string */
/* long date format string */
/* native name for Monday */
/* native name for Tuesday */
/* native name for Wednesday */
/* native name for Thursday */
/* native name for Friday */
/* native name for Saturday */
/* native name for Sunday */
/* abbreviated name for Monday */
/* abbreviated name for Tuesday */
/* abbreviated name for Wednesday */
/* abbreviated name for Thursday */
/* abbreviated name for Friday */
/* abbreviated name for Saturday */
/* abbreviated name for Sunday */
/* native name for January */
/* native name for February */
/* native name for March */
/* native name for April */
/* native name for May */
/* native name for June */
/* native name for July */
/* native name for August */
/* native name for September */
/* native name for October */
/* native name for November */
/* native name for December */
/* native name for 13th month (if any) */
/* abbreviated name for January */
/* abbreviated name for February */
/* abbreviated name for March */
/* abbreviated name for April */
/* abbreviated name for May */
/* abbreviated name for June */
/* abbreviated name for July */
/* abbreviated name for August */
/* abbreviated name for September */
/* abbreviated name for October */
/* abbreviated name for November */
/* abbreviated name for December */
/* abbreviated name for 13th month (if any) */


/*
 *  Calendar Enumeration Value.
 */
/* enumerate all calendars */


/*
 *  Calendar ID Values.
 */
/* Gregorian (localized) calendar */
/* Gregorian (U.S.) calendar */
/* Japanese Emperor Era calendar */
/* Republic of China Era calendar */
/* Korean Tangun Era calendar */




/***************************************************************************
* Typedefs
*
* Define all types for the NLS component here.
\***************************************************************************/

/*
 *  Locale type constant.
 */
typedef DWORD LCTYPE;

/*
 *  Calendar type constant.
 */
typedef DWORD CALTYPE;

/*
 *  Calendar ID.
 */
typedef DWORD CALID;


/*
 *  CP Info.
 */

typedef struct _cpinfo {
    UINT    MaxCharSize;                    /* max length (bytes) of a char */ 
    BYTE    DefaultChar[ 2 ];   /* default character */ 
    BYTE    LeadByte[ 12 ];        /* lead byte ranges */ 
} CPINFO, *LPCPINFO;


/*
 *  Number format.
 */

typedef struct _numberfmtA {
    UINT    NumDigits;                 /* number of decimal digits */ 
    UINT    LeadingZero;               /* if leading zero in decimal fields */ 
    UINT    Grouping;                  /* group size left of decimal */ 
    LPSTR   lpDecimalSep;              /* ptr to decimal separator string */ 
    LPSTR   lpThousandSep;             /* ptr to thousand separator string */ 
    UINT    NegativeOrder;             /* negative number ordering */ 
} NUMBERFMTA, *LPNUMBERFMTA;
typedef struct _numberfmtW {
    UINT    NumDigits;                 /* number of decimal digits */ 
    UINT    LeadingZero;               /* if leading zero in decimal fields */ 
    UINT    Grouping;                  /* group size left of decimal */ 
    LPWSTR  lpDecimalSep;              /* ptr to decimal separator string */ 
    LPWSTR  lpThousandSep;             /* ptr to thousand separator string */ 
    UINT    NegativeOrder;             /* negative number ordering */ 
} NUMBERFMTW, *LPNUMBERFMTW;
#line 515 "C:\WATCOM\H\NT\winnls.h"
typedef NUMBERFMTA NUMBERFMT;
typedef LPNUMBERFMTA LPNUMBERFMT;
// UNICODE


/*
 *  Currency format.
 */

typedef struct _currencyfmtA {
    UINT    NumDigits;                 /* number of decimal digits */ 
    UINT    LeadingZero;               /* if leading zero in decimal fields */ 
    UINT    Grouping;                  /* group size left of decimal */ 
    LPSTR   lpDecimalSep;              /* ptr to decimal separator string */ 
    LPSTR   lpThousandSep;             /* ptr to thousand separator string */ 
    UINT    NegativeOrder;             /* negative currency ordering */ 
    UINT    PositiveOrder;             /* positive currency ordering */ 
    LPSTR   lpCurrencySymbol;          /* ptr to currency symbol string */ 
} CURRENCYFMTA, *LPCURRENCYFMTA;
typedef struct _currencyfmtW {
    UINT    NumDigits;                 /* number of decimal digits */ 
    UINT    LeadingZero;               /* if leading zero in decimal fields */ 
    UINT    Grouping;                  /* group size left of decimal */ 
    LPWSTR  lpDecimalSep;              /* ptr to decimal separator string */ 
    LPWSTR  lpThousandSep;             /* ptr to thousand separator string */ 
    UINT    NegativeOrder;             /* negative currency ordering */ 
    UINT    PositiveOrder;             /* positive currency ordering */ 
    LPWSTR  lpCurrencySymbol;          /* ptr to currency symbol string */ 
} CURRENCYFMTW, *LPCURRENCYFMTW;
#line 548 "C:\WATCOM\H\NT\winnls.h"
typedef CURRENCYFMTA CURRENCYFMT;
typedef LPCURRENCYFMTA LPCURRENCYFMT;
// UNICODE



/*
 *  Enumeration function constants.
 */

/* !STRICT */#line 573 "C:\WATCOM\H\NT\winnls.h"

typedef FARPROC LOCALE_ENUMPROCA;
typedef FARPROC CODEPAGE_ENUMPROCA;
typedef FARPROC DATEFMT_ENUMPROCA;
typedef FARPROC TIMEFMT_ENUMPROCA;
typedef FARPROC CALINFO_ENUMPROCA;

typedef FARPROC LOCALE_ENUMPROCW;
typedef FARPROC CODEPAGE_ENUMPROCW;
typedef FARPROC DATEFMT_ENUMPROCW;
typedef FARPROC TIMEFMT_ENUMPROCW;
typedef FARPROC CALINFO_ENUMPROCW;

/* !STRICT */

#line 597 "C:\WATCOM\H\NT\winnls.h"







// !UNICODE



/***************************************************************************
* Macros
*
* Define all macros for the NLS component here.
\***************************************************************************/



/***************************************************************************
* Function Prototypes
*
* Only prototypes for the NLS APIs should go here.
\***************************************************************************/

/*
 *  Code Page Dependent APIs.
 */

 __declspec(dllimport) 
BOOL
 __stdcall 
IsValidCodePage(
    UINT  CodePage);

 __declspec(dllimport) 
UINT
 __stdcall 
GetACP(void);

 __declspec(dllimport) 
UINT
 __stdcall 
GetOEMCP(void);

 __declspec(dllimport) 
BOOL
 __stdcall 
GetCPInfo(
    UINT      CodePage,
    LPCPINFO  lpCPInfo);

 __declspec(dllimport) 
BOOL
 __stdcall 
IsDBCSLeadByte(
    BYTE  TestChar);

 __declspec(dllimport) 
BOOL
 __stdcall 
IsDBCSLeadByteEx(
    UINT  CodePage,
    BYTE  TestChar);

 __declspec(dllimport) 
int
 __stdcall 
MultiByteToWideChar(
    UINT     CodePage,
    DWORD    dwFlags,
    LPCSTR   lpMultiByteStr,
    int      cchMultiByte,
    LPWSTR   lpWideCharStr,
    int      cchWideChar);

 __declspec(dllimport) 
int
 __stdcall 
WideCharToMultiByte(
    UINT     CodePage,
    DWORD    dwFlags,
    LPCWSTR  lpWideCharStr,
    int      cchWideChar,
    LPSTR    lpMultiByteStr,
    int      cchMultiByte,
    LPCSTR   lpDefaultChar,
    LPBOOL   lpUsedDefaultChar);


/*
 *  Locale Dependent APIs.
 */

 __declspec(dllimport) 
int
 __stdcall 
CompareStringA(
    LCID     Locale,
    DWORD    dwCmpFlags,
    LPCSTR lpString1,
    int      cchCount1,
    LPCSTR lpString2,
    int      cchCount2);
 __declspec(dllimport) 
int
 __stdcall 
CompareStringW(
    LCID     Locale,
    DWORD    dwCmpFlags,
    LPCWSTR lpString1,
    int      cchCount1,
    LPCWSTR lpString2,
    int      cchCount2);
#line 714 "C:\WATCOM\H\NT\winnls.h"

// !UNICODE

 __declspec(dllimport) 
int
 __stdcall 
LCMapStringA(
    LCID     Locale,
    DWORD    dwMapFlags,
    LPCSTR lpSrcStr,
    int      cchSrc,
    LPSTR  lpDestStr,
    int      cchDest);
 __declspec(dllimport) 
int
 __stdcall 
LCMapStringW(
    LCID     Locale,
    DWORD    dwMapFlags,
    LPCWSTR lpSrcStr,
    int      cchSrc,
    LPWSTR  lpDestStr,
    int      cchDest);
#line 740 "C:\WATCOM\H\NT\winnls.h"

// !UNICODE

 __declspec(dllimport) 
int
 __stdcall 
GetLocaleInfoA(
    LCID     Locale,
    LCTYPE   LCType,
    LPSTR  lpLCData,
    int      cchData);
 __declspec(dllimport) 
int
 __stdcall 
GetLocaleInfoW(
    LCID     Locale,
    LCTYPE   LCType,
    LPWSTR  lpLCData,
    int      cchData);
#line 762 "C:\WATCOM\H\NT\winnls.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
SetLocaleInfoA(
    LCID     Locale,
    LCTYPE   LCType,
    LPCSTR lpLCData);
 __declspec(dllimport) 
BOOL
 __stdcall 
SetLocaleInfoW(
    LCID     Locale,
    LCTYPE   LCType,
    LPCWSTR lpLCData);
#line 782 "C:\WATCOM\H\NT\winnls.h"

// !UNICODE

 __declspec(dllimport) 
int
 __stdcall 
GetTimeFormatA(
    LCID     Locale,
    DWORD    dwFlags,
     const  SYSTEMTIME *lpTime,
    LPCSTR lpFormat,
    LPSTR  lpTimeStr,
    int      cchTime);
 __declspec(dllimport) 
int
 __stdcall 
GetTimeFormatW(
    LCID     Locale,
    DWORD    dwFlags,
     const  SYSTEMTIME *lpTime,
    LPCWSTR lpFormat,
    LPWSTR  lpTimeStr,
    int      cchTime);
#line 808 "C:\WATCOM\H\NT\winnls.h"

// !UNICODE

 __declspec(dllimport) 
int
 __stdcall 
GetDateFormatA(
    LCID     Locale,
    DWORD    dwFlags,
     const  SYSTEMTIME *lpDate,
    LPCSTR lpFormat,
    LPSTR  lpDateStr,
    int      cchDate);
 __declspec(dllimport) 
int
 __stdcall 
GetDateFormatW(
    LCID     Locale,
    DWORD    dwFlags,
     const  SYSTEMTIME *lpDate,
    LPCWSTR lpFormat,
    LPWSTR  lpDateStr,
    int      cchDate);
#line 834 "C:\WATCOM\H\NT\winnls.h"

// !UNICODE

 __declspec(dllimport) 
int
 __stdcall 
GetNumberFormatA(
    LCID     Locale,
    DWORD    dwFlags,
    LPCSTR lpValue,
     const  NUMBERFMTA *lpFormat,
    LPSTR  lpNumberStr,
    int      cchNumber);
 __declspec(dllimport) 
int
 __stdcall 
GetNumberFormatW(
    LCID     Locale,
    DWORD    dwFlags,
    LPCWSTR lpValue,
     const  NUMBERFMTW *lpFormat,
    LPWSTR  lpNumberStr,
    int      cchNumber);
#line 860 "C:\WATCOM\H\NT\winnls.h"

// !UNICODE

 __declspec(dllimport) 
int
 __stdcall 
GetCurrencyFormatA(
    LCID     Locale,
    DWORD    dwFlags,
    LPCSTR lpValue,
     const  CURRENCYFMTA *lpFormat,
    LPSTR  lpCurrencyStr,
    int      cchCurrency);
 __declspec(dllimport) 
int
 __stdcall 
GetCurrencyFormatW(
    LCID     Locale,
    DWORD    dwFlags,
    LPCWSTR lpValue,
     const  CURRENCYFMTW *lpFormat,
    LPWSTR  lpCurrencyStr,
    int      cchCurrency);
#line 886 "C:\WATCOM\H\NT\winnls.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
EnumCalendarInfoA(
    CALINFO_ENUMPROCA lpCalInfoEnumProc,
    LCID              Locale,
    CALID             Calendar,
    CALTYPE           CalType);
 __declspec(dllimport) 
BOOL
 __stdcall 
EnumCalendarInfoW(
    CALINFO_ENUMPROCW lpCalInfoEnumProc,
    LCID              Locale,
    CALID             Calendar,
    CALTYPE           CalType);
#line 908 "C:\WATCOM\H\NT\winnls.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
EnumTimeFormatsA(
    TIMEFMT_ENUMPROCA lpTimeFmtEnumProc,
    LCID              Locale,
    DWORD             dwFlags);
 __declspec(dllimport) 
BOOL
 __stdcall 
EnumTimeFormatsW(
    TIMEFMT_ENUMPROCW lpTimeFmtEnumProc,
    LCID              Locale,
    DWORD             dwFlags);
#line 928 "C:\WATCOM\H\NT\winnls.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
EnumDateFormatsA(
    DATEFMT_ENUMPROCA lpDateFmtEnumProc,
    LCID              Locale,
    DWORD             dwFlags);
 __declspec(dllimport) 
BOOL
 __stdcall 
EnumDateFormatsW(
    DATEFMT_ENUMPROCW lpDateFmtEnumProc,
    LCID              Locale,
    DWORD             dwFlags);
#line 948 "C:\WATCOM\H\NT\winnls.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
IsValidLocale(
    LCID   Locale,
    DWORD  dwFlags);

 __declspec(dllimport) 
LCID
 __stdcall 
ConvertDefaultLocale(
    LCID   Locale);

 __declspec(dllimport) 
LCID
 __stdcall 
GetThreadLocale(void);

 __declspec(dllimport) 
BOOL
 __stdcall 
SetThreadLocale(
    LCID  Locale
    );

 __declspec(dllimport) 
LANGID
 __stdcall 
GetSystemDefaultLangID(void);

 __declspec(dllimport) 
LANGID
 __stdcall 
GetUserDefaultLangID(void);

 __declspec(dllimport) 
LCID
 __stdcall 
GetSystemDefaultLCID(void);

 __declspec(dllimport) 
LCID
 __stdcall 
GetUserDefaultLCID(void);

/*
 *  Locale Independent APIs.
 */

 __declspec(dllimport) 
BOOL
 __stdcall 
GetStringTypeExA(
    LCID     Locale,
    DWORD    dwInfoType,
    LPCSTR lpSrcStr,
    int      cchSrc,
    LPWORD   lpCharType);
 __declspec(dllimport) 
BOOL
 __stdcall 
GetStringTypeExW(
    LCID     Locale,
    DWORD    dwInfoType,
    LPCWSTR lpSrcStr,
    int      cchSrc,
    LPWORD   lpCharType);
#line 1021 "C:\WATCOM\H\NT\winnls.h"

// !UNICODE

/*
 *  NOTE: The parameters for GetStringTypeA and GetStringTypeW are
 *        NOT the same.  The W version was shipped in NT 3.1.  The
 *        A version was then shipped in 16-bit OLE with the wrong
 *        parameters (ported from Win95).  To be compatible, we
 *        must break the relationship between the A and W versions
 *        of GetStringType.  There will be NO function call for the
 *        generic GetStringType.
 *
 *        GetStringTypeEx (above) should be used instead.
 */
 __declspec(dllimport) 
BOOL
 __stdcall 
GetStringTypeA(
    LCID     Locale,
    DWORD    dwInfoType,
    LPCSTR   lpSrcStr,
    int      cchSrc,
    LPWORD   lpCharType);

 __declspec(dllimport) 
BOOL
 __stdcall 
GetStringTypeW(
    DWORD    dwInfoType,
    LPCWSTR  lpSrcStr,
    int      cchSrc,
    LPWORD   lpCharType);


 __declspec(dllimport) 
int
 __stdcall 
FoldStringA(
    DWORD    dwMapFlags,
    LPCSTR lpSrcStr,
    int      cchSrc,
    LPSTR  lpDestStr,
    int      cchDest);
 __declspec(dllimport) 
int
 __stdcall 
FoldStringW(
    DWORD    dwMapFlags,
    LPCWSTR lpSrcStr,
    int      cchSrc,
    LPWSTR  lpDestStr,
    int      cchDest);
#line 1076 "C:\WATCOM\H\NT\winnls.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
EnumSystemLocalesA(
    LOCALE_ENUMPROCA lpLocaleEnumProc,
    DWORD            dwFlags);
 __declspec(dllimport) 
BOOL
 __stdcall 
EnumSystemLocalesW(
    LOCALE_ENUMPROCW lpLocaleEnumProc,
    DWORD            dwFlags);
#line 1094 "C:\WATCOM\H\NT\winnls.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
EnumSystemCodePagesA(
    CODEPAGE_ENUMPROCA lpCodePageEnumProc,
    DWORD              dwFlags);
 __declspec(dllimport) 
BOOL
 __stdcall 
EnumSystemCodePagesW(
    CODEPAGE_ENUMPROCW lpCodePageEnumProc,
    DWORD              dwFlags);
#line 1112 "C:\WATCOM\H\NT\winnls.h"

// !UNICODE



// NONLS


}


// _WINNLS_
#line 161 "C:\WATCOM\H\NT\windows.h"

#line 1 "C:\WATCOM\H\NT\wincon.h"
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1989-1995  Microsoft Corporation

Module Name:

    wincon.h

Abstract:

    This module contains the public data structures, data types,
    and procedures exported by the NT console subsystem.

Created:

    26-Oct-1990

Revision History:

--*/





extern "C" {


typedef struct _COORD {
    SHORT X;
    SHORT Y;
} COORD, *PCOORD;

typedef struct _SMALL_RECT {
    SHORT Left;
    SHORT Top;
    SHORT Right;
    SHORT Bottom;
} SMALL_RECT, *PSMALL_RECT;

typedef struct _KEY_EVENT_RECORD {
    BOOL bKeyDown;
    WORD wRepeatCount;
    WORD wVirtualKeyCode;
    WORD wVirtualScanCode;
    union {
        WCHAR UnicodeChar;
        CHAR   AsciiChar;
    } uChar;
    DWORD dwControlKeyState;
} KEY_EVENT_RECORD, *PKEY_EVENT_RECORD;

//
// ControlKeyState flags
//

// the right alt key is pressed.
// the left alt key is pressed.
// the right ctrl key is pressed.
// the left ctrl key is pressed.
// the shift key is pressed.
// the numlock light is on.
// the scrolllock light is on.
// the capslock light is on.
// the key is enhanced.

typedef struct _MOUSE_EVENT_RECORD {
    COORD dwMousePosition;
    DWORD dwButtonState;
    DWORD dwControlKeyState;
    DWORD dwEventFlags;
} MOUSE_EVENT_RECORD, *PMOUSE_EVENT_RECORD;

//
// ButtonState flags
//







//
// EventFlags
//




typedef struct _WINDOW_BUFFER_SIZE_RECORD {
    COORD dwSize;
} WINDOW_BUFFER_SIZE_RECORD, *PWINDOW_BUFFER_SIZE_RECORD;

typedef struct _MENU_EVENT_RECORD {
    UINT dwCommandId;
} MENU_EVENT_RECORD, *PMENU_EVENT_RECORD;

typedef struct _FOCUS_EVENT_RECORD {
    BOOL bSetFocus;
} FOCUS_EVENT_RECORD, *PFOCUS_EVENT_RECORD;

#line 1 "C:\WATCOM\H\NT\pshpack4.h"
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pshpack4.h

Abstract:

    This file turns 4 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push)

#pragma pack(4)
#line 32 "C:\WATCOM\H\NT\pshpack4.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 103 "C:\WATCOM\H\NT\wincon.h"


typedef struct _INPUT_RECORD {
    WORD EventType;
    union {
        KEY_EVENT_RECORD KeyEvent;
        MOUSE_EVENT_RECORD MouseEvent;
        WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
        MENU_EVENT_RECORD MenuEvent;
        FOCUS_EVENT_RECORD FocusEvent;
    } Event;
} INPUT_RECORD, *PINPUT_RECORD;

#line 1 "C:\WATCOM\H\NT\poppack.h"
/*++

Copyright (c) 1990,95  Microsoft Corporation

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)
#line 33 "C:\WATCOM\H\NT\poppack.h"
#line 36 "C:\WATCOM\H\NT\poppack.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 116 "C:\WATCOM\H\NT\wincon.h"


//
//  EventType flags:
//

// Event contains key event record
// Event contains mouse event record
// Event contains window change event record
// Event contains menu event record
// event contains focus change

typedef struct _CHAR_INFO {
    union {
        WCHAR UnicodeChar;
        CHAR   AsciiChar;
    } Char;
    WORD Attributes;
} CHAR_INFO, *PCHAR_INFO;

//
// Attributes flags:
//

// text color contains blue.
// text color contains green.
// text color contains red.
// text color is intensified.
// background color contains blue.
// background color contains green.
// background color contains red.
// background color is intensified.


typedef struct _CONSOLE_SCREEN_BUFFER_INFO {
    COORD dwSize;
    COORD dwCursorPosition;
    WORD  wAttributes;
    SMALL_RECT srWindow;
    COORD dwMaximumWindowSize;
} CONSOLE_SCREEN_BUFFER_INFO, *PCONSOLE_SCREEN_BUFFER_INFO;

typedef struct _CONSOLE_CURSOR_INFO {
    DWORD  dwSize;
    BOOL   bVisible;
} CONSOLE_CURSOR_INFO, *PCONSOLE_CURSOR_INFO;

//
// typedef for ctrl-c handler routines
//

typedef
BOOL
( __stdcall  *PHANDLER_ROUTINE)(
    DWORD CtrlType
    );




// 3 is reserved!
// 4 is reserved!



//
//  Input Mode flags:
//







//
// Output Mode flags:
//




//
// direct API definitions.
//

 __declspec(dllimport) 
BOOL
 __stdcall 
PeekConsoleInputA(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
PeekConsoleInputW(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead
    );
#line 223 "C:\WATCOM\H\NT\wincon.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
ReadConsoleInputA(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
ReadConsoleInputW(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead
    );
#line 247 "C:\WATCOM\H\NT\wincon.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
WriteConsoleInputA(
    HANDLE hConsoleInput,
     const  INPUT_RECORD *lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsWritten
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
WriteConsoleInputW(
    HANDLE hConsoleInput,
     const  INPUT_RECORD *lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsWritten
    );
#line 271 "C:\WATCOM\H\NT\wincon.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
ReadConsoleOutputA(
    HANDLE hConsoleOutput,
    PCHAR_INFO lpBuffer,
    COORD dwBufferSize,
    COORD dwBufferCoord,
    PSMALL_RECT lpReadRegion
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
ReadConsoleOutputW(
    HANDLE hConsoleOutput,
    PCHAR_INFO lpBuffer,
    COORD dwBufferSize,
    COORD dwBufferCoord,
    PSMALL_RECT lpReadRegion
    );
#line 297 "C:\WATCOM\H\NT\wincon.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
WriteConsoleOutputA(
    HANDLE hConsoleOutput,
     const  CHAR_INFO *lpBuffer,
    COORD dwBufferSize,
    COORD dwBufferCoord,
    PSMALL_RECT lpWriteRegion
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
WriteConsoleOutputW(
    HANDLE hConsoleOutput,
     const  CHAR_INFO *lpBuffer,
    COORD dwBufferSize,
    COORD dwBufferCoord,
    PSMALL_RECT lpWriteRegion
    );
#line 323 "C:\WATCOM\H\NT\wincon.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
ReadConsoleOutputCharacterA(
    HANDLE hConsoleOutput,
    LPSTR lpCharacter,
    DWORD nLength,
    COORD dwReadCoord,
    LPDWORD lpNumberOfCharsRead
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
ReadConsoleOutputCharacterW(
    HANDLE hConsoleOutput,
    LPWSTR lpCharacter,
    DWORD nLength,
    COORD dwReadCoord,
    LPDWORD lpNumberOfCharsRead
    );
#line 349 "C:\WATCOM\H\NT\wincon.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
ReadConsoleOutputAttribute(
    HANDLE hConsoleOutput,
    LPWORD lpAttribute,
    DWORD nLength,
    COORD dwReadCoord,
    LPDWORD lpNumberOfAttrsRead
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
WriteConsoleOutputCharacterA(
    HANDLE hConsoleOutput,
    LPCSTR lpCharacter,
    DWORD nLength,
    COORD dwWriteCoord,
    LPDWORD lpNumberOfCharsWritten
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
WriteConsoleOutputCharacterW(
    HANDLE hConsoleOutput,
    LPCWSTR lpCharacter,
    DWORD nLength,
    COORD dwWriteCoord,
    LPDWORD lpNumberOfCharsWritten
    );
#line 386 "C:\WATCOM\H\NT\wincon.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
WriteConsoleOutputAttribute(
    HANDLE hConsoleOutput,
     const  WORD *lpAttribute,
    DWORD nLength,
    COORD dwWriteCoord,
    LPDWORD lpNumberOfAttrsWritten
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
FillConsoleOutputCharacterA(
    HANDLE hConsoleOutput,
    CHAR  cCharacter,
    DWORD  nLength,
    COORD  dwWriteCoord,
    LPDWORD lpNumberOfCharsWritten
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
FillConsoleOutputCharacterW(
    HANDLE hConsoleOutput,
    WCHAR  cCharacter,
    DWORD  nLength,
    COORD  dwWriteCoord,
    LPDWORD lpNumberOfCharsWritten
    );
#line 423 "C:\WATCOM\H\NT\wincon.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
FillConsoleOutputAttribute(
    HANDLE hConsoleOutput,
    WORD   wAttribute,
    DWORD  nLength,
    COORD  dwWriteCoord,
    LPDWORD lpNumberOfAttrsWritten
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetConsoleMode(
    HANDLE hConsoleHandle,
    LPDWORD lpMode
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetNumberOfConsoleInputEvents(
    HANDLE hConsoleInput,
    LPDWORD lpNumberOfEvents
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetConsoleScreenBufferInfo(
    HANDLE hConsoleOutput,
    PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo
    );

 __declspec(dllimport) 
COORD
 __stdcall 
GetLargestConsoleWindowSize(
    HANDLE hConsoleOutput
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetConsoleCursorInfo(
    HANDLE hConsoleOutput,
    PCONSOLE_CURSOR_INFO lpConsoleCursorInfo
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GetNumberOfConsoleMouseButtons(
    LPDWORD lpNumberOfMouseButtons
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetConsoleMode(
    HANDLE hConsoleHandle,
    DWORD dwMode
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetConsoleActiveScreenBuffer(
    HANDLE hConsoleOutput
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
FlushConsoleInputBuffer(
    HANDLE hConsoleInput
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetConsoleScreenBufferSize(
    HANDLE hConsoleOutput,
    COORD dwSize
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetConsoleCursorPosition(
    HANDLE hConsoleOutput,
    COORD dwCursorPosition
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetConsoleCursorInfo(
    HANDLE hConsoleOutput,
     const  CONSOLE_CURSOR_INFO *lpConsoleCursorInfo
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
ScrollConsoleScreenBufferA(
    HANDLE hConsoleOutput,
     const  SMALL_RECT *lpScrollRectangle,
     const  SMALL_RECT *lpClipRectangle,
    COORD dwDestinationOrigin,
     const  CHAR_INFO *lpFill
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
ScrollConsoleScreenBufferW(
    HANDLE hConsoleOutput,
     const  SMALL_RECT *lpScrollRectangle,
     const  SMALL_RECT *lpClipRectangle,
    COORD dwDestinationOrigin,
     const  CHAR_INFO *lpFill
    );
#line 552 "C:\WATCOM\H\NT\wincon.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
SetConsoleWindowInfo(
    HANDLE hConsoleOutput,
    BOOL bAbsolute,
     const  SMALL_RECT *lpConsoleWindow
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetConsoleTextAttribute(
    HANDLE hConsoleOutput,
    WORD wAttributes
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetConsoleCtrlHandler(
    PHANDLER_ROUTINE HandlerRoutine,
    BOOL Add
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
GenerateConsoleCtrlEvent(
    DWORD dwCtrlEvent,
    DWORD dwProcessGroupId
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
AllocConsole(  void  );

 __declspec(dllimport) 
BOOL
 __stdcall 
FreeConsole(  void  );


 __declspec(dllimport) 
DWORD
 __stdcall 
GetConsoleTitleA(
    LPSTR lpConsoleTitle,
    DWORD nSize
    );
 __declspec(dllimport) 
DWORD
 __stdcall 
GetConsoleTitleW(
    LPWSTR lpConsoleTitle,
    DWORD nSize
    );
#line 616 "C:\WATCOM\H\NT\wincon.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
SetConsoleTitleA(
    LPCSTR lpConsoleTitle
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
SetConsoleTitleW(
    LPCWSTR lpConsoleTitle
    );
#line 634 "C:\WATCOM\H\NT\wincon.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
ReadConsoleA(
    HANDLE hConsoleInput,
    LPVOID lpBuffer,
    DWORD nNumberOfCharsToRead,
    LPDWORD lpNumberOfCharsRead,
    LPVOID lpReserved
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
ReadConsoleW(
    HANDLE hConsoleInput,
    LPVOID lpBuffer,
    DWORD nNumberOfCharsToRead,
    LPDWORD lpNumberOfCharsRead,
    LPVOID lpReserved
    );
#line 660 "C:\WATCOM\H\NT\wincon.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
WriteConsoleA(
    HANDLE hConsoleOutput,
     const   void  *lpBuffer,
    DWORD nNumberOfCharsToWrite,
    LPDWORD lpNumberOfCharsWritten,
    LPVOID lpReserved
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
WriteConsoleW(
    HANDLE hConsoleOutput,
     const   void  *lpBuffer,
    DWORD nNumberOfCharsToWrite,
    LPDWORD lpNumberOfCharsWritten,
    LPVOID lpReserved
    );
#line 686 "C:\WATCOM\H\NT\wincon.h"

// !UNICODE



 __declspec(dllimport) 
HANDLE
 __stdcall 
CreateConsoleScreenBuffer(
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
     const  SECURITY_ATTRIBUTES *lpSecurityAttributes,
    DWORD dwFlags,
    LPVOID lpScreenBufferData
    );

 __declspec(dllimport) 
UINT
 __stdcall 
GetConsoleCP(  void  );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetConsoleCP(
    UINT wCodePageID
    );

 __declspec(dllimport) 
UINT
 __stdcall 
GetConsoleOutputCP(  void  );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetConsoleOutputCP(
    UINT wCodePageID
    );


}


// _WINCON_
#line 162 "C:\WATCOM\H\NT\windows.h"

#line 1 "C:\WATCOM\H\NT\winver.h"
/*****************************************************************************
*                                                                             *
* winver.h -    Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL.  This library is                    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*               Copyright (c) 1993-1995, Microsoft Corp.  All rights reserved *
*                                                                             *
\*****************************************************************************/





extern "C" {


/* ----- Symbols ----- */




/* ----- VS_VERSION.dwFileFlags ----- */




/* ----- VS_VERSION.dwFileFlags ----- */







/* ----- VS_VERSION.dwFileOS ----- */


















/* ----- VS_VERSION.dwFileType ----- */








/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */













/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */




/* ----- VerFindFile() flags ----- */






/* ----- VerInstallFile() flags ----- */



























/* RC doesn't need to see the rest of this */

/* ----- Types and structures ----- */

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */ 
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */ 
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */ 
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */ 
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */ 
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */ 
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */ 
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */ 
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */ 
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */ 
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */ 
    DWORD   dwFileDateMS;           /* e.g. 0 */ 
    DWORD   dwFileDateLS;           /* e.g. 0 */ 
} VS_FIXEDFILEINFO;

/* ----- Function prototypes ----- */

DWORD
 __stdcall 
VerFindFileA(
        DWORD uFlags,
        LPSTR szFileName,
        LPSTR szWinDir,
        LPSTR szAppDir,
        LPSTR szCurDir,
        PUINT lpuCurDirLen,
        LPSTR szDestDir,
        PUINT lpuDestDirLen
        );
DWORD
 __stdcall 
VerFindFileW(
        DWORD uFlags,
        LPWSTR szFileName,
        LPWSTR szWinDir,
        LPWSTR szAppDir,
        LPWSTR szCurDir,
        PUINT lpuCurDirLen,
        LPWSTR szDestDir,
        PUINT lpuDestDirLen
        );
#line 170 "C:\WATCOM\H\NT\winver.h"

// !UNICODE

DWORD
 __stdcall 
VerInstallFileA(
        DWORD uFlags,
        LPSTR szSrcFileName,
        LPSTR szDestFileName,
        LPSTR szSrcDir,
        LPSTR szDestDir,
        LPSTR szCurDir,
        LPSTR szTmpFile,
        PUINT lpuTmpFileLen
        );
DWORD
 __stdcall 
VerInstallFileW(
        DWORD uFlags,
        LPWSTR szSrcFileName,
        LPWSTR szDestFileName,
        LPWSTR szSrcDir,
        LPWSTR szDestDir,
        LPWSTR szCurDir,
        LPWSTR szTmpFile,
        PUINT lpuTmpFileLen
        );
#line 200 "C:\WATCOM\H\NT\winver.h"

// !UNICODE

/* Returns size of version info in bytes */
DWORD
 __stdcall 
GetFileVersionInfoSizeA(
        LPSTR lptstrFilename, /* Filename of version stamped file */ 
        LPDWORD lpdwHandle
        );                      /* Information for use by GetFileVersionInfo */ 
/* Returns size of version info in bytes */
DWORD
 __stdcall 
GetFileVersionInfoSizeW(
        LPWSTR lptstrFilename, /* Filename of version stamped file */ 
        LPDWORD lpdwHandle
        );                      /* Information for use by GetFileVersionInfo */ 
#line 220 "C:\WATCOM\H\NT\winver.h"

// !UNICODE

/* Read version info into buffer */
BOOL
 __stdcall 
GetFileVersionInfoA(
        LPSTR lptstrFilename, /* Filename of version stamped file */ 
        DWORD dwHandle,         /* Information from GetFileVersionSize */ 
        DWORD dwLen,            /* Length of buffer for info */ 
        LPVOID lpData
        );                      /* Buffer to place the data structure */ 
/* Read version info into buffer */
BOOL
 __stdcall 
GetFileVersionInfoW(
        LPWSTR lptstrFilename, /* Filename of version stamped file */ 
        DWORD dwHandle,         /* Information from GetFileVersionSize */ 
        DWORD dwLen,            /* Length of buffer for info */ 
        LPVOID lpData
        );                      /* Buffer to place the data structure */ 
#line 244 "C:\WATCOM\H\NT\winver.h"

// !UNICODE

DWORD
 __stdcall 
VerLanguageNameA(
        DWORD wLang,
        LPSTR szLang,
        DWORD nSize
        );
DWORD
 __stdcall 
VerLanguageNameW(
        DWORD wLang,
        LPWSTR szLang,
        DWORD nSize
        );
#line 264 "C:\WATCOM\H\NT\winver.h"

// !UNICODE

BOOL
 __stdcall 
VerQueryValueA(
        const LPVOID pBlock,
        LPSTR lpSubBlock,
        LPVOID * lplpBuffer,
        PUINT puLen
        );
BOOL
 __stdcall 
VerQueryValueW(
        const LPVOID pBlock,
        LPWSTR lpSubBlock,
        LPVOID * lplpBuffer,
        PUINT puLen
        );
#line 286 "C:\WATCOM\H\NT\winver.h"

// !UNICODE

/* !RC_INVOKED */


}


/* !VER_H */
#line 163 "C:\WATCOM\H\NT\windows.h"

#line 1 "C:\WATCOM\H\NT\winreg.h"
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    Winreg.h

Abstract:

    This module contains the function prototypes and constant, type and
    structure definitions for the Windows 32-Bit Registry API.

--*/






extern "C" {



//
// Requested Key access mask type.
//

typedef ACCESS_MASK REGSAM;

//
// Type definitions.
//

 typedef HANDLE HKEY ;
typedef HKEY *PHKEY;

//
// Reserved Key Handles.
//






 



/*NOINC*/




struct val_context {
    int valuelen;       // the total length of this value 
    LPVOID value_context;   // provider's context 
    LPVOID val_buff_ptr;    // where in the ouput buffer the value is. 
};

typedef struct val_context    *PVALCONTEXT;

typedef struct pvalueA {           // Provider supplied value/context. 
    LPSTR   pv_valuename;          // The value name pointer 
    int pv_valuelen;
    LPVOID pv_value_context;
    DWORD pv_type;
}PVALUEA,    *PPVALUEA;
typedef struct pvalueW {           // Provider supplied value/context. 
    LPWSTR  pv_valuename;          // The value name pointer 
    int pv_valuelen;
    LPVOID pv_value_context;
    DWORD pv_type;
}PVALUEW,    *PPVALUEW;
#line 80 "C:\WATCOM\H\NT\winreg.h"
typedef PVALUEA PVALUE;
typedef PPVALUEA PPVALUE;
// UNICODE

typedef
DWORD  __cdecl 
QUERYHANDLER (LPVOID keycontext, PVALCONTEXT val_list, DWORD num_vals,
          LPVOID outputbuffer, DWORD    *total_outlen, DWORD input_blen);

typedef QUERYHANDLER    *PQUERYHANDLER;

typedef struct provider_info {
    PQUERYHANDLER pi_R0_1val;
    PQUERYHANDLER pi_R0_allvals;
    PQUERYHANDLER pi_R3_1val;
    PQUERYHANDLER pi_R3_allvals;
    DWORD pi_flags;    // capability flags (none defined yet). 
    LPVOID pi_key_context;
}REG_PROVIDER;

typedef struct provider_info    *PPROVIDER;

typedef struct value_entA {
    LPSTR   ve_valuename;
    DWORD ve_valuelen;
    DWORD ve_valueptr;
    DWORD ve_type;
}VALENTA,    *PVALENTA;
typedef struct value_entW {
    LPWSTR  ve_valuename;
    DWORD ve_valuelen;
    DWORD ve_valueptr;
    DWORD ve_type;
}VALENTW,    *PVALENTW;
#line 118 "C:\WATCOM\H\NT\winreg.h"
typedef VALENTA VALENT;
typedef PVALENTA PVALENT;
// UNICODE

// not(_PROVIDER_STRUCTS_DEFINED)
/*INC*/

/* WINVER >= 0x0400 */

//
// Default values for parameters that do not exist in the Win 3.1
// compatible APIs.
//



//
// API Prototypes.
//


 __declspec(dllimport) 
LONG
 __stdcall 
RegCloseKey (
    HKEY hKey
    );

 __declspec(dllimport) 
LONG
 __stdcall 
RegConnectRegistryA (
    LPSTR lpMachineName,
    HKEY hKey,
    PHKEY phkResult
    );
 __declspec(dllimport) 
LONG
 __stdcall 
RegConnectRegistryW (
    LPWSTR lpMachineName,
    HKEY hKey,
    PHKEY phkResult
    );
#line 165 "C:\WATCOM\H\NT\winreg.h"

// !UNICODE

 __declspec(dllimport) 
LONG
 __stdcall 
RegCreateKeyA (
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    );
 __declspec(dllimport) 
LONG
 __stdcall 
RegCreateKeyW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    );
#line 187 "C:\WATCOM\H\NT\winreg.h"

// !UNICODE

 __declspec(dllimport) 
LONG
 __stdcall 
RegCreateKeyExA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Reserved,
    LPSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );
 __declspec(dllimport) 
LONG
 __stdcall 
RegCreateKeyExW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );
#line 221 "C:\WATCOM\H\NT\winreg.h"

// !UNICODE

 __declspec(dllimport) 
LONG
 __stdcall 
RegDeleteKeyA (
    HKEY hKey,
    LPCSTR lpSubKey
    );
 __declspec(dllimport) 
LONG
 __stdcall 
RegDeleteKeyW (
    HKEY hKey,
    LPCWSTR lpSubKey
    );
#line 241 "C:\WATCOM\H\NT\winreg.h"

// !UNICODE

 __declspec(dllimport) 
LONG
 __stdcall 
RegDeleteValueA (
    HKEY hKey,
    LPCSTR lpValueName
    );
 __declspec(dllimport) 
LONG
 __stdcall 
RegDeleteValueW (
    HKEY hKey,
    LPCWSTR lpValueName
    );
#line 261 "C:\WATCOM\H\NT\winreg.h"

// !UNICODE

 __declspec(dllimport) 
LONG
 __stdcall 
RegEnumKeyA (
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    DWORD cbName
    );
 __declspec(dllimport) 
LONG
 __stdcall 
RegEnumKeyW (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    DWORD cbName
    );
#line 285 "C:\WATCOM\H\NT\winreg.h"

// !UNICODE

 __declspec(dllimport) 
LONG
 __stdcall 
RegEnumKeyExA (
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    );
 __declspec(dllimport) 
LONG
 __stdcall 
RegEnumKeyExW (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    );
#line 317 "C:\WATCOM\H\NT\winreg.h"

// !UNICODE

 __declspec(dllimport) 
LONG
 __stdcall 
RegEnumValueA (
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );
 __declspec(dllimport) 
LONG
 __stdcall 
RegEnumValueW (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );
#line 349 "C:\WATCOM\H\NT\winreg.h"

// !UNICODE

 __declspec(dllimport) 
LONG
 __stdcall 
RegFlushKey (
    HKEY hKey
    );

 __declspec(dllimport) 
LONG
 __stdcall 
RegGetKeySecurity (
    HKEY hKey,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPDWORD lpcbSecurityDescriptor
    );

 __declspec(dllimport) 
LONG
 __stdcall 
RegLoadKeyA (
    HKEY    hKey,
    LPCSTR  lpSubKey,
    LPCSTR  lpFile
    );
 __declspec(dllimport) 
LONG
 __stdcall 
RegLoadKeyW (
    HKEY    hKey,
    LPCWSTR  lpSubKey,
    LPCWSTR  lpFile
    );
#line 388 "C:\WATCOM\H\NT\winreg.h"

// !UNICODE

 __declspec(dllimport) 
LONG
 __stdcall 
RegNotifyChangeKeyValue (
    HKEY hKey,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter,
    HANDLE hEvent,
    BOOL fAsynchronus
    );

 __declspec(dllimport) 
LONG
 __stdcall 
RegOpenKeyA (
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    );
 __declspec(dllimport) 
LONG
 __stdcall 
RegOpenKeyW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    );
#line 421 "C:\WATCOM\H\NT\winreg.h"

// !UNICODE

 __declspec(dllimport) 
LONG
 __stdcall 
RegOpenKeyExA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );
 __declspec(dllimport) 
LONG
 __stdcall 
RegOpenKeyExW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );
#line 447 "C:\WATCOM\H\NT\winreg.h"

// !UNICODE

 __declspec(dllimport) 
LONG
 __stdcall 
RegQueryInfoKeyA (
    HKEY hKey,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    );
 __declspec(dllimport) 
LONG
 __stdcall 
RegQueryInfoKeyW (
    HKEY hKey,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    );
#line 487 "C:\WATCOM\H\NT\winreg.h"

// !UNICODE

 __declspec(dllimport) 
LONG
 __stdcall 
RegQueryValueA (
    HKEY hKey,
    LPCSTR lpSubKey,
    LPSTR lpValue,
    PLONG   lpcbValue
    );
 __declspec(dllimport) 
LONG
 __stdcall 
RegQueryValueW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPWSTR lpValue,
    PLONG   lpcbValue
    );
#line 511 "C:\WATCOM\H\NT\winreg.h"

// !UNICODE

 
 __declspec(dllimport) 
LONG
 __stdcall 
RegQueryMultipleValuesA (
    HKEY hKey,
    PVALENTA val_list,
    DWORD num_vals,
    LPSTR lpValueBuf,
    LPDWORD ldwTotsize
    );
 __declspec(dllimport) 
LONG
 __stdcall 
RegQueryMultipleValuesW (
    HKEY hKey,
    PVALENTW val_list,
    DWORD num_vals,
    LPWSTR lpValueBuf,
    LPDWORD ldwTotsize
    );
#line 538 "C:\WATCOM\H\NT\winreg.h"

// !UNICODE
/* WINVER >= 0x0400 */

 __declspec(dllimport) 
LONG
 __stdcall 
RegQueryValueExA (
    HKEY hKey,
    LPCSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );
 __declspec(dllimport) 
LONG
 __stdcall 
RegQueryValueExW (
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );
#line 567 "C:\WATCOM\H\NT\winreg.h"

// !UNICODE

 __declspec(dllimport) 
LONG
 __stdcall 
RegReplaceKeyA (
    HKEY     hKey,
    LPCSTR  lpSubKey,
    LPCSTR  lpNewFile,
    LPCSTR  lpOldFile
    );
 __declspec(dllimport) 
LONG
 __stdcall 
RegReplaceKeyW (
    HKEY     hKey,
    LPCWSTR  lpSubKey,
    LPCWSTR  lpNewFile,
    LPCWSTR  lpOldFile
    );
#line 591 "C:\WATCOM\H\NT\winreg.h"

// !UNICODE

 __declspec(dllimport) 
LONG
 __stdcall 
RegRestoreKeyA (
    HKEY hKey,
    LPCSTR lpFile,
    DWORD   dwFlags
    );
 __declspec(dllimport) 
LONG
 __stdcall 
RegRestoreKeyW (
    HKEY hKey,
    LPCWSTR lpFile,
    DWORD   dwFlags
    );
#line 613 "C:\WATCOM\H\NT\winreg.h"

// !UNICODE

 __declspec(dllimport) 
LONG
 __stdcall 
RegSaveKeyA (
    HKEY hKey,
    LPCSTR lpFile,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
 __declspec(dllimport) 
LONG
 __stdcall 
RegSaveKeyW (
    HKEY hKey,
    LPCWSTR lpFile,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
#line 635 "C:\WATCOM\H\NT\winreg.h"

// !UNICODE

 __declspec(dllimport) 
LONG
 __stdcall 
RegSetKeySecurity (
    HKEY hKey,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

 __declspec(dllimport) 
LONG
 __stdcall 
RegSetValueA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD dwType,
    LPCSTR lpData,
    DWORD cbData
    );
 __declspec(dllimport) 
LONG
 __stdcall 
RegSetValueW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD dwType,
    LPCWSTR lpData,
    DWORD cbData
    );
#line 670 "C:\WATCOM\H\NT\winreg.h"

// !UNICODE


 __declspec(dllimport) 
LONG
 __stdcall 
RegSetValueExA (
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
     const  BYTE* lpData,
    DWORD cbData
    );
 __declspec(dllimport) 
LONG
 __stdcall 
RegSetValueExW (
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
     const  BYTE* lpData,
    DWORD cbData
    );
#line 699 "C:\WATCOM\H\NT\winreg.h"

// !UNICODE

 __declspec(dllimport) 
LONG
 __stdcall 
RegUnLoadKeyA (
    HKEY    hKey,
    LPCSTR lpSubKey
    );
 __declspec(dllimport) 
LONG
 __stdcall 
RegUnLoadKeyW (
    HKEY    hKey,
    LPCWSTR lpSubKey
    );
#line 719 "C:\WATCOM\H\NT\winreg.h"

// !UNICODE

//
// Remoteable System Shutdown APIs
//

 __declspec(dllimport) 
BOOL
 __stdcall 
InitiateSystemShutdownA(
    LPSTR lpMachineName,
    LPSTR lpMessage,
    DWORD dwTimeout,
    BOOL bForceAppsClosed,
    BOOL bRebootAfterShutdown
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
InitiateSystemShutdownW(
    LPWSTR lpMachineName,
    LPWSTR lpMessage,
    DWORD dwTimeout,
    BOOL bForceAppsClosed,
    BOOL bRebootAfterShutdown
    );
#line 749 "C:\WATCOM\H\NT\winreg.h"

// !UNICODE


 __declspec(dllimport) 
BOOL
 __stdcall 
AbortSystemShutdownA(
    LPSTR lpMachineName
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
AbortSystemShutdownW(
    LPWSTR lpMachineName
    );
#line 768 "C:\WATCOM\H\NT\winreg.h"

// !UNICODE


}



// _WINREG_
#line 164 "C:\WATCOM\H\NT\windows.h"

#line 1 "C:\WATCOM\H\NT\winnetwk.h"
/*++

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    winnetwk.h

Abstract:

    Standard WINNET Header File for WIN32

Environment:

    User Mode -Win32

Notes:

    optional-notes

--*/





extern "C" {


//
// Network types
//






















//
//  Network Resources.
//




 


/* WINVER >= 0x0400 */




 

/* WINVER >= 0x0400 */




 



/* WINVER >= 0x0400 */








 




/* WINVER >= 0x0400 */


typedef struct  _NETRESOURCEA {
    DWORD    dwScope;
    DWORD    dwType;
    DWORD    dwDisplayType;
    DWORD    dwUsage;
    LPSTR    lpLocalName;
    LPSTR    lpRemoteName;
    LPSTR    lpComment ;
    LPSTR    lpProvider;
}NETRESOURCEA, *LPNETRESOURCEA;
typedef struct  _NETRESOURCEW {
    DWORD    dwScope;
    DWORD    dwType;
    DWORD    dwDisplayType;
    DWORD    dwUsage;
    LPWSTR   lpLocalName;
    LPWSTR   lpRemoteName;
    LPWSTR   lpComment ;
    LPWSTR   lpProvider;
}NETRESOURCEW, *LPNETRESOURCEW;
#line 122 "C:\WATCOM\H\NT\winnetwk.h"
typedef NETRESOURCEA NETRESOURCE;
typedef LPNETRESOURCEA LPNETRESOURCE;
// UNICODE

//
//  Network Connections.
// 









 




/* WINVER >= 0x0400 */

DWORD  __stdcall 
WNetAddConnectionA(
     LPCSTR   lpRemoteName,
     LPCSTR   lpPassword,
     LPCSTR   lpLocalName
    );
DWORD  __stdcall 
WNetAddConnectionW(
     LPCWSTR   lpRemoteName,
     LPCWSTR   lpPassword,
     LPCWSTR   lpLocalName
    );
#line 160 "C:\WATCOM\H\NT\winnetwk.h"

// !UNICODE

DWORD  __stdcall 
WNetAddConnection2A(
     LPNETRESOURCEA lpNetResource,
     LPCSTR       lpPassword,
     LPCSTR       lpUserName,
     DWORD          dwFlags
    );
DWORD  __stdcall 
WNetAddConnection2W(
     LPNETRESOURCEW lpNetResource,
     LPCWSTR       lpPassword,
     LPCWSTR       lpUserName,
     DWORD          dwFlags
    );
#line 180 "C:\WATCOM\H\NT\winnetwk.h"

// !UNICODE

DWORD  __stdcall 
WNetAddConnection3A(
     HWND           hwndOwner,
     LPNETRESOURCEA lpNetResource,
     LPCSTR       lpPassword,
     LPCSTR       lpUserName,
     DWORD          dwFlags
    );
DWORD  __stdcall 
WNetAddConnection3W(
     HWND           hwndOwner,
     LPNETRESOURCEW lpNetResource,
     LPCWSTR       lpPassword,
     LPCWSTR       lpUserName,
     DWORD          dwFlags
    );
#line 202 "C:\WATCOM\H\NT\winnetwk.h"

// !UNICODE

DWORD  __stdcall 
WNetCancelConnectionA(
     LPCSTR lpName,
     BOOL     fForce
    );
DWORD  __stdcall 
WNetCancelConnectionW(
     LPCWSTR lpName,
     BOOL     fForce
    );
#line 218 "C:\WATCOM\H\NT\winnetwk.h"

// !UNICODE

DWORD  __stdcall 
WNetCancelConnection2A(
     LPCSTR lpName,
     DWORD    dwFlags,
     BOOL     fForce
    );
DWORD  __stdcall 
WNetCancelConnection2W(
     LPCWSTR lpName,
     DWORD    dwFlags,
     BOOL     fForce
    );
#line 236 "C:\WATCOM\H\NT\winnetwk.h"

// !UNICODE

DWORD  __stdcall 
WNetGetConnectionA(
     LPCSTR lpLocalName,
     LPSTR  lpRemoteName,
     LPDWORD  lpnLength
    );
DWORD  __stdcall 
WNetGetConnectionW(
     LPCWSTR lpLocalName,
     LPWSTR  lpRemoteName,
     LPDWORD  lpnLength
    );
#line 254 "C:\WATCOM\H\NT\winnetwk.h"

// !UNICODE

 
DWORD  __stdcall 
WNetUseConnectionA(
    HWND            hwndOwner,
    LPNETRESOURCEA  lpNetResource,
    LPCSTR        lpUserID,
    LPCSTR        lpPassword,
    DWORD           dwFlags,
    LPSTR         lpAccessName,
    LPDWORD         lpBufferSize,
    LPDWORD         lpResult
    );
DWORD  __stdcall 
WNetUseConnectionW(
    HWND            hwndOwner,
    LPNETRESOURCEW  lpNetResource,
    LPCWSTR        lpUserID,
    LPCWSTR        lpPassword,
    DWORD           dwFlags,
    LPWSTR         lpAccessName,
    LPDWORD         lpBufferSize,
    LPDWORD         lpResult
    );
#line 283 "C:\WATCOM\H\NT\winnetwk.h"

// !UNICODE

DWORD  __stdcall 
WNetSetConnectionA(
    LPCSTR    lpName,
    DWORD       dwProperties,
    LPVOID      pvValues
    );
DWORD  __stdcall 
WNetSetConnectionW(
    LPCWSTR    lpName,
    DWORD       dwProperties,
    LPVOID      pvValues
    );
#line 301 "C:\WATCOM\H\NT\winnetwk.h"

// !UNICODE
/* WINVER >= 0x0400 */

//
//  Network Connection Dialogs.
// 

DWORD  __stdcall 
WNetConnectionDialog(
    HWND  hwnd,
    DWORD dwType
    );

DWORD  __stdcall 
WNetDisconnectDialog(
    HWND  hwnd,
    DWORD dwType
    );

 
typedef struct _CONNECTDLGSTRUCTA{
    DWORD cbStructure;       /* size of this structure in bytes */ 
    HWND hwndOwner;          /* owner window for the dialog */ 
    LPNETRESOURCEA lpConnRes;/* Requested Resource info    */ 
    DWORD dwFlags;           /* flags (see below) */ 
    DWORD dwDevNum;          /* number of devices connected to */ 
} CONNECTDLGSTRUCTA,    *LPCONNECTDLGSTRUCTA;
typedef struct _CONNECTDLGSTRUCTW{
    DWORD cbStructure;       /* size of this structure in bytes */ 
    HWND hwndOwner;          /* owner window for the dialog */ 
    LPNETRESOURCEW lpConnRes;/* Requested Resource info    */ 
    DWORD dwFlags;           /* flags (see below) */ 
    DWORD dwDevNum;          /* number of devices connected to */ 
} CONNECTDLGSTRUCTW,    *LPCONNECTDLGSTRUCTW;
#line 340 "C:\WATCOM\H\NT\winnetwk.h"
typedef CONNECTDLGSTRUCTA CONNECTDLGSTRUCT;
typedef LPCONNECTDLGSTRUCTA LPCONNECTDLGSTRUCT;
// UNICODE

/* Resource path should be read-only    */
/* Netware -style movable connection point enabled */
/* Use MRU combobox  */
/* Hide persistent connect checkbox  */

/*
 * NOTE:  Set at most ONE of the below flags.  If neither flag is set,
 *        then the persistence is set to whatever the user chose during
 *        a previous connection
 */
/* Force persistent connection */
/* Force connection NOT persistent */

DWORD  __stdcall 
WNetConnectionDialog1A(
    LPCONNECTDLGSTRUCTA lpConnDlgStruct
    );
DWORD  __stdcall 
WNetConnectionDialog1W(
    LPCONNECTDLGSTRUCTW lpConnDlgStruct
    );
#line 368 "C:\WATCOM\H\NT\winnetwk.h"

// !UNICODE

typedef struct _DISCDLGSTRUCTA{
    DWORD           cbStructure;      /* size of this structure in bytes */ 
    HWND            hwndOwner;        /* owner window for the dialog */ 
    LPSTR           lpLocalName;      /* local device name */ 
    LPSTR           lpRemoteName;     /* network resource name */ 
    DWORD           dwFlags;          /* flags */ 
} DISCDLGSTRUCTA,    *LPDISCDLGSTRUCTA;
typedef struct _DISCDLGSTRUCTW{
    DWORD           cbStructure;      /* size of this structure in bytes */ 
    HWND            hwndOwner;        /* owner window for the dialog */ 
    LPWSTR          lpLocalName;      /* local device name */ 
    LPWSTR          lpRemoteName;     /* network resource name */ 
    DWORD           dwFlags;          /* flags */ 
} DISCDLGSTRUCTW,    *LPDISCDLGSTRUCTW;
#line 389 "C:\WATCOM\H\NT\winnetwk.h"
typedef DISCDLGSTRUCTA DISCDLGSTRUCT;
typedef LPDISCDLGSTRUCTA LPDISCDLGSTRUCT;
// UNICODE




DWORD  __stdcall 
WNetDisconnectDialog1A(
    LPDISCDLGSTRUCTA lpConnDlgStruct
    );
DWORD  __stdcall 
WNetDisconnectDialog1W(
    LPDISCDLGSTRUCTW lpConnDlgStruct
    );
#line 407 "C:\WATCOM\H\NT\winnetwk.h"

// !UNICODE
/* WINVER >= 0x0400 */

//
//  Network Browsing.
//

DWORD  __stdcall 
WNetOpenEnumA(
     DWORD          dwScope,
     DWORD          dwType,
     DWORD          dwUsage,
     LPNETRESOURCEA lpNetResource,
     LPHANDLE       lphEnum
    );
DWORD  __stdcall 
WNetOpenEnumW(
     DWORD          dwScope,
     DWORD          dwType,
     DWORD          dwUsage,
     LPNETRESOURCEW lpNetResource,
     LPHANDLE       lphEnum
    );
#line 434 "C:\WATCOM\H\NT\winnetwk.h"

// !UNICODE

DWORD  __stdcall 
WNetEnumResourceA(
     HANDLE  hEnum,
     LPDWORD lpcCount,
     LPVOID  lpBuffer,
     LPDWORD lpBufferSize
    );
DWORD  __stdcall 
WNetEnumResourceW(
     HANDLE  hEnum,
     LPDWORD lpcCount,
     LPVOID  lpBuffer,
     LPDWORD lpBufferSize
    );
#line 454 "C:\WATCOM\H\NT\winnetwk.h"

// !UNICODE

DWORD  __stdcall 
WNetCloseEnum(
    HANDLE   hEnum
    );

//
//  Universal Naming.
//




typedef struct  _UNIVERSAL_NAME_INFOA {
    LPSTR    lpUniversalName;
}UNIVERSAL_NAME_INFOA, *LPUNIVERSAL_NAME_INFOA;
typedef struct  _UNIVERSAL_NAME_INFOW {
    LPWSTR   lpUniversalName;
}UNIVERSAL_NAME_INFOW, *LPUNIVERSAL_NAME_INFOW;
#line 479 "C:\WATCOM\H\NT\winnetwk.h"
typedef UNIVERSAL_NAME_INFOA UNIVERSAL_NAME_INFO;
typedef LPUNIVERSAL_NAME_INFOA LPUNIVERSAL_NAME_INFO;
// UNICODE

typedef struct  _REMOTE_NAME_INFOA {
    LPSTR    lpUniversalName;
    LPSTR    lpConnectionName;
    LPSTR    lpRemainingPath;
}REMOTE_NAME_INFOA, *LPREMOTE_NAME_INFOA;
typedef struct  _REMOTE_NAME_INFOW {
    LPWSTR   lpUniversalName;
    LPWSTR   lpConnectionName;
    LPWSTR   lpRemainingPath;
}REMOTE_NAME_INFOW, *LPREMOTE_NAME_INFOW;
#line 497 "C:\WATCOM\H\NT\winnetwk.h"
typedef REMOTE_NAME_INFOA REMOTE_NAME_INFO;
typedef LPREMOTE_NAME_INFOA LPREMOTE_NAME_INFO;
// UNICODE

DWORD  __stdcall 
WNetGetUniversalNameA(
     LPCSTR lpLocalPath,
     DWORD    dwInfoLevel,
     LPVOID   lpBuffer,
     LPDWORD  lpBufferSize
     );
DWORD  __stdcall 
WNetGetUniversalNameW(
     LPCWSTR lpLocalPath,
     DWORD    dwInfoLevel,
     LPVOID   lpBuffer,
     LPDWORD  lpBufferSize
     );
#line 518 "C:\WATCOM\H\NT\winnetwk.h"

// !UNICODE

//
//  Authentication and Logon/Logoff.
//

DWORD  __stdcall 
WNetGetUserA(
     LPCSTR  lpName,
     LPSTR   lpUserName,
     LPDWORD   lpnLength
    );
DWORD  __stdcall 
WNetGetUserW(
     LPCWSTR  lpName,
     LPWSTR   lpUserName,
     LPDWORD   lpnLength
    );
#line 540 "C:\WATCOM\H\NT\winnetwk.h"

// !UNICODE

//
// Other.
//

 




/* WINVER >= 0x0400 */

 
DWORD  __stdcall 
WNetGetProviderNameA(
    DWORD   dwNetType,
    LPSTR lpProviderName,
    LPDWORD lpBufferSize
    );
DWORD  __stdcall 
WNetGetProviderNameW(
    DWORD   dwNetType,
    LPWSTR lpProviderName,
    LPDWORD lpBufferSize
    );
#line 570 "C:\WATCOM\H\NT\winnetwk.h"

// !UNICODE

typedef struct _NETINFOSTRUCT{
    DWORD cbStructure;
    DWORD dwProviderVersion;
    DWORD dwStatus;
    DWORD dwCharacteristics;
    DWORD dwHandle;
    WORD  wNetType;
    DWORD dwPrinters;
    DWORD dwDrives;
} NETINFOSTRUCT,    *LPNETINFOSTRUCT;

/* Provider running as 16 bit Winnet Driver */
/* Provider requires disk redirections to connect */
/* Provider requires printer redirections to connect */

DWORD  __stdcall 
WNetGetNetworkInformationA(
    LPCSTR          lpProvider,
    LPNETINFOSTRUCT   lpNetInfoStruct
    );
DWORD  __stdcall 
WNetGetNetworkInformationW(
    LPCWSTR          lpProvider,
    LPNETINFOSTRUCT   lpNetInfoStruct
    );
#line 601 "C:\WATCOM\H\NT\winnetwk.h"

// !UNICODE

//
//  User Profiles.
//

typedef UINT (    __stdcall  *PFNGETPROFILEPATHA) (
    LPCSTR    pszUsername,
    LPSTR     pszBuffer,
    UINT        cbBuffer
    );
typedef UINT (    __stdcall  *PFNGETPROFILEPATHW) (
    LPCWSTR    pszUsername,
    LPWSTR     pszBuffer,
    UINT        cbBuffer
    );
#line 621 "C:\WATCOM\H\NT\winnetwk.h"

// !UNICODE

typedef UINT (    __stdcall  *PFNRECONCILEPROFILEA) (
    LPCSTR    pszCentralFile,
    LPCSTR    pszLocalFile,
    DWORD       dwFlags
    );
typedef UINT (    __stdcall  *PFNRECONCILEPROFILEW) (
    LPCWSTR    pszCentralFile,
    LPCWSTR    pszLocalFile,
    DWORD       dwFlags
    );
#line 637 "C:\WATCOM\H\NT\winnetwk.h"

// !UNICODE

/* if set, do for logon, else for logoff */
/* if set, reconcile .INI file, else reg. hive */

//
//  Policies.
//

typedef BOOL (    __stdcall  *PFNPROCESSPOLICIESA) (
    HWND        hwnd,
    LPCSTR    pszPath,
    LPCSTR    pszUsername,
    LPCSTR    pszComputerName,
    DWORD       dwFlags
    );
typedef BOOL (    __stdcall  *PFNPROCESSPOLICIESW) (
    HWND        hwnd,
    LPCWSTR    pszPath,
    LPCWSTR    pszUsername,
    LPCWSTR    pszComputerName,
    DWORD       dwFlags
    );
#line 664 "C:\WATCOM\H\NT\winnetwk.h"

// !UNICODE

/* if set, display error messages, else fail silently if error */
/* WINVER >= 0x0400 */

//
//  Error handling.
// 

DWORD  __stdcall 
WNetGetLastErrorA(
     LPDWORD    lpError,
     LPSTR    lpErrorBuf,
     DWORD      nErrorBufSize,
     LPSTR    lpNameBuf,
     DWORD      nNameBufSize
    );
DWORD  __stdcall 
WNetGetLastErrorW(
     LPDWORD    lpError,
     LPWSTR    lpErrorBuf,
     DWORD      nErrorBufSize,
     LPWSTR    lpNameBuf,
     DWORD      nNameBufSize
    );
#line 693 "C:\WATCOM\H\NT\winnetwk.h"

// !UNICODE

//
//  STATUS CODES
//

// General   




















 


/* WINVER >= 0x0400 */

// Connection
















// Enumeration




 
// Authentication




/* WINVER >= 0x0400 */

//
//  For Shell
//

 
typedef struct _NETCONNECTINFOSTRUCT{
    DWORD cbStructure;
    DWORD dwFlags;
    DWORD dwSpeed;
    DWORD dwDelay;
    DWORD dwOptDataSize;
} NETCONNECTINFOSTRUCT,  *LPNETCONNECTINFOSTRUCT;






DWORD  __stdcall 
MultinetGetConnectionPerformanceA(
        LPNETRESOURCEA lpNetResource,
        LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
        );
DWORD  __stdcall 
MultinetGetConnectionPerformanceW(
        LPNETRESOURCEW lpNetResource,
        LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
        );
#line 787 "C:\WATCOM\H\NT\winnetwk.h"

// !UNICODE
/* WINVER >= 0x0400 */


}


// _WINNETWK_
#line 165 "C:\WATCOM\H\NT\windows.h"



#line 1 "C:\WATCOM\H\NT\cderr.h"
/*****************************************************************************
*                                                                             *
* cderr.h -     Common dialog error return codes                              *
*                                                                             *
* Version 1.0								      *
*                                                                             *
* Copyright (c) 1992-1995, Microsoft Corp.	All rights reserved.	      *
*                                                                             *
\*****************************************************************************/
















































/* !_INC_CDERR */
#line 168 "C:\WATCOM\H\NT\windows.h"

#line 1 "C:\WATCOM\H\NT\dde.h"
/*****************************************************************************
*                                                                             *
* dde.h -       Dynamic Data Exchange structures and definitions              *
*                                                                             *
* Copyright (c) 1993-1995, Microsoft Corp.	All rights reserved	      *
*                                                                             *
\*****************************************************************************/



#line 14 "C:\WATCOM\H\NT\dde.h"


extern "C" {


/* DDE window messages */













/*----------------------------------------------------------------------------
|       DDEACK structure
|
|	Structure of wStatus (LOWORD(lParam)) in WM_DDE_ACK message
|       sent in response to a WM_DDE_DATA, WM_DDE_REQUEST, WM_DDE_POKE,
|       WM_DDE_ADVISE, or WM_DDE_UNADVISE message.
|
----------------------------------------------------------------------------*/

typedef struct {
        unsigned short bAppReturnCode:8,
                 reserved:6,
                 fBusy:1,
		 fAck:1;
} DDEACK;


/*----------------------------------------------------------------------------
|       DDEADVISE structure
|
|	WM_DDE_ADVISE parameter structure for hOptions (LOWORD(lParam))
|
----------------------------------------------------------------------------*/

typedef struct {
        unsigned short reserved:14,
                 fDeferUpd:1,
		 fAckReq:1;
	short     cfFormat;
} DDEADVISE;


/*----------------------------------------------------------------------------
|       DDEDATA structure
|
|       WM_DDE_DATA parameter structure for hData (LOWORD(lParam)).
|       The actual size of this structure depends on the size of
|       the Value array.
|
----------------------------------------------------------------------------*/

typedef struct {
	unsigned short unused:12,
                 fResponse:1,
                 fRelease:1,
                 reserved:1,
                 fAckReq:1;
	short	 cfFormat;
	BYTE	 Value[1];
} DDEDATA;


/*----------------------------------------------------------------------------
|	DDEPOKE structure
|
|	WM_DDE_POKE parameter structure for hData (LOWORD(lParam)).
|       The actual size of this structure depends on the size of
|       the Value array.
|
----------------------------------------------------------------------------*/

typedef struct {
	unsigned short unused:13,  /* Earlier versions of DDE.H incorrectly */ 
                             /* 12 unused bits.                       */
		 fRelease:1,
		 fReserved:2;
	short    cfFormat;
	BYTE	 Value[1];  /* This member was named rgb[1] in previous */ 
                            /* versions of DDE.H                        */

} DDEPOKE;

/*----------------------------------------------------------------------------
The following typedef's were used in previous versions of the Windows SDK.
They are still valid.  The above typedef's define exactly the same structures
as those below.  The above typedef names are recommended, however, as they
are more meaningful.

Note that the DDEPOKE structure typedef'ed in earlier versions of DDE.H did
not correctly define the bit positions.
----------------------------------------------------------------------------*/

typedef struct {
        unsigned short unused:13,
                 fRelease:1,
                 fDeferUpd:1,
		 fAckReq:1;
	short	 cfFormat;
} DDELN;

typedef struct {
	unsigned short unused:12,
                 fAck:1,
                 fRelease:1,
                 fReserved:1,
                 fAckReq:1;
	short	 cfFormat;
	BYTE	 rgb[1];
} DDEUP;


/*
 * DDE SECURITY
 */

BOOL
 __stdcall 
DdeSetQualityOfService(
    HWND hwndClient,
     const  SECURITY_QUALITY_OF_SERVICE *pqosNew,
    PSECURITY_QUALITY_OF_SERVICE pqosPrev);

BOOL
 __stdcall 
ImpersonateDdeClientWindow(
    HWND hWndClient,
    HWND hWndServer);

/*
 * DDE message packing APIs
 */
LONG  __stdcall  PackDDElParam(UINT msg, UINT uiLo, UINT uiHi);
BOOL  __stdcall  UnpackDDElParam(UINT msg, LONG lParam, PUINT puiLo, PUINT puiHi);
BOOL  __stdcall  FreeDDElParam(UINT msg, LONG lParam);
LONG  __stdcall  ReuseDDElParam(LONG lParam, UINT msgIn, UINT msgOut, UINT uiLo, UINT uiHi);


}


// _DDEHEADER_INCLUDED_
#line 169 "C:\WATCOM\H\NT\windows.h"

#line 1 "C:\WATCOM\H\NT\ddeml.h"
/*++ BUILD Version: 0001 // Increment this if a change has global effects --*/

/*****************************************************************************
*                                                                             *
*  ddeml.h -    DDEML API header file                                         *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1993-95, Microsoft Corp.  All rights reserved.  *
*                                                                             *
\*****************************************************************************/




extern "C" {
/* __cplusplus */

/******** public types ********/

 typedef HANDLE HCONVLIST ;
 typedef HANDLE HCONV ;
 typedef HANDLE HSZ ;
 typedef HANDLE HDDEDATA ;


/* the following structure is for use with XTYP_WILDCONNECT processing. */

typedef struct tagHSZPAIR {
    HSZ hszSvc;
    HSZ hszTopic;
} HSZPAIR;
typedef HSZPAIR    *PHSZPAIR;

/* The following structure is used by DdeConnect() and DdeConnectList() and
   by XTYP_CONNECT and XTYP_WILDCONNECT callbacks. */

typedef struct tagCONVCONTEXT {
    UINT        cb;             /* set to sizeof(CONVCONTEXT) */ 
    UINT        wFlags;         /* none currently defined. */ 
    UINT        wCountryID;     /* country code for topic/item strings used. */ 
    int         iCodePage;      /* codepage used for topic/item strings. */ 
    DWORD       dwLangID;       /* language ID for topic/item strings. */ 
    DWORD       dwSecurity;     /* Private security code. */ 
    SECURITY_QUALITY_OF_SERVICE qos;  /* client side's quality of service */ 
} CONVCONTEXT;
typedef CONVCONTEXT    *PCONVCONTEXT;


/* The following structure is used by DdeQueryConvInfo(): */

typedef struct tagCONVINFO {
    DWORD   cb;            /* sizeof(CONVINFO)  */ 
    DWORD   hUser;         /* user specified field  */ 
    HCONV   hConvPartner;  /* hConv on other end or 0 if non-ddemgr partner  */ 
    HSZ     hszSvcPartner; /* app name of partner if obtainable  */ 
    HSZ     hszServiceReq; /* AppName requested for connection  */ 
    HSZ     hszTopic;      /* Topic name for conversation  */ 
    HSZ     hszItem;       /* transaction item name or NULL if quiescent  */ 
    UINT    wFmt;          /* transaction format or NULL if quiescent  */ 
    UINT    wType;         /* XTYP_ for current transaction  */ 
    UINT    wStatus;       /* ST_ constant for current conversation  */ 
    UINT    wConvst;       /* XST_ constant for current transaction  */ 
    UINT    wLastError;    /* last transaction error.  */ 
    HCONVLIST hConvList;   /* parent hConvList if this conversation is in a list */ 
    CONVCONTEXT ConvCtxt;  /* conversation context */ 
    HWND    hwnd;          /* window handle for this conversation */ 
    HWND    hwndPartner;   /* partner window handle for this conversation */ 
} CONVINFO;
typedef CONVINFO    *PCONVINFO;

/***** conversation states (usState) *****/

/* quiescent states */


/* mid-initiation states */

/* active conversation states */












/* used in LOWORD(dwData1) of XTYP_ADVREQ callbacks... */


/***** conversation status bits (fsStatus) *****/












/* DDE constants for wStatus field */















/***** message filter hook types *****/



/***** codepage constants ****/

/* default codepage for windows & old DDE convs. */


/***** transaction types *****/

/* CBR_BLOCK will not work */
/* DDE_FDEFERUPD */
/* DDE_FACKREQ */
























/* shift to turn XTYP_ into an index */

/***** Timeout constants *****/



/***** Transaction ID constants *****/



/****** public strings used in DDE ******/

#line 184 "C:\WATCOM\H\NT\ddeml.h"











/****** API entry points ******/

typedef HDDEDATA  __stdcall  FNCALLBACK(UINT wType, UINT wFmt, HCONV hConv,
        HSZ hsz1, HSZ hsz2, HDDEDATA hData, DWORD dwData1, DWORD dwData2);
typedef HDDEDATA ( __stdcall  *PFNCALLBACK)(UINT wType, UINT wFmt, HCONV hConv,
        HSZ hsz1, HSZ hsz2, HDDEDATA hData, DWORD dwData1, DWORD dwData2);



/* DLL registration functions */

UINT  __stdcall  DdeInitializeA(LPDWORD pidInst, PFNCALLBACK pfnCallback,
        DWORD afCmd, DWORD ulRes);
UINT  __stdcall  DdeInitializeW(LPDWORD pidInst, PFNCALLBACK pfnCallback,
        DWORD afCmd, DWORD ulRes);
#line 213 "C:\WATCOM\H\NT\ddeml.h"

// !UNICODE

/*
 * Callback filter flags for use with standard apps.
 */















/*
 * Application command flags
 */




/*
 * Application classification flags
 */





BOOL  __stdcall  DdeUninitialize(DWORD idInst);

/*
 * conversation enumeration functions
 */

HCONVLIST  __stdcall  DdeConnectList(DWORD idInst, HSZ hszService, HSZ hszTopic,
        HCONVLIST hConvList, PCONVCONTEXT pCC);
HCONV  __stdcall  DdeQueryNextServer(HCONVLIST hConvList, HCONV hConvPrev);
BOOL  __stdcall  DdeDisconnectList(HCONVLIST hConvList);

/*
 * conversation control functions
 */

HCONV  __stdcall  DdeConnect(DWORD idInst, HSZ hszService, HSZ hszTopic,
        PCONVCONTEXT pCC);
BOOL  __stdcall  DdeDisconnect(HCONV hConv);
HCONV  __stdcall  DdeReconnect(HCONV hConv);
UINT  __stdcall  DdeQueryConvInfo(HCONV hConv, DWORD idTransaction, PCONVINFO pConvInfo);
BOOL  __stdcall  DdeSetUserHandle(HCONV hConv, DWORD id, DWORD hUser);
BOOL  __stdcall  DdeAbandonTransaction(DWORD idInst, HCONV hConv, DWORD idTransaction);


/*
 * app server interface functions
 */

BOOL  __stdcall  DdePostAdvise(DWORD idInst, HSZ hszTopic, HSZ hszItem);
BOOL  __stdcall  DdeEnableCallback(DWORD idInst, HCONV hConv, UINT wCmd);
BOOL  __stdcall  DdeImpersonateClient(HCONV hConv);







HDDEDATA  __stdcall  DdeNameService(DWORD idInst, HSZ hsz1, HSZ hsz2, UINT afCmd);






/*
 * app client interface functions
 */

HDDEDATA  __stdcall  DdeClientTransaction(LPBYTE pData, DWORD cbData,
        HCONV hConv, HSZ hszItem, UINT wFmt, UINT wType,
        DWORD dwTimeout, LPDWORD pdwResult);

/*
 *data transfer functions
 */

HDDEDATA  __stdcall  DdeCreateDataHandle(DWORD idInst, LPBYTE pSrc, DWORD cb,
        DWORD cbOff, HSZ hszItem, UINT wFmt, UINT afCmd);
HDDEDATA  __stdcall  DdeAddData(HDDEDATA hData, LPBYTE pSrc, DWORD cb, DWORD cbOff);
DWORD  __stdcall  DdeGetData(HDDEDATA hData, LPBYTE pDst, DWORD cbMax, DWORD cbOff);
LPBYTE  __stdcall  DdeAccessData(HDDEDATA hData, LPDWORD pcbDataSize);
BOOL  __stdcall  DdeUnaccessData(HDDEDATA hData);
BOOL  __stdcall  DdeFreeDataHandle(HDDEDATA hData);




UINT  __stdcall  DdeGetLastError(DWORD idInst);

/* must be 0 */
























HSZ   __stdcall  DdeCreateStringHandleA(DWORD idInst, LPCSTR psz, int iCodePage);
HSZ   __stdcall  DdeCreateStringHandleW(DWORD idInst, LPCWSTR psz, int iCodePage);
#line 349 "C:\WATCOM\H\NT\ddeml.h"

// !UNICODE
DWORD  __stdcall  DdeQueryStringA(DWORD idInst, HSZ hsz, LPSTR psz, DWORD cchMax, int iCodePage);
DWORD  __stdcall  DdeQueryStringW(DWORD idInst, HSZ hsz, LPWSTR psz, DWORD cchMax, int iCodePage);
#line 356 "C:\WATCOM\H\NT\ddeml.h"

// !UNICODE
BOOL  __stdcall  DdeFreeStringHandle(DWORD idInst, HSZ hsz);
BOOL  __stdcall  DdeKeepStringHandle(DWORD idInst, HSZ hsz);
int  __stdcall  DdeCmpStringHandles(HSZ hsz1, HSZ hsz2);



/*
 * DDEML public debugging header file info
 */

typedef struct tagDDEML_MSG_HOOK_DATA {    // new for NT 
    UINT uiLo;      // unpacked lo and hi parts of lParam 
    UINT uiHi;
    DWORD cbData;   // amount of data in message, if any. May be > than 32 bytes. 
    DWORD Data[8];  // data peeking by DDESPY is limited to 32 bytes. 
} DDEML_MSG_HOOK_DATA, *PDDEML_MSG_HOOK_DATA;


typedef struct tagMONMSGSTRUCT {
    UINT    cb;
    HWND    hwndTo;
    DWORD   dwTime;
    HANDLE  hTask;
    UINT    wMsg;
    WPARAM  wParam;
    LPARAM  lParam;
    DDEML_MSG_HOOK_DATA dmhd;       // new for NT 
} MONMSGSTRUCT, *PMONMSGSTRUCT;

typedef struct tagMONCBSTRUCT {
    UINT   cb;
    DWORD  dwTime;
    HANDLE hTask;
    DWORD  dwRet;
    UINT   wType;
    UINT   wFmt;
    HCONV  hConv;
    HSZ    hsz1;
    HSZ    hsz2;
    HDDEDATA hData;
    DWORD  dwData1;
    DWORD  dwData2;
    CONVCONTEXT cc;                 // new for NT for XTYP_CONNECT callbacks 
    DWORD  cbData;                  // new for NT for data peeking 
    DWORD  Data[8];                 // new for NT for data peeking 
} MONCBSTRUCT, *PMONCBSTRUCT;

typedef struct tagMONHSZSTRUCTA {
    UINT   cb;
    BOOL   fsAction;    /* MH_ value */ 
    DWORD  dwTime;
    HSZ    hsz;
    HANDLE hTask;
    CHAR    str[1];
} MONHSZSTRUCTA, *PMONHSZSTRUCTA;
typedef struct tagMONHSZSTRUCTW {
    UINT   cb;
    BOOL   fsAction;    /* MH_ value */ 
    DWORD  dwTime;
    HSZ    hsz;
    HANDLE hTask;
    WCHAR   str[1];
} MONHSZSTRUCTW, *PMONHSZSTRUCTW;
#line 425 "C:\WATCOM\H\NT\ddeml.h"
typedef MONHSZSTRUCTA MONHSZSTRUCT;
typedef PMONHSZSTRUCTA PMONHSZSTRUCT;
// UNICODE






typedef struct tagMONERRSTRUCT {
    UINT    cb;
    UINT    wLastError;
    DWORD   dwTime;
    HANDLE  hTask;
} MONERRSTRUCT, *PMONERRSTRUCT;

typedef struct tagMONLINKSTRUCT {
    UINT    cb;
    DWORD   dwTime;
    HANDLE  hTask;
    BOOL    fEstablished;
    BOOL    fNoData;
    HSZ     hszSvc;
    HSZ     hszTopic;
    HSZ     hszItem;
    UINT    wFmt;
    BOOL    fServer;
    HCONV   hConvServer;
    HCONV   hConvClient;
} MONLINKSTRUCT, *PMONLINKSTRUCT;

typedef struct tagMONCONVSTRUCT {
    UINT    cb;
    BOOL    fConnect;
    DWORD   dwTime;
    HANDLE  hTask;
    HSZ     hszSvc;
    HSZ     hszTopic;
    HCONV   hConvClient;        // Globally unique value != apps local hConv 
    HCONV   hConvServer;        // Globally unique value != apps local hConv 
} MONCONVSTRUCT, *PMONCONVSTRUCT;





/*
 * Callback filter flags for use with MONITOR apps - 0 implies no monitor
 * callbacks.
 */









/* NODDEMLSPY */


}
/* __cplusplus */

/* _INC_DDEMLH */


#line 170 "C:\WATCOM\H\NT\windows.h"

#line 1 "C:\WATCOM\H\NT\dlgs.h"
/*---------------------------------------------------------------------------*/
/* Dlgs.h : UI dialog header                                                 */
/*                                                                           */
/* Copyright (c) Microsoft Corporation, 1990-1995                            */
/*---------------------------------------------------------------------------*/




/*----Constants--------------------------------------------------------------*/


    /* Push buttons */

















    /* Checkboxes */
















    /* Radio buttons */
















    /* Groups, frames, rectangles, and icons */
















    /* Static text */
































    /* Listboxes */
















    /* Combo boxes */
















    /* Edit controls */
















    /* Scroll bars */









/* These dialog resource ordinals really start at 0x0600, but the
 * RC Compiler can't handle hex for resource IDs, hence the decimal.
 */










 

/* WINVER >= 0x30a */



/*----Types------------------------------------------------------------------*/
typedef struct tagCRGB
    {
    BYTE    bRed;
    BYTE    bGreen;
    BYTE    bBlue;
    BYTE    bExtra;
    }
CRGB;           /* RGB Color */ 


// _DLGSH_INCLUDED_
#line 171 "C:\WATCOM\H\NT\windows.h"

#line 1 "C:\WATCOM\H\NT\lzexpand.h"
/*
** lzdos.h - Public interface to LZEXP?.LIB.
*/





extern "C" {


/*
** Error Return Codes
*/

/* invalid input handle */
/* invalid output handle */
/* corrupt compressed file format */
/* out of space for output file */
/* insufficient memory for LZFile struct */
/* bad global handle */
/* input parameter out of acceptable range*/
/* compression algorithm not recognized */


/*
** Prototypes
*/

INT
 __stdcall 
LZStart(
	 void 
	);

 void 
 __stdcall 
LZDone(
	 void 
	);

LONG
 __stdcall 
CopyLZFile(
	INT,
	INT
	);

LONG
 __stdcall 
LZCopy(
	INT,
	INT
	);

INT
 __stdcall 
LZInit(
	INT
	);

INT
 __stdcall 
GetExpandedNameA(
	LPSTR,
	LPSTR
	);
INT
 __stdcall 
GetExpandedNameW(
	LPWSTR,
	LPWSTR
	);
#line 77 "C:\WATCOM\H\NT\lzexpand.h"

// !UNICODE

INT
 __stdcall 
LZOpenFileA(
	LPSTR,
	LPOFSTRUCT,
	WORD
	);
INT
 __stdcall 
LZOpenFileW(
	LPWSTR,
	LPOFSTRUCT,
	WORD
	);
#line 97 "C:\WATCOM\H\NT\lzexpand.h"

// !UNICODE

LONG
 __stdcall 
LZSeek(
	INT,
	LONG,
	INT
	);

INT
 __stdcall 
LZRead(
	INT,
	LPSTR,
	INT
	);

 void 
 __stdcall 
LZClose(
	INT
	);


}



// _LZEXPAND_
#line 172 "C:\WATCOM\H\NT\windows.h"

#line 1 "C:\WATCOM\H\NT\mmsystem.h"
/*==========================================================================
 *
 *  mmsystem.h -- Include file for Multimedia API's
 *
 *  Version 4.00
 *
 *  Copyright (C) 1992-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *--------------------------------------------------------------------------
 *
 *  Define:         Prevent inclusion of:
 *  --------------  --------------------------------------------------------
 *  MMNODRV         Installable driver support
 *  MMNOSOUND       Sound support
 *  MMNOWAVE        Waveform support
 *  MMNOMIDI        MIDI support
 *  MMNOAUX         Auxiliary audio support
 *  MMNOMIXER       Mixer support
 *  MMNOTIMER       Timer support
 *  MMNOJOY         Joystick support
 *  MMNOMCI         MCI support
 *  MMNOMMIO        Multimedia file I/O support
 *  MMNOMMSYSTEM    General MMSYSTEM functions
 *
 *==========================================================================
 */


/* #defined if mmsystem.h has been included */


#line 1 "C:\WATCOM\H\NT\pshpack1.h"
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pshpack1.h

Abstract:

    This file turns 1 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push)

#pragma pack(1)
#line 32 "C:\WATCOM\H\NT\pshpack1.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 32 "C:\WATCOM\H\NT\mmsystem.h"

#line 38 "C:\WATCOM\H\NT\mmsystem.h"


extern "C" {            /* Assume C declarations for C++ */ 
/* __cplusplus */




#line 49 "C:\WATCOM\H\NT\mmsystem.h"


#line 54 "C:\WATCOM\H\NT\mmsystem.h"

#line 74 "C:\WATCOM\H\NT\mmsystem.h"

/****************************************************************************

		    General constants and data types

****************************************************************************/

/* general constants */
/* max product name length (including NULL) */
/* max error text length (including NULL) */
/* max oem vxd name length (including NULL) */

/*
 *  Microsoft Manufacturer and Product ID's (these have been moved to
 *  MMREG.H for Windows 4.00 and above).
 */
 #line 109 "C:\WATCOM\H\NT\mmsystem.h"

/* general data types */


typedef UINT        MMVERSION;  /* major (high byte), minor (low byte) */ 
#line 117 "C:\WATCOM\H\NT\mmsystem.h"
typedef UINT        MMRESULT;   /* error return code, 0 means no error */ 
				/* call as if(err=xxxx(...)) Error(err); else */


typedef UINT      *LPUINT;

/* MMTIME data structure */
typedef struct mmtime_tag
{
    UINT            wType;      /* indicates the contents of the union */ 
    union
    {
	DWORD       ms;         /* milliseconds */ 
	DWORD       sample;     /* samples */ 
	DWORD       cb;         /* byte count */ 
	DWORD       ticks;      /* ticks in MIDI stream */ 

	/* SMPTE */
	struct
	{
	    BYTE    hour;       /* hours */ 
	    BYTE     min ;        /* minutes */ 
	    BYTE    sec;        /* seconds */ 
	    BYTE    frame;      /* frames  */ 
	    BYTE    fps;        /* frames per second */ 
	    BYTE    dummy;      /* pad */ 

	    BYTE    pad[2];

	} smpte;

	/* MIDI */
	struct
	{
	    DWORD songptrpos;   /* song pointer position */ 
	} midi;
    } u;
} MMTIME, *PMMTIME,    *NPMMTIME,    *LPMMTIME;

/* types for wType field in MMTIME struct */
/* time in milliseconds */
/* number of wave samples */
/* current byte offset */
/* SMPTE time */
/* MIDI time */
/* Ticks within MIDI stream */

/*
 *
 *
 */




/****************************************************************************

		    Multimedia Extensions Window Messages

****************************************************************************/

/* joystick */








/* MCI */

/* waveform output */



/* waveform input */



/* MIDI input */






/* MIDI output */



/* these are also in msvideo.h */

 /* installable drivers */
 
 
 


/* these are used by msacm.h */





 
/* Callback for MEVT_POSITIONCB */


 


/* MIM_DONE w/ pending events */

/* WINVER >= 0x0400 */
/* mixer line change notify */
/* mixer control change notify */

/****************************************************************************

		String resource number bases (internal use)

****************************************************************************/















/****************************************************************************

			General error return values

****************************************************************************/

/* general error return values */
/* no error */
/* unspecified error */
/* device ID out of range */
/* driver failed enable */
/* device already allocated */
/* device handle is invalid */
/* no device driver present */
/* memory allocation error */
/* function isn't supported */
/* error value out of range */
/* invalid flag passed */
/* invalid parameter passed */
/* handle being used */
						   /* simultaneously on another */
						   /* thread (eg callback) */
/* specified alias not found */
/* bad registry database */
/* registry key not found */
/* registry read error */
/* registry write error */
/* registry delete error */
/* registry value not found */
/* driver does not call DriverCallback */
/* last error in range */

 
 typedef HANDLE HDRVR ;
/* ifdef WINVER < 0x030a */



/****************************************************************************

			Installable driver support

****************************************************************************/


typedef struct DRVCONFIGINFOEX {
    DWORD   dwDCISize;
    LPCWSTR  lpszDCISectionName;
    LPCWSTR  lpszDCIAliasName;
    DWORD    dnDevNode;
} DRVCONFIGINFOEX, *PDRVCONFIGINFOEX,    *NPDRVCONFIGINFOEX,    *LPDRVCONFIGINFOEX;

#line 315 "C:\WATCOM\H\NT\mmsystem.h"

 



/* Driver messages */















/* LPARAM of DRV_CONFIGURE message */

typedef struct tagDRVCONFIGINFO {
    DWORD   dwDCISize;
    LPCWSTR  lpszDCISectionName;
    LPCWSTR  lpszDCIAliasName;
} DRVCONFIGINFO, *PDRVCONFIGINFO,    *NPDRVCONFIGINFO,    *LPDRVCONFIGINFO;
#line 350 "C:\WATCOM\H\NT\mmsystem.h"

/* Supported return values for DRV_CONFIGURE message */




/* installable driver function prototypes */

 

typedef LRESULT ( __stdcall * DRIVERPROC)(DWORD, HDRVR, UINT, LPARAM, LPARAM);

 __declspec(dllimport)  LRESULT    __stdcall  CloseDriver(HDRVR hDriver, LONG lParam1, LONG lParam2);
 __declspec(dllimport)  HDRVR      __stdcall  OpenDriver(LPCWSTR szDriverName, LPCWSTR szSectionName, LONG lParam2);
 __declspec(dllimport)  LRESULT    __stdcall  SendDriverMessage(HDRVR hDriver, UINT message, LONG lParam1, LONG lParam2);
 __declspec(dllimport)  HMODULE    __stdcall  DrvGetModuleHandle(HDRVR hDriver);
 __declspec(dllimport)  HMODULE    __stdcall  GetDriverModuleHandle(HDRVR hDriver);
 __declspec(dllimport)  LRESULT    __stdcall  DefDriverProc(DWORD dwDriverIdentifier, HDRVR hdrvr, UINT uMsg, LPARAM lParam1, LPARAM lParam2);
 /* ifndef _WIN32_VXD */
/* ifdef _WIN32 */#line 377 "C:\WATCOM\H\NT\mmsystem.h"
/* DRV_LOAD */
/* ifdef (WINVER < 0x030a) || defined(_WIN32) */

 
/* return values from DriverProc() function */




/* ifdef WINVER >= 0x030a */




/* ifndef MMNODRV */

/****************************************************************************

			  Driver callback support

****************************************************************************/

/* flags used with waveOutOpen(), waveInOpen(), midiInOpen(), and */
/* midiOutOpen() to specify the type of the dwCallback parameter. */

/* callback type mask */
/* no callback */
/* dwCallback is a HWND */
/* dwCallback is a HTASK */
/* dwCallback is a FARPROC */

/* thread ID replaces 16 bit task */
/* dwCallback is an EVENT Handle */




typedef void ( __stdcall  DRVCALLBACK)(HDRVR hdrvr, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2);

typedef DRVCALLBACK    *LPDRVCALLBACK;

typedef DRVCALLBACK     *PDRVCALLBACK;


/* ifndef _WIN32_VXD */



/****************************************************************************

		    General MMSYSTEM support

****************************************************************************/

 #line 434 "C:\WATCOM\H\NT\mmsystem.h"


#line 439 "C:\WATCOM\H\NT\mmsystem.h"

/* ifndef _WIN32_VXD */
/* ifndef MMNOMMSYSTEM */



/****************************************************************************

			    Sound support

****************************************************************************/



 __declspec(dllimport)  BOOL  __stdcall  sndPlaySoundA(LPCSTR pszSound, UINT fuSound);
 __declspec(dllimport)  BOOL  __stdcall  sndPlaySoundW(LPCWSTR pszSound, UINT fuSound);
#line 458 "C:\WATCOM\H\NT\mmsystem.h"

// !UNICODE

#line 464 "C:\WATCOM\H\NT\mmsystem.h"

/*
 *  flag values for fuSound and fdwSound arguments on [snd]PlaySound
 */
/* play synchronously (default) */
/* play asynchronously */
/* silence (!default) if sound not found */
/* pszSound points to a memory file */
/* loop the sound until next sndPlaySound */
/* don't stop any currently playing sound */

/* don't wait if the driver is busy */
/* name is a registry alias */
/* alias is a predefined ID */
/* name is file name */
/* name is resource name or atom */
 
/* purge non-static events for task */
/* look for application specific association */
/* WINVER >= 0x0400 */

/* alias base */













 __declspec(dllimport)  BOOL  __stdcall  PlaySoundA(LPCSTR pszSound, HMODULE hmod, DWORD fdwSound);
 __declspec(dllimport)  BOOL  __stdcall  PlaySoundW(LPCWSTR pszSound, HMODULE hmod, DWORD fdwSound);
#line 504 "C:\WATCOM\H\NT\mmsystem.h"

// !UNICODE

#line 510 "C:\WATCOM\H\NT\mmsystem.h"

/* ifndef _WIN32_VXD */
/* ifndef MMNOSOUND */


/****************************************************************************

			Waveform audio support

****************************************************************************/

/* waveform audio error return values */
/* unsupported wave format */
/* still something playing */
/* header not prepared */
/* device is synchronous */
/* last error in range */

/* waveform audio data types */
 typedef HANDLE HWAVE ;
 typedef HANDLE HWAVEIN ;
 typedef HANDLE HWAVEOUT ;

typedef HWAVEIN    *LPHWAVEIN;
typedef HWAVEOUT    *LPHWAVEOUT;
typedef DRVCALLBACK WAVECALLBACK;
typedef WAVECALLBACK    *LPWAVECALLBACK;


/* wave callback messages */







/* device ID for wave device mapper */


/* flags for dwFlags parameter in waveOutOpen() and waveInOpen() */


 



/* WINVER >= 0x0400 */

/* wave data block header */
typedef struct wavehdr_tag {
    LPSTR       lpData;                 /* pointer to locked data buffer */ 
    DWORD       dwBufferLength;         /* length of data buffer */ 
    DWORD       dwBytesRecorded;        /* used for input only */ 
    DWORD       dwUser;                 /* for client's use */ 
    DWORD       dwFlags;                /* assorted flags (see defines) */ 
    DWORD       dwLoops;                /* loop control counter */ 
    struct wavehdr_tag    *lpNext;     /* reserved for driver */ 
    DWORD       reserved;               /* reserved for driver */ 
} WAVEHDR, *PWAVEHDR,    *NPWAVEHDR,    *LPWAVEHDR;

/* flags for dwFlags field of WAVEHDR */
/* done bit */
/* set if this header has been prepared */
/* loop start block */
/* loop end block */
/* reserved for driver */

/* waveform output device capabilities structure */


typedef struct tagWAVEOUTCAPSA {
    WORD    wMid;                  /* manufacturer ID */ 
    WORD    wPid;                  /* product ID */ 
    MMVERSION vDriverVersion;      /* version of the driver */ 
    CHAR    szPname[ 32 ];  /* product name (NULL terminated string) */ 
    DWORD   dwFormats;             /* formats supported */ 
    WORD    wChannels;             /* number of sources supported */ 
    WORD    wReserved1;            /* packing */ 
    DWORD   dwSupport;             /* functionality supported by driver */ 
} WAVEOUTCAPSA, *PWAVEOUTCAPSA, *NPWAVEOUTCAPSA, *LPWAVEOUTCAPSA;
typedef struct tagWAVEOUTCAPSW {
    WORD    wMid;                  /* manufacturer ID */ 
    WORD    wPid;                  /* product ID */ 
    MMVERSION vDriverVersion;      /* version of the driver */ 
    WCHAR   szPname[ 32 ];  /* product name (NULL terminated string) */ 
    DWORD   dwFormats;             /* formats supported */ 
    WORD    wChannels;             /* number of sources supported */ 
    WORD    wReserved1;            /* packing */ 
    DWORD   dwSupport;             /* functionality supported by driver */ 
} WAVEOUTCAPSW, *PWAVEOUTCAPSW, *NPWAVEOUTCAPSW, *LPWAVEOUTCAPSW;
#line 607 "C:\WATCOM\H\NT\mmsystem.h"
typedef WAVEOUTCAPSA WAVEOUTCAPS;
typedef PWAVEOUTCAPSA PWAVEOUTCAPS;
typedef NPWAVEOUTCAPSA NPWAVEOUTCAPS;
typedef LPWAVEOUTCAPSA LPWAVEOUTCAPS;
// UNICODE

#line 624 "C:\WATCOM\H\NT\mmsystem.h"

/* flags for dwSupport field of WAVEOUTCAPS */
/* supports pitch control */
/* supports playback rate control */
/* supports volume control */
/* separate left-right volume control */




/* waveform input device capabilities structure */


typedef struct tagWAVEINCAPSA {
    WORD    wMid;                    /* manufacturer ID */ 
    WORD    wPid;                    /* product ID */ 
    MMVERSION vDriverVersion;        /* version of the driver */ 
    CHAR    szPname[ 32 ];    /* product name (NULL terminated string) */ 
    DWORD   dwFormats;               /* formats supported */ 
    WORD    wChannels;               /* number of channels supported */ 
    WORD    wReserved1;              /* structure packing */ 
} WAVEINCAPSA, *PWAVEINCAPSA, *NPWAVEINCAPSA, *LPWAVEINCAPSA;
typedef struct tagWAVEINCAPSW {
    WORD    wMid;                    /* manufacturer ID */ 
    WORD    wPid;                    /* product ID */ 
    MMVERSION vDriverVersion;        /* version of the driver */ 
    WCHAR   szPname[ 32 ];    /* product name (NULL terminated string) */ 
    DWORD   dwFormats;               /* formats supported */ 
    WORD    wChannels;               /* number of channels supported */ 
    WORD    wReserved1;              /* structure packing */ 
} WAVEINCAPSW, *PWAVEINCAPSW, *NPWAVEINCAPSW, *LPWAVEINCAPSW;
#line 661 "C:\WATCOM\H\NT\mmsystem.h"
typedef WAVEINCAPSA WAVEINCAPS;
typedef PWAVEINCAPSA PWAVEINCAPS;
typedef NPWAVEINCAPSA NPWAVEINCAPS;
typedef LPWAVEINCAPSA LPWAVEINCAPS;
// UNICODE

#line 677 "C:\WATCOM\H\NT\mmsystem.h"

/* defines for dwFormat field of WAVEINCAPS and WAVEOUTCAPS */
/* invalid format */
/* 11.025 kHz, Mono,   8-bit  */
/* 11.025 kHz, Stereo, 8-bit  */
/* 11.025 kHz, Mono,   16-bit */
/* 11.025 kHz, Stereo, 16-bit */
/* 22.05  kHz, Mono,   8-bit  */
/* 22.05  kHz, Stereo, 8-bit  */
/* 22.05  kHz, Mono,   16-bit */
/* 22.05  kHz, Stereo, 16-bit */
/* 44.1   kHz, Mono,   8-bit  */
/* 44.1   kHz, Stereo, 8-bit  */
/* 44.1   kHz, Mono,   16-bit */
/* 44.1   kHz, Stereo, 16-bit */

/* OLD general waveform format structure (information common to all formats) */
typedef struct waveformat_tag {
    WORD    wFormatTag;        /* format type */ 
    WORD    nChannels;         /* number of channels (i.e. mono, stereo, etc.) */ 
    DWORD   nSamplesPerSec;    /* sample rate */ 
    DWORD   nAvgBytesPerSec;   /* for buffer estimation */ 
    WORD    nBlockAlign;       /* block size of data */ 
} WAVEFORMAT, *PWAVEFORMAT,    *NPWAVEFORMAT,    *LPWAVEFORMAT;

/* flags for wFormatTag field of WAVEFORMAT */


/* specific waveform format structure for PCM data */
typedef struct pcmwaveformat_tag {
    WAVEFORMAT  wf;
    WORD        wBitsPerSample;
} PCMWAVEFORMAT, *PPCMWAVEFORMAT,    *NPPCMWAVEFORMAT,    *LPPCMWAVEFORMAT;




/*
 *  extended waveform format structure used for all non-PCM formats. this
 *  structure is common to all non-PCM formats.
 */
typedef struct tWAVEFORMATEX
{
    WORD        wFormatTag;         /* format type */ 
    WORD        nChannels;          /* number of channels (i.e. mono, stereo...) */ 
    DWORD       nSamplesPerSec;     /* sample rate */ 
    DWORD       nAvgBytesPerSec;    /* for buffer estimation */ 
    WORD        nBlockAlign;        /* block size of data */ 
    WORD        wBitsPerSample;     /* number of bits per sample of mono data */ 
    WORD        cbSize;             /* the count in bytes of the size of */ 
				    /* extra information (after cbSize) */
} WAVEFORMATEX, *PWAVEFORMATEX,    *NPWAVEFORMATEX,    *LPWAVEFORMATEX;
typedef const WAVEFORMATEX    *LPCWAVEFORMATEX;

/* _WAVEFORMATEX_ */


/* waveform audio function prototypes */
 __declspec(dllimport)  UINT  __stdcall  waveOutGetNumDevs(void);



 __declspec(dllimport)  MMRESULT  __stdcall  waveOutGetDevCapsA(UINT uDeviceID, LPWAVEOUTCAPSA pwoc, UINT cbwoc);
 __declspec(dllimport)  MMRESULT  __stdcall  waveOutGetDevCapsW(UINT uDeviceID, LPWAVEOUTCAPSW pwoc, UINT cbwoc);
#line 744 "C:\WATCOM\H\NT\mmsystem.h"

// !UNICODE

#line 750 "C:\WATCOM\H\NT\mmsystem.h"

 
 __declspec(dllimport)  MMRESULT  __stdcall  waveOutGetVolume(HWAVEOUT hwo, LPDWORD pdwVolume);
 __declspec(dllimport)  MMRESULT  __stdcall  waveOutSetVolume(HWAVEOUT hwo, DWORD dwVolume);
#line 758 "C:\WATCOM\H\NT\mmsystem.h"



 __declspec(dllimport)  MMRESULT  __stdcall  waveOutGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText);
 __declspec(dllimport)  MMRESULT  __stdcall  waveOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);
#line 766 "C:\WATCOM\H\NT\mmsystem.h"

// !UNICODE

#line 772 "C:\WATCOM\H\NT\mmsystem.h"

 __declspec(dllimport)  MMRESULT  __stdcall  waveOutOpen(LPHWAVEOUT phwo, UINT uDeviceID,
    LPCWAVEFORMATEX pwfx, DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);

 __declspec(dllimport)  MMRESULT  __stdcall  waveOutClose(HWAVEOUT hwo);
 __declspec(dllimport)  MMRESULT  __stdcall  waveOutPrepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
 __declspec(dllimport)  MMRESULT  __stdcall  waveOutUnprepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
 __declspec(dllimport)  MMRESULT  __stdcall  waveOutWrite(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
 __declspec(dllimport)  MMRESULT  __stdcall  waveOutPause(HWAVEOUT hwo);
 __declspec(dllimport)  MMRESULT  __stdcall  waveOutRestart(HWAVEOUT hwo);
 __declspec(dllimport)  MMRESULT  __stdcall  waveOutReset(HWAVEOUT hwo);
 __declspec(dllimport)  MMRESULT  __stdcall  waveOutBreakLoop(HWAVEOUT hwo);
 __declspec(dllimport)  MMRESULT  __stdcall  waveOutGetPosition(HWAVEOUT hwo, LPMMTIME pmmt, UINT cbmmt);
 __declspec(dllimport)  MMRESULT  __stdcall  waveOutGetPitch(HWAVEOUT hwo, LPDWORD pdwPitch);
 __declspec(dllimport)  MMRESULT  __stdcall  waveOutSetPitch(HWAVEOUT hwo, DWORD dwPitch);
 __declspec(dllimport)  MMRESULT  __stdcall  waveOutGetPlaybackRate(HWAVEOUT hwo, LPDWORD pdwRate);
 __declspec(dllimport)  MMRESULT  __stdcall  waveOutSetPlaybackRate(HWAVEOUT hwo, DWORD dwRate);
 __declspec(dllimport)  MMRESULT  __stdcall  waveOutGetID(HWAVEOUT hwo, LPUINT puDeviceID);

 

 __declspec(dllimport)  MMRESULT  __stdcall  waveOutMessage(HWAVEOUT hwo, UINT uMsg, DWORD dw1, DWORD dw2);
#line 797 "C:\WATCOM\H\NT\mmsystem.h"
/* ifdef WINVER >= 0x030a */

 __declspec(dllimport)  UINT  __stdcall  waveInGetNumDevs(void);



 __declspec(dllimport)  MMRESULT  __stdcall  waveInGetDevCapsA(UINT uDeviceID, LPWAVEINCAPSA pwic, UINT cbwic);
 __declspec(dllimport)  MMRESULT  __stdcall  waveInGetDevCapsW(UINT uDeviceID, LPWAVEINCAPSW pwic, UINT cbwic);
#line 808 "C:\WATCOM\H\NT\mmsystem.h"

// !UNICODE

#line 814 "C:\WATCOM\H\NT\mmsystem.h"



 __declspec(dllimport)  MMRESULT  __stdcall  waveInGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText);
 __declspec(dllimport)  MMRESULT  __stdcall  waveInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);
#line 822 "C:\WATCOM\H\NT\mmsystem.h"

// !UNICODE

#line 828 "C:\WATCOM\H\NT\mmsystem.h"

 __declspec(dllimport)  MMRESULT  __stdcall  waveInOpen(LPHWAVEIN phwi, UINT uDeviceID,
    LPCWAVEFORMATEX pwfx, DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);

 __declspec(dllimport)  MMRESULT  __stdcall  waveInClose(HWAVEIN hwi);
 __declspec(dllimport)  MMRESULT  __stdcall  waveInPrepareHeader(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);
 __declspec(dllimport)  MMRESULT  __stdcall  waveInUnprepareHeader(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);
 __declspec(dllimport)  MMRESULT  __stdcall  waveInAddBuffer(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);
 __declspec(dllimport)  MMRESULT  __stdcall  waveInStart(HWAVEIN hwi);
 __declspec(dllimport)  MMRESULT  __stdcall  waveInStop(HWAVEIN hwi);
 __declspec(dllimport)  MMRESULT  __stdcall  waveInReset(HWAVEIN hwi);
 __declspec(dllimport)  MMRESULT  __stdcall  waveInGetPosition(HWAVEIN hwi, LPMMTIME pmmt, UINT cbmmt);
 __declspec(dllimport)  MMRESULT  __stdcall  waveInGetID(HWAVEIN hwi, LPUINT puDeviceID);

 

 __declspec(dllimport)  MMRESULT  __stdcall  waveInMessage(HWAVEIN hwi, UINT uMsg, DWORD dw1, DWORD dw2);
#line 848 "C:\WATCOM\H\NT\mmsystem.h"
/* ifdef WINVER >= 0x030a */

/* ifndef _WIN32_VXD */

/* ifndef MMNOWAVE */


/****************************************************************************

			    MIDI audio support

****************************************************************************/

/* MIDI error return values */
/* header not prepared */
/* still something playing */
/* no configured instruments */
/* hardware is still busy */
/* port no longer connected */
/* invalid MIF */
/* operation unsupported w/ open mode */
/* thru device 'eating' a message */
/* last error in range */

/* MIDI audio data types */
 typedef HANDLE HMIDI ;
 typedef HANDLE HMIDIIN ;
 typedef HANDLE HMIDIOUT ;
 typedef HANDLE HMIDISTRM ;

typedef HMIDI    *LPHMIDI;
typedef HMIDIIN    *LPHMIDIIN;
typedef HMIDIOUT    *LPHMIDIOUT;
typedef HMIDISTRM    *LPHMIDISTRM;
typedef DRVCALLBACK MIDICALLBACK;
typedef MIDICALLBACK    *LPMIDICALLBACK;

typedef WORD PATCHARRAY[ 128 ];
typedef WORD    *LPPATCHARRAY;
typedef WORD KEYARRAY[ 128 ];
typedef WORD    *LPKEYARRAY;
/* ifndef _WIN32_VXD */

/* MIDI callback messages */










 


/* WINVER >= 0x0400 */

/* device ID for MIDI mapper */



 
/* flags for dwFlags parm of midiInOpen() */

/* WINVER >= 0x0400 */

/* flags for wFlags parm of midiOutCachePatches(), midiOutCacheDrumPatches() */





/* MIDI output device capabilities structure */


typedef struct tagMIDIOUTCAPSA {
    WORD    wMid;                  /* manufacturer ID */ 
    WORD    wPid;                  /* product ID */ 
    MMVERSION vDriverVersion;      /* version of the driver */ 
    CHAR    szPname[ 32 ];  /* product name (NULL terminated string) */ 
    WORD    wTechnology;           /* type of device */ 
    WORD    wVoices;               /* # of voices (internal synth only) */ 
    WORD    wNotes;                /* max # of notes (internal synth only) */ 
    WORD    wChannelMask;          /* channels used (internal synth only) */ 
    DWORD   dwSupport;             /* functionality supported by driver */ 
} MIDIOUTCAPSA, *PMIDIOUTCAPSA, *NPMIDIOUTCAPSA, *LPMIDIOUTCAPSA;
typedef struct tagMIDIOUTCAPSW {
    WORD    wMid;                  /* manufacturer ID */ 
    WORD    wPid;                  /* product ID */ 
    MMVERSION vDriverVersion;      /* version of the driver */ 
    WCHAR   szPname[ 32 ];  /* product name (NULL terminated string) */ 
    WORD    wTechnology;           /* type of device */ 
    WORD    wVoices;               /* # of voices (internal synth only) */ 
    WORD    wNotes;                /* max # of notes (internal synth only) */ 
    WORD    wChannelMask;          /* channels used (internal synth only) */ 
    DWORD   dwSupport;             /* functionality supported by driver */ 
} MIDIOUTCAPSW, *PMIDIOUTCAPSW, *NPMIDIOUTCAPSW, *LPMIDIOUTCAPSW;
#line 953 "C:\WATCOM\H\NT\mmsystem.h"
typedef MIDIOUTCAPSA MIDIOUTCAPS;
typedef PMIDIOUTCAPSA PMIDIOUTCAPS;
typedef NPMIDIOUTCAPSA NPMIDIOUTCAPS;
typedef LPMIDIOUTCAPSA LPMIDIOUTCAPS;
// UNICODE

#line 972 "C:\WATCOM\H\NT\mmsystem.h"

/* flags for wTechnology field of MIDIOUTCAPS structure */
/* output port */
/* generic internal synth */
/* square wave internal synth */
/* FM internal synth */
/* MIDI mapper */

/* flags for dwSupport field of MIDIOUTCAPS structure */
/* supports volume control */
/* separate left-right volume control */

 
/* driver supports midiStreamOut directly */
/* WINVER >= 0x0400 */

/* MIDI input device capabilities structure */


typedef struct tagMIDIINCAPSA {
    WORD        wMid;                   /* manufacturer ID */ 
    WORD        wPid;                   /* product ID */ 
    MMVERSION   vDriverVersion;         /* version of the driver */ 
    CHAR        szPname[ 32 ];   /* product name (NULL terminated string) */ 
 
    DWORD   dwSupport;             /* functionality supported by driver */ 

} MIDIINCAPSA, *PMIDIINCAPSA, *NPMIDIINCAPSA, *LPMIDIINCAPSA;
typedef struct tagMIDIINCAPSW {
    WORD        wMid;                   /* manufacturer ID */ 
    WORD        wPid;                   /* product ID */ 
    MMVERSION   vDriverVersion;         /* version of the driver */ 
    WCHAR       szPname[ 32 ];   /* product name (NULL terminated string) */ 
 
    DWORD   dwSupport;             /* functionality supported by driver */ 

} MIDIINCAPSW, *PMIDIINCAPSW, *NPMIDIINCAPSW, *LPMIDIINCAPSW;
#line 1015 "C:\WATCOM\H\NT\mmsystem.h"
typedef MIDIINCAPSA MIDIINCAPS;
typedef PMIDIINCAPSA PMIDIINCAPS;
typedef NPMIDIINCAPSA NPMIDIINCAPS;
typedef LPMIDIINCAPSA LPMIDIINCAPS;
// UNICODE

#line 1032 "C:\WATCOM\H\NT\mmsystem.h"

/* MIDI data block header */
typedef struct midihdr_tag {
    LPSTR       lpData;               /* pointer to locked data block */ 
    DWORD       dwBufferLength;       /* length of data in data block */ 
    DWORD       dwBytesRecorded;      /* used for input only */ 
    DWORD       dwUser;               /* for client's use */ 
    DWORD       dwFlags;              /* assorted flags (see defines) */ 
    struct midihdr_tag    *lpNext;   /* reserved for driver */ 
    DWORD       reserved;             /* reserved for driver */ 
 
    DWORD       dwOffset;             /* Callback offset into buffer */ 
    DWORD       dwReserved[8];        /* Reserved for MMSYSTEM */ 

} MIDIHDR, *PMIDIHDR,    *NPMIDIHDR,    *LPMIDIHDR;

 
typedef struct midievent_tag
{
    DWORD       dwDeltaTime;          /* Ticks since last event */ 
    DWORD       dwStreamID;           /* Reserved; must be zero */ 
    DWORD       dwEvent;              /* Event type and parameters */ 
    DWORD       dwParms[1];           /* Parameters if this is a long event */ 
} MIDIEVENT;

typedef struct midistrmbuffver_tag
{
    DWORD       dwVersion;                  /* Stream buffer format version */ 
    DWORD       dwMid;                      /* Manufacturer ID as defined in MMREG.H */ 
    DWORD       dwOEMVersion;               /* Manufacturer version for custom ext */ 
} MIDISTRMBUFFVER;
/* WINVER >= 0x0400 */

/* flags for dwFlags field of MIDIHDR structure */
/* done bit */
/* set if header prepared */
/* reserved for driver */
/* Buffer is stream buffer */

 
/* */
/* Type codes which go in the high byte of the event DWORD of a stream buffer */
/* */
/* Type codes 00-7F contain parameters within the low 24 bits */
/* Type codes 80-FF contain a length of their parameter in the low 24 */
/* bits, followed by their parameter data in the buffer. The event */
/* DWORD contains the exact byte length; the parm data itself must be */
/* padded to be an even multiple of 4 bytes long. */
/* */








/* parm = shortmsg for midiOutShortMsg */
/* parm = new tempo in microsec/qn     */
/* parm = unused; does nothing         */

/* 0x04-0x7F reserved */

/* parm = bytes to send verbatim       */
/* parm = comment data                 */
/* parm = MIDISTRMBUFFVER struct       */

/* 0x81-0xFF reserved */



/* */
/* Structures and defines for midiStreamProperty */
/* */



/* These are intentionally both non-zero so the app cannot accidentally */
/* leave the operation off and happen to appear to work due to default */
/* action. */




typedef struct midiproptimediv_tag
{
    DWORD       cbStruct;
    DWORD       dwTimeDiv;
} MIDIPROPTIMEDIV,    *LPMIDIPROPTIMEDIV;

typedef struct midiproptempo_tag
{
    DWORD       cbStruct;
    DWORD       dwTempo;
} MIDIPROPTEMPO,    *LPMIDIPROPTEMPO;

/* WINVER >= 0x0400 */



/* MIDI function prototypes */
 __declspec(dllimport)  UINT  __stdcall  midiOutGetNumDevs(void);
 
 __declspec(dllimport)  MMRESULT  __stdcall  midiStreamOpen(LPHMIDISTRM phms, LPUINT puDeviceID, DWORD cMidi, DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);
 __declspec(dllimport)  MMRESULT  __stdcall  midiStreamClose(HMIDISTRM hms);

 __declspec(dllimport)  MMRESULT  __stdcall  midiStreamProperty(HMIDISTRM hms, LPBYTE lppropdata, DWORD dwProperty);
 __declspec(dllimport)  MMRESULT  __stdcall  midiStreamPosition(HMIDISTRM hms, LPMMTIME lpmmt, UINT cbmmt);

 __declspec(dllimport)  MMRESULT  __stdcall  midiStreamOut(HMIDISTRM hms, LPMIDIHDR pmh, UINT cbmh);
 __declspec(dllimport)  MMRESULT  __stdcall  midiStreamPause(HMIDISTRM hms);
 __declspec(dllimport)  MMRESULT  __stdcall  midiStreamRestart(HMIDISTRM hms);
 __declspec(dllimport)  MMRESULT  __stdcall  midiStreamStop(HMIDISTRM hms);


 __declspec(dllimport)  MMRESULT  __stdcall  midiConnect(HMIDI hmi, HMIDIOUT hmo, LPVOID pReserved);
 __declspec(dllimport)  MMRESULT  __stdcall  midiDisconnect(HMIDI hmi, HMIDIOUT hmo, LPVOID pReserved);

/* WINVER >= 0x0400 */



 __declspec(dllimport)  MMRESULT  __stdcall  midiOutGetDevCapsA(UINT uDeviceID, LPMIDIOUTCAPSA pmoc, UINT cbmoc);
 __declspec(dllimport)  MMRESULT  __stdcall  midiOutGetDevCapsW(UINT uDeviceID, LPMIDIOUTCAPSW pmoc, UINT cbmoc);
#line 1159 "C:\WATCOM\H\NT\mmsystem.h"

// !UNICODE

#line 1165 "C:\WATCOM\H\NT\mmsystem.h"

 
 __declspec(dllimport)  MMRESULT  __stdcall  midiOutGetVolume(HMIDIOUT hmo, LPDWORD pdwVolume);
 __declspec(dllimport)  MMRESULT  __stdcall  midiOutSetVolume(HMIDIOUT hmo, DWORD dwVolume);
#line 1173 "C:\WATCOM\H\NT\mmsystem.h"



 __declspec(dllimport)  MMRESULT  __stdcall  midiOutGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText);
 __declspec(dllimport)  MMRESULT  __stdcall  midiOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);
#line 1181 "C:\WATCOM\H\NT\mmsystem.h"

// !UNICODE

#line 1187 "C:\WATCOM\H\NT\mmsystem.h"

 __declspec(dllimport)  MMRESULT  __stdcall  midiOutOpen(LPHMIDIOUT phmo, UINT uDeviceID,
    DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);
 __declspec(dllimport)  MMRESULT  __stdcall  midiOutClose(HMIDIOUT hmo);
 __declspec(dllimport)  MMRESULT  __stdcall  midiOutPrepareHeader(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh);
 __declspec(dllimport)  MMRESULT  __stdcall  midiOutUnprepareHeader(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh);
 __declspec(dllimport)  MMRESULT  __stdcall  midiOutShortMsg(HMIDIOUT hmo, DWORD dwMsg);
 __declspec(dllimport)  MMRESULT  __stdcall  midiOutLongMsg(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh);
 __declspec(dllimport)  MMRESULT  __stdcall  midiOutReset(HMIDIOUT hmo);
 __declspec(dllimport)  MMRESULT  __stdcall  midiOutCachePatches(HMIDIOUT hmo, UINT uBank, LPWORD pwpa, UINT fuCache);
 __declspec(dllimport)  MMRESULT  __stdcall  midiOutCacheDrumPatches(HMIDIOUT hmo, UINT uPatch, LPWORD pwkya, UINT fuCache);
 __declspec(dllimport)  MMRESULT  __stdcall  midiOutGetID(HMIDIOUT hmo, LPUINT puDeviceID);

 

 __declspec(dllimport)  MMRESULT  __stdcall  midiOutMessage(HMIDIOUT hmo, UINT uMsg, DWORD dw1, DWORD dw2);
#line 1206 "C:\WATCOM\H\NT\mmsystem.h"
/* ifdef WINVER >= 0x030a */

 __declspec(dllimport)  UINT  __stdcall  midiInGetNumDevs(void);



 __declspec(dllimport)  MMRESULT  __stdcall  midiInGetDevCapsA(UINT uDeviceID, LPMIDIINCAPSA pmic, UINT cbmic);
 __declspec(dllimport)  MMRESULT  __stdcall  midiInGetDevCapsW(UINT uDeviceID, LPMIDIINCAPSW pmic, UINT cbmic);
#line 1217 "C:\WATCOM\H\NT\mmsystem.h"

// !UNICODE
 __declspec(dllimport)  MMRESULT  __stdcall  midiInGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText);
 __declspec(dllimport)  MMRESULT  __stdcall  midiInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);
#line 1224 "C:\WATCOM\H\NT\mmsystem.h"

// !UNICODE

#line 1231 "C:\WATCOM\H\NT\mmsystem.h"

 __declspec(dllimport)  MMRESULT  __stdcall  midiInOpen(LPHMIDIIN phmi, UINT uDeviceID,
	DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);
 __declspec(dllimport)  MMRESULT  __stdcall  midiInClose(HMIDIIN hmi);
 __declspec(dllimport)  MMRESULT  __stdcall  midiInPrepareHeader(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh);
 __declspec(dllimport)  MMRESULT  __stdcall  midiInUnprepareHeader(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh);
 __declspec(dllimport)  MMRESULT  __stdcall  midiInAddBuffer(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh);
 __declspec(dllimport)  MMRESULT  __stdcall  midiInStart(HMIDIIN hmi);
 __declspec(dllimport)  MMRESULT  __stdcall  midiInStop(HMIDIIN hmi);
 __declspec(dllimport)  MMRESULT  __stdcall  midiInReset(HMIDIIN hmi);
 __declspec(dllimport)  MMRESULT  __stdcall  midiInGetID(HMIDIIN hmi, LPUINT puDeviceID);

 

 __declspec(dllimport)  MMRESULT  __stdcall  midiInMessage(HMIDIIN hmi, UINT uMsg, DWORD dw1, DWORD dw2);
#line 1249 "C:\WATCOM\H\NT\mmsystem.h"
/* ifdef WINVER >= 0x030a */

/* ifndef _WIN32_VXD */

/* ifndef MMNOMIDI */


/****************************************************************************

			Auxiliary audio support

****************************************************************************/

/* device ID for aux device mapper */


/* Auxiliary audio device capabilities structure */


typedef struct tagAUXCAPSA {
    WORD        wMid;                /* manufacturer ID */ 
    WORD        wPid;                /* product ID */ 
    MMVERSION   vDriverVersion;      /* version of the driver */ 
    CHAR        szPname[ 32 ];/* product name (NULL terminated string) */ 
    WORD        wTechnology;         /* type of device */ 
    WORD        wReserved1;          /* padding */ 
    DWORD       dwSupport;           /* functionality supported by driver */ 
} AUXCAPSA, *PAUXCAPSA, *NPAUXCAPSA, *LPAUXCAPSA;
typedef struct tagAUXCAPSW {
    WORD        wMid;                /* manufacturer ID */ 
    WORD        wPid;                /* product ID */ 
    MMVERSION   vDriverVersion;      /* version of the driver */ 
    WCHAR       szPname[ 32 ];/* product name (NULL terminated string) */ 
    WORD        wTechnology;         /* type of device */ 
    WORD        wReserved1;          /* padding */ 
    DWORD       dwSupport;           /* functionality supported by driver */ 
} AUXCAPSW, *PAUXCAPSW, *NPAUXCAPSW, *LPAUXCAPSW;
#line 1292 "C:\WATCOM\H\NT\mmsystem.h"
typedef AUXCAPSA AUXCAPS;
typedef PAUXCAPSA PAUXCAPS;
typedef NPAUXCAPSA NPAUXCAPS;
typedef LPAUXCAPSA LPAUXCAPS;
// UNICODE

#line 1308 "C:\WATCOM\H\NT\mmsystem.h"

/* flags for wTechnology field in AUXCAPS structure */
/* audio from internal CD-ROM drive */
/* audio from auxiliary input jacks */

/* flags for dwSupport field in AUXCAPS structure */
/* supports volume control */
/* separate left-right volume control */



/* auxiliary audio function prototypes */
 __declspec(dllimport)  UINT  __stdcall  auxGetNumDevs(void);


 __declspec(dllimport)  MMRESULT  __stdcall  auxGetDevCapsA(UINT uDeviceID, LPAUXCAPSA pac, UINT cbac);
 __declspec(dllimport)  MMRESULT  __stdcall  auxGetDevCapsW(UINT uDeviceID, LPAUXCAPSW pac, UINT cbac);
#line 1328 "C:\WATCOM\H\NT\mmsystem.h"

// !UNICODE

#line 1334 "C:\WATCOM\H\NT\mmsystem.h"
 __declspec(dllimport)  MMRESULT  __stdcall  auxSetVolume(UINT uDeviceID, DWORD dwVolume);
 __declspec(dllimport)  MMRESULT  __stdcall  auxGetVolume(UINT uDeviceID, LPDWORD pdwVolume);

 

 __declspec(dllimport)  MMRESULT  __stdcall  auxOutMessage(UINT uDeviceID, UINT uMsg, DWORD dw1, DWORD dw2);
#line 1343 "C:\WATCOM\H\NT\mmsystem.h"
/* ifdef WINVER >= 0x030a */

/* ifndef _WIN32_VXD */

/* ifndef MMNOAUX */



/****************************************************************************

			    Mixer Support

****************************************************************************/

 typedef HANDLE HMIXEROBJ ;
typedef HMIXEROBJ    *LPHMIXEROBJ;

 typedef HANDLE HMIXER ;
typedef HMIXER        *LPHMIXER;




/* */
/*  MMRESULT error return values specific to the mixer API */
/* */
/* */


















 __declspec(dllimport)  UINT  __stdcall  mixerGetNumDevs(void);



typedef struct tagMIXERCAPSA {
    WORD            wMid;                   /* manufacturer id */ 
    WORD            wPid;                   /* product id */ 
    MMVERSION       vDriverVersion;         /* version of the driver */ 
    CHAR            szPname[ 32 ];   /* product name */ 
    DWORD           fdwSupport;             /* misc. support bits */ 
    DWORD           cDestinations;          /* count of destinations */ 
} MIXERCAPSA, *PMIXERCAPSA, *LPMIXERCAPSA;
typedef struct tagMIXERCAPSW {
    WORD            wMid;                   /* manufacturer id */ 
    WORD            wPid;                   /* product id */ 
    MMVERSION       vDriverVersion;         /* version of the driver */ 
    WCHAR           szPname[ 32 ];   /* product name */ 
    DWORD           fdwSupport;             /* misc. support bits */ 
    DWORD           cDestinations;          /* count of destinations */ 
} MIXERCAPSW, *PMIXERCAPSW, *LPMIXERCAPSW;
#line 1413 "C:\WATCOM\H\NT\mmsystem.h"
typedef MIXERCAPSA MIXERCAPS;
typedef PMIXERCAPSA PMIXERCAPS;
typedef LPMIXERCAPSA LPMIXERCAPS;
// UNICODE

#line 1428 "C:\WATCOM\H\NT\mmsystem.h"



 __declspec(dllimport)  MMRESULT  __stdcall  mixerGetDevCapsA(UINT uMxId, LPMIXERCAPSA pmxcaps, UINT cbmxcaps);
 __declspec(dllimport)  MMRESULT  __stdcall  mixerGetDevCapsW(UINT uMxId, LPMIXERCAPSW pmxcaps, UINT cbmxcaps);
#line 1436 "C:\WATCOM\H\NT\mmsystem.h"

// !UNICODE

#line 1442 "C:\WATCOM\H\NT\mmsystem.h"

 __declspec(dllimport)  MMRESULT  __stdcall  mixerOpen(LPHMIXER phmx, UINT uMxId, DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);

 __declspec(dllimport)  MMRESULT  __stdcall  mixerClose(HMIXER hmx);

 __declspec(dllimport)  DWORD  __stdcall  mixerMessage(HMIXER hmx, UINT uMsg, DWORD dwParam1, DWORD dwParam2);



typedef struct tagMIXERLINEA {
    DWORD       cbStruct;               /* size of MIXERLINE structure */ 
    DWORD       dwDestination;          /* zero based destination index */ 
    DWORD       dwSource;               /* zero based source index (if source) */ 
    DWORD       dwLineID;               /* unique line id for mixer device */ 
    DWORD       fdwLine;                /* state/information about line */ 
    DWORD       dwUser;                 /* driver specific information */ 
    DWORD       dwComponentType;        /* component type line connects to */ 
    DWORD       cChannels;              /* number of channels line supports */ 
    DWORD       cConnections;           /* number of connections [possible] */ 
    DWORD       cControls;              /* number of controls at this line */ 
    CHAR        szShortName[ 16 ];
    CHAR        szName[ 64 ];
    struct {
	DWORD   dwType;                 /* MIXERLINE_TARGETTYPE_xxxx */ 
	DWORD   dwDeviceID;             /* target device ID of device type */ 
	WORD    wMid;                   /* of target device */ 
	WORD    wPid;                   /*      " */ 
	MMVERSION vDriverVersion;       /*      " */ 
	CHAR    szPname[ 32 ];   /*      " */ 
    } Target;
} MIXERLINEA, *PMIXERLINEA, *LPMIXERLINEA;
typedef struct tagMIXERLINEW {
    DWORD       cbStruct;               /* size of MIXERLINE structure */ 
    DWORD       dwDestination;          /* zero based destination index */ 
    DWORD       dwSource;               /* zero based source index (if source) */ 
    DWORD       dwLineID;               /* unique line id for mixer device */ 
    DWORD       fdwLine;                /* state/information about line */ 
    DWORD       dwUser;                 /* driver specific information */ 
    DWORD       dwComponentType;        /* component type line connects to */ 
    DWORD       cChannels;              /* number of channels line supports */ 
    DWORD       cConnections;           /* number of connections [possible] */ 
    DWORD       cControls;              /* number of controls at this line */ 
    WCHAR       szShortName[ 16 ];
    WCHAR       szName[ 64 ];
    struct {
	DWORD   dwType;                 /* MIXERLINE_TARGETTYPE_xxxx */ 
	DWORD   dwDeviceID;             /* target device ID of device type */ 
	WORD    wMid;                   /* of target device */ 
	WORD    wPid;                   /*      " */ 
	MMVERSION vDriverVersion;       /*      " */ 
	WCHAR   szPname[ 32 ];   /*      " */ 
    } Target;
} MIXERLINEW, *PMIXERLINEW, *LPMIXERLINEW;
#line 1500 "C:\WATCOM\H\NT\mmsystem.h"
typedef MIXERLINEA MIXERLINE;
typedef PMIXERLINEA PMIXERLINE;
typedef LPMIXERLINEA LPMIXERLINE;
// UNICODE

#line 1529 "C:\WATCOM\H\NT\mmsystem.h"

/* */
/*  MIXERLINE.fdwLine */
/* */
/* */




/* */
/*  MIXERLINE.dwComponentType */
/* */
/*  component types for destinations and sources */
/* */
/* */


























/* */
/*  MIXERLINE.Target.dwType */
/* */
/* */









 __declspec(dllimport)  MMRESULT  __stdcall  mixerGetLineInfoA(HMIXEROBJ hmxobj, LPMIXERLINEA pmxl, DWORD fdwInfo);
 __declspec(dllimport)  MMRESULT  __stdcall  mixerGetLineInfoW(HMIXEROBJ hmxobj, LPMIXERLINEW pmxl, DWORD fdwInfo);
#line 1588 "C:\WATCOM\H\NT\mmsystem.h"

// !UNICODE

#line 1594 "C:\WATCOM\H\NT\mmsystem.h"









 __declspec(dllimport)  MMRESULT  __stdcall  mixerGetID(HMIXEROBJ hmxobj, UINT    *puMxId, DWORD fdwId);

/* */
/*  MIXERCONTROL */
/* */
/* */


typedef struct tagMIXERCONTROLA {
    DWORD           cbStruct;           /* size in bytes of MIXERCONTROL */ 
    DWORD           dwControlID;        /* unique control id for mixer device */ 
    DWORD           dwControlType;      /* MIXERCONTROL_CONTROLTYPE_xxx */ 
    DWORD           fdwControl;         /* MIXERCONTROL_CONTROLF_xxx */ 
    DWORD           cMultipleItems;     /* if MIXERCONTROL_CONTROLF_MULTIPLE set */ 
    CHAR            szShortName[ 16 ];
    CHAR            szName[ 64 ];
    union {
	struct {
	    LONG    lMinimum;           /* signed minimum for this control */ 
	    LONG    lMaximum;           /* signed maximum for this control */ 
	};
	struct {
	    DWORD   dwMinimum;          /* unsigned minimum for this control */ 
	    DWORD   dwMaximum;          /* unsigned maximum for this control */ 
	};
	DWORD       dwReserved[6];
    } Bounds;
    union {
	DWORD       cSteps;             /* # of steps between min & max */ 
	DWORD       cbCustomData;       /* size in bytes of custom data */ 
	DWORD       dwReserved[6];      /* !!! needed? we have cbStruct.... */ 
    } Metrics;
} MIXERCONTROLA, *PMIXERCONTROLA, *LPMIXERCONTROLA;
typedef struct tagMIXERCONTROLW {
    DWORD           cbStruct;           /* size in bytes of MIXERCONTROL */ 
    DWORD           dwControlID;        /* unique control id for mixer device */ 
    DWORD           dwControlType;      /* MIXERCONTROL_CONTROLTYPE_xxx */ 
    DWORD           fdwControl;         /* MIXERCONTROL_CONTROLF_xxx */ 
    DWORD           cMultipleItems;     /* if MIXERCONTROL_CONTROLF_MULTIPLE set */ 
    WCHAR           szShortName[ 16 ];
    WCHAR           szName[ 64 ];
    union {
	struct {
	    LONG    lMinimum;           /* signed minimum for this control */ 
	    LONG    lMaximum;           /* signed maximum for this control */ 
	};
	struct {
	    DWORD   dwMinimum;          /* unsigned minimum for this control */ 
	    DWORD   dwMaximum;          /* unsigned maximum for this control */ 
	};
	DWORD       dwReserved[6];
    } Bounds;
    union {
	DWORD       cSteps;             /* # of steps between min & max */ 
	DWORD       cbCustomData;       /* size in bytes of custom data */ 
	DWORD       dwReserved[6];      /* !!! needed? we have cbStruct.... */ 
    } Metrics;
} MIXERCONTROLW, *PMIXERCONTROLW, *LPMIXERCONTROLW;
#line 1666 "C:\WATCOM\H\NT\mmsystem.h"
typedef MIXERCONTROLA MIXERCONTROL;
typedef PMIXERCONTROLA PMIXERCONTROL;
typedef LPMIXERCONTROLA LPMIXERCONTROL;
// UNICODE

#line 1698 "C:\WATCOM\H\NT\mmsystem.h"

/* */
/*  MIXERCONTROL.fdwControl */
/* */
/* */




/* */
/*  MIXERCONTROL_CONTROLTYPE_xxx building block defines */
/* */
/* */




























/* in 10ths */
/* in 10ths */

/* */
/*  Commonly used control types for specifying MIXERCONTROL.dwControlType */
/* */
































/* */
/*  MIXERLINECONTROLS */
/* */


typedef struct tagMIXERLINECONTROLSA {
    DWORD           cbStruct;       /* size in bytes of MIXERLINECONTROLS */ 
    DWORD           dwLineID;       /* line id (from MIXERLINE.dwLineID) */ 
    union {
	DWORD       dwControlID;    /* MIXER_GETLINECONTROLSF_ONEBYID */ 
	DWORD       dwControlType;  /* MIXER_GETLINECONTROLSF_ONEBYTYPE */ 
    };
    DWORD           cControls;      /* count of controls pmxctrl points to */ 
    DWORD           cbmxctrl;       /* size in bytes of _one_ MIXERCONTROL */ 
    LPMIXERCONTROLA pamxctrl;       /* pointer to first MIXERCONTROL array */ 
} MIXERLINECONTROLSA, *PMIXERLINECONTROLSA, *LPMIXERLINECONTROLSA;
typedef struct tagMIXERLINECONTROLSW {
    DWORD           cbStruct;       /* size in bytes of MIXERLINECONTROLS */ 
    DWORD           dwLineID;       /* line id (from MIXERLINE.dwLineID) */ 
    union {
	DWORD       dwControlID;    /* MIXER_GETLINECONTROLSF_ONEBYID */ 
	DWORD       dwControlType;  /* MIXER_GETLINECONTROLSF_ONEBYTYPE */ 
    };
    DWORD           cControls;      /* count of controls pmxctrl points to */ 
    DWORD           cbmxctrl;       /* size in bytes of _one_ MIXERCONTROL */ 
    LPMIXERCONTROLW pamxctrl;       /* pointer to first MIXERCONTROL array */ 
} MIXERLINECONTROLSW, *PMIXERLINECONTROLSW, *LPMIXERLINECONTROLSW;
#line 1809 "C:\WATCOM\H\NT\mmsystem.h"
typedef MIXERLINECONTROLSA MIXERLINECONTROLS;
typedef PMIXERLINECONTROLSA PMIXERLINECONTROLS;
typedef LPMIXERLINECONTROLSA LPMIXERLINECONTROLS;
// UNICODE

#line 1827 "C:\WATCOM\H\NT\mmsystem.h"

/* */
/* */
/* */


 __declspec(dllimport)  MMRESULT  __stdcall  mixerGetLineControlsA(HMIXEROBJ hmxobj, LPMIXERLINECONTROLSA pmxlc, DWORD fdwControls);
 __declspec(dllimport)  MMRESULT  __stdcall  mixerGetLineControlsW(HMIXEROBJ hmxobj, LPMIXERLINECONTROLSW pmxlc, DWORD fdwControls);
#line 1838 "C:\WATCOM\H\NT\mmsystem.h"

// !UNICODE

#line 1844 "C:\WATCOM\H\NT\mmsystem.h"







typedef struct tMIXERCONTROLDETAILS {
    DWORD           cbStruct;       /* size in bytes of MIXERCONTROLDETAILS */ 
    DWORD           dwControlID;    /* control id to get/set details on */ 
    DWORD           cChannels;      /* number of channels in paDetails array */ 
    union {
	HWND        hwndOwner;      /* for MIXER_SETCONTROLDETAILSF_CUSTOM */ 
	DWORD       cMultipleItems; /* if _MULTIPLE, the number of items per channel */ 
    };
    DWORD           cbDetails;      /* size of _one_ details_XX struct */ 
    LPVOID          paDetails;      /* pointer to array of details_XX structs */ 
} MIXERCONTROLDETAILS, *PMIXERCONTROLDETAILS,    *LPMIXERCONTROLDETAILS;

/* */
/*  MIXER_GETCONTROLDETAILSF_LISTTEXT */
/* */
/* */


typedef struct tagMIXERCONTROLDETAILS_LISTTEXTA {
    DWORD           dwParam1;
    DWORD           dwParam2;
    CHAR            szName[ 64 ];
} MIXERCONTROLDETAILS_LISTTEXTA, *PMIXERCONTROLDETAILS_LISTTEXTA, *LPMIXERCONTROLDETAILS_LISTTEXTA;
typedef struct tagMIXERCONTROLDETAILS_LISTTEXTW {
    DWORD           dwParam1;
    DWORD           dwParam2;
    WCHAR           szName[ 64 ];
} MIXERCONTROLDETAILS_LISTTEXTW, *PMIXERCONTROLDETAILS_LISTTEXTW, *LPMIXERCONTROLDETAILS_LISTTEXTW;
#line 1884 "C:\WATCOM\H\NT\mmsystem.h"
typedef MIXERCONTROLDETAILS_LISTTEXTA MIXERCONTROLDETAILS_LISTTEXT;
typedef PMIXERCONTROLDETAILS_LISTTEXTA PMIXERCONTROLDETAILS_LISTTEXT;
typedef LPMIXERCONTROLDETAILS_LISTTEXTA LPMIXERCONTROLDETAILS_LISTTEXT;
// UNICODE

#line 1896 "C:\WATCOM\H\NT\mmsystem.h"

/* */
/*  MIXER_GETCONTROLDETAILSF_VALUE */
/* */
/* */
typedef struct tMIXERCONTROLDETAILS_BOOLEAN {
    LONG            fValue;
}       MIXERCONTROLDETAILS_BOOLEAN,
      *PMIXERCONTROLDETAILS_BOOLEAN,
    *LPMIXERCONTROLDETAILS_BOOLEAN;

typedef struct tMIXERCONTROLDETAILS_SIGNED {
    LONG            lValue;
}       MIXERCONTROLDETAILS_SIGNED,
      *PMIXERCONTROLDETAILS_SIGNED,
    *LPMIXERCONTROLDETAILS_SIGNED;

typedef struct tMIXERCONTROLDETAILS_UNSIGNED {
    DWORD           dwValue;
}       MIXERCONTROLDETAILS_UNSIGNED,
      *PMIXERCONTROLDETAILS_UNSIGNED,
    *LPMIXERCONTROLDETAILS_UNSIGNED;



 __declspec(dllimport)  MMRESULT  __stdcall  mixerGetControlDetailsA(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails);
 __declspec(dllimport)  MMRESULT  __stdcall  mixerGetControlDetailsW(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails);
#line 1926 "C:\WATCOM\H\NT\mmsystem.h"

// !UNICODE

#line 1932 "C:\WATCOM\H\NT\mmsystem.h"






 __declspec(dllimport)  MMRESULT  __stdcall  mixerSetControlDetails(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails);






/* ifndef _WIN32_VXD */
/* ifndef MMNOMIXER */



/****************************************************************************

			    Timer support

****************************************************************************/

/* timer error return values */
/* no error */
/* request not completed */
/* time struct size */

/* timer data types */
typedef void ( __stdcall  TIMECALLBACK)(UINT uTimerID, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2);

typedef TIMECALLBACK    *LPTIMECALLBACK;

/* flags for fuEvent parameter of timeSetEvent() function */
/* program timer for single event */
/* program for continuous periodic event */


/* callback is function */
/* callback is event - use SetEvent */
/* callback is event - use PulseEvent */


/* timer device capabilities data structure */
typedef struct timecaps_tag {
    UINT    wPeriodMin;     /* minimum period supported  */ 
    UINT    wPeriodMax;     /* maximum period supported  */ 
} TIMECAPS, *PTIMECAPS,    *NPTIMECAPS,    *LPTIMECAPS;

/* timer function prototypes */
 __declspec(dllimport)  MMRESULT  __stdcall  timeGetSystemTime(LPMMTIME pmmt, UINT cbmmt);
 __declspec(dllimport)  DWORD  __stdcall  timeGetTime(void);
 __declspec(dllimport)  MMRESULT  __stdcall  timeSetEvent(UINT uDelay, UINT uResolution,
    LPTIMECALLBACK fptc, DWORD dwUser, UINT fuEvent);
 __declspec(dllimport)  MMRESULT  __stdcall  timeKillEvent(UINT uTimerID);
 __declspec(dllimport)  MMRESULT  __stdcall  timeGetDevCaps(LPTIMECAPS ptc, UINT cbtc);
 __declspec(dllimport)  MMRESULT  __stdcall  timeBeginPeriod(UINT uPeriod);
 __declspec(dllimport)  MMRESULT  __stdcall  timeEndPeriod(UINT uPeriod);

/* ifndef _WIN32_VXD */
/* ifndef MMNOTIMER */


/****************************************************************************

			    Joystick support

****************************************************************************/

/* joystick error return values */
/* no error */
/* bad parameters */
/* request not completed */
/* joystick is unplugged */

/* constants used with JOYINFO and JOYINFOEX structures and MM_JOY* messages */









/* constants used with JOYINFOEX */





























/* constants used with JOYINFOEX structure */










/* axis 5 */
/* axis 6 */






















/* joystick ID constants */



/* joystick driver capabilites */








/* joystick device capabilities data structure */


typedef struct tagJOYCAPSA {
    WORD    wMid;                /* manufacturer ID */ 
    WORD    wPid;                /* product ID */ 
    CHAR    szPname[ 32 ];/* product name (NULL terminated string) */ 
    UINT    wXmin;               /* minimum x position value */ 
    UINT    wXmax;               /* maximum x position value */ 
    UINT    wYmin;               /* minimum y position value */ 
    UINT    wYmax;               /* maximum y position value */ 
    UINT    wZmin;               /* minimum z position value */ 
    UINT    wZmax;               /* maximum z position value */ 
    UINT    wNumButtons;         /* number of buttons */ 
    UINT    wPeriodMin;          /* minimum message period when captured */ 
    UINT    wPeriodMax;          /* maximum message period when captured */ 
 
    UINT    wRmin;               /* minimum r position value */ 
    UINT    wRmax;               /* maximum r position value */ 
    UINT    wUmin;               /* minimum u (5th axis) position value */ 
    UINT    wUmax;               /* maximum u (5th axis) position value */ 
    UINT    wVmin;               /* minimum v (6th axis) position value */ 
    UINT    wVmax;               /* maximum v (6th axis) position value */ 
    UINT    wCaps;	 	 /* joystick capabilites */ 
    UINT    wMaxAxes;	 	 /* maximum number of axes supported */ 
    UINT    wNumAxes;	 	 /* number of axes in use */ 
    UINT    wMaxButtons;	 /* maximum number of buttons supported */ 
    CHAR    szRegKey[ 32 ];/* registry key */ 
    CHAR    szOEMVxD[ 260 ]; /* OEM VxD in use */ 

} JOYCAPSA, *PJOYCAPSA, *NPJOYCAPSA, *LPJOYCAPSA;
typedef struct tagJOYCAPSW {
    WORD    wMid;                /* manufacturer ID */ 
    WORD    wPid;                /* product ID */ 
    WCHAR   szPname[ 32 ];/* product name (NULL terminated string) */ 
    UINT    wXmin;               /* minimum x position value */ 
    UINT    wXmax;               /* maximum x position value */ 
    UINT    wYmin;               /* minimum y position value */ 
    UINT    wYmax;               /* maximum y position value */ 
    UINT    wZmin;               /* minimum z position value */ 
    UINT    wZmax;               /* maximum z position value */ 
    UINT    wNumButtons;         /* number of buttons */ 
    UINT    wPeriodMin;          /* minimum message period when captured */ 
    UINT    wPeriodMax;          /* maximum message period when captured */ 
 
    UINT    wRmin;               /* minimum r position value */ 
    UINT    wRmax;               /* maximum r position value */ 
    UINT    wUmin;               /* minimum u (5th axis) position value */ 
    UINT    wUmax;               /* maximum u (5th axis) position value */ 
    UINT    wVmin;               /* minimum v (6th axis) position value */ 
    UINT    wVmax;               /* maximum v (6th axis) position value */ 
    UINT    wCaps;	 	 /* joystick capabilites */ 
    UINT    wMaxAxes;	 	 /* maximum number of axes supported */ 
    UINT    wNumAxes;	 	 /* number of axes in use */ 
    UINT    wMaxButtons;	 /* maximum number of buttons supported */ 
    WCHAR   szRegKey[ 32 ];/* registry key */ 
    WCHAR   szOEMVxD[ 260 ]; /* OEM VxD in use */ 

} JOYCAPSW, *PJOYCAPSW, *NPJOYCAPSW, *LPJOYCAPSW;
#line 2161 "C:\WATCOM\H\NT\mmsystem.h"
typedef JOYCAPSA JOYCAPS;
typedef PJOYCAPSA PJOYCAPS;
typedef NPJOYCAPSA NPJOYCAPS;
typedef LPJOYCAPSA LPJOYCAPS;
// UNICODE

#line 2197 "C:\WATCOM\H\NT\mmsystem.h"

/* joystick information data structure */
typedef struct joyinfo_tag {
    UINT wXpos;                 /* x position */ 
    UINT wYpos;                 /* y position */ 
    UINT wZpos;                 /* z position */ 
    UINT wButtons;              /* button states */ 
} JOYINFO, *PJOYINFO,    *NPJOYINFO,    *LPJOYINFO;

 
typedef struct joyinfoex_tag {
    DWORD dwSize;		 /* size of structure */ 
    DWORD dwFlags;		 /* flags to indicate what to return */ 
    DWORD dwXpos;                /* x position */ 
    DWORD dwYpos;                /* y position */ 
    DWORD dwZpos;                /* z position */ 
    DWORD dwRpos;		 /* rudder/4th axis position */ 
    DWORD dwUpos;		 /* 5th axis position */ 
    DWORD dwVpos;		 /* 6th axis position */ 
    DWORD dwButtons;             /* button states */ 
    DWORD dwButtonNumber;        /* current button number pressed */ 
    DWORD dwPOV;                 /* point of view state */ 
    DWORD dwReserved1;		 /* reserved for communication between winmm & driver */ 
    DWORD dwReserved2;		 /* reserved for future expansion */ 
} JOYINFOEX, *PJOYINFOEX,    *NPJOYINFOEX,    *LPJOYINFOEX;
/* WINVER >= 0x0400 */



/* joystick function prototypes */
 __declspec(dllimport)  UINT  __stdcall  joyGetNumDevs(void);


 __declspec(dllimport)  MMRESULT  __stdcall  joyGetDevCapsA(UINT uJoyID, LPJOYCAPSA pjc, UINT cbjc);
 __declspec(dllimport)  MMRESULT  __stdcall  joyGetDevCapsW(UINT uJoyID, LPJOYCAPSW pjc, UINT cbjc);
#line 2235 "C:\WATCOM\H\NT\mmsystem.h"

// !UNICODE

#line 2241 "C:\WATCOM\H\NT\mmsystem.h"
 __declspec(dllimport)  MMRESULT  __stdcall  joyGetPos(UINT uJoyID, LPJOYINFO pji);

 
 __declspec(dllimport)  MMRESULT  __stdcall  joyGetPosEx(UINT uJoyID, LPJOYINFOEX pji);
/* WINVER >= 0x0400 */

 __declspec(dllimport)  MMRESULT  __stdcall  joyGetThreshold(UINT uJoyID, LPUINT puThreshold);
 __declspec(dllimport)  MMRESULT  __stdcall  joyReleaseCapture(UINT uJoyID);
 __declspec(dllimport)  MMRESULT  __stdcall  joySetCapture(HWND hwnd, UINT uJoyID, UINT uPeriod,
    BOOL fChanged);
 __declspec(dllimport)  MMRESULT  __stdcall  joySetThreshold(UINT uJoyID, UINT uThreshold);

/* ifndef _WIN32_VXD */

/* ifndef MMNOJOY */



/****************************************************************************

			Multimedia File I/O support

****************************************************************************/

/* MMIO error return values */

/* file not found */
/* out of memory */
/* cannot open */
/* cannot close */
/* cannot read */
/* cannot write */
/* cannot seek */
/* cannot expand file */
/* chunk not found */
/*  */
/* path incorrect */
/* file was protected */
/* file in use */
/* network not responding */
/* no more file handles  */
/* default error file error */

/* MMIO constants */
/* compound file name separator char. */

/* MMIO data types */
typedef DWORD           FOURCC;         /* a four character code */ 
typedef char    *    HPSTR;          /* a huge version of LPSTR */ 
 typedef HANDLE HMMIO ;                  /* a handle to an open file */ 
typedef LRESULT ( __stdcall  MMIOPROC)(LPSTR lpmmioinfo, UINT uMsg,
	    LPARAM lParam1, LPARAM lParam2);
typedef MMIOPROC    *LPMMIOPROC;

/* general MMIO information data structure */
typedef struct _MMIOINFO
{
	/* general fields */
	DWORD           dwFlags;        /* general status flags */ 
	FOURCC          fccIOProc;      /* pointer to I/O procedure */ 
	LPMMIOPROC      pIOProc;        /* pointer to I/O procedure */ 
	UINT            wErrorRet;      /* place for error to be returned */ 
	HTASK           htask;          /* alternate local task */ 

	/* fields maintained by MMIO functions during buffered I/O */
	LONG            cchBuffer;      /* size of I/O buffer (or 0L) */ 
	HPSTR           pchBuffer;      /* start of I/O buffer (or NULL) */ 
	HPSTR           pchNext;        /* pointer to next byte to read/write */ 
	HPSTR           pchEndRead;     /* pointer to last valid byte to read */ 
	HPSTR           pchEndWrite;    /* pointer to last byte to write */ 
	LONG            lBufOffset;     /* disk offset of start of buffer */ 

	/* fields maintained by I/O procedure */
	LONG            lDiskOffset;    /* disk offset of next read or write */ 
	DWORD           adwInfo[3];     /* data specific to type of MMIOPROC */ 

	/* other fields maintained by MMIO */
	DWORD           dwReserved1;    /* reserved for MMIO use */ 
	DWORD           dwReserved2;    /* reserved for MMIO use */ 
	HMMIO           hmmio;          /* handle to open file */ 
} MMIOINFO, *PMMIOINFO,    *NPMMIOINFO,    *LPMMIOINFO;
typedef const MMIOINFO    *LPCMMIOINFO;

/* RIFF chunk information data structure */
typedef struct _MMCKINFO
{
	FOURCC          ckid;           /* chunk ID */ 
	DWORD           cksize;         /* chunk size */ 
	FOURCC          fccType;        /* form type or list type */ 
	DWORD           dwDataOffset;   /* offset of data portion of chunk */ 
	DWORD           dwFlags;        /* flags used by MMIO functions */ 
} MMCKINFO, *PMMCKINFO,    *NPMMCKINFO,    *LPMMCKINFO;
typedef const MMCKINFO *LPCMMCKINFO;

/* bit field masks */
/* open file for reading/writing/both */
/* file sharing mode number */

/* constants for dwFlags field of MMIOINFO */
/* create new file (or truncate file) */
/* parse new file returning path */
/* create new file (or truncate file) */
/* checks for existence of file */
/* mmioOpen() should allocate a buffer */
/* mmioOpen() should retrieve temp name */

/* I/O buffer is dirty */

/* read/write mode numbers (bit field MMIO_RWMODE) */
/* open file for reading only */
/* open file for writing only */
/* open file for reading and writing */

/* share mode numbers (bit field MMIO_SHAREMODE) */
/* compatibility mode */
/* exclusive-access mode */
/* deny writing to other processes */
/* deny reading to other processes */
/* deny nothing to other processes */

/* various MMIO flags */
/* mmioClose: keep file handle open */
/* mmioFlush: empty the I/O buffer */
/* mmioStringToFOURCC: to u-case */
/* mmioInstallIOProc: install MMIOProc */
/* mmioInstallIOProc: install globally */
/* mmioInstallIOProc: remove MMIOProc */
/* mmioInstallIOProc: Unicode MMIOProc */
/* mmioInstallIOProc: find an MMIOProc */
/* mmioDescend: find a chunk by ID */
/* mmioDescend: find a LIST chunk */
/* mmioDescend: find a RIFF chunk */
/* mmioCreateChunk: make a LIST chunk */
/* mmioCreateChunk: make a RIFF chunk */

/* message numbers for MMIOPROC I/O procedure functions */
/* read */
/* write */
/* seek to a new position in file */
/* open file */
/* close file */
/* write and flush */

 
/* rename specified file */
/* ifdef WINVER >= 0x030a */

/* beginning of user-defined messages */

/* standard four character codes */



/* four character codes used to identify standard built-in I/O procedures */



/* flags for mmioSeek() */

/* seek to an absolute position */
/* seek relative to current position */
/* seek relative to end of file */
/* ifndef SEEK_SET */

/* other constants */
/* default buffer size */

/* MMIO macros */


/* MMIO function prototypes */


 __declspec(dllimport)  FOURCC  __stdcall  mmioStringToFOURCCA(LPCSTR sz, UINT uFlags);
 __declspec(dllimport)  FOURCC  __stdcall  mmioStringToFOURCCW(LPCWSTR sz, UINT uFlags);
#line 2419 "C:\WATCOM\H\NT\mmsystem.h"

// !UNICODE
 __declspec(dllimport)  LPMMIOPROC  __stdcall  mmioInstallIOProcA(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);
 __declspec(dllimport)  LPMMIOPROC  __stdcall  mmioInstallIOProcW(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);
#line 2426 "C:\WATCOM\H\NT\mmsystem.h"

// !UNICODE
 __declspec(dllimport)  HMMIO  __stdcall  mmioOpenA(LPSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen);
 __declspec(dllimport)  HMMIO  __stdcall  mmioOpenW(LPWSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen);
#line 2433 "C:\WATCOM\H\NT\mmsystem.h"

// !UNICODE
 __declspec(dllimport)  MMRESULT  __stdcall  mmioRenameA(LPCSTR pszFileName, LPCSTR pszNewFileName, LPCMMIOINFO pmmioinfo, DWORD fdwRename);
 __declspec(dllimport)  MMRESULT  __stdcall  mmioRenameW(LPCWSTR pszFileName, LPCWSTR pszNewFileName, LPCMMIOINFO pmmioinfo, DWORD fdwRename);
#line 2440 "C:\WATCOM\H\NT\mmsystem.h"

// !UNICODE
#line 2450 "C:\WATCOM\H\NT\mmsystem.h"

 __declspec(dllimport)  MMRESULT  __stdcall  mmioClose(HMMIO hmmio, UINT fuClose);
 __declspec(dllimport)  LONG  __stdcall  mmioRead(HMMIO hmmio, HPSTR pch, LONG cch);
 __declspec(dllimport)  LONG  __stdcall  mmioWrite(HMMIO hmmio, const char   * pch, LONG cch);
 __declspec(dllimport)  LONG  __stdcall  mmioSeek(HMMIO hmmio, LONG lOffset, int iOrigin);
 __declspec(dllimport)  MMRESULT  __stdcall  mmioGetInfo(HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuInfo);
 __declspec(dllimport)  MMRESULT  __stdcall  mmioSetInfo(HMMIO hmmio, LPCMMIOINFO pmmioinfo, UINT fuInfo);
 __declspec(dllimport)  MMRESULT  __stdcall  mmioSetBuffer(HMMIO hmmio, LPSTR pchBuffer, LONG cchBuffer,
    UINT fuBuffer);
 __declspec(dllimport)  MMRESULT  __stdcall  mmioFlush(HMMIO hmmio, UINT fuFlush);
 __declspec(dllimport)  MMRESULT  __stdcall  mmioAdvance(HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuAdvance);
 __declspec(dllimport)  LRESULT  __stdcall  mmioSendMessage(HMMIO hmmio, UINT uMsg,
    LPARAM lParam1, LPARAM lParam2);
 __declspec(dllimport)  MMRESULT  __stdcall  mmioDescend(HMMIO hmmio, LPMMCKINFO pmmcki,
    const MMCKINFO   * pmmckiParent, UINT fuDescend);
 __declspec(dllimport)  MMRESULT  __stdcall  mmioAscend(HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuAscend);
 __declspec(dllimport)  MMRESULT  __stdcall  mmioCreateChunk(HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuCreate);

/* ifndef _WIN32_VXD */
/* ifndef MMNOMMIO */



/****************************************************************************

			    MCI support

****************************************************************************/

/* MCIERROR is defined in some post 3.1 apps */

typedef DWORD   MCIERROR;       /* error return code, 0 means no error */ 


/* Same with MCIDEVICEID */

typedef UINT    MCIDEVICEID;    /* MCI device ID type */ 


typedef UINT ( __stdcall  *YIELDPROC)(MCIDEVICEID mciId, DWORD dwYieldData);

/* MCI function prototypes */


 __declspec(dllimport)  MCIERROR  __stdcall  mciSendCommandA(MCIDEVICEID mciId, UINT uMsg, DWORD dwParam1, DWORD dwParam2);
 __declspec(dllimport)  MCIERROR  __stdcall  mciSendCommandW(MCIDEVICEID mciId, UINT uMsg, DWORD dwParam1, DWORD dwParam2);
#line 2499 "C:\WATCOM\H\NT\mmsystem.h"

// !UNICODE
 __declspec(dllimport)  MCIERROR   __stdcall  mciSendStringA(LPCSTR lpstrCommand, LPSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);
 __declspec(dllimport)  MCIERROR   __stdcall  mciSendStringW(LPCWSTR lpstrCommand, LPWSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);
#line 2506 "C:\WATCOM\H\NT\mmsystem.h"

// !UNICODE
 __declspec(dllimport)  MCIDEVICEID  __stdcall  mciGetDeviceIDA(LPCSTR pszDevice);
 __declspec(dllimport)  MCIDEVICEID  __stdcall  mciGetDeviceIDW(LPCWSTR pszDevice);
#line 2513 "C:\WATCOM\H\NT\mmsystem.h"

// !UNICODE
 __declspec(dllimport)  MCIDEVICEID  __stdcall  mciGetDeviceIDFromElementIDA(DWORD dwElementID, LPCSTR lpstrType );
 __declspec(dllimport)  MCIDEVICEID  __stdcall  mciGetDeviceIDFromElementIDW(DWORD dwElementID, LPCWSTR lpstrType );
#line 2520 "C:\WATCOM\H\NT\mmsystem.h"

// !UNICODE
 __declspec(dllimport)  BOOL  __stdcall  mciGetErrorStringA(MCIERROR mcierr, LPSTR pszText, UINT cchText);
 __declspec(dllimport)  BOOL  __stdcall  mciGetErrorStringW(MCIERROR mcierr, LPWSTR pszText, UINT cchText);
#line 2527 "C:\WATCOM\H\NT\mmsystem.h"

// !UNICODE

#line 2536 "C:\WATCOM\H\NT\mmsystem.h"

 __declspec(dllimport)  BOOL  __stdcall  mciSetYieldProc(MCIDEVICEID mciId, YIELDPROC fpYieldProc,
    DWORD dwYieldData);

 
 __declspec(dllimport)  HTASK  __stdcall  mciGetCreatorTask(MCIDEVICEID mciId);
 __declspec(dllimport)  YIELDPROC  __stdcall  mciGetYieldProc(MCIDEVICEID mciId, LPDWORD pdwYieldData);
/* ifdef WINVER >= 0x030a */

 /* ifdef WINVER < 0x030a */#line 2548 "C:\WATCOM\H\NT\mmsystem.h"

/* MCI error return values */
















































































/* all custom device driver errors must be >= than this value */


/* 0x0800 */
/* MCI command message identifiers */
































/* all custom MCI command messages must be >= than this value */



/* device ID for "all devices" */


/* constants for predefined MCI device types */
/* (MCI_STRING_OFFSET + 1) */
/* (MCI_STRING_OFFSET + 2) */
/* (MCI_STRING_OFFSET + 3) */
/* (MCI_STRING_OFFSET + 4) */
/* (MCI_STRING_OFFSET + 5) */
/* (MCI_STRING_OFFSET + 6) */
/* (MCI_STRING_OFFSET + 7) */
/* (MCI_STRING_OFFSET + 8) */
/* (MCI_STRING_OFFSET + 9) */
/* (MCI_STRING_OFFSET + 10) */
/* (MCI_STRING_OFFSET + 11) */





/* return values for 'status mode' command */








/* constants used in 'set time format' and 'status time format' commands */












/* MCI time format conversion macros */


























/* flags for wParam of MM_MCINOTIFY message */





/* common flags for dwFlags parameter of MCI command messages */






/* flags for dwFlags parameter of MCI_OPEN command message */







/* flags for dwFlags parameter of MCI_SEEK command message */



/* flags for dwFlags parameter of MCI_STATUS command message */



/* flags for dwItem field of the MCI_STATUS_PARMS parameter block */









/* flags for dwFlags parameter of MCI_INFO command message */







/* flags for dwFlags parameter of MCI_GETDEVCAPS command message */


/* flags for dwItem field of the MCI_GETDEVCAPS_PARMS parameter block */










/* flags for dwFlags parameter of MCI_SYSINFO command message */





/* flags for dwFlags parameter of MCI_SET command message */








/* flags for dwAudio field of MCI_SET_PARMS or MCI_SEQ_SET_PARMS */




/* flags for dwFlags parameter of MCI_BREAK command message */




/* flags for dwFlags parameter of MCI_RECORD command message */



/* flags for dwFlags parameter of MCI_SAVE command message */


/* flags for dwFlags parameter of MCI_LOAD command message */


/* generic parameter block for MCI command messages with no special parameters */
typedef struct tagMCI_GENERIC_PARMS {
    DWORD   dwCallback;
} MCI_GENERIC_PARMS, *PMCI_GENERIC_PARMS,    *LPMCI_GENERIC_PARMS;

/* parameter block for MCI_OPEN command message */


typedef struct tagMCI_OPEN_PARMSA {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCSTR     lpstrDeviceType;
    LPCSTR     lpstrElementName;
    LPCSTR     lpstrAlias;
} MCI_OPEN_PARMSA, *PMCI_OPEN_PARMSA, *LPMCI_OPEN_PARMSA;
typedef struct tagMCI_OPEN_PARMSW {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCWSTR    lpstrDeviceType;
    LPCWSTR    lpstrElementName;
    LPCWSTR    lpstrAlias;
} MCI_OPEN_PARMSW, *PMCI_OPEN_PARMSW, *LPMCI_OPEN_PARMSW;
#line 2863 "C:\WATCOM\H\NT\mmsystem.h"
typedef MCI_OPEN_PARMSA MCI_OPEN_PARMS;
typedef PMCI_OPEN_PARMSA PMCI_OPEN_PARMS;
typedef LPMCI_OPEN_PARMSA LPMCI_OPEN_PARMS;
// UNICODE

#line 2878 "C:\WATCOM\H\NT\mmsystem.h"

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_PLAY_PARMS, *PMCI_PLAY_PARMS,    *LPMCI_PLAY_PARMS;

/* parameter block for MCI_SEEK command message */
typedef struct tagMCI_SEEK_PARMS {
    DWORD   dwCallback;
    DWORD   dwTo;
} MCI_SEEK_PARMS, *PMCI_SEEK_PARMS,    *LPMCI_SEEK_PARMS;

/* parameter block for MCI_STATUS command message */
typedef struct tagMCI_STATUS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
} MCI_STATUS_PARMS, *PMCI_STATUS_PARMS,    * LPMCI_STATUS_PARMS;

/* parameter block for MCI_INFO command message */


typedef struct tagMCI_INFO_PARMSA {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMSA, * LPMCI_INFO_PARMSA;
typedef struct tagMCI_INFO_PARMSW {
    DWORD   dwCallback;
    LPWSTR  lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMSW, * LPMCI_INFO_PARMSW;
#line 2917 "C:\WATCOM\H\NT\mmsystem.h"
typedef MCI_INFO_PARMSA MCI_INFO_PARMS;
typedef LPMCI_INFO_PARMSA LPMCI_INFO_PARMS;
// UNICODE

#line 2928 "C:\WATCOM\H\NT\mmsystem.h"

/* parameter block for MCI_GETDEVCAPS command message */
typedef struct tagMCI_GETDEVCAPS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
} MCI_GETDEVCAPS_PARMS, *PMCI_GETDEVCAPS_PARMS,    * LPMCI_GETDEVCAPS_PARMS;

/* parameter block for MCI_SYSINFO command message */


typedef struct tagMCI_SYSINFO_PARMSA {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    UINT    wDeviceType;
} MCI_SYSINFO_PARMSA, *PMCI_SYSINFO_PARMSA, * LPMCI_SYSINFO_PARMSA;
typedef struct tagMCI_SYSINFO_PARMSW {
    DWORD   dwCallback;
    LPWSTR  lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    UINT    wDeviceType;
} MCI_SYSINFO_PARMSW, *PMCI_SYSINFO_PARMSW, * LPMCI_SYSINFO_PARMSW;
#line 2958 "C:\WATCOM\H\NT\mmsystem.h"
typedef MCI_SYSINFO_PARMSA MCI_SYSINFO_PARMS;
typedef PMCI_SYSINFO_PARMSA PMCI_SYSINFO_PARMS;
typedef LPMCI_SYSINFO_PARMSA LPMCI_SYSINFO_PARMS;
// UNICODE
#line 2972 "C:\WATCOM\H\NT\mmsystem.h"

/* parameter block for MCI_SET command message */
typedef struct tagMCI_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
} MCI_SET_PARMS, *PMCI_SET_PARMS,    *LPMCI_SET_PARMS;

/* parameter block for MCI_BREAK command message */
typedef struct tagMCI_BREAK_PARMS {
    DWORD   dwCallback;

    int     nVirtKey;
    HWND    hwndBreak;
#line 2992 "C:\WATCOM\H\NT\mmsystem.h"
} MCI_BREAK_PARMS, *PMCI_BREAK_PARMS,    * LPMCI_BREAK_PARMS;

/* parameter block for MCI_SAVE command message */


typedef struct tagMCI_SAVE_PARMSA {
    DWORD    dwCallback;
    LPCSTR    lpfilename;
} MCI_SAVE_PARMSA, *PMCI_SAVE_PARMSA, * LPMCI_SAVE_PARMSA;
typedef struct tagMCI_SAVE_PARMSW {
    DWORD    dwCallback;
    LPCWSTR   lpfilename;
} MCI_SAVE_PARMSW, *PMCI_SAVE_PARMSW, * LPMCI_SAVE_PARMSW;
#line 3010 "C:\WATCOM\H\NT\mmsystem.h"
typedef MCI_SAVE_PARMSA MCI_SAVE_PARMS;
typedef PMCI_SAVE_PARMSA PMCI_SAVE_PARMS;
typedef LPMCI_SAVE_PARMSA LPMCI_SAVE_PARMS;
// UNICODE

#line 3021 "C:\WATCOM\H\NT\mmsystem.h"

/* parameter block for MCI_LOAD command message */


typedef struct tagMCI_LOAD_PARMSA {
    DWORD    dwCallback;
    LPCSTR      lpfilename;
} MCI_LOAD_PARMSA, *PMCI_LOAD_PARMSA, * LPMCI_LOAD_PARMSA;
typedef struct tagMCI_LOAD_PARMSW {
    DWORD    dwCallback;
    LPCWSTR     lpfilename;
} MCI_LOAD_PARMSW, *PMCI_LOAD_PARMSW, * LPMCI_LOAD_PARMSW;
#line 3038 "C:\WATCOM\H\NT\mmsystem.h"
typedef MCI_LOAD_PARMSA MCI_LOAD_PARMS;
typedef PMCI_LOAD_PARMSA PMCI_LOAD_PARMS;
typedef LPMCI_LOAD_PARMSA LPMCI_LOAD_PARMS;
// UNICODE

#line 3049 "C:\WATCOM\H\NT\mmsystem.h"

/* parameter block for MCI_RECORD command message */
typedef struct tagMCI_RECORD_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_RECORD_PARMS,    *LPMCI_RECORD_PARMS;

/* MCI extensions for videodisc devices */

/* flag for dwReturn field of MCI_STATUS_PARMS */
/* MCI_STATUS command, (dwItem == MCI_STATUS_MODE) */


/* flag for dwReturn field of MCI_STATUS_PARMS */
/* MCI_STATUS command, (dwItem == MCI_VD_STATUS_MEDIA_TYPE) */






/* flags for dwFlags parameter of MCI_PLAY command message */






/* flag for dwFlags parameter of MCI_SEEK command message */


/* flags for dwItem field of MCI_STATUS_PARMS parameter block */






/* flags for dwFlags parameter of MCI_GETDEVCAPS command message */






/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */





/* flags for the dwFlags parameter of MCI_STEP command message */



/* flag for the MCI_ESCAPE command message */


/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_VD_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_VD_PLAY_PARMS, *PMCI_VD_PLAY_PARMS,    *LPMCI_VD_PLAY_PARMS;

/* parameter block for MCI_STEP command message */
typedef struct tagMCI_VD_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_VD_STEP_PARMS, *PMCI_VD_STEP_PARMS,    *LPMCI_VD_STEP_PARMS;

/* parameter block for MCI_ESCAPE command message */


typedef struct tagMCI_VD_ESCAPE_PARMSA {
    DWORD   dwCallback;
    LPCSTR      lpstrCommand;
} MCI_VD_ESCAPE_PARMSA, *PMCI_VD_ESCAPE_PARMSA, *LPMCI_VD_ESCAPE_PARMSA;
typedef struct tagMCI_VD_ESCAPE_PARMSW {
    DWORD   dwCallback;
    LPCWSTR     lpstrCommand;
} MCI_VD_ESCAPE_PARMSW, *PMCI_VD_ESCAPE_PARMSW, *LPMCI_VD_ESCAPE_PARMSW;
#line 3138 "C:\WATCOM\H\NT\mmsystem.h"
typedef MCI_VD_ESCAPE_PARMSA MCI_VD_ESCAPE_PARMS;
typedef PMCI_VD_ESCAPE_PARMSA PMCI_VD_ESCAPE_PARMS;
typedef LPMCI_VD_ESCAPE_PARMSA LPMCI_VD_ESCAPE_PARMS;
// UNICODE

#line 3149 "C:\WATCOM\H\NT\mmsystem.h"

/* MCI extensions for CD audio devices */

/* flags for the dwItem field of the MCI_STATUS_PARMS parameter block */


/* flags for the dwReturn field of MCI_STATUS_PARMS parameter block */
/* MCI_STATUS command, (dwItem == MCI_CDA_STATUS_TYPE_TRACK) */



/* MCI extensions for waveform audio devices */




/* flags for the dwFlags parameter of MCI_OPEN command message */


/* flags for the dwFlags parameter of MCI_SET command message */







/* flags for the dwFlags parameter of MCI_STATUS, MCI_SET command messages */



/* flags for the dwItem field of MCI_STATUS_PARMS parameter block */








/* flags for the dwFlags parameter of MCI_SET command message */



/* flags for the dwFlags parameter of MCI_GETDEVCAPS command message */



/* parameter block for MCI_OPEN command message */


typedef struct tagMCI_WAVE_OPEN_PARMSA {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD   dwBufferSeconds;
} MCI_WAVE_OPEN_PARMSA, *PMCI_WAVE_OPEN_PARMSA, *LPMCI_WAVE_OPEN_PARMSA;
typedef struct tagMCI_WAVE_OPEN_PARMSW {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCWSTR     lpstrDeviceType;
    LPCWSTR     lpstrElementName;
    LPCWSTR     lpstrAlias;
    DWORD   dwBufferSeconds;
} MCI_WAVE_OPEN_PARMSW, *PMCI_WAVE_OPEN_PARMSW, *LPMCI_WAVE_OPEN_PARMSW;
#line 3221 "C:\WATCOM\H\NT\mmsystem.h"
typedef MCI_WAVE_OPEN_PARMSA MCI_WAVE_OPEN_PARMS;
typedef PMCI_WAVE_OPEN_PARMSA PMCI_WAVE_OPEN_PARMS;
typedef LPMCI_WAVE_OPEN_PARMSA LPMCI_WAVE_OPEN_PARMS;
// UNICODE

#line 3237 "C:\WATCOM\H\NT\mmsystem.h"

/* parameter block for MCI_DELETE command message */
typedef struct tagMCI_WAVE_DELETE_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_WAVE_DELETE_PARMS, *PMCI_WAVE_DELETE_PARMS,    *LPMCI_WAVE_DELETE_PARMS;

/* parameter block for MCI_SET command message */
typedef struct tagMCI_WAVE_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;

    UINT    wInput;
    UINT    wOutput;
#line 3259 "C:\WATCOM\H\NT\mmsystem.h"
    WORD    wFormatTag;
    WORD    wReserved2;
    WORD    nChannels;
    WORD    wReserved3;
    DWORD   nSamplesPerSec;
    DWORD   nAvgBytesPerSec;
    WORD    nBlockAlign;
    WORD    wReserved4;
    WORD    wBitsPerSample;
    WORD    wReserved5;
} MCI_WAVE_SET_PARMS, *PMCI_WAVE_SET_PARMS,    * LPMCI_WAVE_SET_PARMS;

/* MCI extensions for MIDI sequencer devices */

/* flags for the dwReturn field of MCI_STATUS_PARMS parameter block */
/* MCI_STATUS command, (dwItem == MCI_SEQ_STATUS_DIVTYPE) */






/* flags for the dwMaster field of MCI_SEQ_SET_PARMS parameter block */
/* MCI_SET command, (dwFlags == MCI_SEQ_SET_MASTER) */







/* flags for the dwItem field of MCI_STATUS_PARMS parameter block */









/* flags for the dwFlags parameter of MCI_SET command message */






/* parameter block for MCI_SET command message */
typedef struct tagMCI_SEQ_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    DWORD   dwTempo;
    DWORD   dwPort;
    DWORD   dwSlave;
    DWORD   dwMaster;
    DWORD   dwOffset;
} MCI_SEQ_SET_PARMS, *PMCI_SEQ_SET_PARMS,    * LPMCI_SEQ_SET_PARMS;

/* MCI extensions for animation devices */

/* flags for dwFlags parameter of MCI_OPEN command message */




/* flags for dwFlags parameter of MCI_PLAY command message */






/* flags for dwFlags parameter of MCI_STEP command message */



/* flags for dwItem field of MCI_STATUS_PARMS parameter block */






/* flags for the dwFlags parameter of MCI_INFO command message */


/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */








/* flags for the MCI_REALIZE command message */



/* flags for dwFlags parameter of MCI_WINDOW command message */






/* flags for hWnd field of MCI_ANIM_WINDOW_PARMS parameter block */
/* MCI_WINDOW command message, (dwFlags == MCI_ANIM_WINDOW_HWND) */


/* flags for dwFlags parameter of MCI_PUT command message */




/* flags for dwFlags parameter of MCI_WHERE command message */



/* flags for dwFlags parameter of MCI_UPDATE command message */


/* parameter block for MCI_OPEN command message */


typedef struct tagMCI_ANIM_OPEN_PARMSA {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_ANIM_OPEN_PARMSA, *PMCI_ANIM_OPEN_PARMSA, *LPMCI_ANIM_OPEN_PARMSA;
typedef struct tagMCI_ANIM_OPEN_PARMSW {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCWSTR     lpstrDeviceType;
    LPCWSTR     lpstrElementName;
    LPCWSTR     lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_ANIM_OPEN_PARMSW, *PMCI_ANIM_OPEN_PARMSW, *LPMCI_ANIM_OPEN_PARMSW;
#line 3409 "C:\WATCOM\H\NT\mmsystem.h"
typedef MCI_ANIM_OPEN_PARMSA MCI_ANIM_OPEN_PARMS;
typedef PMCI_ANIM_OPEN_PARMSA PMCI_ANIM_OPEN_PARMS;
typedef LPMCI_ANIM_OPEN_PARMSA LPMCI_ANIM_OPEN_PARMS;
// UNICODE

#line 3427 "C:\WATCOM\H\NT\mmsystem.h"

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_ANIM_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_ANIM_PLAY_PARMS, *PMCI_ANIM_PLAY_PARMS,    *LPMCI_ANIM_PLAY_PARMS;

/* parameter block for MCI_STEP command message */
typedef struct tagMCI_ANIM_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_ANIM_STEP_PARMS, *PMCI_ANIM_STEP_PARMS,    *LPMCI_ANIM_STEP_PARMS;

/* parameter block for MCI_WINDOW command message */


typedef struct tagMCI_ANIM_WINDOW_PARMSA {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCSTR     lpstrText;
} MCI_ANIM_WINDOW_PARMSA, *PMCI_ANIM_WINDOW_PARMSA, * LPMCI_ANIM_WINDOW_PARMSA;
typedef struct tagMCI_ANIM_WINDOW_PARMSW {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCWSTR    lpstrText;
} MCI_ANIM_WINDOW_PARMSW, *PMCI_ANIM_WINDOW_PARMSW, * LPMCI_ANIM_WINDOW_PARMSW;
#line 3462 "C:\WATCOM\H\NT\mmsystem.h"
typedef MCI_ANIM_WINDOW_PARMSA MCI_ANIM_WINDOW_PARMS;
typedef PMCI_ANIM_WINDOW_PARMSA PMCI_ANIM_WINDOW_PARMS;
typedef LPMCI_ANIM_WINDOW_PARMSA LPMCI_ANIM_WINDOW_PARMS;
// UNICODE

#line 3477 "C:\WATCOM\H\NT\mmsystem.h"

/* parameter block for MCI_PUT, MCI_UPDATE, MCI_WHERE command messages */
typedef struct tagMCI_ANIM_RECT_PARMS {
    DWORD   dwCallback;
/* ifdef MCI_USE_OFFEXT */#line 3485 "C:\WATCOM\H\NT\mmsystem.h"
    RECT    rc;
/* ifdef MCI_USE_OFFEXT */
} MCI_ANIM_RECT_PARMS;
typedef MCI_ANIM_RECT_PARMS * PMCI_ANIM_RECT_PARMS;
typedef MCI_ANIM_RECT_PARMS    * LPMCI_ANIM_RECT_PARMS;

/* parameter block for MCI_UPDATE PARMS */
typedef struct tagMCI_ANIM_UPDATE_PARMS {
    DWORD   dwCallback;
    RECT    rc;
    HDC     hDC;
} MCI_ANIM_UPDATE_PARMS, *PMCI_ANIM_UPDATE_PARMS,    * LPMCI_ANIM_UPDATE_PARMS;

/* MCI extensions for video overlay devices */

/* flags for dwFlags parameter of MCI_OPEN command message */



/* flags for dwFlags parameter of MCI_STATUS command message */



/* flags for dwFlags parameter of MCI_INFO command message */


/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */




/* flags for dwFlags parameter of MCI_WINDOW command message */






/* flags for hWnd parameter of MCI_OVLY_WINDOW_PARMS parameter block */


/* flags for dwFlags parameter of MCI_PUT command message */






/* flags for dwFlags parameter of MCI_WHERE command message */





/* parameter block for MCI_OPEN command message */


typedef struct tagMCI_OVLY_OPEN_PARMSA {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_OVLY_OPEN_PARMSA, *PMCI_OVLY_OPEN_PARMSA, *LPMCI_OVLY_OPEN_PARMSA;
typedef struct tagMCI_OVLY_OPEN_PARMSW {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCWSTR     lpstrDeviceType;
    LPCWSTR     lpstrElementName;
    LPCWSTR     lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_OVLY_OPEN_PARMSW, *PMCI_OVLY_OPEN_PARMSW, *LPMCI_OVLY_OPEN_PARMSW;
#line 3565 "C:\WATCOM\H\NT\mmsystem.h"
typedef MCI_OVLY_OPEN_PARMSA MCI_OVLY_OPEN_PARMS;
typedef PMCI_OVLY_OPEN_PARMSA PMCI_OVLY_OPEN_PARMS;
typedef LPMCI_OVLY_OPEN_PARMSA LPMCI_OVLY_OPEN_PARMS;
// UNICODE

#line 3583 "C:\WATCOM\H\NT\mmsystem.h"

/* parameter block for MCI_WINDOW command message */


typedef struct tagMCI_OVLY_WINDOW_PARMSA {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCSTR      lpstrText;
} MCI_OVLY_WINDOW_PARMSA, *PMCI_OVLY_WINDOW_PARMSA, * LPMCI_OVLY_WINDOW_PARMSA;
typedef struct tagMCI_OVLY_WINDOW_PARMSW {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCWSTR     lpstrText;
} MCI_OVLY_WINDOW_PARMSW, *PMCI_OVLY_WINDOW_PARMSW, * LPMCI_OVLY_WINDOW_PARMSW;
#line 3604 "C:\WATCOM\H\NT\mmsystem.h"
typedef MCI_OVLY_WINDOW_PARMSA MCI_OVLY_WINDOW_PARMS;
typedef PMCI_OVLY_WINDOW_PARMSA PMCI_OVLY_WINDOW_PARMS;
typedef LPMCI_OVLY_WINDOW_PARMSA LPMCI_OVLY_WINDOW_PARMS;
// UNICODE
#line 3618 "C:\WATCOM\H\NT\mmsystem.h"

/* parameter block for MCI_PUT, MCI_UPDATE, and MCI_WHERE command messages */
typedef struct tagMCI_OVLY_RECT_PARMS {
    DWORD   dwCallback;
/* ifdef MCI_USE_OFFEXT */#line 3626 "C:\WATCOM\H\NT\mmsystem.h"
    RECT    rc;
/* ifdef MCI_USE_OFFEXT */
} MCI_OVLY_RECT_PARMS, *PMCI_OVLY_RECT_PARMS,    * LPMCI_OVLY_RECT_PARMS;

/* parameter block for MCI_SAVE command message */


typedef struct tagMCI_OVLY_SAVE_PARMSA {
    DWORD   dwCallback;
    LPCSTR      lpfilename;
    RECT    rc;
} MCI_OVLY_SAVE_PARMSA, *PMCI_OVLY_SAVE_PARMSA, * LPMCI_OVLY_SAVE_PARMSA;
typedef struct tagMCI_OVLY_SAVE_PARMSW {
    DWORD   dwCallback;
    LPCWSTR     lpfilename;
    RECT    rc;
} MCI_OVLY_SAVE_PARMSW, *PMCI_OVLY_SAVE_PARMSW, * LPMCI_OVLY_SAVE_PARMSW;
#line 3648 "C:\WATCOM\H\NT\mmsystem.h"
typedef MCI_OVLY_SAVE_PARMSA MCI_OVLY_SAVE_PARMS;
typedef PMCI_OVLY_SAVE_PARMSA PMCI_OVLY_SAVE_PARMS;
typedef LPMCI_OVLY_SAVE_PARMSA LPMCI_OVLY_SAVE_PARMS;
// UNICODE
#line 3659 "C:\WATCOM\H\NT\mmsystem.h"

/* parameter block for MCI_LOAD command message */


typedef struct tagMCI_OVLY_LOAD_PARMSA {
    DWORD   dwCallback;
    LPCSTR      lpfilename;
    RECT    rc;
} MCI_OVLY_LOAD_PARMSA, *PMCI_OVLY_LOAD_PARMSA, * LPMCI_OVLY_LOAD_PARMSA;
typedef struct tagMCI_OVLY_LOAD_PARMSW {
    DWORD   dwCallback;
    LPCWSTR     lpfilename;
    RECT    rc;
} MCI_OVLY_LOAD_PARMSW, *PMCI_OVLY_LOAD_PARMSW, * LPMCI_OVLY_LOAD_PARMSW;
#line 3678 "C:\WATCOM\H\NT\mmsystem.h"
typedef MCI_OVLY_LOAD_PARMSA MCI_OVLY_LOAD_PARMS;
typedef PMCI_OVLY_LOAD_PARMSA PMCI_OVLY_LOAD_PARMS;
typedef LPMCI_OVLY_LOAD_PARMSA LPMCI_OVLY_LOAD_PARMS;
// UNICODE
#line 3689 "C:\WATCOM\H\NT\mmsystem.h"

/* ifndef _WIN32_VXD */
/* ifndef MMNOMCI */

/****************************************************************************

			DISPLAY Driver extensions

****************************************************************************/


    /* use with SetBkMode() */

    /* use to determine ROP support */
/* ifndef NEWTRANSPARENT */

/****************************************************************************

			DIB Driver extensions

****************************************************************************/

/* DIB.DRV select dib escape */


/****************************************************************************

			ScreenSaver support

    The current application will receive a syscommand of SC_SCREENSAVE just
    before the screen saver is invoked.  If the app wishes to prevent a
    screen save, return non-zero value, otherwise call DefWindowProc().

****************************************************************************/

/* ifndef SC_SCREENSAVE */#line 3729 "C:\WATCOM\H\NT\mmsystem.h"


}                       /* End of extern "C" { */ 
/* __cplusplus */


#line 1 "C:\WATCOM\H\NT\poppack.h"
/*++

Copyright (c) 1990,95  Microsoft Corporation

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)
#line 33 "C:\WATCOM\H\NT\poppack.h"
#line 36 "C:\WATCOM\H\NT\poppack.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 3735 "C:\WATCOM\H\NT\mmsystem.h"

#line 3741 "C:\WATCOM\H\NT\mmsystem.h"

/* _INC_MMSYSTEM */
#line 173 "C:\WATCOM\H\NT\windows.h"

#line 1 "C:\WATCOM\H\NT\nb30.h"
//*++
//
// Copyright (c) 1991-1995  Microsoft Corporation
//
// Module Name:
//
//  nb30.h
//
// Abstract:
//
//  This module contains the definitions for portable NetBIOS 3.0
//  support.
//
//--*/





extern "C" {


/****************************************************************
 *                                                              *
 *              Data structure templates                        *
 *                                                              *
 ****************************************************************/

/* absolute length of a net name           */
/* lana's in range 0 to MAX_LANA inclusive */

/*
 * Network Control Block
 */

typedef struct _NCB {
    UCHAR   ncb_command;            /* command code                   */ 
    UCHAR   ncb_retcode;            /* return code                    */ 
    UCHAR   ncb_lsn;                /* local session number           */ 
    UCHAR   ncb_num;                /* number of our network name     */ 
    PUCHAR  ncb_buffer;             /* address of message buffer      */ 
    WORD    ncb_length;             /* size of message buffer         */ 
    UCHAR   ncb_callname[ 16 ]; /* blank-padded name of remote    */ 
    UCHAR   ncb_name[ 16 ];     /* our blank-padded netname       */ 
    UCHAR   ncb_rto;                /* rcv timeout/retry count        */ 
    UCHAR   ncb_sto;                /* send timeout/sys timeout       */ 
    void ( __stdcall  *ncb_post)( struct _NCB * ); /* POST routine address        */ 
    UCHAR   ncb_lana_num;           /* lana (adapter) number          */ 
    UCHAR   ncb_cmd_cplt;           /* 0xff => commmand pending       */ 
    UCHAR   ncb_reserve[10];        /* reserved, used by BIOS         */ 
    HANDLE  ncb_event;              /* HANDLE to Win32 event which    */ 
                                    /* will be set to the signalled   */
                                    /* state when an ASYNCH command   */
                                    /* completes                      */
} NCB, *PNCB;

/*
 *  Structure returned to the NCB command NCBASTAT is ADAPTER_STATUS followed
 *  by an array of NAME_BUFFER structures.
 */

typedef struct _ADAPTER_STATUS {
    UCHAR   adapter_address[6];
    UCHAR   rev_major;
    UCHAR   reserved0;
    UCHAR   adapter_type;
    UCHAR   rev_minor;
    WORD    duration;
    WORD    frmr_recv;
    WORD    frmr_xmit;

    WORD    iframe_recv_err;

    WORD    xmit_aborts;
    DWORD   xmit_success;
    DWORD   recv_success;

    WORD    iframe_xmit_err;

    WORD    recv_buff_unavail;
    WORD    t1_timeouts;
    WORD    ti_timeouts;
    DWORD   reserved1;
    WORD    free_ncbs;
    WORD    max_cfg_ncbs;
    WORD    max_ncbs;
    WORD    xmit_buf_unavail;
    WORD    max_dgram_size;
    WORD    pending_sess;
    WORD    max_cfg_sess;
    WORD    max_sess;
    WORD    max_sess_pkt_size;
    WORD    name_count;
} ADAPTER_STATUS, *PADAPTER_STATUS;

typedef struct _NAME_BUFFER {
    UCHAR   name[ 16 ];
    UCHAR   name_num;
    UCHAR   name_flags;
} NAME_BUFFER, *PNAME_BUFFER;

//  values for name_flags bits.












/*
 *  Structure returned to the NCB command NCBSSTAT is SESSION_HEADER followed
 *  by an array of SESSION_BUFFER structures. If the NCB_NAME starts with an
 *  asterisk then an array of these structures is returned containing the
 *  status for all names.
 */

typedef struct _SESSION_HEADER {
    UCHAR   sess_name;
    UCHAR   num_sess;
    UCHAR   rcv_dg_outstanding;
    UCHAR   rcv_any_outstanding;
} SESSION_HEADER, *PSESSION_HEADER;

typedef struct _SESSION_BUFFER {
    UCHAR   lsn;
    UCHAR   state;
    UCHAR   local_name[ 16 ];
    UCHAR   remote_name[ 16 ];
    UCHAR   rcvs_outstanding;
    UCHAR   sends_outstanding;
} SESSION_BUFFER, *PSESSION_BUFFER;

//  Values for state








/*
 *  Structure returned to the NCB command NCBENUM.
 *
 *  On a system containing lana's 0, 2 and 3, a structure with
 *  length =3, lana[0]=0, lana[1]=2 and lana[2]=3 will be returned.
 */

typedef struct _LANA_ENUM {
    UCHAR   length;         //  Number of valid entries in lana[] 
    UCHAR   lana[ 254 +1];
} LANA_ENUM, *PLANA_ENUM;

/*
 *  Structure returned to the NCB command NCBFINDNAME is FIND_NAME_HEADER followed
 *  by an array of FIND_NAME_BUFFER structures.
 */

typedef struct _FIND_NAME_HEADER {
    WORD    node_count;
    UCHAR   reserved;
    UCHAR   unique_group;
} FIND_NAME_HEADER, *PFIND_NAME_HEADER;

typedef struct _FIND_NAME_BUFFER {
    UCHAR   length;
    UCHAR   access_control;
    UCHAR   frame_control;
    UCHAR   destination_addr[6];
    UCHAR   source_addr[6];
    UCHAR   routing_info[18];
} FIND_NAME_BUFFER, *PFIND_NAME_BUFFER;

/*
 *  Structure provided with NCBACTION. The purpose of NCBACTION is to provide
 *  transport specific extensions to netbios.
 */

typedef struct _ACTION_HEADER {
    ULONG   transport_id;
    USHORT  action_code;
    USHORT  reserved;
} ACTION_HEADER, *PACTION_HEADER;

//  Values for transport_id





/****************************************************************
 *                                                              *
 *              Special values and constants                    *
 *                                                              *
 ****************************************************************/

/*
 *      NCB Command codes
 */

/* NCB CALL                           */
/* NCB LISTEN                         */
/* NCB HANG UP                        */
/* NCB SEND                           */
/* NCB RECEIVE                        */
/* NCB RECEIVE ANY                    */
/* NCB CHAIN SEND                     */
/* NCB SEND DATAGRAM                  */
/* NCB RECEIVE DATAGRAM               */
/* NCB SEND BROADCAST DATAGRAM        */
/* NCB RECEIVE BROADCAST DATAGRAM     */
/* NCB ADD NAME                       */
/* NCB DELETE NAME                    */
/* NCB RESET                          */
/* NCB ADAPTER STATUS                 */
/* NCB SESSION STATUS                 */
/* NCB CANCEL                         */
/* NCB ADD GROUP NAME                 */
/* NCB ENUMERATE LANA NUMBERS         */
/* NCB UNLINK                         */
/* NCB SEND NO ACK                    */
/* NCB CHAIN SEND NO ACK              */
/* NCB LAN STATUS ALERT               */
/* NCB ACTION                         */
/* NCB FIND NAME                      */
/* NCB TRACE                          */


/* high bit set == asynchronous       */

/*
 *      NCB Return codes
 */

/* good return                                */
                                /* also returned when ASYNCH request accepted */
/* illegal buffer length                      */
/* illegal command                            */
/* command timed out                          */
/* message incomplete, issue another command  */
/* illegal buffer address                     */
/* session number out of range                */
/* no resource available                      */
/* session closed                             */
/* command cancelled                          */
/* duplicate name                             */
/* name table full                            */
/* no deletions, name has active sessions     */
/* local session table full                   */
/* remote session table full                  */
/* illegal name number                        */
/* no callname                                */
/* cannot put * in NCB_NAME                   */
/* name in use on remote adapter              */
/* name deleted                               */
/* session ended abnormally                   */
/* name conflict detected                     */
/* interface busy, IRET before retrying       */
/* too many commands outstanding, retry later */
/* ncb_lana_num field invalid                 */
/* command completed while cancel occurring   */
/* command not valid to cancel                */
/* name defined by anther local process       */
/* environment undefined. RESET required      */
/* required OS resources exhausted            */
/* max number of applications exceeded        */
/* no saps available for netbios              */
/* requested resources are not available      */
/* invalid ncb address or length > segment    */
/* invalid NCB DDID                           */
/* lock of user area failed                   */
/* NETBIOS not loaded                         */
/* system error                               */

/* asynchronous command is not yet finished   */

/****************************************************************
 *                                                              *
 *              main user entry point for NetBIOS 3.0           *
 *                                                              *
 * Usage: result = Netbios( pncb );                             *
 ****************************************************************/

UCHAR
 __stdcall 
Netbios(
    PNCB pncb
    );

/****************************************************************
 *                                                              *
 *              Prefix for callback routines                    *
 *                                                              *
 * Usage in a declaration: NCB_POST MyPostRoutine( PNCB pncb ); *
 ****************************************************************/




}


/* NCB_INCLUDED */
#line 174 "C:\WATCOM\H\NT\windows.h"

#line 1 "C:\WATCOM\H\NT\rpc.h"
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    rpc.h

Abstract:

    Master include file for RPC applications.

--*/


#line 1 "C:\WATCOM\H\NT\windows.h"
/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) 1985-1995, Microsoft Corporation

Module Name:


    windows.h

Abstract:

    Master include file for Windows applications.

--*/

/* _WINDOWS_ */#line 216 "C:\WATCOM\H\NT\windows.h"
#line 16 "C:\WATCOM\H\NT\rpc.h"

// RPC_NO_WINDOWS_H





extern "C" {











typedef void * I_RPC_HANDLE;
typedef long RPC_STATUS;








#line 52 "C:\WATCOM\H\NT\rpc.h"





/* IN */

#line 1 "C:\WATCOM\H\NT\rpcdce.h"
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    rpcdce.h

Abstract:

    This module contains the DCE RPC runtime APIs.

--*/





extern "C" {






/*typedef char small;*/
/*typedef unsigned char byte;*/
/*typedef unsigned char boolean;*/

typedef I_RPC_HANDLE RPC_BINDING_HANDLE;
typedef RPC_BINDING_HANDLE handle_t;


/* GUID_DEFINED */#line 44 "C:\WATCOM\H\NT\rpcdce.h"



typedef GUID UUID;





typedef struct _RPC_BINDING_VECTOR
{
    unsigned long Count;
    RPC_BINDING_HANDLE BindingH[1];
} RPC_BINDING_VECTOR;




typedef struct _UUID_VECTOR
{
  unsigned long Count;
  UUID *Uuid[1];
} UUID_VECTOR;




typedef void    * RPC_IF_HANDLE;



typedef struct _RPC_IF_ID
{
    UUID Uuid;
    unsigned short VersMajor;
    unsigned short VersMinor;
} RPC_IF_ID;














typedef struct _RPC_PROTSEQ_VECTORA
{
    unsigned int Count;
    unsigned char    * Protseq[1];
} RPC_PROTSEQ_VECTORA;

typedef struct _RPC_PROTSEQ_VECTORW
{
    unsigned int Count;
    unsigned short    * Protseq[1];
} RPC_PROTSEQ_VECTORW;

/* UNICODE */#line 110 "C:\WATCOM\H\NT\rpcdce.h"

/* UNICODE */

/* RPC_UNICODE_SUPPORTED */#line 122 "C:\WATCOM\H\NT\rpcdce.h"

typedef void  __stdcall 
RPC_OBJECT_INQ_FN (
       UUID    * ObjectUuid,
       UUID    * TypeUuid,
       RPC_STATUS    * Status
    );



typedef struct
{
    unsigned int Count;
    unsigned long Stats[1];
} RPC_STATS_VECTOR;






typedef struct
{
  unsigned long Count;
  RPC_IF_ID    * IfId[1];
} RPC_IF_ID_VECTOR;

/* client */
RPC_STATUS  __stdcall 
RpcBindingCopy (
       RPC_BINDING_HANDLE SourceBinding,
       RPC_BINDING_HANDLE    * DestinationBinding
    );

/* client */
RPC_STATUS  __stdcall 
RpcBindingFree (
          RPC_BINDING_HANDLE    * Binding
    );

/* client */



RPC_STATUS  __stdcall 
RpcBindingFromStringBindingA (
       unsigned char    * StringBinding,
       RPC_BINDING_HANDLE    * Binding
    );

RPC_STATUS  __stdcall 
RpcBindingFromStringBindingW (
       unsigned short    * StringBinding,
       RPC_BINDING_HANDLE    * Binding
    );

/* UNICODE */#line 181 "C:\WATCOM\H\NT\rpcdce.h"

/* UNICODE */

/* RPC_UNICODE_SUPPORTED */#line 193 "C:\WATCOM\H\NT\rpcdce.h"

/* RpcBindingInqAuthClient */
/* RpcBindingInqAuthInfo */

/* client/server */
RPC_STATUS  __stdcall 
RpcBindingInqObject (
       RPC_BINDING_HANDLE Binding,
       UUID    * ObjectUuid
    );

/* client */
RPC_STATUS  __stdcall 
RpcBindingReset (
       RPC_BINDING_HANDLE Binding
    );

/* RpcBindingServerFromClient : UNSUPPORTED */
/* RpcBindingSetAuthInfo */

/* client */
RPC_STATUS  __stdcall 
RpcBindingSetObject (
       RPC_BINDING_HANDLE Binding,
       UUID    * ObjectUuid
    );

/* client/server */
RPC_STATUS  __stdcall 
RpcMgmtInqDefaultProtectLevel(
        unsigned long AuthnSvc,
       unsigned long    *AuthnLevel
    );

/* client/server */



RPC_STATUS  __stdcall 
RpcBindingToStringBindingA (
       RPC_BINDING_HANDLE Binding,
       unsigned char    *    * StringBinding
    );

RPC_STATUS  __stdcall 
RpcBindingToStringBindingW (
       RPC_BINDING_HANDLE Binding,
       unsigned short    *    * StringBinding
    );

/* UNICODE */#line 246 "C:\WATCOM\H\NT\rpcdce.h"

/* UNICODE */

/* RPC_UNICODE_SUPPORTED */#line 258 "C:\WATCOM\H\NT\rpcdce.h"

/* client/server */
RPC_STATUS  __stdcall 
RpcBindingVectorFree (
          RPC_BINDING_VECTOR    *    * BindingVector
    );

/* client/server */



RPC_STATUS  __stdcall 
RpcStringBindingComposeA (
       unsigned char    * ObjUuid   ,
       unsigned char    * Protseq   ,
       unsigned char    * NetworkAddr   ,
       unsigned char    * Endpoint   ,
       unsigned char    * Options   ,
       unsigned char    *    * StringBinding   
    );

RPC_STATUS  __stdcall 
RpcStringBindingComposeW (
       unsigned short    * ObjUuid   ,
       unsigned short    * Protseq   ,
       unsigned short    * NetworkAddr   ,
       unsigned short    * Endpoint   ,
       unsigned short    * Options   ,
       unsigned short    *    * StringBinding   
    );

/* UNICODE */#line 292 "C:\WATCOM\H\NT\rpcdce.h"

/* UNICODE */

/* RPC_UNICODE_SUPPORTED */#line 308 "C:\WATCOM\H\NT\rpcdce.h"

/* client/server */



RPC_STATUS  __stdcall 
RpcStringBindingParseA (
       unsigned char    * StringBinding,
       unsigned char    *    * ObjUuid   ,
       unsigned char    *    * Protseq   ,
       unsigned char    *    * NetworkAddr   ,
       unsigned char    *    * Endpoint   ,
       unsigned char    *    * NetworkOptions   
    );

RPC_STATUS  __stdcall 
RpcStringBindingParseW (
       unsigned short    * StringBinding,
       unsigned short    *    * ObjUuid   ,
       unsigned short    *    * Protseq   ,
       unsigned short    *    * NetworkAddr   ,
       unsigned short    *    * Endpoint   ,
       unsigned short    *    * NetworkOptions   
    );

/* UNICODE */#line 336 "C:\WATCOM\H\NT\rpcdce.h"

/* UNICODE */

/* RPC_UNICODE_SUPPORTED */#line 352 "C:\WATCOM\H\NT\rpcdce.h"

/* client/server */



RPC_STATUS  __stdcall 
RpcStringFreeA (
          unsigned char    *    * String
    );

RPC_STATUS  __stdcall 
RpcStringFreeW (
          unsigned short    *    * String
    );

/* UNICODE */#line 370 "C:\WATCOM\H\NT\rpcdce.h"

/* UNICODE */

/* RPC_UNICODE_SUPPORTED */#line 381 "C:\WATCOM\H\NT\rpcdce.h"

/* client/server */
RPC_STATUS  __stdcall 
RpcIfInqId (
       RPC_IF_HANDLE RpcIfHandle,
       RPC_IF_ID    * RpcIfId
    );

/* client/server */



RPC_STATUS  __stdcall 
RpcNetworkIsProtseqValidA (
       unsigned char    * Protseq
    );

RPC_STATUS  __stdcall 
RpcNetworkIsProtseqValidW (
       unsigned short    * Protseq
    );

/* UNICODE */#line 406 "C:\WATCOM\H\NT\rpcdce.h"

/* UNICODE */

/* RPC_UNICODE_SUPPORTED */#line 417 "C:\WATCOM\H\NT\rpcdce.h"

/* client */
RPC_STATUS  __stdcall 
RpcMgmtInqComTimeout (
       RPC_BINDING_HANDLE Binding,
       unsigned int    * Timeout
    );

/* client */
RPC_STATUS  __stdcall 
RpcMgmtSetComTimeout (
       RPC_BINDING_HANDLE Binding,
       unsigned int Timeout
    );

/* client */
RPC_STATUS  __stdcall 
RpcMgmtSetCancelTimeout(
    long Timeout
    );


/* server */



RPC_STATUS  __stdcall 
RpcNetworkInqProtseqsA (
       RPC_PROTSEQ_VECTORA    *    * ProtseqVector
    );

RPC_STATUS  __stdcall 
RpcNetworkInqProtseqsW (
       RPC_PROTSEQ_VECTORW    *    * ProtseqVector
    );

/* UNICODE */#line 456 "C:\WATCOM\H\NT\rpcdce.h"

/* UNICODE */

/* RPC_UNICODE_SUPPORTED */#line 467 "C:\WATCOM\H\NT\rpcdce.h"

/* server */
RPC_STATUS  __stdcall 
RpcObjectInqType (
       UUID    * ObjUuid,
       UUID    * TypeUuid   
    );

/* server */
RPC_STATUS  __stdcall 
RpcObjectSetInqFn (
       RPC_OBJECT_INQ_FN    * InquiryFn
    );

/* server */
RPC_STATUS  __stdcall 
RpcObjectSetType (
       UUID    * ObjUuid,
       UUID    * TypeUuid   
    );

/* server */



RPC_STATUS  __stdcall 
RpcProtseqVectorFreeA (
          RPC_PROTSEQ_VECTORA    *    * ProtseqVector
    );

RPC_STATUS  __stdcall 
RpcProtseqVectorFreeW (
          RPC_PROTSEQ_VECTORW    *    * ProtseqVector
    );

/* UNICODE */#line 505 "C:\WATCOM\H\NT\rpcdce.h"

/* UNICODE */

/* RPC_UNICODE_SUPPORTED */#line 516 "C:\WATCOM\H\NT\rpcdce.h"

/* server */
RPC_STATUS  __stdcall 
RpcServerInqBindings (
       RPC_BINDING_VECTOR    *    * BindingVector
    );

/* server */
RPC_STATUS  __stdcall 
RpcServerInqIf (
       RPC_IF_HANDLE IfSpec,
       UUID    * MgrTypeUuid,   
        void     *    * MgrEpv
    );

/* server */
RPC_STATUS  __stdcall 
RpcServerListen (
       unsigned int MinimumCallThreads,
       unsigned int MaxCalls,
       unsigned int DontWait
    );

/* server */
RPC_STATUS  __stdcall 
RpcServerRegisterIf (
       RPC_IF_HANDLE IfSpec,
       UUID    * MgrTypeUuid   ,
        void     * MgrEpv   
    );

/* server */
RPC_STATUS  __stdcall 
RpcServerUnregisterIf (
       RPC_IF_HANDLE IfSpec,
       UUID    * MgrTypeUuid,   
       unsigned int WaitForCallsToComplete
    );

/* server */
RPC_STATUS  __stdcall 
RpcServerUseAllProtseqs (
       unsigned int MaxCalls,
       void    * SecurityDescriptor   
    );

/* server */
RPC_STATUS  __stdcall 
RpcServerUseAllProtseqsIf (
       unsigned int MaxCalls,
       RPC_IF_HANDLE IfSpec,
       void    * SecurityDescriptor   
    );

/* server */



RPC_STATUS  __stdcall 
RpcServerUseProtseqA (
       unsigned char    * Protseq,
       unsigned int MaxCalls,
       void    * SecurityDescriptor   
    );

RPC_STATUS  __stdcall 
RpcServerUseProtseqW (
       unsigned short    * Protseq,
       unsigned int MaxCalls,
       void    * SecurityDescriptor   
    );

/* UNICODE */#line 591 "C:\WATCOM\H\NT\rpcdce.h"

/* UNICODE */

/* RPC_UNICODE_SUPPORTED */#line 604 "C:\WATCOM\H\NT\rpcdce.h"

/* server */



RPC_STATUS  __stdcall 
RpcServerUseProtseqEpA (
       unsigned char    * Protseq,
       unsigned int MaxCalls,
       unsigned char    * Endpoint,
       void    * SecurityDescriptor   
    );

RPC_STATUS  __stdcall 
RpcServerUseProtseqEpW (
       unsigned short    * Protseq,
       unsigned int MaxCalls,
       unsigned short    * Endpoint,
       void    * SecurityDescriptor   
    );

/* UNICODE */#line 628 "C:\WATCOM\H\NT\rpcdce.h"

/* UNICODE */

/* RPC_UNICODE_SUPPORTED */#line 642 "C:\WATCOM\H\NT\rpcdce.h"

/* server */



RPC_STATUS  __stdcall 
RpcServerUseProtseqIfA (
       unsigned char    * Protseq,
       unsigned int MaxCalls,
       RPC_IF_HANDLE IfSpec,
       void    * SecurityDescriptor   
    );

RPC_STATUS  __stdcall 
RpcServerUseProtseqIfW (
       unsigned short    * Protseq,
       unsigned int MaxCalls,
       RPC_IF_HANDLE IfSpec,
       void    * SecurityDescriptor   
    );

/* UNICODE */#line 666 "C:\WATCOM\H\NT\rpcdce.h"

/* UNICODE */

/* RPC_UNICODE_SUPPORTED */#line 680 "C:\WATCOM\H\NT\rpcdce.h"

/* server */
RPC_STATUS  __stdcall 
RpcMgmtStatsVectorFree (
       RPC_STATS_VECTOR ** StatsVector
    );

/* server */
RPC_STATUS  __stdcall 
RpcMgmtInqStats (
       RPC_BINDING_HANDLE Binding,
       RPC_STATS_VECTOR ** Statistics
    );

/* server */
RPC_STATUS  __stdcall 
RpcMgmtIsServerListening (
       RPC_BINDING_HANDLE Binding
    );

/* server */
RPC_STATUS  __stdcall 
RpcMgmtStopServerListening (
       RPC_BINDING_HANDLE Binding
    );

/* server */
RPC_STATUS  __stdcall 
RpcMgmtWaitServerListen (
    void
    );

/* server */
RPC_STATUS  __stdcall 
RpcMgmtSetServerStackSize (
       unsigned long ThreadStackSize
    );

/* client */
RPC_STATUS  __stdcall 
RpcMgmtEnableIdleCleanup (
    void
    );

RPC_STATUS  __stdcall 
RpcMgmtInqIfIds (
       RPC_BINDING_HANDLE Binding,
       RPC_IF_ID_VECTOR    *    * IfIdVector
    );

RPC_STATUS  __stdcall 
RpcIfIdVectorFree (
          RPC_IF_ID_VECTOR    *    * IfIdVector
    );



RPC_STATUS  __stdcall 
RpcMgmtInqServerPrincNameA (
       RPC_BINDING_HANDLE Binding,
       unsigned long AuthnSvc,
       unsigned char    *    * ServerPrincName
    );

RPC_STATUS  __stdcall 
RpcMgmtInqServerPrincNameW (
       RPC_BINDING_HANDLE Binding,
       unsigned long AuthnSvc,
       unsigned short    *    * ServerPrincName
    );

/* UNICODE */#line 754 "C:\WATCOM\H\NT\rpcdce.h"

/* UNICODE */

/* RPC_UNICODE_SUPPORTED */#line 767 "C:\WATCOM\H\NT\rpcdce.h"



RPC_STATUS  __stdcall 
RpcServerInqDefaultPrincNameA (
       unsigned long AuthnSvc,
       unsigned char    *    * PrincName
    );

RPC_STATUS  __stdcall 
RpcServerInqDefaultPrincNameW (
       unsigned long AuthnSvc,
       unsigned short    *    * PrincName
    );

/* UNICODE */#line 785 "C:\WATCOM\H\NT\rpcdce.h"

/* UNICODE */

/* RPC_UNICODE_SUPPORTED */#line 797 "C:\WATCOM\H\NT\rpcdce.h"

/* client */
RPC_STATUS  __stdcall 
RpcEpResolveBinding (
       RPC_BINDING_HANDLE Binding,
       RPC_IF_HANDLE IfSpec
    );

/* client */



RPC_STATUS  __stdcall 
RpcNsBindingInqEntryNameA (
       RPC_BINDING_HANDLE Binding,
       unsigned long EntryNameSyntax,
       unsigned char    *    * EntryName
    );

RPC_STATUS  __stdcall 
RpcNsBindingInqEntryNameW (
       RPC_BINDING_HANDLE Binding,
       unsigned long EntryNameSyntax,
       unsigned short    *    * EntryName
    );

/* UNICODE */#line 826 "C:\WATCOM\H\NT\rpcdce.h"

/* UNICODE */

/* RPC_UNICODE_SUPPORTED */#line 839 "C:\WATCOM\H\NT\rpcdce.h"

typedef void    * RPC_AUTH_IDENTITY_HANDLE;
typedef void    * RPC_AUTHZ_HANDLE;

























#line 875 "C:\WATCOM\H\NT\rpcdce.h"





typedef struct _SEC_WINNT_AUTH_IDENTITY_W {
  unsigned short    *User;
  unsigned long UserLength;
  unsigned short    *Domain;
  unsigned long DomainLength;
  unsigned short    *Password;
  unsigned long PasswordLength;
  unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_W, *PSEC_WINNT_AUTH_IDENTITY_W;

typedef struct _SEC_WINNT_AUTH_IDENTITY_A {
  unsigned char    *User;
  unsigned long UserLength;
  unsigned char    *Domain;
  unsigned long DomainLength;
  unsigned char    *Password;
  unsigned long PasswordLength;
  unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_A, *PSEC_WINNT_AUTH_IDENTITY_A;

// UNICODE#line 905 "C:\WATCOM\H\NT\rpcdce.h"



// UNICODE
// defined(__RPC_DOS__) || defined(__RPC_WIN16__)







RPC_STATUS  __stdcall 
RpcBindingInqAuthClientA (
       RPC_BINDING_HANDLE ClientBinding,   
       RPC_AUTHZ_HANDLE    * Privs,
       unsigned char    *    * ServerPrincName,   
       unsigned long    * AuthnLevel,   
       unsigned long    * AuthnSvc,   
       unsigned long    * AuthzSvc   
    );

RPC_STATUS  __stdcall 
RpcBindingInqAuthClientW (
       RPC_BINDING_HANDLE ClientBinding,   
       RPC_AUTHZ_HANDLE    * Privs,
       unsigned short    *    * ServerPrincName,   
       unsigned long    * AuthnLevel,   
       unsigned long    * AuthnSvc,   
       unsigned long    * AuthzSvc   
    );

RPC_STATUS  __stdcall 
RpcBindingInqAuthInfoA (
       RPC_BINDING_HANDLE Binding,
       unsigned char    *    * ServerPrincName,   
       unsigned long    * AuthnLevel,   
       unsigned long    * AuthnSvc,   
       RPC_AUTH_IDENTITY_HANDLE    * AuthIdentity,   
       unsigned long    * AuthzSvc   
    );

RPC_STATUS  __stdcall 
RpcBindingInqAuthInfoW (
       RPC_BINDING_HANDLE Binding,
       unsigned short    *    * ServerPrincName,   
       unsigned long    * AuthnLevel,   
       unsigned long    * AuthnSvc,   
       RPC_AUTH_IDENTITY_HANDLE    * AuthIdentity,   
       unsigned long    * AuthzSvc   
    );

RPC_STATUS  __stdcall 
RpcBindingSetAuthInfoA (
       RPC_BINDING_HANDLE Binding,
       unsigned char    * ServerPrincName,
       unsigned long AuthnLevel,
       unsigned long AuthnSvc,
       RPC_AUTH_IDENTITY_HANDLE AuthIdentity,   
       unsigned long AuthzSvc
    );

RPC_STATUS  __stdcall 
RpcBindingSetAuthInfoW (
       RPC_BINDING_HANDLE Binding,
       unsigned short    * ServerPrincName,
       unsigned long AuthnLevel,
       unsigned long AuthnSvc,
       RPC_AUTH_IDENTITY_HANDLE AuthIdentity,   
       unsigned long AuthzSvc
    );

typedef void
( __stdcall  * RPC_AUTH_KEY_RETRIEVAL_FN) (
       void    * Arg,
       unsigned short    * ServerPrincName,
       unsigned long KeyVer,
       void    *    * Key,
       RPC_STATUS    * Status
    );

RPC_STATUS  __stdcall 
RpcServerRegisterAuthInfoA (
       unsigned char    * ServerPrincName,
       unsigned long AuthnSvc,
       RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn   ,
       void    * Arg   
    );

RPC_STATUS  __stdcall 
RpcServerRegisterAuthInfoW (
       unsigned short    * ServerPrincName,
       unsigned long AuthnSvc,
       RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn   ,
       void    * Arg   
    );

/* UNICODE */#line 1008 "C:\WATCOM\H\NT\rpcdce.h"




/* UNICODE */

/* RPC_UNICODE_SUPPORTED */#line 1064 "C:\WATCOM\H\NT\rpcdce.h"

typedef struct {
    unsigned char    * UserName;
    unsigned char    * ComputerName;
    unsigned short Privilege;
    unsigned long AuthFlags;
} RPC_CLIENT_INFORMATION1,    * PRPC_CLIENT_INFORMATION1;

RPC_STATUS  __stdcall 
RpcBindingServerFromClient (
       RPC_BINDING_HANDLE ClientBinding,
       RPC_BINDING_HANDLE    * ServerBinding
    );

void  __stdcall 
RpcRaiseException (
       RPC_STATUS exception
    );

RPC_STATUS  __stdcall 
RpcTestCancel(
    );

RPC_STATUS  __stdcall 
RpcCancelThread(
       void * Thread
    );

/* client/server */
RPC_STATUS  __stdcall 
UuidCreate (
       UUID    * Uuid
    );



/* client/server */
RPC_STATUS  __stdcall 
UuidToStringA (
       UUID    * Uuid,
       unsigned char    *    * StringUuid
    );

/* client/server */
RPC_STATUS  __stdcall 
UuidFromStringA (
       unsigned char    * StringUuid,
       UUID    * Uuid
    );

/* client/server */
RPC_STATUS  __stdcall 
UuidToStringW (
       UUID    * Uuid,
       unsigned short    *    * StringUuid
    );

/* client/server */
RPC_STATUS  __stdcall 
UuidFromStringW (
       unsigned short    * StringUuid,
       UUID    * Uuid
    );

/* UNICODE */#line 1132 "C:\WATCOM\H\NT\rpcdce.h"


/* UNICODE */

/* RPC_UNICODE_SUPPORTED */#line 1153 "C:\WATCOM\H\NT\rpcdce.h"

signed int  __stdcall 
UuidCompare (
       UUID    * Uuid1,
       UUID    * Uuid2,
       RPC_STATUS    * Status
    );

RPC_STATUS  __stdcall 
UuidCreateNil (
       UUID    * NilUuid
    );

int  __stdcall 
UuidEqual (
       UUID    * Uuid1,
       UUID    * Uuid2,
       RPC_STATUS    * Status
    );

unsigned short  __stdcall 
UuidHash (
       UUID    * Uuid,
       RPC_STATUS    * Status
    );

int  __stdcall 
UuidIsNil (
       UUID    * Uuid,
       RPC_STATUS    * Status
    );



RPC_STATUS  __stdcall 
RpcEpRegisterNoReplaceA (
       RPC_IF_HANDLE IfSpec,
       RPC_BINDING_VECTOR * BindingVector,
       UUID_VECTOR * UuidVector   ,
       unsigned char * Annotation
    );

RPC_STATUS  __stdcall 
RpcEpRegisterNoReplaceW (
       RPC_IF_HANDLE IfSpec,
       RPC_BINDING_VECTOR * BindingVector,
       UUID_VECTOR * UuidVector   ,
       unsigned short  * Annotation
    );

RPC_STATUS  __stdcall 
RpcEpRegisterA (
       RPC_IF_HANDLE IfSpec,
       RPC_BINDING_VECTOR * BindingVector,
       UUID_VECTOR * UuidVector   ,
       unsigned char * Annotation
    );

RPC_STATUS  __stdcall 
RpcEpRegisterW (
       RPC_IF_HANDLE IfSpec,
       RPC_BINDING_VECTOR * BindingVector,
       UUID_VECTOR * UuidVector   ,
       unsigned short * Annotation
    );

/* UNICODE */#line 1223 "C:\WATCOM\H\NT\rpcdce.h"


/* UNICODE */

/* RPC_UNICODE_SUPPORTED */#line 1246 "C:\WATCOM\H\NT\rpcdce.h"


RPC_STATUS  __stdcall 
RpcEpUnregister(
       RPC_IF_HANDLE IfSpec,
       RPC_BINDING_VECTOR * BindingVector,
       UUID_VECTOR * UuidVector
    );



RPC_STATUS  __stdcall 
DceErrorInqTextA (
       RPC_STATUS RpcStatus,
       unsigned char    * ErrorText
    );

RPC_STATUS  __stdcall 
DceErrorInqTextW (
       RPC_STATUS RpcStatus,
       unsigned short    * ErrorText
    );

/* UNICODE */#line 1272 "C:\WATCOM\H\NT\rpcdce.h"

/* UNICODE */

/* RPC_UNICODE_SUPPORTED */#line 1284 "C:\WATCOM\H\NT\rpcdce.h"



typedef I_RPC_HANDLE * RPC_EP_INQ_HANDLE;












RPC_STATUS  __stdcall 
RpcMgmtEpEltInqBegin (
       RPC_BINDING_HANDLE EpBinding   ,
       unsigned long InquiryType,
       RPC_IF_ID    * IfId   ,
       unsigned long VersOption   ,
       UUID    * ObjectUuid   ,
       RPC_EP_INQ_HANDLE    * InquiryContext
    );

RPC_STATUS  __stdcall 
RpcMgmtEpEltInqDone (
          RPC_EP_INQ_HANDLE    * InquiryContext
    );



RPC_STATUS  __stdcall 
RpcMgmtEpEltInqNextA (
       RPC_EP_INQ_HANDLE InquiryContext,
       RPC_IF_ID    * IfId,
       RPC_BINDING_HANDLE    * Binding   ,
       UUID    * ObjectUuid   ,
       unsigned char    *    * Annotation   
    );

RPC_STATUS  __stdcall 
RpcMgmtEpEltInqNextW (
       RPC_EP_INQ_HANDLE InquiryContext,
       RPC_IF_ID    * IfId,
       RPC_BINDING_HANDLE    * Binding   ,
       UUID    * ObjectUuid   ,
       unsigned short    *    * Annotation   
    );

/* UNICODE */#line 1338 "C:\WATCOM\H\NT\rpcdce.h"

/* UNICODE */

/* RPC_UNICODE_SUPPORTED */#line 1352 "C:\WATCOM\H\NT\rpcdce.h"

RPC_STATUS  __stdcall 
RpcMgmtEpUnregister (
       RPC_BINDING_HANDLE EpBinding   ,
       RPC_IF_ID    * IfId,
       RPC_BINDING_HANDLE Binding,
       UUID    * ObjectUuid   
    );

typedef int
( __stdcall  * RPC_MGMT_AUTHORIZATION_FN) (
       RPC_BINDING_HANDLE ClientBinding,
       unsigned long RequestedMgmtOperation,
       RPC_STATUS    * Status
    );







RPC_STATUS  __stdcall 
RpcMgmtSetAuthorizationFn (
       RPC_MGMT_AUTHORIZATION_FN AuthorizationFn
    );

#line 1 "C:\WATCOM\H\NT\rpcdcep.h"
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    rpcdcep.h

Abstract:

    This module contains the private RPC runtime APIs for use by the
    stubs and by support libraries.  Applications must not call these
    routines.

--*/




// Set the packing level for RPC structures for Dos and Windows.

#line 25 "C:\WATCOM\H\NT\rpcdcep.h"


extern "C" {


typedef struct _RPC_VERSION {
    unsigned short MajorVersion;
    unsigned short MinorVersion;
} RPC_VERSION;

typedef struct _RPC_SYNTAX_IDENTIFIER {
    GUID SyntaxGUID;
    RPC_VERSION SyntaxVersion;
} RPC_SYNTAX_IDENTIFIER,    * PRPC_SYNTAX_IDENTIFIER;

typedef struct _RPC_MESSAGE
{
    RPC_BINDING_HANDLE Handle;
    unsigned long DataRepresentation;
    void    * Buffer;
    unsigned int BufferLength;
    unsigned int ProcNum;
    PRPC_SYNTAX_IDENTIFIER TransferSyntax;
    void    * RpcInterfaceInformation;
    void    * ReservedForRuntime;
     void     * ManagerEpv;
    void    * ImportContext;
    unsigned long RpcFlags;
} RPC_MESSAGE,    * PRPC_MESSAGE;


typedef RPC_STATUS  __stdcall  RPC_FORWARD_FUNCTION(
                          UUID                * InterfaceId,
                          RPC_VERSION         * InterfaceVersion,
                          UUID                * ObjectId,
                          unsigned char            * Rpcpro,
                          void    *    * ppDestEndpoint);

/*
 * Types of function calls for datagram and rpc
 */

/* 0b000...000 */
/* 0b000...001 */
/* 0b000...010 */
/* 0b000...100 */



#line 77 "C:\WATCOM\H\NT\rpcdcep.h"





typedef
void
( __stdcall     * RPC_DISPATCH_FUNCTION) (
          PRPC_MESSAGE Message
    );

typedef struct {
    unsigned int DispatchTableCount;
    RPC_DISPATCH_FUNCTION    * DispatchTable;
    int Reserved;
} RPC_DISPATCH_TABLE,    * PRPC_DISPATCH_TABLE;

typedef struct _RPC_PROTSEQ_ENDPOINT
{
    unsigned char    * RpcProtocolSequence;
    unsigned char    * Endpoint;
} RPC_PROTSEQ_ENDPOINT,    * PRPC_PROTSEQ_ENDPOINT;

/*
Both of these types MUST start with the InterfaceId and TransferSyntax.
Look at RpcIfInqId and I_RpcIfInqTransferSyntaxes to see why.
*/

typedef struct _RPC_SERVER_INTERFACE
{
    unsigned int Length;
    RPC_SYNTAX_IDENTIFIER InterfaceId;
    RPC_SYNTAX_IDENTIFIER TransferSyntax;
    PRPC_DISPATCH_TABLE DispatchTable;
    unsigned int RpcProtseqEndpointCount;
    PRPC_PROTSEQ_ENDPOINT RpcProtseqEndpoint;
     void     *DefaultManagerEpv;
    void const    *InterpreterInfo;
} RPC_SERVER_INTERFACE,    * PRPC_SERVER_INTERFACE;

typedef struct _RPC_CLIENT_INTERFACE
{
    unsigned int Length;
    RPC_SYNTAX_IDENTIFIER InterfaceId;
    RPC_SYNTAX_IDENTIFIER TransferSyntax;
    PRPC_DISPATCH_TABLE DispatchTable;
    unsigned int RpcProtseqEndpointCount;
    PRPC_PROTSEQ_ENDPOINT RpcProtseqEndpoint;
    unsigned long Reserved;
    void const    * InterpreterInfo;
} RPC_CLIENT_INTERFACE,    * PRPC_CLIENT_INTERFACE;

RPC_STATUS  __stdcall 
I_RpcGetBuffer (
          RPC_MESSAGE    * Message
    );

RPC_STATUS  __stdcall 
I_RpcSendReceive (
          RPC_MESSAGE    * Message
    );

RPC_STATUS  __stdcall 
I_RpcFreeBuffer (
          RPC_MESSAGE    * Message
    );

typedef void * I_RPC_MUTEX;

void  __stdcall 
I_RpcRequestMutex (
          I_RPC_MUTEX * Mutex
    );

void  __stdcall 
I_RpcClearMutex (
       I_RPC_MUTEX Mutex
    );

void  __stdcall 
I_RpcDeleteMutex (
       I_RPC_MUTEX Mutex
    );

void    *  __stdcall 
I_RpcAllocate (
       unsigned int Size
    );

void  __stdcall 
I_RpcFree (
       void    * Object
    );

void  __stdcall 
I_RpcPauseExecution (
       unsigned long Milliseconds
    );

typedef
void
( __stdcall     * PRPC_RUNDOWN) (
    void    * AssociationContext
    );

RPC_STATUS  __stdcall 
I_RpcMonitorAssociation (
       RPC_BINDING_HANDLE Handle,
       PRPC_RUNDOWN RundownRoutine,
       void * Context
    );

RPC_STATUS  __stdcall 
I_RpcStopMonitorAssociation (
       RPC_BINDING_HANDLE Handle
    );

RPC_BINDING_HANDLE  __stdcall 
I_RpcGetCurrentCallHandle(
    void
    );

RPC_STATUS  __stdcall 
I_RpcGetAssociationContext (
       void    *    * AssociationContext
    );

RPC_STATUS  __stdcall 
I_RpcSetAssociationContext (
       void    * AssociationContext
    );



RPC_STATUS  __stdcall 
I_RpcNsBindingSetEntryName (
       RPC_BINDING_HANDLE Binding,
       unsigned long EntryNameSyntax,
       unsigned short    * EntryName
    );

#line 228 "C:\WATCOM\H\NT\rpcdcep.h"



RPC_STATUS  __stdcall 
I_RpcBindingInqDynamicEndpoint (
       RPC_BINDING_HANDLE Binding,
       unsigned short    *    * DynamicEndpoint
    );

#line 246 "C:\WATCOM\H\NT\rpcdcep.h"






RPC_STATUS  __stdcall 
I_RpcBindingInqTransportType (
       RPC_BINDING_HANDLE Binding,
       unsigned int    * Type
    );

typedef struct _RPC_TRANSFER_SYNTAX
{
    UUID Uuid;
    unsigned short VersMajor;
    unsigned short VersMinor;
} RPC_TRANSFER_SYNTAX;

RPC_STATUS  __stdcall 
I_RpcIfInqTransferSyntaxes (
       RPC_IF_HANDLE RpcIfHandle,
       RPC_TRANSFER_SYNTAX    * TransferSyntaxes,
       unsigned int TransferSyntaxSize,
       unsigned int    * TransferSyntaxCount
    );

RPC_STATUS  __stdcall 
I_UuidCreate (
       UUID    * Uuid
    );

RPC_STATUS  __stdcall 
I_RpcBindingCopy (
       RPC_BINDING_HANDLE SourceBinding,
       RPC_BINDING_HANDLE    * DestinationBinding
    );

RPC_STATUS  __stdcall 
I_RpcBindingIsClientLocal (
       RPC_BINDING_HANDLE BindingHandle   ,
       unsigned int    * ClientLocalFlag
    );

void  __stdcall 
I_RpcSsDontSerializeContext (
    void
    );


RPC_STATUS  __stdcall 
I_RpcServerRegisterForwardFunction (
       RPC_FORWARD_FUNCTION    * pForwardFunction
                       );
RPC_STATUS  __stdcall 
I_RpcConnectionInqSockBuffSize(
     unsigned long    * RecvBuffSize,
     unsigned long    * SendBuffSize
  );

RPC_STATUS  __stdcall 
I_RpcConnectionSetSockBuffSize(
     unsigned long RecvBuffSize,
     unsigned long SendBuffSize
  );



typedef
RPC_STATUS
( __stdcall     * RPC_BLOCKING_FUNCTION) (
       void    *RpcWindowHandle,
       void    *Context
    );

RPC_STATUS  __stdcall 
I_RpcBindingSetAsync(
       RPC_BINDING_HANDLE Binding,
       RPC_BLOCKING_FUNCTION BlockingHook
    );

RPC_STATUS  __stdcall 
I_RpcAsyncSendReceive(
          RPC_MESSAGE    * Message,
       void    * Context
    );

RPC_STATUS  __stdcall 
I_RpcGetThreadWindowHandle(
       void    *    * WindowHandle
    );

RPC_STATUS  __stdcall 
I_RpcServerThreadPauseListening(
    );

RPC_STATUS  __stdcall 
I_RpcServerThreadContinueListening(
    );

RPC_STATUS  __stdcall 
I_RpcServerUnregisterEndpointA (
       unsigned char * Protseq,
       unsigned char * Endpoint
    );

RPC_STATUS  __stdcall 
I_RpcServerUnregisterEndpointW (
       unsigned short * Protseq,
       unsigned short * Endpoint
    );

#line 361 "C:\WATCOM\H\NT\rpcdcep.h"



// __RPC_WIN32__


}


// Reset the packing level for Dos and Windows.

#line 375 "C:\WATCOM\H\NT\rpcdcep.h"

/* __RPCDCEP_H__ */
#line 1379 "C:\WATCOM\H\NT\rpcdce.h"



}


/* __RPCDCE_H__ */
#line 59 "C:\WATCOM\H\NT\rpc.h"

#line 1 "C:\WATCOM\H\NT\rpcnsi.h"
/*++

Copyright (c) 1992-1995 Microsoft Corporation

Module Name:

    rpcnsi.h

Abstract:

    This file contains the types and function definitions to use the
    Name Service Independent APIs.

--*/




typedef void    * RPC_NS_HANDLE;












/* Server APIs */

RPC_STATUS  __stdcall 
RpcNsBindingExportA(
       unsigned long EntryNameSyntax   ,
       unsigned char    * EntryName,
       RPC_IF_HANDLE IfSpec   ,
       RPC_BINDING_VECTOR    * BindingVec   ,
       UUID_VECTOR    * ObjectUuidVec   
    );


RPC_STATUS  __stdcall 
RpcNsBindingUnexportA(
       unsigned long EntryNameSyntax   ,
       unsigned char    * EntryName,
       RPC_IF_HANDLE IfSpec   ,
       UUID_VECTOR    * ObjectUuidVec   
    );



RPC_STATUS  __stdcall 
RpcNsBindingExportW(
       unsigned long EntryNameSyntax   ,
       unsigned short    * EntryName,
       RPC_IF_HANDLE IfSpec   ,
       RPC_BINDING_VECTOR    * BindingVec   ,
       UUID_VECTOR    * ObjectUuidVec   
    );

RPC_STATUS  __stdcall 
RpcNsBindingUnexportW(
       unsigned long EntryNameSyntax   ,
       unsigned short    * EntryName,
       RPC_IF_HANDLE IfSpec   ,
       UUID_VECTOR    * ObjectUuidVec   
    );



/* Client APIs */

RPC_STATUS  __stdcall 
RpcNsBindingLookupBeginA(
       unsigned long EntryNameSyntax   ,
       unsigned char    * EntryName   ,
       RPC_IF_HANDLE IfSpec   ,
       UUID    * ObjUuid   ,
       unsigned long BindingMaxCount   ,
       RPC_NS_HANDLE    * LookupContext
    );



RPC_STATUS  __stdcall 
RpcNsBindingLookupBeginW(
       unsigned long EntryNameSyntax   ,
       unsigned short    * EntryName   ,
       RPC_IF_HANDLE IfSpec   ,
       UUID    * ObjUuid   ,
       unsigned long BindingMaxCount   ,
       RPC_NS_HANDLE    * LookupContext
    );


RPC_STATUS  __stdcall 
RpcNsBindingLookupNext(
        RPC_NS_HANDLE LookupContext,
       RPC_BINDING_VECTOR    *    * BindingVec
    );

RPC_STATUS  __stdcall 
RpcNsBindingLookupDone(
          RPC_NS_HANDLE    * LookupContext
    );

/* Group APIs */

RPC_STATUS  __stdcall 
RpcNsGroupDeleteA(
       unsigned long GroupNameSyntax   ,
       unsigned char    * GroupName
    );

RPC_STATUS  __stdcall 
RpcNsGroupMbrAddA(
       unsigned long GroupNameSyntax   ,
       unsigned char    * GroupName,
       unsigned long MemberNameSyntax   ,
       unsigned char    * MemberName
    );

RPC_STATUS  __stdcall 
RpcNsGroupMbrRemoveA(
       unsigned long GroupNameSyntax   ,
       unsigned char    * GroupName,
       unsigned long MemberNameSyntax   ,
       unsigned char    * MemberName
    );

RPC_STATUS  __stdcall 
RpcNsGroupMbrInqBeginA(
       unsigned long GroupNameSyntax   ,
       unsigned char    * GroupName,
       unsigned long MemberNameSyntax   ,
       RPC_NS_HANDLE    * InquiryContext
    );

RPC_STATUS  __stdcall 
RpcNsGroupMbrInqNextA(
        RPC_NS_HANDLE InquiryContext,
       unsigned char    *    * MemberName
    );



RPC_STATUS  __stdcall 
RpcNsGroupDeleteW(
       unsigned long GroupNameSyntax   ,
       unsigned short    * GroupName
    );

RPC_STATUS  __stdcall 
RpcNsGroupMbrAddW(
       unsigned long GroupNameSyntax   ,
       unsigned short    * GroupName,
       unsigned long MemberNameSyntax   ,
       unsigned short    * MemberName
    );

RPC_STATUS  __stdcall 
RpcNsGroupMbrRemoveW(
       unsigned long GroupNameSyntax   ,
       unsigned short    * GroupName,
       unsigned long MemberNameSyntax   ,
       unsigned short    * MemberName
    );

RPC_STATUS  __stdcall 
RpcNsGroupMbrInqBeginW(
       unsigned long GroupNameSyntax   ,
       unsigned short    * GroupName,
       unsigned long MemberNameSyntax   ,
       RPC_NS_HANDLE    * InquiryContext
    );

RPC_STATUS  __stdcall 
RpcNsGroupMbrInqNextW(
        RPC_NS_HANDLE InquiryContext,
       unsigned short    *    * MemberName
    );



RPC_STATUS  __stdcall 
RpcNsGroupMbrInqDone(
          RPC_NS_HANDLE    * InquiryContext
    );

/* Profile APIs */

RPC_STATUS  __stdcall 
RpcNsProfileDeleteA(
       unsigned long ProfileNameSyntax   ,
       unsigned char    * ProfileName
    );

RPC_STATUS  __stdcall 
RpcNsProfileEltAddA(
       unsigned long ProfileNameSyntax   ,
       unsigned char    * ProfileName,
       RPC_IF_ID    * IfId   ,
       unsigned long MemberNameSyntax   ,
       unsigned char    * MemberName,
       unsigned long Priority,
       unsigned char    * Annotation   
    );

RPC_STATUS  __stdcall 
RpcNsProfileEltRemoveA(
       unsigned long ProfileNameSyntax   ,
       unsigned char    * ProfileName,
       RPC_IF_ID    * IfId   ,
       unsigned long MemberNameSyntax   ,
       unsigned char    * MemberName
    );

RPC_STATUS  __stdcall 
RpcNsProfileEltInqBeginA(
       unsigned long ProfileNameSyntax   ,
       unsigned char    * ProfileName,
       unsigned long InquiryType,
       RPC_IF_ID    * IfId   ,
       unsigned long VersOption,
       unsigned long MemberNameSyntax   ,
       unsigned char    * MemberName   ,
       RPC_NS_HANDLE    * InquiryContext
    );

RPC_STATUS  __stdcall 
RpcNsProfileEltInqNextA(
       RPC_NS_HANDLE InquiryContext,
       RPC_IF_ID    * IfId,
       unsigned char    *    * MemberName,
       unsigned long    * Priority,
       unsigned char    *    * Annotation
    );



RPC_STATUS  __stdcall 
RpcNsProfileDeleteW(
       unsigned long ProfileNameSyntax   ,
       unsigned short    * ProfileName
    );

RPC_STATUS  __stdcall 
RpcNsProfileEltAddW(
       unsigned long ProfileNameSyntax   ,
       unsigned short    * ProfileName,
       RPC_IF_ID    * IfId   ,
       unsigned long MemberNameSyntax   ,
       unsigned short    * MemberName,
       unsigned long Priority,
       unsigned short    * Annotation   
    );

RPC_STATUS  __stdcall 
RpcNsProfileEltRemoveW(
       unsigned long ProfileNameSyntax   ,
       unsigned short    * ProfileName,
       RPC_IF_ID    * IfId   ,
       unsigned long MemberNameSyntax   ,
       unsigned short    * MemberName
    );

RPC_STATUS  __stdcall 
RpcNsProfileEltInqBeginW(
       unsigned long ProfileNameSyntax   ,
       unsigned short    * ProfileName,
       unsigned long InquiryType,
       RPC_IF_ID    * IfId   ,
       unsigned long VersOption,
       unsigned long MemberNameSyntax   ,
       unsigned short    * MemberName   ,
       RPC_NS_HANDLE    * InquiryContext
    );

RPC_STATUS  __stdcall 
RpcNsProfileEltInqNextW(
       RPC_NS_HANDLE InquiryContext,
       RPC_IF_ID    * IfId,
       unsigned short    *    * MemberName,
       unsigned long    * Priority,
       unsigned short    *    * Annotation
    );



RPC_STATUS  __stdcall 
RpcNsProfileEltInqDone(
          RPC_NS_HANDLE    * InquiryContext
    );

/* Entry object APIs */

RPC_STATUS  __stdcall 
RpcNsEntryObjectInqBeginA(
       unsigned long EntryNameSyntax   ,
       unsigned char    * EntryName,
       RPC_NS_HANDLE    * InquiryContext
    );



RPC_STATUS  __stdcall 
RpcNsEntryObjectInqBeginW(
       unsigned long EntryNameSyntax   ,
       unsigned short    * EntryName,
       RPC_NS_HANDLE    * InquiryContext
    );



RPC_STATUS  __stdcall 
RpcNsEntryObjectInqNext(
        RPC_NS_HANDLE InquiryContext,
       UUID    * ObjUuid
    );

RPC_STATUS  __stdcall 
RpcNsEntryObjectInqDone(
          RPC_NS_HANDLE    * InquiryContext
    );

/* Management and MISC APIs */

RPC_STATUS  __stdcall 
RpcNsEntryExpandNameA(
       unsigned long EntryNameSyntax   ,
       unsigned char    * EntryName,
       unsigned char    *    * ExpandedName
    );

RPC_STATUS  __stdcall 
RpcNsMgmtBindingUnexportA(
       unsigned long EntryNameSyntax   ,
       unsigned char    * EntryName,
       RPC_IF_ID    * IfId   ,
       unsigned long VersOption,
       UUID_VECTOR    * ObjectUuidVec   
    );

RPC_STATUS  __stdcall 
RpcNsMgmtEntryCreateA(
       unsigned long EntryNameSyntax   ,
       unsigned char    * EntryName
    );

RPC_STATUS  __stdcall 
RpcNsMgmtEntryDeleteA(
       unsigned long EntryNameSyntax   ,
       unsigned char    * EntryName
    );

RPC_STATUS  __stdcall 
RpcNsMgmtEntryInqIfIdsA(
       unsigned long EntryNameSyntax   ,
       unsigned char    * EntryName,
       RPC_IF_ID_VECTOR    *    * IfIdVec
    );

RPC_STATUS  __stdcall 
RpcNsMgmtHandleSetExpAge(
       RPC_NS_HANDLE NsHandle,
       unsigned long ExpirationAge
    );

RPC_STATUS  __stdcall 
RpcNsMgmtInqExpAge(
       unsigned long    * ExpirationAge
    );

RPC_STATUS  __stdcall 
RpcNsMgmtSetExpAge(
       unsigned long ExpirationAge
    );



RPC_STATUS  __stdcall 
RpcNsEntryExpandNameW(
       unsigned long EntryNameSyntax   ,
       unsigned short    * EntryName,
       unsigned short    *    * ExpandedName
    );

RPC_STATUS  __stdcall 
RpcNsMgmtBindingUnexportW(
       unsigned long EntryNameSyntax   ,
       unsigned short    * EntryName,
       RPC_IF_ID    * IfId   ,
       unsigned long VersOption,
       UUID_VECTOR    * ObjectUuidVec   
    );

RPC_STATUS  __stdcall 
RpcNsMgmtEntryCreateW(
       unsigned long EntryNameSyntax   ,
       unsigned short    * EntryName
    );

RPC_STATUS  __stdcall 
RpcNsMgmtEntryDeleteW(
       unsigned long EntryNameSyntax   ,
       unsigned short    * EntryName
    );

RPC_STATUS  __stdcall 
RpcNsMgmtEntryInqIfIdsW(
       unsigned long EntryNameSyntax   ,
       unsigned short    * EntryName,
       RPC_IF_ID_VECTOR    *    * IfIdVec
    );



/* Client API's implemented in wrappers. */

RPC_STATUS  __stdcall 
RpcNsBindingImportBeginA(
       unsigned long EntryNameSyntax   ,
       unsigned char    * EntryName   ,
       RPC_IF_HANDLE IfSpec   ,
       UUID    * ObjUuid   ,
       RPC_NS_HANDLE    * ImportContext
    );



RPC_STATUS  __stdcall 
RpcNsBindingImportBeginW(
       unsigned long EntryNameSyntax   ,
       unsigned short    * EntryName   ,
       RPC_IF_HANDLE IfSpec   ,
       UUID    * ObjUuid   ,
       RPC_NS_HANDLE    * ImportContext
    );



RPC_STATUS  __stdcall 
RpcNsBindingImportNext(
       RPC_NS_HANDLE ImportContext,
       RPC_BINDING_HANDLE     * Binding
    );

RPC_STATUS  __stdcall 
RpcNsBindingImportDone(
          RPC_NS_HANDLE    * ImportContext
    );

RPC_STATUS  __stdcall 
RpcNsBindingSelect(
          RPC_BINDING_VECTOR    * BindingVec,
       RPC_BINDING_HANDLE     * Binding
    );

#line 485 "C:\WATCOM\H\NT\rpcnsi.h"






















/* UNICODE */

/* __RPCNSI_H__ */
#line 60 "C:\WATCOM\H\NT\rpc.h"

#line 1 "C:\WATCOM\H\NT\rpcnterr.h"
/*********************************************************/
/**               Microsoft LAN Manager                 **/
/**       Copyright(c) Microsoft Corp., 1987-1995       **/
/**                                                     **/
/**     Rpc Error Codes from the compiler and runtime   **/
/**                                                     **/
/*********************************************************/

/*
If you change this file, you must also change rpcerr.h.
*/





















/* __RPCNTERR_H__ */
#line 61 "C:\WATCOM\H\NT\rpc.h"



#line 1 "C:\WATCOM\H\NT\excpt.h"
/*
 *  excpt.h	Structured Exception Handling types, defines and routines
 *
 *  Copyright by WATCOM International Corp. 1988-1996.  All rights reserved.
 */




extern "C" {



/*
 * Exception disposition return values.
 */
typedef enum _EXCEPTION_DISPOSITION {
    ExceptionContinueExecution,
    ExceptionContinueSearch,
    ExceptionNestedException,
    ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION;


/*
 * Prototype for SEH support function.
 */
struct _EXCEPTION_RECORD;
struct _CONTEXT;

EXCEPTION_DISPOSITION __cdecl _except_handler (
	struct _EXCEPTION_RECORD *ExceptionRecord,
	void * EstablisherFrame,
	struct _CONTEXT *ContextRecord,
	void * DispatcherContext
	);

/*
 * Keywords and intrinsics for SEH
 */











unsigned long __cdecl _exception_code(void);
void *	      __cdecl _exception_info(void);
int	      __cdecl _abnormal_termination(void);


/*
 * Legal values for expression in except().
 */






};


#line 64 "C:\WATCOM\H\NT\rpc.h"

#line 1 "C:\WATCOM\H\NT\winerror.h"
/************************************************************************
*                                                                       *
*   winerror.h --  error code definitions for the Win32 API functions   *  
*                                                                       *
*   Copyright (c) 1991-1995, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/

// _WINERROR_#line 8859 "C:\WATCOM\H\NT\winerror.h"
#line 65 "C:\WATCOM\H\NT\rpc.h"






// trystmts






// exceptstmts








// trystmts






// finallystmts







RPC_STATUS  __stdcall 
RpcImpersonateClient (
       RPC_BINDING_HANDLE BindingHandle   
    );

RPC_STATUS  __stdcall 
RpcRevertToSelf (
    );

long  __stdcall 
I_RpcMapWin32Status (
       RPC_STATUS Status
    );


}


// __RPC_H__

#line 175 "C:\WATCOM\H\NT\windows.h"

#line 1 "C:\WATCOM\H\NT\shellapi.h"
/*****************************************************************************
*                                                                             *
* shellapi.h -  SHELL.DLL functions, types, and definitions                   *
*                                                                             *
* Copyright (c) 1992-1995, Microsoft Corp.  All rights reserved               *
*                                                                             *
\*****************************************************************************/






//
// Define API decoration for direct importing of DLL references.
//



#line 23 "C:\WATCOM\H\NT\shellapi.h"
// WINSHELLAPI

#line 1 "C:\WATCOM\H\NT\pshpack1.h"
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pshpack1.h

Abstract:

    This file turns 1 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push)

#pragma pack(1)
#line 32 "C:\WATCOM\H\NT\pshpack1.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 25 "C:\WATCOM\H\NT\shellapi.h"



extern "C" {            /* Assume C declarations for C++ */ 
/* __cplusplus */



 typedef HANDLE HDROP ;

 __declspec(dllimport)  UINT  __stdcall  DragQueryFileA(HDROP,UINT,LPSTR,UINT);
 __declspec(dllimport)  UINT  __stdcall  DragQueryFileW(HDROP,UINT,LPWSTR,UINT);
#line 40 "C:\WATCOM\H\NT\shellapi.h"

// !UNICODE
 __declspec(dllimport)  BOOL  __stdcall  DragQueryPoint(HDROP,LPPOINT);
 __declspec(dllimport)   void   __stdcall  DragFinish(HDROP);
 __declspec(dllimport)   void   __stdcall  DragAcceptFiles(HWND,BOOL);

 __declspec(dllimport)  HINSTANCE  __stdcall  ShellExecuteA(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd);
 __declspec(dllimport)  HINSTANCE  __stdcall  ShellExecuteW(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd);
#line 51 "C:\WATCOM\H\NT\shellapi.h"

// !UNICODE
 __declspec(dllimport)  HINSTANCE  __stdcall  FindExecutableA(LPCSTR lpFile, LPCSTR lpDirectory, LPSTR lpResult);
 __declspec(dllimport)  HINSTANCE  __stdcall  FindExecutableW(LPCWSTR lpFile, LPCWSTR lpDirectory, LPWSTR lpResult);
#line 58 "C:\WATCOM\H\NT\shellapi.h"

// !UNICODE
 __declspec(dllimport)  LPWSTR *   __stdcall  CommandLineToArgvW(LPCWSTR lpCmdLine, int*pNumArgs);

 __declspec(dllimport)  INT        __stdcall  ShellAboutA(HWND hWnd, LPCSTR szApp, LPCSTR szOtherStuff, HICON hIcon);
 __declspec(dllimport)  INT        __stdcall  ShellAboutW(HWND hWnd, LPCWSTR szApp, LPCWSTR szOtherStuff, HICON hIcon);
#line 67 "C:\WATCOM\H\NT\shellapi.h"

// !UNICODE
 __declspec(dllimport)  HICON      __stdcall  DuplicateIcon(HINSTANCE hInst, HICON hIcon);
 __declspec(dllimport)  HICON      __stdcall  ExtractAssociatedIconA(HINSTANCE hInst, LPSTR lpIconPath, LPWORD lpiIcon);
 __declspec(dllimport)  HICON      __stdcall  ExtractAssociatedIconW(HINSTANCE hInst, LPWSTR lpIconPath, LPWORD lpiIcon);
#line 75 "C:\WATCOM\H\NT\shellapi.h"

// !UNICODE
 __declspec(dllimport)  HICON      __stdcall  ExtractIconA(HINSTANCE hInst, LPCSTR lpszExeFileName, UINT nIconIndex);
 __declspec(dllimport)  HICON      __stdcall  ExtractIconW(HINSTANCE hInst, LPCWSTR lpszExeFileName, UINT nIconIndex);
#line 82 "C:\WATCOM\H\NT\shellapi.h"

// !UNICODE

 
typedef struct _DRAGINFOA {
    UINT uSize;                 /* init with sizeof(DRAGINFO) */ 
    POINT pt;
    BOOL fNC;
    LPSTR   lpFileList;
    DWORD grfKeyState;
} DRAGINFOA,   * LPDRAGINFOA;
typedef struct _DRAGINFOW {
    UINT uSize;                 /* init with sizeof(DRAGINFO) */ 
    POINT pt;
    BOOL fNC;
    LPWSTR  lpFileList;
    DWORD grfKeyState;
} DRAGINFOW,   * LPDRAGINFOW;
#line 104 "C:\WATCOM\H\NT\shellapi.h"
typedef DRAGINFOA DRAGINFO;
typedef LPDRAGINFOA LPDRAGINFO;
// UNICODE


////
//// AppBar stuff
////






// lParam == TRUE/FALSE means activate/deactivate

// this can fail at any time.  MUST check the result
                                        // lParam = TRUE/FALSE  Set/Unset
                                        // uEdge = what edge



// these are put in the wparam of callback messages



// lParam == TRUE means hide

// flags for get state








typedef struct _AppBarData
{
    DWORD cbSize;
    HWND hWnd;
    UINT uCallbackMessage;
    UINT uEdge;
    RECT rc;
    LPARAM lParam; // message specific 
} APPBARDATA, *PAPPBARDATA;

 __declspec(dllimport)  UINT  __stdcall  SHAppBarMessage(DWORD dwMessage, PAPPBARDATA pData);

////
////  EndAppBar
////



 __declspec(dllimport)  DWORD    __stdcall  DoEnvironmentSubstA(LPSTR szString, UINT cbString);
 __declspec(dllimport)  DWORD    __stdcall  DoEnvironmentSubstW(LPWSTR szString, UINT cbString);
#line 164 "C:\WATCOM\H\NT\shellapi.h"

// !UNICODE
 __declspec(dllimport)  LPSTR  __stdcall  FindEnvironmentStringA(LPSTR szEnvVar);
 __declspec(dllimport)  LPWSTR  __stdcall  FindEnvironmentStringW(LPWSTR szEnvVar);
#line 171 "C:\WATCOM\H\NT\shellapi.h"

// !UNICODE


 __declspec(dllimport)  UINT  __stdcall  ExtractIconExA(LPCSTR lpszFile, int nIconIndex, HICON    *phiconLarge, HICON    *phiconSmall, UINT nIcons);
 __declspec(dllimport)  UINT  __stdcall  ExtractIconExW(LPCWSTR lpszFile, int nIconIndex, HICON    *phiconLarge, HICON    *phiconSmall, UINT nIcons);
#line 180 "C:\WATCOM\H\NT\shellapi.h"

// !UNICODE



////
//// Shell File Operations
////

//these need to be kept in sync with the ones in shlobj.h








// don't create progress/report

// Don't prompt the user.
// Fill in SHFILEOPSTRUCT.hNameMappings
                                      // Must be freed using SHFreeNameMappings

// on *.*, do only files
// means don't show names of files
// don't confirm making any needed dirs

typedef WORD FILEOP_FLAGS;

// printer is being deleted
// printer is being renamed
// port this printer connected to is being changed
                                // if this id is set, the strings received by
                                // the copyhook are a doubly-null terminated
                                // list of strings.  The first is the printer
                                // name and the second is the printer port.
// PO_RENAME and PO_PORTCHANGE at same time.

// no POF_ flags currently defined

typedef WORD PRINTEROP_FLAGS;

// FO_MOVE

// implicit parameters are:
//      if pFrom or pTo are unqualified names the current directories are
//      taken from the global current drive/directory settings managed
//      by Get/SetCurrentDrive/Directory
//
//      the global confirmation settings

typedef struct _SHFILEOPSTRUCTA
{
        HWND            hwnd;
        UINT            wFunc;
        LPCSTR          pFrom;
        LPCSTR          pTo;
        FILEOP_FLAGS    fFlags;
        BOOL            fAnyOperationsAborted;
        LPVOID          hNameMappings;
        LPCSTR           lpszProgressTitle; // only used if FOF_SIMPLEPROGRESS 
} SHFILEOPSTRUCTA,    *LPSHFILEOPSTRUCTA;
typedef struct _SHFILEOPSTRUCTW
{
        HWND            hwnd;
        UINT            wFunc;
        LPCWSTR         pFrom;
        LPCWSTR         pTo;
        FILEOP_FLAGS    fFlags;
        BOOL            fAnyOperationsAborted;
        LPVOID          hNameMappings;
        LPCWSTR          lpszProgressTitle; // only used if FOF_SIMPLEPROGRESS 
} SHFILEOPSTRUCTW,    *LPSHFILEOPSTRUCTW;
#line 258 "C:\WATCOM\H\NT\shellapi.h"
typedef SHFILEOPSTRUCTA SHFILEOPSTRUCT;
typedef LPSHFILEOPSTRUCTA LPSHFILEOPSTRUCT;
// UNICODE

 __declspec(dllimport)  int  __stdcall  SHFileOperationA(LPSHFILEOPSTRUCTA lpFileOp);
 __declspec(dllimport)  int  __stdcall  SHFileOperationW(LPSHFILEOPSTRUCTW lpFileOp);
#line 267 "C:\WATCOM\H\NT\shellapi.h"

// !UNICODE

 __declspec(dllimport)  void  __stdcall  SHFreeNameMappings(HANDLE hNameMappings);

typedef struct _SHNAMEMAPPINGA
{
    LPSTR   pszOldPath;
    LPSTR   pszNewPath;
    int   cchOldPath;
    int   cchNewPath;
} SHNAMEMAPPINGA,    *LPSHNAMEMAPPINGA;
typedef struct _SHNAMEMAPPINGW
{
    LPWSTR  pszOldPath;
    LPWSTR  pszNewPath;
    int   cchOldPath;
    int   cchNewPath;
} SHNAMEMAPPINGW,    *LPSHNAMEMAPPINGW;
#line 290 "C:\WATCOM\H\NT\shellapi.h"
typedef SHNAMEMAPPINGA SHNAMEMAPPING;
typedef LPSHNAMEMAPPINGA LPSHNAMEMAPPING;
// UNICODE






////
//// End Shell File Operations
////

////
////  Begin ShellExecuteEx and family
////









/* ShellExecute() and ShellExecuteEx() error codes */

/* regular WinExec() codes */
// file not found
// path not found
// access denied
// out of memory


/* WINVER >= 0x0400 */

/* error values for ShellExecute() beyond the regular WinExec() codes */







 

// Note CLASSKEY overrides CLASSNAME


// Note INVOKEIDLIST overrides IDLIST











typedef struct _SHELLEXECUTEINFOA
{
        DWORD cbSize;
        ULONG fMask;
        HWND hwnd;
        LPCSTR   lpVerb;
        LPCSTR   lpFile;
        LPCSTR   lpParameters;
        LPCSTR   lpDirectory;
        int nShow;
        HINSTANCE hInstApp;
        // Optional fields
        LPVOID lpIDList;
        LPCSTR   lpClass;
        HKEY hkeyClass;
        DWORD dwHotKey;
        HANDLE hIcon;
        HANDLE hProcess;
} SHELLEXECUTEINFOA,    *LPSHELLEXECUTEINFOA;
typedef struct _SHELLEXECUTEINFOW
{
        DWORD cbSize;
        ULONG fMask;
        HWND hwnd;
        LPCWSTR  lpVerb;
        LPCWSTR  lpFile;
        LPCWSTR  lpParameters;
        LPCWSTR  lpDirectory;
        int nShow;
        HINSTANCE hInstApp;
        // Optional fields
        LPVOID lpIDList;
        LPCWSTR  lpClass;
        HKEY hkeyClass;
        DWORD dwHotKey;
        HANDLE hIcon;
        HANDLE hProcess;
} SHELLEXECUTEINFOW,    *LPSHELLEXECUTEINFOW;
#line 393 "C:\WATCOM\H\NT\shellapi.h"
typedef SHELLEXECUTEINFOA SHELLEXECUTEINFO;
typedef LPSHELLEXECUTEINFOA LPSHELLEXECUTEINFO;
// UNICODE

 __declspec(dllimport)  BOOL  __stdcall  ShellExecuteExA(LPSHELLEXECUTEINFOA lpExecInfo);
 __declspec(dllimport)  BOOL  __stdcall  ShellExecuteExW(LPSHELLEXECUTEINFOW lpExecInfo);
#line 402 "C:\WATCOM\H\NT\shellapi.h"

// !UNICODE
 __declspec(dllimport)  void  __stdcall  WinExecErrorA(HWND hwnd, int error, LPCSTR lpstrFileName, LPCSTR lpstrTitle);
 __declspec(dllimport)  void  __stdcall  WinExecErrorW(HWND hwnd, int error, LPCWSTR lpstrFileName, LPCWSTR lpstrTitle);
#line 409 "C:\WATCOM\H\NT\shellapi.h"

// !UNICODE

////
////  End ShellExecuteEx and family
////


////
//// Tray notification definitions
////

typedef struct _NOTIFYICONDATAA {
        DWORD cbSize;
        HWND hWnd;
        UINT uID;
        UINT uFlags;
        UINT uCallbackMessage;
        HICON hIcon;
        CHAR   szTip[64];
} NOTIFYICONDATAA, *PNOTIFYICONDATAA;
typedef struct _NOTIFYICONDATAW {
        DWORD cbSize;
        HWND hWnd;
        UINT uID;
        UINT uFlags;
        UINT uCallbackMessage;
        HICON hIcon;
        WCHAR  szTip[64];
} NOTIFYICONDATAW, *PNOTIFYICONDATAW;
#line 443 "C:\WATCOM\H\NT\shellapi.h"
typedef NOTIFYICONDATAA NOTIFYICONDATA;
typedef PNOTIFYICONDATAA PNOTIFYICONDATA;
// UNICODE










 __declspec(dllimport)  BOOL  __stdcall  Shell_NotifyIconA(DWORD dwMessage, PNOTIFYICONDATAA lpData);
 __declspec(dllimport)  BOOL  __stdcall  Shell_NotifyIconW(DWORD dwMessage, PNOTIFYICONDATAW lpData);
#line 461 "C:\WATCOM\H\NT\shellapi.h"

// !UNICODE

////
//// End Tray Notification Icons
////



////
//// Begin SHGetFileInfo
////

/*
 * The SHGetFileInfo API provides an easy way to get attributes
 * for a file given a pathname.
 *
 *   PARAMETERS
 *
 *     pszPath              file name to get info about
 *     dwFileAttributes     file attribs, only used with SHGFI_USEFILEATTRIBUTES
 *     psfi                 place to return file info
 *     cbFileInfo           size of structure
 *     uFlags               flags
 *
 *   RETURN
 *     TRUE if things worked
 */

typedef struct _SHFILEINFOA
{
        HICON       hIcon;                      // out: icon 
        int         iIcon;                      // out: icon index 
        DWORD       dwAttributes;               // out: SFGAO_ flags 
        CHAR        szDisplayName[ 260 ];    // out: display name (or path) 
        CHAR        szTypeName[80];             // out: type name 
} SHFILEINFOA;
typedef struct _SHFILEINFOW
{
        HICON       hIcon;                      // out: icon 
        int         iIcon;                      // out: icon index 
        DWORD       dwAttributes;               // out: SFGAO_ flags 
        WCHAR       szDisplayName[ 260 ];    // out: display name (or path) 
        WCHAR       szTypeName[80];             // out: type name 
} SHFILEINFOW;
#line 509 "C:\WATCOM\H\NT\shellapi.h"
typedef SHFILEINFOA SHFILEINFO;
// UNICODE

// get icon
// get display name
// get type name
// get attributes
// get icon location
// return exe type
// get system icon index
// put a link overlay on icon
// show icon in selected state
// get large icon
// get small icon
// get open icon
// get shell size icon
// pszPath is a pidl
// use passed dwFileAttribute

 __declspec(dllimport)  DWORD  __stdcall  SHGetFileInfoA(LPCSTR pszPath, DWORD dwFileAttributes, SHFILEINFOA    *psfi, UINT cbFileInfo, UINT uFlags);
 __declspec(dllimport)  DWORD  __stdcall  SHGetFileInfoW(LPCWSTR pszPath, DWORD dwFileAttributes, SHFILEINFOW    *psfi, UINT cbFileInfo, UINT uFlags);
#line 533 "C:\WATCOM\H\NT\shellapi.h"

// !UNICODE


 __declspec(dllimport)  BOOL  __stdcall  SHGetNewLinkInfoA(LPCSTR pszLinkTo, LPCSTR pszDir, LPSTR pszName,
                             BOOL    * pfMustCopy, UINT uFlags);
 __declspec(dllimport)  BOOL  __stdcall  SHGetNewLinkInfoW(LPCWSTR pszLinkTo, LPCWSTR pszDir, LPWSTR pszName,
                             BOOL    * pfMustCopy, UINT uFlags);
#line 544 "C:\WATCOM\H\NT\shellapi.h"

// !UNICODE

// pszLinkTo is a pidl
// Make name "Shortcut to xxx"


////
//// End SHGetFileInfo
////




/* WINVER >= 0x0400 */


}
/* __cplusplus */

#line 1 "C:\WATCOM\H\NT\poppack.h"
/*++

Copyright (c) 1990,95  Microsoft Corporation

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)
#line 33 "C:\WATCOM\H\NT\poppack.h"
#line 36 "C:\WATCOM\H\NT\poppack.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 564 "C:\WATCOM\H\NT\shellapi.h"


/* _INC_SHELLAPI */
#line 176 "C:\WATCOM\H\NT\windows.h"

#line 1 "C:\WATCOM\H\NT\winperf.h"
/*++

Copyright (C) 1993 - 1995 Microsoft Corporation

Module Name:

    winperf.h

Abstract:

    Header file for the Performance Monitor data.

    This file contains the definitions of the data structures returned
    by the Configuration Registry in response to a request for
    performance data.  This file is used by both the Configuration
    Registry and the Performance Monitor to define their interface.
    The complete interface is described here, except for the name
    of the node to query in the registry.  It is

                   HKEY_PERFORMANCE_DATA.

    By querying that node with a subkey of "Global" the caller will
    retrieve the structures described here.

    There is no need to RegOpenKey() the reserved handle HKEY_PERFORMANCE_DATA,
    but the caller should RegCloseKey() the handle so that network transports
    and drivers can be removed or installed (which cannot happen while
    they are open for monitoring.)  Remote requests must first
    RegConnectRegistry().

--*/




//  Data structure definitions.

//  In order for data to be returned through the Configuration Registry
//  in a system-independent fashion, it must be self-describing.

//  In the following, all offsets are in bytes.

//
//  Data is returned through the Configuration Registry in a
//  a data block which begins with a _PERF_DATA_BLOCK structure.
//





typedef struct _PERF_DATA_BLOCK {
    WCHAR           Signature[4];       // Signature: Unicode "PERF" 
    DWORD           LittleEndian;       // 0 = Big Endian, 1 = Little Endian 
    DWORD           Version;            // Version of these data structures 
                                        // starting at 1
    DWORD           Revision;           // Revision of these data structures 
                                        // starting at 0 for each Version
    DWORD           TotalByteLength;    // Total length of data block 
    DWORD           HeaderLength;       // Length of this structure 
    DWORD           NumObjectTypes;     // Number of types of objects 
                                        // being reported
    LONG            DefaultObject;      // Object Title Index of default 
                                        // object to display when data from
                                        // this system is retrieved (-1 =
                                        // none, but this is not expected to
                                        // be used)
    SYSTEMTIME      SystemTime;         // Time at the system under 
                                        // measurement
    LARGE_INTEGER   PerfTime;           // Performance counter value 
                                        // at the system under measurement
    LARGE_INTEGER   PerfFreq;           // Performance counter frequency 
                                        // at the system under measurement
    LARGE_INTEGER   PerfTime100nSec;    // Performance counter time in 100 nsec 
                                        // units at the system under measurement
    DWORD           SystemNameLength;   // Length of the system name 
    DWORD           SystemNameOffset;   // Offset, from beginning of this 
                                        // structure, to name of system
                                        // being measured
} PERF_DATA_BLOCK, *PPERF_DATA_BLOCK;


//
//  The _PERF_DATA_BLOCK structure is followed by NumObjectTypes of
//  data sections, one for each type of object measured.  Each object
//  type section begins with a _PERF_OBJECT_TYPE structure.
//


typedef struct _PERF_OBJECT_TYPE {
    DWORD           TotalByteLength;    // Length of this object definition 
                                        // including this structure, the
                                        // counter definitions, and the
                                        // instance definitions and the
                                        // counter blocks for each instance:
                                        // This is the offset from this
                                        // structure to the next object, if
                                        // any
    DWORD           DefinitionLength;   // Length of object definition, 
                                        // which includes this structure
                                        // and the counter definition
                                        // structures for this object: this
                                        // is the offset of the first
                                        // instance or of the counters
                                        // for this object if there is
                                        // no instance
    DWORD           HeaderLength;       // Length of this structure: this 
                                        // is the offset to the first
                                        // counter definition for this
                                        // object
    DWORD           ObjectNameTitleIndex;
                                        // Index to name in Title Database
    LPWSTR          ObjectNameTitle;    // Initially NULL, for use by 
                                        // analysis program to point to
                                        // retrieved title string
    DWORD           ObjectHelpTitleIndex;
                                        // Index to Help in Title Database
    LPWSTR          ObjectHelpTitle;    // Initially NULL, for use by 
                                        // analysis program to point to
                                        // retrieved title string
    DWORD           DetailLevel;        // Object level of detail (for 
                                        // controlling display complexity);
                                        // will be min of detail levels
                                        // for all this object's counters
    DWORD           NumCounters;        // Number of counters in each 
                                        // counter block (one counter
                                        // block per instance)
    LONG            DefaultCounter;     // Default counter to display when 
                                        // this object is selected, index
                                        // starting at 0 (-1 = none, but
                                        // this is not expected to be used)
    LONG            NumInstances;       // Number of object instances 
                                        // for which counters are being
                                        // returned from the system under
                                        // measurement. If the object defined
                                        // will never have any instance data
                                        // structures (PERF_INSTANCE_DEFINITION)
                                        // then this value should be -1, if the
                                        // object can have 0 or more instances,
                                        // but has none present, then this
                                        // should be 0, otherwise this field
                                        // contains the number of instances of
                                        // this counter.
    DWORD           CodePage;           // 0 if instance strings are in 
                                        // UNICODE, else the Code Page of
                                        // the instance names
    LARGE_INTEGER   PerfTime;           // Sample Time in "Object" units 
                                        //
    LARGE_INTEGER   PerfFreq;           // Frequency of "Object" units in 
                                        // counts per second.
} PERF_OBJECT_TYPE, *PPERF_OBJECT_TYPE;

// no instances (see NumInstances above)
//
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//
//  PERF_COUNTER_DEFINITION.CounterType field values
//
//
//        Counter ID Field Definition:
//
//   3      2        2    2    2        1        1    1
//   1      8        4    2    0        6        2    0    8                0
//  +--------+--------+----+----+--------+--------+----+----+----------------+
//  |Display |Calculation  |Time|Counter |        |Ctr |Size|                |
//  |Flags   |Modifiers    |Base|SubType |Reserved|Type|Fld |   Reserved     |
//  +--------+--------+----+----+--------+--------+----+----+----------------+
//
//
//  The counter type is the "or" of the following values as described below
//
//  select one of the following to indicate the counter's data size
//


// for Zero Length fields
// length is in CounterLength field
                                            //  of Counter Definition struct
//
//  select one of the following values to indicate the counter field usage
//
// a number (not a counter)
// an increasing numeric value
// a text field
// displays a zero
//
//  If the PERF_TYPE_NUMBER field was selected, then select one of the
//  following to describe the Number
//
// display as HEX value
// display as a decimal integer
// display as a decimal/1000
//
//  If the PERF_TYPE_COUNTER value was selected then select one of the
//  following to indicate the type of counter
//
// display counter value
// divide ctr / delta time
// divide ctr / base
// base value used in fractions
// subtract counter from current time
// Use Queuelen processing func.
// Counter begins or ends a histogram
//
//  If the PERF_TYPE_TEXT value was selected, then select one of the
//  following to indicate the type of TEXT data.
//
// type of text in text field
// ASCII using the CodePage field
//
//  Timer SubTypes
//
// use system perf. freq for base
// use 100 NS timer time base units
// use the object timer freq
//
//  Any types that have calculations performed can use one or more of
//  the following calculation modification flags listed here
//
// compute difference first
// compute base diff as well
// show as 1.00-value (assumes:
// sum of multiple instances
//
//  Select one of the following values to indicate the display suffix (if any)
//
// no suffix
// "/sec"
// "%"
// "secs"
// value is not displayed
//
//  Predefined counter types
//

// 32-bit Counter.  Divide delta by delta time.  Display suffix: "/sec"





// 64-bit Timer.  Divide delta by delta time.  Display suffix: "%"




// Queue Length Space-Time Product. Divide delta by delta time. No Display Suffix.




// 64-bit Counter.  Divide delta by delta time. Display Suffix: "/sec"




// Indicates the counter is not a  counter but rather Unicode text Display as text.




// Indicates the data is a counter  which should not be
// time averaged on display (such as an error counter on a serial line)
// Display as is.  No Display Suffix.




// Same as PERF_COUNTER_RAWCOUNT except its size is a large integer




// Special case for RAWCOUNT that want to be displayed in hex
// Indicates the data is a counter  which should not be
// time averaged on display (such as an error counter on a serial line)
// Display as is.  No Display Suffix.




// Same as PERF_COUNTER_RAWCOUNT_HEX except its size is a large integer





// A count which is either 1 or 0 on each sampling interrupt (% busy)
// Divide delta by delta base. Display Suffix: "%"




// A count which is sampled on each sampling interrupt (queue length)
// Divide delta by delta time. No Display Suffix.




// A label: no data is associated with this counter (it has 0 length)
// Do not display.



// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 - delta divided by delta time.  Display suffix: "%"





// The divisor for a sample, used with the previous counter to form a
// sampled %.  You must check for >0 before dividing by this!  This
// counter will directly follow the  numerator counter.  It should not
// be displayed to the user.



// for compatibility with pre-beta versions

// A timer which, when divided by an average base, produces a time
// in seconds which is the average time of some operation.  This
// timer times total operations, and  the base is the number of opera-
// tions.  Display Suffix: "sec"




// Used as the denominator in the computation of time or count
// averages.  Must directly follow the numerator counter.  Not dis-
// played to the user.



// for compatibility with pre-beta versions


// A bulk count which, when divided (typically) by the number of
// operations, gives (typically) the number of bytes per operation.
// No Display Suffix.




// 64-bit Timer in 100 nsec units. Display delta divided by
// delta time.  Display suffix: "%"




// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 - delta divided by delta time.  Display suffix: "%"





// 64-bit Timer.  Divide delta by delta time.  Display suffix: "%"
// Timer for multiple instances, so result can exceed 100%.





// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 * _MULTI_BASE - delta divided by delta time.
// Display suffix: "%" Timer for multiple instances, so result
// can exceed 100%.  Followed by a counter of type _MULTI_BASE.





// Number of instances to which the preceding _MULTI_..._INV counter
// applies.  Used as a factor to get the percentage.




// 64-bit Timer in 100 nsec units. Display delta divided by delta time.
// Display suffix: "%" Timer for multiple instances, so result can exceed 100%.





// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 * _MULTI_BASE - delta divided by delta time.
// Display suffix: "%" Timer for multiple instances, so result
// can exceed 100%.  Followed by a counter of type _MULTI_BASE.





// Indicates the data is a fraction of the following counter  which
// should not be time averaged on display (such as free space over
// total space.) Display as is.  Display the quotient as "%".




// Indicates the data is a base for the preceding counter which should
// not be time averaged on display (such as free space over total space.)



// for compatibility with pre-beta versions

// The data collected in this counter is actually the start time of the
// item being measured. For display, this data is subtracted from the
// sample time to yield the elapsed time as the difference between the two.
// In the definition below, the PerfTime field of the Object contains
// the sample time as indicated by the PERF_OBJECT_TIMER bit and the
// difference is scaled by the PerfFreq of the Object to convert the time
// units into seconds.



//
//  The following counter type can be used with the preceding types to
//  define a range of values to be displayed in a histogram.
//


                                        // Counter begins or ends a histogram

//
//  The following are used to determine the level of detail associated
//  with the counter.  The user will be setting the level of detail
//  that should be displayed at any given time.
//

// The uninformed can understand it
// For the advanced user
// For the expert user
// For the system designer


//
//  There is one of the following for each of the
//  PERF_OBJECT_TYPE.NumCounters.  The Unicode names in this structure MUST
//  come from a message file.
//

typedef struct _PERF_COUNTER_DEFINITION {
    DWORD           ByteLength;         // Length in bytes of this structure 
    DWORD           CounterNameTitleIndex;
                                        // Index of Counter name into
                                        // Title Database
    LPWSTR          CounterNameTitle;   // Initially NULL, for use by 
                                        // analysis program to point to
                                        // retrieved title string
    DWORD           CounterHelpTitleIndex;
                                        // Index of Counter Help into
                                        // Title Database
    LPWSTR          CounterHelpTitle;   // Initially NULL, for use by 
                                        // analysis program to point to
                                        // retrieved title string
    LONG            DefaultScale;       // Power of 10 by which to scale 
                                        // chart line if vertical axis is 100
                                        // 0 ==> 1, 1 ==> 10, -1 ==>1/10, etc.
    DWORD           DetailLevel;        // Counter level of detail (for 
                                        // controlling display complexity)
    DWORD           CounterType;        // Type of counter 
    DWORD           CounterSize;        // Size of counter in bytes 
    DWORD           CounterOffset;      // Offset from the start of the 
                                        // PERF_COUNTER_BLOCK to the first
                                        // byte of this counter
} PERF_COUNTER_DEFINITION, *PPERF_COUNTER_DEFINITION;

//
//  If (PERF_DATA_BLOCK.NumInstances >= 0) then there will be
//  PERF_DATA_BLOCK.NumInstances of a (PERF_INSTANCE_DEFINITION
//  followed by a PERF_COUNTER_BLOCK followed by the counter data fields)
//  for each instance.
//
//  If (PERF_DATA_BLOCK.NumInstances < 0) then the counter definition
//  strucutre above will be followed by only a PERF_COUNTER_BLOCK and the
//  counter data for that COUNTER.
//



typedef struct _PERF_INSTANCE_DEFINITION {
    DWORD           ByteLength;         // Length in bytes of this structure, 
                                        // including the subsequent name
    DWORD           ParentObjectTitleIndex;
                                        // Title Index to name of "parent"
                                        // object (e.g., if thread, then
                                        // process is parent object type);
                                        // if logical drive, the physical
                                        // drive is parent object type
    DWORD           ParentObjectInstance;
                                        // Index to instance of parent object
                                        // type which is the parent of this
                                        // instance.
    LONG            UniqueID;           // A unique ID used instead of 
                                        // matching the name to identify
                                        // this instance, -1 = none
    DWORD           NameOffset;         // Offset from beginning of 
                                        // this struct to the Unicode name
                                        // of this instance
    DWORD           NameLength;         // Length in bytes of name; 0 = none 

} PERF_INSTANCE_DEFINITION, *PPERF_INSTANCE_DEFINITION;
//
//  If .ParentObjectName is 0, there
//  is no parent-child hierarchy for this object type.  Otherwise,
//   the .ParentObjectInstance is an index, starting at 0, into the
//  instances reported for the parent object type.  It is only
//  meaningful if .ParentObjectName is not 0.  The purpose of all this
//  is to permit reporting/summation of object instances like threads
//  within processes, and logical drives within physical drives.
//
//
//  The PERF_INSTANCE_DEFINITION will be followed by a PERF_COUNTER_BLOCK.
//

typedef struct _PERF_COUNTER_BLOCK {
    DWORD           ByteLength;         // Length in bytes of this structure, 
                                        // including the following counters
} PERF_COUNTER_BLOCK, *PPERF_COUNTER_BLOCK;

//
//  The PERF_COUNTER_BLOCK is followed by PERF_OBJECT_TYPE.NumCounters
//  number of counters.
//

//
//  function typedefs for extensible counter function prototypes
//
typedef DWORD ( __stdcall  PM_OPEN_PROC) (LPWSTR);
typedef DWORD ( __stdcall  PM_COLLECT_PROC) (LPWSTR, LPVOID *, LPDWORD, LPDWORD);
typedef DWORD ( __stdcall  PM_CLOSE_PROC) (void);

// _WINPERF_


#line 177 "C:\WATCOM\H\NT\windows.h"

#line 1 "C:\WATCOM\H\NT\winsock.h"
/* WINSOCK.H--definitions to be used with the WINSOCK.DLL
 * Copyright (c) 1993-1995, Microsoft Corp. All rights reserved.
 *
 * This header file corresponds to version 1.1 of the Windows Sockets specification.
 *
 * This file includes parts which are Copyright (c) 1982-1986 Regents
 * of the University of California.  All rights reserved.  The
 * Berkeley Software License Agreement specifies the terms and
 * conditions for redistribution.
 *
 */




/*
 * Pull in WINDOWS.H if necessary
 */
/* _INC_WINDOWS */#line 22 "C:\WATCOM\H\NT\winsock.h"

/*
 * Basic system type definitions, taken from the BSD file sys/types.h.
 */
typedef unsigned char   u_char;
typedef unsigned short  u_short;
typedef unsigned int    u_int;
typedef unsigned long   u_long;

/*
 * The new type to be used in all
 * instances which refer to sockets.
 */
typedef u_int           SOCKET;

/*
 * Select uses arrays of SOCKETs.  These macros manipulate such
 * arrays.  FD_SETSIZE may be defined by the user before including
 * this file, but the default here should be >= 64.
 *
 * CAVEAT IMPLEMENTOR and USER: THESE MACROS AND TYPES MUST BE
 * INCLUDED IN WINSOCK.H EXACTLY AS SHOWN HERE.
 */


/* FD_SETSIZE */

typedef struct fd_set {
        u_int   fd_count;               /* how many are SET? */ 
        SOCKET  fd_array[ 64 ];   /* an array of SOCKETs */ 
} fd_set;


extern "C" {


extern int  __stdcall     __WSAFDIsSet(SOCKET, fd_set    *);


}



























/*
 * Structure used in select() call, taken from the BSD file sys/time.h.
 */
struct timeval {
        long    tv_sec;         /* seconds */ 
        long    tv_usec;        /* and microseconds */ 
};

/*
 * Operations on timevals.
 *
 * NB: timercmp does not work for >= or <=.
 */






/*
 * Commands for ioctlsocket(),  taken from the BSD file fcntl.h.
 *
 *
 * Ioctl's have the command encoded in the lower word,
 * and the size of any in or out parameters in the upper
 * word.  The high 2 bits of the upper word are used
 * to encode the in/out status of the parameter; for now
 * we restrict parameters to at most 128 bytes.
 */
/* parameters must be < 128 bytes */
/* no parameters */
/* copy out parameters */
/* copy in parameters */

                                        /* 0x20000000 distinguishes new &
                                           old ioctl's */






/* get # bytes to read */
/* set/clear non-blocking i/o */
/* set/clear async i/o */

/* Socket I/O Controls */
/* set high watermark */
/* get high watermark */
/* set low watermark */
/* get low watermark */
/* at oob mark? */

/*
 * Structures returned by network data base library, taken from the
 * BSD file netdb.h.  All addresses are supplied in host order, and
 * returned in network order (suitable for use in system calls).
 */

struct  hostent {
        char       * h_name;           /* official name of host */ 
        char       *    * h_aliases;  /* alias list */ 
        short   h_addrtype;             /* host address type */ 
        short   h_length;               /* length of address */ 
        char       *    * h_addr_list; /* list of addresses */ 
/* address, for backward compat */
};

/*
 * It is assumed here that a network number
 * fits in 32 bits.
 */
struct  netent {
        char       * n_name;           /* official name of net */ 
        char       *    * n_aliases;  /* alias list */ 
        short   n_addrtype;             /* net address type */ 
        u_long  n_net;                  /* network # */ 
};

struct  servent {
        char       * s_name;           /* official service name */ 
        char       *    * s_aliases;  /* alias list */ 
        short   s_port;                 /* port # */ 
        char       * s_proto;          /* protocol to use */ 
};

struct  protoent {
        char       * p_name;           /* official protocol name */ 
        char       *    * p_aliases;  /* alias list */ 
        short   p_proto;                /* protocol # */ 
};

/*
 * Constants and structures defined by the internet system,
 * Per RFC 790, September 1981, taken from the BSD file netinet/in.h.
 */

/*
 * Protocols
 */
/* dummy for IP */
/* control message protocol */
/* gateway^2 (deprecated) */
/* tcp */
/* pup */
/* user datagram protocol */
/* xns idp */
/* UNOFFICIAL net disk proto */

/* raw IP packet */


/*
 * Port/socket numbers: network standard functions
 */













/*
 * Port/socket numbers: host specific functions
 */






/*
 * UNIX TCP sockets
 */





/*
 * UNIX UDP sockets
 */



                                        /* 520+1 also used */

/*
 * Ports < IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).
 */


/*
 * Link numbers
 */




/*
 * Internet address (old style... should be updated)
 */
struct in_addr {
        union {
                struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { u_short s_w1,s_w2; } S_un_w;
                u_long S_addr;
        } S_un;

                                /* can be used for most tcp & ip code */

                                /* host on imp */

                                /* network */

                                /* imp */

                                /* imp # */

                                /* logical host */
};

/*
 * Definitions of bits in internet address integers.
 * On subnets, the decomposition of addresses to host and net parts
 * is done according to subnet mask, not the masks here.
 */






















/*
 * Socket address, internet style.
 */
struct sockaddr_in {
        short   sin_family;
        u_short sin_port;
        struct  in_addr sin_addr;
        char    sin_zero[8];
};




typedef struct WSAData {
        WORD                    wVersion;
        WORD                    wHighVersion;
        char                    szDescription[ 256 +1];
        char                    szSystemStatus[ 128 +1];
        unsigned short          iMaxSockets;
        unsigned short          iMaxUdpDg;
        char    *              lpVendorInfo;
} WSADATA;

typedef WSADATA    *LPWSADATA;

/*
 * Options for use with [gs]etsockopt at the IP level.
 */
/* set/get IP per-packet options    */
/* set/get IP multicast interface   */
/* set/get IP multicast timetolive  */
/* set/get IP multicast loopback    */
/* add  an IP group membership      */
/* drop an IP group membership      */

/* normally limit m'casts to 1 hop  */
/* normally hear sends if a member  */
/* per socket; must fit in one mbuf */

/*
 * Argument structure for IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP.
 */
struct ip_mreq {
        struct in_addr  imr_multiaddr;  /* IP multicast address of group */ 
        struct in_addr  imr_interface;  /* local IP address of interface */ 
};

/*
 * Definitions related to sockets: types, address families, options,
 * taken from the BSD file sys/socket.h.
 */

/*
 * This is used instead of -1, since the
 * SOCKET type is unsigned.
 */



/*
 * Types
 */
/* stream socket */
/* datagram socket */
/* raw-protocol interface */
/* reliably-delivered message */
/* sequenced packet stream */

/*
 * Option flags per-socket.
 */
/* turn on debugging info recording */
/* socket has had listen() */
/* allow local address reuse */
/* keep connections alive */
/* just use interface addresses */
/* permit sending of broadcast msgs */
/* bypass hardware when possible */
/* linger on close if data present */
/* leave received OOB data in line */



/*
 * Additional options.
 */
/* send buffer size */
/* receive buffer size */
/* send low-water mark */
/* receive low-water mark */
/* send timeout */
/* receive timeout */
/* get error status and clear */
/* get socket type */

/*
 * Options for connect and disconnect data and options.  Used only by
 * non-TCP/IP transports such as DECNet, OSI TP4, etc.
 */









/*
 * Option for opening sockets for synchronous access.
 */





/*
 * Other NT-specific options.
 */



/*
 * TCP options.
 */



/*
 * Address families.
 */
/* unspecified */
/* local to host (pipes, portals) */
/* internetwork: UDP, TCP, etc. */
/* arpanet imp addresses */
/* pup protocols: e.g. BSP */
/* mit CHAOS protocols */
/* IPX and SPX */
/* XEROX NS protocols */
/* ISO protocols */
/* OSI is ISO */
/* european computer manufacturers */
/* datakit protocols */
/* CCITT protocols, X.25 etc */
/* IBM SNA */
/* DECnet */
/* Direct data link interface */
/* LAT */
/* NSC Hyperchannel */
/* AppleTalk */
/* NetBios-style addresses */
/* VoiceView */



/*
 * Structure used by kernel to store most
 * addresses.
 */
struct sockaddr {
        u_short sa_family;              /* address family */ 
        char    sa_data[14];            /* up to 14 bytes of direct address */ 
};

/*
 * Structure used by kernel to pass protocol
 * information in raw sockets.
 */
struct sockproto {
        u_short sp_family;              /* address family */ 
        u_short sp_protocol;            /* protocol */ 
};

/*
 * Protocol families, same as address families for now.
 */























/*
 * Structure used for manipulating linger option.
 */
struct  linger {
        u_short l_onoff;                /* option on/off */ 
        u_short l_linger;               /* linger time */ 
};

/*
 * Level number for (get/set)sockopt() to apply to socket itself.
 */
/* options for socket level */

/*
 * Maximum queue length specifiable by listen.
 */


/* process out-of-band data */
/* peek at incoming message */
/* send without using routing tables */



/* partial send or recv for message xport */

/*
 * Define constant based on rfc883, used by gethostbyxxxx() calls.
 */


/*
 * Define flags to be used with the WSAAsyncSelect() call.
 */







/*
 * All Windows Sockets error constants are biased by WSABASEERR from
 * the "normal"
 */

/*
 * Windows Sockets definitions of regular Microsoft C error constants
 */







/*
 * Windows Sockets definitions of regular Berkeley error constants
 */








































/*
 * Extended Windows Sockets error constant definitions
 */




/*
 * Error return codes from gethostbyname() and gethostbyaddr()
 * (when using the resolver). Note that these errors are
 * retrieved via WSAGetLastError() and must therefore follow
 * the rules for avoiding clashes with error numbers from
 * specific implementations or language run-time systems.
 * For this reason the codes are based at WSABASEERR+1001.
 * Note also that [WSA]NO_ADDRESS is defined only for
 * compatibility purposes.
 */



/* Authoritative Answer: Host not found */



/* Non-Authoritative: Host not found, or SERVERFAIL */



/* Non recoverable errors, FORMERR, REFUSED, NOTIMP */



/* Valid name, no data record of requested type */



/* no address, look for MX record */



/*
 * Windows Sockets errors redefined as regular Berkeley error constants.
 * These are commented out in Windows NT to avoid conflicts with errno.h.
 * Use the WSA constants instead.
 */
#line 687 "C:\WATCOM\H\NT\winsock.h"

/* Socket function prototypes */


extern "C" {


SOCKET  __stdcall     accept (SOCKET s, struct sockaddr    *addr,
                          int    *addrlen);

int  __stdcall     bind (SOCKET s, const struct sockaddr    *addr, int namelen);

int  __stdcall     closesocket (SOCKET s);

int  __stdcall     connect (SOCKET s, const struct sockaddr    *name, int namelen);

int  __stdcall     ioctlsocket (SOCKET s, long cmd, u_long    *argp);

int  __stdcall     getpeername (SOCKET s, struct sockaddr    *name,
                            int    * namelen);

int  __stdcall     getsockname (SOCKET s, struct sockaddr    *name,
                            int    * namelen);

int  __stdcall     getsockopt (SOCKET s, int level, int optname,
                           char    * optval, int    *optlen);

u_long  __stdcall     htonl (u_long hostlong);

u_short  __stdcall     htons (u_short hostshort);

unsigned long  __stdcall     inet_addr (const char    * cp);

char    *  __stdcall     inet_ntoa (struct in_addr in);

int  __stdcall     listen (SOCKET s, int backlog);

u_long  __stdcall     ntohl (u_long netlong);

u_short  __stdcall     ntohs (u_short netshort);

int  __stdcall     recv (SOCKET s, char    * buf, int len, int flags);

int  __stdcall     recvfrom (SOCKET s, char    * buf, int len, int flags,
                         struct sockaddr    *from, int    * fromlen);

int  __stdcall     select (int nfds, fd_set    *readfds, fd_set    *writefds,
                       fd_set    *exceptfds, const struct timeval    *timeout);

int  __stdcall     send (SOCKET s, const char    * buf, int len, int flags);

int  __stdcall     sendto (SOCKET s, const char    * buf, int len, int flags,
                       const struct sockaddr    *to, int tolen);

int  __stdcall     setsockopt (SOCKET s, int level, int optname,
                           const char    * optval, int optlen);

int  __stdcall     shutdown (SOCKET s, int how);

SOCKET  __stdcall     socket (int af, int type, int protocol);

/* Database function prototypes */

struct hostent    *  __stdcall     gethostbyaddr(const char    * addr,
                                              int len, int type);

struct hostent    *  __stdcall     gethostbyname(const char    * name);

int  __stdcall     gethostname (char    * name, int namelen);

struct servent    *  __stdcall     getservbyport(int port, const char    * proto);

struct servent    *  __stdcall     getservbyname(const char    * name,
                                              const char    * proto);

struct protoent    *  __stdcall     getprotobynumber(int proto);

struct protoent    *  __stdcall     getprotobyname(const char    * name);

/* Microsoft Windows Extension function prototypes */

int  __stdcall     WSAStartup(WORD wVersionRequired, LPWSADATA lpWSAData);

int  __stdcall     WSACleanup(void);

void  __stdcall     WSASetLastError(int iError);

int  __stdcall     WSAGetLastError(void);

BOOL  __stdcall     WSAIsBlocking(void);

int  __stdcall     WSAUnhookBlockingHook(void);

FARPROC  __stdcall     WSASetBlockingHook(FARPROC lpBlockFunc);

int  __stdcall     WSACancelBlockingCall(void);

HANDLE  __stdcall     WSAAsyncGetServByName(HWND hWnd, u_int wMsg,
                                        const char    * name,
                                        const char    * proto,
                                        char    * buf, int buflen);

HANDLE  __stdcall     WSAAsyncGetServByPort(HWND hWnd, u_int wMsg, int port,
                                        const char    * proto, char    * buf,
                                        int buflen);

HANDLE  __stdcall     WSAAsyncGetProtoByName(HWND hWnd, u_int wMsg,
                                         const char    * name, char    * buf,
                                         int buflen);

HANDLE  __stdcall     WSAAsyncGetProtoByNumber(HWND hWnd, u_int wMsg,
                                           int number, char    * buf,
                                           int buflen);

HANDLE  __stdcall     WSAAsyncGetHostByName(HWND hWnd, u_int wMsg,
                                        const char    * name, char    * buf,
                                        int buflen);

HANDLE  __stdcall     WSAAsyncGetHostByAddr(HWND hWnd, u_int wMsg,
                                        const char    * addr, int len, int type,
                                        char    * buf, int buflen);

int  __stdcall     WSACancelAsyncRequest(HANDLE hAsyncTaskHandle);

int  __stdcall     WSAAsyncSelect(SOCKET s, HWND hWnd, u_int wMsg,
                               long lEvent);

int  __stdcall     WSARecvEx (SOCKET s, char    * buf, int len, int    *flags);

typedef struct _TRANSMIT_FILE_BUFFERS {
    PVOID Head;
    DWORD HeadLength;
    PVOID Tail;
    DWORD TailLength;
} TRANSMIT_FILE_BUFFERS, *PTRANSMIT_FILE_BUFFERS, *LPTRANSMIT_FILE_BUFFERS;

BOOL
 __stdcall    
TransmitFile (
       SOCKET hSocket,
       HANDLE hFile,
       DWORD nNumberOfBytesToWrite,
       DWORD nNumberOfBytesPerSend,
       LPOVERLAPPED lpOverlapped,
       LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,
       DWORD dwReserved
    );


}


/* Microsoft Windows Extended data types */
typedef struct sockaddr SOCKADDR;
typedef struct sockaddr *PSOCKADDR;
typedef struct sockaddr    *LPSOCKADDR;

typedef struct sockaddr_in SOCKADDR_IN;
typedef struct sockaddr_in *PSOCKADDR_IN;
typedef struct sockaddr_in    *LPSOCKADDR_IN;

typedef struct linger LINGER;
typedef struct linger *PLINGER;
typedef struct linger    *LPLINGER;

typedef struct in_addr IN_ADDR;
typedef struct in_addr *PIN_ADDR;
typedef struct in_addr    *LPIN_ADDR;

typedef struct fd_set  FD_SET ;
typedef struct fd_set *PFD_SET;
typedef struct fd_set    *LPFD_SET;

typedef struct hostent HOSTENT;
typedef struct hostent *PHOSTENT;
typedef struct hostent    *LPHOSTENT;

typedef struct servent SERVENT;
typedef struct servent *PSERVENT;
typedef struct servent    *LPSERVENT;

typedef struct protoent PROTOENT;
typedef struct protoent *PPROTOENT;
typedef struct protoent    *LPPROTOENT;

typedef struct timeval TIMEVAL;
typedef struct timeval *PTIMEVAL;
typedef struct timeval    *LPTIMEVAL;

/*
 * Windows message parameter composition and decomposition
 * macros.
 *
 * WSAMAKEASYNCREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to a WSAAsyncGetXByY() routine.
 */

/*
 * WSAMAKESELECTREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to WSAAsyncSelect().
 */

/*
 * WSAGETASYNCBUFLEN is intended for use by the Windows Sockets application
 * to extract the buffer length from the lParam in the response
 * to a WSAGetXByY().
 */

/*
 * WSAGETASYNCERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAGetXByY().
 */

/*
 * WSAGETSELECTEVENT is intended for use by the Windows Sockets application
 * to extract the event code from the lParam in the response
 * to a WSAAsyncSelect().
 */

/*
 * WSAGETSELECTERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAAsyncSelect().
 */


/* _WINSOCKAPI_ */


#line 178 "C:\WATCOM\H\NT\windows.h"


#line 1 "C:\WATCOM\H\NT\commdlg.h"
/************************************************************************
*                                                                       *
*   commdlg.h -- This module defines the 32-Bit Common Dialog APIs      *
*                                                                       *
*   Copyright (c) 1992-1995, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/



#line 1 "C:\WATCOM\H\NT\pshpack1.h"
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pshpack1.h

Abstract:

    This file turns 1 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push)

#pragma pack(1)
#line 32 "C:\WATCOM\H\NT\pshpack1.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 11 "C:\WATCOM\H\NT\commdlg.h"
         /* Assume byte packing throughout */


extern "C" {            /* Assume C declarations for C++ */ 
/* __cplusplus */

 


/* __cplusplus */#line 23 "C:\WATCOM\H\NT\commdlg.h"
/* WINVER >= 0x0400 */

typedef UINT ( __stdcall  *LPOFNHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

typedef struct tagOFNA {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HINSTANCE    hInstance;
   LPCSTR       lpstrFilter;
   LPSTR        lpstrCustomFilter;
   DWORD        nMaxCustFilter;
   DWORD        nFilterIndex;
   LPSTR        lpstrFile;
   DWORD        nMaxFile;
   LPSTR        lpstrFileTitle;
   DWORD        nMaxFileTitle;
   LPCSTR       lpstrInitialDir;
   LPCSTR       lpstrTitle;
   DWORD        Flags;
   WORD         nFileOffset;
   WORD         nFileExtension;
   LPCSTR       lpstrDefExt;
   LPARAM       lCustData;
   LPOFNHOOKPROC lpfnHook;
   LPCSTR       lpTemplateName;
} OPENFILENAMEA, *LPOPENFILENAMEA;
typedef struct tagOFNW {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HINSTANCE    hInstance;
   LPCWSTR      lpstrFilter;
   LPWSTR       lpstrCustomFilter;
   DWORD        nMaxCustFilter;
   DWORD        nFilterIndex;
   LPWSTR       lpstrFile;
   DWORD        nMaxFile;
   LPWSTR       lpstrFileTitle;
   DWORD        nMaxFileTitle;
   LPCWSTR      lpstrInitialDir;
   LPCWSTR      lpstrTitle;
   DWORD        Flags;
   WORD         nFileOffset;
   WORD         nFileExtension;
   LPCWSTR      lpstrDefExt;
   LPARAM       lCustData;
   LPOFNHOOKPROC lpfnHook;
   LPCWSTR      lpTemplateName;
} OPENFILENAMEW, *LPOPENFILENAMEW;
#line 75 "C:\WATCOM\H\NT\commdlg.h"
typedef OPENFILENAMEA OPENFILENAME;
typedef LPOPENFILENAMEA LPOPENFILENAME;
// UNICODE

BOOL   __stdcall      GetOpenFileNameA(LPOPENFILENAMEA);
BOOL   __stdcall      GetOpenFileNameW(LPOPENFILENAMEW);
#line 84 "C:\WATCOM\H\NT\commdlg.h"

// !UNICODE
BOOL   __stdcall      GetSaveFileNameA(LPOPENFILENAMEA);
BOOL   __stdcall      GetSaveFileNameW(LPOPENFILENAMEW);
#line 91 "C:\WATCOM\H\NT\commdlg.h"

// !UNICODE
short  __stdcall      GetFileTitleA(LPCSTR, LPSTR, WORD);
short  __stdcall      GetFileTitleW(LPCWSTR, LPWSTR, WORD);
#line 98 "C:\WATCOM\H\NT\commdlg.h"

// !UNICODE



















// force no long names for 4.x modules
 
// new look commdlg

// force long names for 3.x modules
/* WINVER >= 0x0400 */

// Return values for the registered message sent to the hook function
// when a sharing violation occurs.  OFN_SHAREFALLTHROUGH allows the
// filename to be accepted, OFN_SHARENOWARN rejects the name but puts
// up no warning (returned when the app has already put up a warning
// message), and OFN_SHAREWARN puts up the default warning message
// for sharing violations.
//
// Note:  Undefined return values map to OFN_SHAREWARN, but are
//        reserved for future use.





typedef UINT ( __stdcall  *LPCCHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

 
// Structure used for all OpenFileName notifications
typedef struct _OFNOTIFYA
{
        NMHDR           hdr;
        LPOPENFILENAMEA lpOFN;
        LPSTR           pszFile;        // May be NULL 
} OFNOTIFYA,    *LPOFNOTIFYA;
// Structure used for all OpenFileName notifications
typedef struct _OFNOTIFYW
{
        NMHDR           hdr;
        LPOPENFILENAMEW lpOFN;
        LPWSTR          pszFile;        // May be NULL 
} OFNOTIFYW,    *LPOFNOTIFYW;
#line 161 "C:\WATCOM\H\NT\commdlg.h"
typedef OFNOTIFYA OFNOTIFY;
typedef LPOFNOTIFYA LPOFNOTIFY;
// UNICODE




// Notifications when Open or Save dialog status changes











// Messages to query information from the Open or Save dialogs

// lParam = pointer to text buffer that gets filled in
// wParam = max number of characters of the text buffer (including NULL)
// return = < 0 if error; number of characters needed (including NULL)





#line 193 "C:\WATCOM\H\NT\commdlg.h"

// !UNICODE

// lParam = pointer to text buffer that gets filled in
// wParam = max number of characters of the text buffer (including NULL)
// return = < 0 if error; number of characters needed (including NULL)





#line 207 "C:\WATCOM\H\NT\commdlg.h"

// !UNICODE

// lParam = pointer to text buffer that gets filled in
// wParam = max number of characters of the text buffer (including NULL)
// return = < 0 if error; number of characters needed (including NULL)





#line 221 "C:\WATCOM\H\NT\commdlg.h"

// !UNICODE

// lParam = pointer to ITEMIDLIST buffer that gets filled in
// wParam = size of the ITEMIDLIST buffer
// return = < 0 if error; length of buffer needed




// lParam = pointer to a string
// wParam = ID of control to change
// return = not used




// lParam = not used
// wParam = ID of control to change
// return = not used




// lParam = pointer to default extension (no dot)
// wParam = not used
// return = not used



/* WINVER >= 0x0400 */

typedef struct tagCHOOSECOLORA {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HWND         hInstance;
   COLORREF     rgbResult;
   COLORREF*    lpCustColors;
   DWORD        Flags;
   LPARAM       lCustData;
   LPCCHOOKPROC lpfnHook;
   LPCSTR       lpTemplateName;
} CHOOSECOLORA, *LPCHOOSECOLORA;
typedef struct tagCHOOSECOLORW {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HWND         hInstance;
   COLORREF     rgbResult;
   COLORREF*    lpCustColors;
   DWORD        Flags;
   LPARAM       lCustData;
   LPCCHOOKPROC lpfnHook;
   LPCWSTR      lpTemplateName;
} CHOOSECOLORW, *LPCHOOSECOLORW;
#line 279 "C:\WATCOM\H\NT\commdlg.h"
typedef CHOOSECOLORA CHOOSECOLOR;
typedef LPCHOOSECOLORA LPCHOOSECOLOR;
// UNICODE

BOOL   __stdcall  ChooseColorA(LPCHOOSECOLORA);
BOOL   __stdcall  ChooseColorW(LPCHOOSECOLORW);
#line 288 "C:\WATCOM\H\NT\commdlg.h"

// !UNICODE








 


/* WINVER >= 0x0400 */

typedef UINT ( __stdcall  *LPFRHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

typedef struct tagFINDREPLACEA {
   DWORD        lStructSize;        // size of this struct 0x20 
   HWND         hwndOwner;          // handle to owner's window 
   HINSTANCE    hInstance;          // instance handle of.EXE that 
                                    //   contains cust. dlg. template
   DWORD        Flags;              // one or more of the FR_?? 
   LPSTR        lpstrFindWhat;      // ptr. to search string 
   LPSTR        lpstrReplaceWith;   // ptr. to replace string 
   WORD         wFindWhatLen;       // size of find buffer 
   WORD         wReplaceWithLen;    // size of replace buffer 
   LPARAM       lCustData;          // data passed to hook fn. 
   LPFRHOOKPROC lpfnHook;           // ptr. to hook fn. or NULL 
   LPCSTR       lpTemplateName;     // custom template name 
} FINDREPLACEA, *LPFINDREPLACEA;
typedef struct tagFINDREPLACEW {
   DWORD        lStructSize;        // size of this struct 0x20 
   HWND         hwndOwner;          // handle to owner's window 
   HINSTANCE    hInstance;          // instance handle of.EXE that 
                                    //   contains cust. dlg. template
   DWORD        Flags;              // one or more of the FR_?? 
   LPWSTR       lpstrFindWhat;      // ptr. to search string 
   LPWSTR       lpstrReplaceWith;   // ptr. to replace string 
   WORD         wFindWhatLen;       // size of find buffer 
   WORD         wReplaceWithLen;    // size of replace buffer 
   LPARAM       lCustData;          // data passed to hook fn. 
   LPFRHOOKPROC lpfnHook;           // ptr. to hook fn. or NULL 
   LPCWSTR      lpTemplateName;     // custom template name 
} FINDREPLACEW, *LPFINDREPLACEW;
#line 337 "C:\WATCOM\H\NT\commdlg.h"
typedef FINDREPLACEA FINDREPLACE;
typedef LPFINDREPLACEA LPFINDREPLACE;
// UNICODE



















HWND   __stdcall     FindTextA(LPFINDREPLACEA);
HWND   __stdcall     FindTextW(LPFINDREPLACEW);
#line 364 "C:\WATCOM\H\NT\commdlg.h"

// !UNICODE
HWND   __stdcall     ReplaceTextA(LPFINDREPLACEA);
HWND   __stdcall     ReplaceTextW(LPFINDREPLACEW);
#line 371 "C:\WATCOM\H\NT\commdlg.h"

// !UNICODE

typedef UINT ( __stdcall  *LPCFHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

typedef struct tagCHOOSEFONTA {
   DWORD           lStructSize;
   HWND            hwndOwner;          // caller's window handle 
   HDC             hDC;                // printer DC/IC or NULL 
   LPLOGFONTA      lpLogFont;          // ptr. to a LOGFONT struct 
   INT             iPointSize;         // 10 * size in points of selected font 
   DWORD           Flags;              // enum. type flags 
   COLORREF        rgbColors;          // returned text color 
   LPARAM          lCustData;          // data passed to hook fn. 
   LPCFHOOKPROC    lpfnHook;           // ptr. to hook function 
   LPCSTR          lpTemplateName;     // custom template name 
   HINSTANCE       hInstance;          // instance handle of.EXE that 
                                       //   contains cust. dlg. template
   LPSTR           lpszStyle;          // return the style field here 
                                       // must be LF_FACESIZE or bigger
   WORD            nFontType;          // same value reported to the EnumFonts 
                                       //   call back with the extra FONTTYPE_
                                       //   bits added
   WORD            ___MISSING_ALIGNMENT__;
   INT             nSizeMin;           // minimum pt size allowed & 
   INT             nSizeMax;           // max pt size allowed if 
                                       //   CF_LIMITSIZE is used
} CHOOSEFONTA, *LPCHOOSEFONTA;
typedef struct tagCHOOSEFONTW {
   DWORD           lStructSize;
   HWND            hwndOwner;          // caller's window handle 
   HDC             hDC;                // printer DC/IC or NULL 
   LPLOGFONTW      lpLogFont;          // ptr. to a LOGFONT struct 
   INT             iPointSize;         // 10 * size in points of selected font 
   DWORD           Flags;              // enum. type flags 
   COLORREF        rgbColors;          // returned text color 
   LPARAM          lCustData;          // data passed to hook fn. 
   LPCFHOOKPROC    lpfnHook;           // ptr. to hook function 
   LPCWSTR         lpTemplateName;     // custom template name 
   HINSTANCE       hInstance;          // instance handle of.EXE that 
                                       //   contains cust. dlg. template
   LPWSTR          lpszStyle;          // return the style field here 
                                       // must be LF_FACESIZE or bigger
   WORD            nFontType;          // same value reported to the EnumFonts 
                                       //   call back with the extra FONTTYPE_
                                       //   bits added
   WORD            ___MISSING_ALIGNMENT__;
   INT             nSizeMin;           // minimum pt size allowed & 
   INT             nSizeMax;           // max pt size allowed if 
                                       //   CF_LIMITSIZE is used
} CHOOSEFONTW, *LPCHOOSEFONTW;
#line 426 "C:\WATCOM\H\NT\commdlg.h"
typedef CHOOSEFONTA CHOOSEFONT;
typedef LPCHOOSEFONTA LPCHOOSEFONT;
// UNICODE

BOOL  __stdcall  ChooseFontA(LPCHOOSEFONTA);
BOOL  __stdcall  ChooseFontW(LPCHOOSEFONTW);
#line 435 "C:\WATCOM\H\NT\commdlg.h"

// !UNICODE













 

/* WINVER >= 0x0400 */





// must also have CF_SCREENFONTS & CF_PRINTERFONTS






 



/* WINVER >= 0x0400 */

// these are extra nFontType bits that are added to what is returned to the
// EnumFonts callback routine












// strings used to obtain unique window message for communication
// between dialog and caller

















#line 513 "C:\WATCOM\H\NT\commdlg.h"









// HIWORD values for lParam of commdlg_LBSelChangeNotify message





typedef UINT ( __stdcall  *LPPRINTHOOKPROC) (HWND, UINT, WPARAM, LPARAM);
typedef UINT ( __stdcall  *LPSETUPHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

typedef struct tagPDA {
   DWORD            lStructSize;
   HWND             hwndOwner;
   HGLOBAL          hDevMode;
   HGLOBAL          hDevNames;
   HDC              hDC;
   DWORD            Flags;
   WORD             nFromPage;
   WORD             nToPage;
   WORD             nMinPage;
   WORD             nMaxPage;
   WORD             nCopies;
   HINSTANCE        hInstance;
   LPARAM           lCustData;
   LPPRINTHOOKPROC  lpfnPrintHook;
   LPSETUPHOOKPROC  lpfnSetupHook;
   LPCSTR           lpPrintTemplateName;
   LPCSTR           lpSetupTemplateName;
   HGLOBAL          hPrintTemplate;
   HGLOBAL          hSetupTemplate;
} PRINTDLGA, *LPPRINTDLGA;
typedef struct tagPDW {
   DWORD            lStructSize;
   HWND             hwndOwner;
   HGLOBAL          hDevMode;
   HGLOBAL          hDevNames;
   HDC              hDC;
   DWORD            Flags;
   WORD             nFromPage;
   WORD             nToPage;
   WORD             nMinPage;
   WORD             nMaxPage;
   WORD             nCopies;
   HINSTANCE        hInstance;
   LPARAM           lCustData;
   LPPRINTHOOKPROC  lpfnPrintHook;
   LPSETUPHOOKPROC  lpfnSetupHook;
   LPCWSTR          lpPrintTemplateName;
   LPCWSTR          lpSetupTemplateName;
   HGLOBAL          hPrintTemplate;
   HGLOBAL          hSetupTemplate;
} PRINTDLGW, *LPPRINTDLGW;
#line 577 "C:\WATCOM\H\NT\commdlg.h"
typedef PRINTDLGA PRINTDLG;
typedef LPPRINTDLGA LPPRINTDLG;
// UNICODE

BOOL   __stdcall      PrintDlgA(LPPRINTDLGA);
BOOL   __stdcall      PrintDlgW(LPPRINTDLGW);
#line 586 "C:\WATCOM\H\NT\commdlg.h"

// !UNICODE


























typedef struct tagDEVNAMES {
   WORD wDriverOffset;
   WORD wDeviceOffset;
   WORD wOutputOffset;
   WORD wDefault;
} DEVNAMES;

typedef DEVNAMES * LPDEVNAMES;



DWORD  __stdcall      CommDlgExtendedError( void );

 








typedef UINT ( __stdcall * LPPAGEPAINTHOOK)( HWND, UINT, WPARAM, LPARAM );
typedef UINT ( __stdcall * LPPAGESETUPHOOK)( HWND, UINT, WPARAM, LPARAM );

typedef struct tagPSDA
{
    DWORD           lStructSize;
    HWND            hwndOwner;
    HGLOBAL         hDevMode;
    HGLOBAL         hDevNames;
    DWORD           Flags;
    POINT           ptPaperSize;
    RECT            rtMinMargin;
    RECT            rtMargin;
    HINSTANCE       hInstance;
    LPARAM          lCustData;
    LPPAGESETUPHOOK lpfnPageSetupHook;
    LPPAGEPAINTHOOK lpfnPagePaintHook;
    LPCSTR          lpPageSetupTemplateName;
    HGLOBAL         hPageSetupTemplate;
} PAGESETUPDLGA, * LPPAGESETUPDLGA;
typedef struct tagPSDW
{
    DWORD           lStructSize;
    HWND            hwndOwner;
    HGLOBAL         hDevMode;
    HGLOBAL         hDevNames;
    DWORD           Flags;
    POINT           ptPaperSize;
    RECT            rtMinMargin;
    RECT            rtMargin;
    HINSTANCE       hInstance;
    LPARAM          lCustData;
    LPPAGESETUPHOOK lpfnPageSetupHook;
    LPPAGEPAINTHOOK lpfnPagePaintHook;
    LPCWSTR         lpPageSetupTemplateName;
    HGLOBAL         hPageSetupTemplate;
} PAGESETUPDLGW, * LPPAGESETUPDLGW;
#line 677 "C:\WATCOM\H\NT\commdlg.h"
typedef PAGESETUPDLGA PAGESETUPDLG;
typedef LPPAGESETUPDLGA LPPAGESETUPDLG;
// UNICODE

BOOL  __stdcall  PageSetupDlgA( LPPAGESETUPDLGA );
BOOL  __stdcall  PageSetupDlgW( LPPAGESETUPDLGW );
#line 686 "C:\WATCOM\H\NT\commdlg.h"

// !UNICODE

// default (printer's)
// 1st of 4 possible

// use caller's
// use caller's
// 2nd of 4 possible
// 3rd of 4 possible


// must be same as PD_*

// must be same as PD_*

// must be same as PD_*
// must be same as PD_*
// must be same as PD_*
// must be same as PD_*


/* WINVER >= 0x0400 */


}
/* __cplusplus */

#line 1 "C:\WATCOM\H\NT\poppack.h"
/*++

Copyright (c) 1990,95  Microsoft Corporation

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)
#line 33 "C:\WATCOM\H\NT\poppack.h"
#line 36 "C:\WATCOM\H\NT\poppack.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 714 "C:\WATCOM\H\NT\commdlg.h"

/* !_INC_COMMDLG */
#line 180 "C:\WATCOM\H\NT\windows.h"

#line 1 "C:\WATCOM\H\NT\winspool.h"
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    WinSpool.h

Abstract:

    Header file for Print APIs

Revision History:

--*/






extern "C" {


 
#line 1 "C:\WATCOM\H\NT\prsht.h"
/*****************************************************************************
*                                                                             *
* prsht.h - - Interface for the Windows Property Sheet Pages                  *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) 1991-1995, Microsoft Corp.      All rights reserved.          *
*                                                                             *
\*****************************************************************************/




//
// Define API decoration for direct importing of DLL references.
//



#line 23 "C:\WATCOM\H\NT\prsht.h"
// WINCOMMCTRLAPI

//
// For compilers that don't support nameless unions
//

#line 34 "C:\WATCOM\H\NT\prsht.h"




// DUMMYUNIONNAME


extern "C" {


 



struct _PSP;
typedef struct _PSP   * HPROPSHEETPAGE;

typedef struct _PROPSHEETPAGEA    *LPPROPSHEETPAGEA;
typedef struct _PROPSHEETPAGEW    *LPPROPSHEETPAGEW;

typedef UINT ( __stdcall     * LPFNPSPCALLBACKA)(HWND hwnd, UINT uMsg, LPPROPSHEETPAGEA ppsp);
typedef UINT ( __stdcall     * LPFNPSPCALLBACKW)(HWND hwnd, UINT uMsg, LPPROPSHEETPAGEW ppsp);

#line 60 "C:\WATCOM\H\NT\prsht.h"


















typedef struct _PROPSHEETPAGEA {
        DWORD           dwSize;
        DWORD           dwFlags;
        HINSTANCE       hInstance;
        union {
            LPCSTR          pszTemplate;

            LPCDLGTEMPLATE  pResource;
#line 89 "C:\WATCOM\H\NT\prsht.h"
        }   ;
        union {
            HICON       hIcon;
            LPCSTR      pszIcon;
        }   ;
        LPCSTR          pszTitle;
        DLGPROC         pfnDlgProc;
        LPARAM          lParam;
        LPFNPSPCALLBACKA pfnCallback;
        UINT    * pcRefParent;
} PROPSHEETPAGEA,    *LPPROPSHEETPAGEA;
typedef const PROPSHEETPAGEA    *LPCPROPSHEETPAGEA;

typedef struct _PROPSHEETPAGEW {
        DWORD           dwSize;
        DWORD           dwFlags;
        HINSTANCE       hInstance;
        union {
            LPCWSTR          pszTemplate;

            LPCDLGTEMPLATE  pResource;
#line 113 "C:\WATCOM\H\NT\prsht.h"
        }  ;
        union {
            HICON       hIcon;
            LPCWSTR      pszIcon;
        }  ;
        LPCWSTR          pszTitle;
        DLGPROC         pfnDlgProc;
        LPARAM          lParam;
        LPFNPSPCALLBACKW pfnCallback;
        UINT    * pcRefParent;
} PROPSHEETPAGEW,    *LPPROPSHEETPAGEW;
typedef const PROPSHEETPAGEW    *LPCPROPSHEETPAGEW;

#line 131 "C:\WATCOM\H\NT\prsht.h"



















typedef int ( __stdcall  *PFNPROPSHEETCALLBACK)(HWND, UINT, LPARAM);

typedef struct _PROPSHEETHEADERA {
        DWORD           dwSize;
        DWORD           dwFlags;
        HWND            hwndParent;
        HINSTANCE       hInstance;
        union {
            HICON       hIcon;
            LPCSTR      pszIcon;
        }  ;
        LPCSTR          pszCaption;


        UINT            nPages;
        union {
            UINT        nStartPage;
            LPCSTR      pStartPage;
        }  ;
        union {
            LPCPROPSHEETPAGEA ppsp;
            HPROPSHEETPAGE    *phpage;
        }  ;
        PFNPROPSHEETCALLBACK pfnCallback;
} PROPSHEETHEADERA,    *LPPROPSHEETHEADERA;
typedef const PROPSHEETHEADERA    *LPCPROPSHEETHEADERA;

typedef struct _PROPSHEETHEADERW {
        DWORD           dwSize;
        DWORD           dwFlags;
        HWND            hwndParent;
        HINSTANCE       hInstance;
        union {
            HICON       hIcon;
            LPCWSTR     pszIcon;
        }  ;
        LPCWSTR         pszCaption;


        UINT            nPages;
        union {
            UINT        nStartPage;
            LPCWSTR     pStartPage;
        }  ;
        union {
            LPCPROPSHEETPAGEW ppsp;
            HPROPSHEETPAGE    *phpage;
        }  ;
        PFNPROPSHEETCALLBACK pfnCallback;
} PROPSHEETHEADERW,    *LPPROPSHEETHEADERW;
typedef const PROPSHEETHEADERW    *LPCPROPSHEETHEADERW;

#line 207 "C:\WATCOM\H\NT\prsht.h"









 __declspec(dllimport)  HPROPSHEETPAGE  __stdcall  CreatePropertySheetPageA(LPCPROPSHEETPAGEA);
 __declspec(dllimport)  HPROPSHEETPAGE  __stdcall  CreatePropertySheetPageW(LPCPROPSHEETPAGEW);
 __declspec(dllimport)  BOOL            __stdcall  DestroyPropertySheetPage(HPROPSHEETPAGE);
 __declspec(dllimport)  int             __stdcall  PropertySheetA(LPCPROPSHEETHEADERA);
 __declspec(dllimport)  int             __stdcall  PropertySheetW(LPCPROPSHEETHEADERW);

#line 226 "C:\WATCOM\H\NT\prsht.h"






typedef BOOL ( __stdcall     * LPFNADDPROPSHEETPAGE)(HPROPSHEETPAGE, LPARAM);
typedef BOOL ( __stdcall     * LPFNADDPROPSHEETPAGES)(LPVOID, LPFNADDPROPSHEETPAGE, LPARAM);


typedef struct _PSHNOTIFY
{
    NMHDR hdr;
    LPARAM lParam;
} PSHNOTIFY,    *LPPSHNOTIFY;








// #define PSN_VALIDATE            (PSN_FIRST-1)


// #define PSN_CANCEL              (PSN_FIRST-3)

































































#line 321 "C:\WATCOM\H\NT\prsht.h"











































#line 367 "C:\WATCOM\H\NT\prsht.h"








































// (WINVER >= 0x0400)


}



#line 26 "C:\WATCOM\H\NT\winspool.h"

/* WINVER >= 0x0400 */

typedef struct _PRINTER_INFO_1A {
    DWORD   Flags;
    LPSTR   pDescription;
    LPSTR   pName;
    LPSTR   pComment;
} PRINTER_INFO_1A, *PPRINTER_INFO_1A, *LPPRINTER_INFO_1A;
typedef struct _PRINTER_INFO_1W {
    DWORD   Flags;
    LPWSTR  pDescription;
    LPWSTR  pName;
    LPWSTR  pComment;
} PRINTER_INFO_1W, *PPRINTER_INFO_1W, *LPPRINTER_INFO_1W;
#line 46 "C:\WATCOM\H\NT\winspool.h"
typedef PRINTER_INFO_1A PRINTER_INFO_1;
typedef PPRINTER_INFO_1A PPRINTER_INFO_1;
typedef LPPRINTER_INFO_1A LPPRINTER_INFO_1;
// UNICODE

typedef struct _PRINTER_INFO_2A {
    LPSTR     pServerName;
    LPSTR     pPrinterName;
    LPSTR     pShareName;
    LPSTR     pPortName;
    LPSTR     pDriverName;
    LPSTR     pComment;
    LPSTR     pLocation;
    LPDEVMODEA pDevMode;
    LPSTR     pSepFile;
    LPSTR     pPrintProcessor;
    LPSTR     pDatatype;
    LPSTR     pParameters;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    DWORD   Attributes;
    DWORD   Priority;
    DWORD   DefaultPriority;
    DWORD   StartTime;
    DWORD   UntilTime;
    DWORD   Status;
    DWORD   cJobs;
    DWORD   AveragePPM;
} PRINTER_INFO_2A, *PPRINTER_INFO_2A, *LPPRINTER_INFO_2A;
typedef struct _PRINTER_INFO_2W {
    LPWSTR    pServerName;
    LPWSTR    pPrinterName;
    LPWSTR    pShareName;
    LPWSTR    pPortName;
    LPWSTR    pDriverName;
    LPWSTR    pComment;
    LPWSTR    pLocation;
    LPDEVMODEW pDevMode;
    LPWSTR    pSepFile;
    LPWSTR    pPrintProcessor;
    LPWSTR    pDatatype;
    LPWSTR    pParameters;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    DWORD   Attributes;
    DWORD   Priority;
    DWORD   DefaultPriority;
    DWORD   StartTime;
    DWORD   UntilTime;
    DWORD   Status;
    DWORD   cJobs;
    DWORD   AveragePPM;
} PRINTER_INFO_2W, *PPRINTER_INFO_2W, *LPPRINTER_INFO_2W;
#line 102 "C:\WATCOM\H\NT\winspool.h"
typedef PRINTER_INFO_2A PRINTER_INFO_2;
typedef PPRINTER_INFO_2A PPRINTER_INFO_2;
typedef LPPRINTER_INFO_2A LPPRINTER_INFO_2;
// UNICODE

typedef struct _PRINTER_INFO_3 {
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
} PRINTER_INFO_3, *PPRINTER_INFO_3, *LPPRINTER_INFO_3;

typedef struct _PRINTER_INFO_4A {
    LPSTR   pPrinterName;
    LPSTR   pServerName;
    DWORD   Attributes;
} PRINTER_INFO_4A, *PPRINTER_INFO_4A, *LPPRINTER_INFO_4A;
typedef struct _PRINTER_INFO_4W {
    LPWSTR  pPrinterName;
    LPWSTR  pServerName;
    DWORD   Attributes;
} PRINTER_INFO_4W, *PPRINTER_INFO_4W, *LPPRINTER_INFO_4W;
#line 126 "C:\WATCOM\H\NT\winspool.h"
typedef PRINTER_INFO_4A PRINTER_INFO_4;
typedef PPRINTER_INFO_4A PPRINTER_INFO_4;
typedef LPPRINTER_INFO_4A LPPRINTER_INFO_4;
// UNICODE

 
typedef struct _PRINTER_INFO_5A {
    LPSTR   pPrinterName;
    LPSTR   pPortName;
    DWORD   Attributes;
    DWORD   DeviceNotSelectedTimeout;
    DWORD   TransmissionRetryTimeout;
} PRINTER_INFO_5A, *PPRINTER_INFO_5A, *LPPRINTER_INFO_5A;
typedef struct _PRINTER_INFO_5W {
    LPWSTR  pPrinterName;
    LPWSTR  pPortName;
    DWORD   Attributes;
    DWORD   DeviceNotSelectedTimeout;
    DWORD   TransmissionRetryTimeout;
} PRINTER_INFO_5W, *PPRINTER_INFO_5W, *LPPRINTER_INFO_5W;
#line 151 "C:\WATCOM\H\NT\winspool.h"
typedef PRINTER_INFO_5A PRINTER_INFO_5;
typedef PPRINTER_INFO_5A PPRINTER_INFO_5;
typedef LPPRINTER_INFO_5A LPPRINTER_INFO_5;
// UNICODE
/* WINVER >= 0x0400 */




 

/* WINVER >= 0x0400 */

























 

/* WINVER >= 0x0400 */














 


/* WINVER >= 0x0400 */








typedef struct _JOB_INFO_1A {
   DWORD    JobId;
   LPSTR      pPrinterName;
   LPSTR      pMachineName;
   LPSTR      pUserName;
   LPSTR      pDocument;
   LPSTR      pDatatype;
   LPSTR      pStatus;
   DWORD    Status;
   DWORD    Priority;
   DWORD    Position;
   DWORD    TotalPages;
   DWORD    PagesPrinted;
   SYSTEMTIME Submitted;
} JOB_INFO_1A, *PJOB_INFO_1A, *LPJOB_INFO_1A;
typedef struct _JOB_INFO_1W {
   DWORD    JobId;
   LPWSTR     pPrinterName;
   LPWSTR     pMachineName;
   LPWSTR     pUserName;
   LPWSTR     pDocument;
   LPWSTR     pDatatype;
   LPWSTR     pStatus;
   DWORD    Status;
   DWORD    Priority;
   DWORD    Position;
   DWORD    TotalPages;
   DWORD    PagesPrinted;
   SYSTEMTIME Submitted;
} JOB_INFO_1W, *PJOB_INFO_1W, *LPJOB_INFO_1W;
#line 252 "C:\WATCOM\H\NT\winspool.h"
typedef JOB_INFO_1A JOB_INFO_1;
typedef PJOB_INFO_1A PJOB_INFO_1;
typedef LPJOB_INFO_1A LPJOB_INFO_1;
// UNICODE

typedef struct _JOB_INFO_2A {
   DWORD    JobId;
   LPSTR      pPrinterName;
   LPSTR      pMachineName;
   LPSTR      pUserName;
   LPSTR      pDocument;
   LPSTR      pNotifyName;
   LPSTR      pDatatype;
   LPSTR      pPrintProcessor;
   LPSTR      pParameters;
   LPSTR      pDriverName;
   LPDEVMODEA pDevMode;
   LPSTR      pStatus;
   PSECURITY_DESCRIPTOR pSecurityDescriptor;
   DWORD    Status;
   DWORD    Priority;
   DWORD    Position;
   DWORD    StartTime;
   DWORD    UntilTime;
   DWORD    TotalPages;
   DWORD    Size;
   SYSTEMTIME Submitted;    // Time the job was spooled 
   DWORD    Time;           // How many seconds the job has been printing 
   DWORD    PagesPrinted;
} JOB_INFO_2A, *PJOB_INFO_2A, *LPJOB_INFO_2A;
typedef struct _JOB_INFO_2W {
   DWORD    JobId;
   LPWSTR     pPrinterName;
   LPWSTR     pMachineName;
   LPWSTR     pUserName;
   LPWSTR     pDocument;
   LPWSTR     pNotifyName;
   LPWSTR     pDatatype;
   LPWSTR     pPrintProcessor;
   LPWSTR     pParameters;
   LPWSTR     pDriverName;
   LPDEVMODEW pDevMode;
   LPWSTR     pStatus;
   PSECURITY_DESCRIPTOR pSecurityDescriptor;
   DWORD    Status;
   DWORD    Priority;
   DWORD    Position;
   DWORD    StartTime;
   DWORD    UntilTime;
   DWORD    TotalPages;
   DWORD    Size;
   SYSTEMTIME Submitted;    // Time the job was spooled 
   DWORD    Time;           // How many seconds the job has been printing 
   DWORD    PagesPrinted;
} JOB_INFO_2W, *PJOB_INFO_2W, *LPJOB_INFO_2W;
#line 312 "C:\WATCOM\H\NT\winspool.h"
typedef JOB_INFO_2A JOB_INFO_2;
typedef PJOB_INFO_2A PJOB_INFO_2;
typedef LPJOB_INFO_2A LPJOB_INFO_2;
// UNICODE





 

/* WINVER >= 0x0400 */











 

/* WINVER >= 0x0400 */



typedef struct _ADDJOB_INFO_1A {
    LPSTR     Path;
    DWORD   JobId;
} ADDJOB_INFO_1A, *PADDJOB_INFO_1A, *LPADDJOB_INFO_1A;
typedef struct _ADDJOB_INFO_1W {
    LPWSTR    Path;
    DWORD   JobId;
} ADDJOB_INFO_1W, *PADDJOB_INFO_1W, *LPADDJOB_INFO_1W;
#line 354 "C:\WATCOM\H\NT\winspool.h"
typedef ADDJOB_INFO_1A ADDJOB_INFO_1;
typedef PADDJOB_INFO_1A PADDJOB_INFO_1;
typedef LPADDJOB_INFO_1A LPADDJOB_INFO_1;
// UNICODE

typedef struct _DRIVER_INFO_1A {
    LPSTR     pName;              // QMS 810 
} DRIVER_INFO_1A, *PDRIVER_INFO_1A, *LPDRIVER_INFO_1A;
typedef struct _DRIVER_INFO_1W {
    LPWSTR    pName;              // QMS 810 
} DRIVER_INFO_1W, *PDRIVER_INFO_1W, *LPDRIVER_INFO_1W;
#line 370 "C:\WATCOM\H\NT\winspool.h"
typedef DRIVER_INFO_1A DRIVER_INFO_1;
typedef PDRIVER_INFO_1A PDRIVER_INFO_1;
typedef LPDRIVER_INFO_1A LPDRIVER_INFO_1;
// UNICODE

typedef struct _DRIVER_INFO_2A {
    DWORD   cVersion;
    LPSTR     pName;              // QMS 810 
    LPSTR     pEnvironment;       // Win32 x86 
    LPSTR     pDriverPath;        // c:\drivers\pscript.dll 
    LPSTR     pDataFile;          // c:\drivers\QMS810.PPD 
    LPSTR     pConfigFile;        // c:\drivers\PSCRPTUI.DLL 
} DRIVER_INFO_2A, *PDRIVER_INFO_2A, *LPDRIVER_INFO_2A;
typedef struct _DRIVER_INFO_2W {
    DWORD   cVersion;
    LPWSTR    pName;              // QMS 810 
    LPWSTR    pEnvironment;       // Win32 x86 
    LPWSTR    pDriverPath;        // c:\drivers\pscript.dll 
    LPWSTR    pDataFile;          // c:\drivers\QMS810.PPD 
    LPWSTR    pConfigFile;        // c:\drivers\PSCRPTUI.DLL 
} DRIVER_INFO_2W, *PDRIVER_INFO_2W, *LPDRIVER_INFO_2W;
#line 396 "C:\WATCOM\H\NT\winspool.h"
typedef DRIVER_INFO_2A DRIVER_INFO_2;
typedef PDRIVER_INFO_2A PDRIVER_INFO_2;
typedef LPDRIVER_INFO_2A LPDRIVER_INFO_2;
// UNICODE

 
typedef struct _DRIVER_INFO_3A {
    DWORD   cVersion;
    LPSTR     pName;                    // QMS 810 
    LPSTR     pEnvironment;             // Win32 x86 
    LPSTR     pDriverPath;              // c:\drivers\pscript.dll 
    LPSTR     pDataFile;                // c:\drivers\QMS810.PPD 
    LPSTR     pConfigFile;              // c:\drivers\PSCRPTUI.DLL 
    LPSTR     pHelpFile;                // c:\drivers\PSCRPTUI.HLP 
    LPSTR     pDependentFiles;          // PSCRIPT.DLL\0QMS810.PPD\0PSCRIPTUI.DLL\0PSCRIPTUI.HLP\0PSTEST.TXT\0\0 
    LPSTR     pMonitorName;             // "PJL monitor" 
    LPSTR     pDefaultDataType;         // "EMF" 
} DRIVER_INFO_3A, *PDRIVER_INFO_3A, *LPDRIVER_INFO_3A;
typedef struct _DRIVER_INFO_3W {
    DWORD   cVersion;
    LPWSTR    pName;                    // QMS 810 
    LPWSTR    pEnvironment;             // Win32 x86 
    LPWSTR    pDriverPath;              // c:\drivers\pscript.dll 
    LPWSTR    pDataFile;                // c:\drivers\QMS810.PPD 
    LPWSTR    pConfigFile;              // c:\drivers\PSCRPTUI.DLL 
    LPWSTR    pHelpFile;                // c:\drivers\PSCRPTUI.HLP 
    LPWSTR    pDependentFiles;          // PSCRIPT.DLL\0QMS810.PPD\0PSCRIPTUI.DLL\0PSCRIPTUI.HLP\0PSTEST.TXT\0\0 
    LPWSTR    pMonitorName;             // "PJL monitor" 
    LPWSTR    pDefaultDataType;         // "EMF" 
} DRIVER_INFO_3W, *PDRIVER_INFO_3W, *LPDRIVER_INFO_3W;
#line 431 "C:\WATCOM\H\NT\winspool.h"
typedef DRIVER_INFO_3A DRIVER_INFO_3;
typedef PDRIVER_INFO_3A PDRIVER_INFO_3;
typedef LPDRIVER_INFO_3A LPDRIVER_INFO_3;
// UNICODE
/* WINVER >= 0x0400 */

typedef struct _DOC_INFO_1A {
    LPSTR     pDocName;
    LPSTR     pOutputFile;
    LPSTR     pDatatype;
} DOC_INFO_1A, *PDOC_INFO_1A, *LPDOC_INFO_1A;
typedef struct _DOC_INFO_1W {
    LPWSTR    pDocName;
    LPWSTR    pOutputFile;
    LPWSTR    pDatatype;
} DOC_INFO_1W, *PDOC_INFO_1W, *LPDOC_INFO_1W;
#line 452 "C:\WATCOM\H\NT\winspool.h"
typedef DOC_INFO_1A DOC_INFO_1;
typedef PDOC_INFO_1A PDOC_INFO_1;
typedef LPDOC_INFO_1A LPDOC_INFO_1;
// UNICODE

typedef struct _FORM_INFO_1A {
    DWORD   Flags;
    LPSTR     pName;
    SIZEL   Size;
    RECTL   ImageableArea;
} FORM_INFO_1A, *PFORM_INFO_1A, *LPFORM_INFO_1A;
typedef struct _FORM_INFO_1W {
    DWORD   Flags;
    LPWSTR    pName;
    SIZEL   Size;
    RECTL   ImageableArea;
} FORM_INFO_1W, *PFORM_INFO_1W, *LPFORM_INFO_1W;
#line 474 "C:\WATCOM\H\NT\winspool.h"
typedef FORM_INFO_1A FORM_INFO_1;
typedef PFORM_INFO_1A PFORM_INFO_1;
typedef LPFORM_INFO_1A LPFORM_INFO_1;
// UNICODE

 
typedef struct _DOC_INFO_2A {
    LPSTR     pDocName;
    LPSTR     pOutputFile;
    LPSTR     pDatatype;
    DWORD   dwMode;
    DWORD   JobId;
} DOC_INFO_2A, *PDOC_INFO_2A, *LPDOC_INFO_2A;
typedef struct _DOC_INFO_2W {
    LPWSTR    pDocName;
    LPWSTR    pOutputFile;
    LPWSTR    pDatatype;
    DWORD   dwMode;
    DWORD   JobId;
} DOC_INFO_2W, *PDOC_INFO_2W, *LPDOC_INFO_2W;
#line 499 "C:\WATCOM\H\NT\winspool.h"
typedef DOC_INFO_2A DOC_INFO_2;
typedef PDOC_INFO_2A PDOC_INFO_2;
typedef LPDOC_INFO_2A LPDOC_INFO_2;
// UNICODE

// start direct read/write channel,
// Direct write only - background read thread ok


/* WINVER >= 0x0400 */




typedef struct _PRINTPROCESSOR_INFO_1A {
    LPSTR     pName;
} PRINTPROCESSOR_INFO_1A, *PPRINTPROCESSOR_INFO_1A, *LPPRINTPROCESSOR_INFO_1A;
typedef struct _PRINTPROCESSOR_INFO_1W {
    LPWSTR    pName;
} PRINTPROCESSOR_INFO_1W, *PPRINTPROCESSOR_INFO_1W, *LPPRINTPROCESSOR_INFO_1W;
#line 524 "C:\WATCOM\H\NT\winspool.h"
typedef PRINTPROCESSOR_INFO_1A PRINTPROCESSOR_INFO_1;
typedef PPRINTPROCESSOR_INFO_1A PPRINTPROCESSOR_INFO_1;
typedef LPPRINTPROCESSOR_INFO_1A LPPRINTPROCESSOR_INFO_1;
// UNICODE

typedef struct _PORT_INFO_1A {
    LPSTR     pName;
} PORT_INFO_1A, *PPORT_INFO_1A, *LPPORT_INFO_1A;
typedef struct _PORT_INFO_1W {
    LPWSTR    pName;
} PORT_INFO_1W, *PPORT_INFO_1W, *LPPORT_INFO_1W;
#line 540 "C:\WATCOM\H\NT\winspool.h"
typedef PORT_INFO_1A PORT_INFO_1;
typedef PPORT_INFO_1A PPORT_INFO_1;
typedef LPPORT_INFO_1A LPPORT_INFO_1;
// UNICODE

 
typedef struct _PORT_INFO_2A {
    LPSTR     pPortName;
    LPSTR     pMonitorName;
    LPSTR     pDescription;
    DWORD     fPortType;
    DWORD     Reserved;
} PORT_INFO_2A, *PPORT_INFO_2A, *LPPORT_INFO_2A;
typedef struct _PORT_INFO_2W {
    LPWSTR    pPortName;
    LPWSTR    pMonitorName;
    LPWSTR    pDescription;
    DWORD     fPortType;
    DWORD     Reserved;
} PORT_INFO_2W, *PPORT_INFO_2W, *LPPORT_INFO_2W;
#line 565 "C:\WATCOM\H\NT\winspool.h"
typedef PORT_INFO_2A PORT_INFO_2;
typedef PPORT_INFO_2A PPORT_INFO_2;
typedef LPPORT_INFO_2A LPPORT_INFO_2;
// UNICODE





/* WINVER >= 0x0400 */

typedef struct _MONITOR_INFO_1A{
    LPSTR     pName;
} MONITOR_INFO_1A, *PMONITOR_INFO_1A, *LPMONITOR_INFO_1A;
typedef struct _MONITOR_INFO_1W{
    LPWSTR    pName;
} MONITOR_INFO_1W, *PMONITOR_INFO_1W, *LPMONITOR_INFO_1W;
#line 587 "C:\WATCOM\H\NT\winspool.h"
typedef MONITOR_INFO_1A MONITOR_INFO_1;
typedef PMONITOR_INFO_1A PMONITOR_INFO_1;
typedef LPMONITOR_INFO_1A LPMONITOR_INFO_1;
// UNICODE

typedef struct _MONITOR_INFO_2A{
    LPSTR     pName;
    LPSTR     pEnvironment;
    LPSTR     pDLLName;
} MONITOR_INFO_2A, *PMONITOR_INFO_2A, *LPMONITOR_INFO_2A;
typedef struct _MONITOR_INFO_2W{
    LPWSTR    pName;
    LPWSTR    pEnvironment;
    LPWSTR    pDLLName;
} MONITOR_INFO_2W, *PMONITOR_INFO_2W, *LPMONITOR_INFO_2W;
#line 607 "C:\WATCOM\H\NT\winspool.h"
typedef MONITOR_INFO_2A MONITOR_INFO_2;
typedef PMONITOR_INFO_2A PMONITOR_INFO_2;
typedef LPMONITOR_INFO_2A LPMONITOR_INFO_2;
// UNICODE

typedef struct _DATATYPES_INFO_1A{
    LPSTR     pName;
} DATATYPES_INFO_1A, *PDATATYPES_INFO_1A, *LPDATATYPES_INFO_1A;
typedef struct _DATATYPES_INFO_1W{
    LPWSTR    pName;
} DATATYPES_INFO_1W, *PDATATYPES_INFO_1W, *LPDATATYPES_INFO_1W;
#line 623 "C:\WATCOM\H\NT\winspool.h"
typedef DATATYPES_INFO_1A DATATYPES_INFO_1;
typedef PDATATYPES_INFO_1A PDATATYPES_INFO_1;
typedef LPDATATYPES_INFO_1A LPDATATYPES_INFO_1;
// UNICODE

typedef struct _PRINTER_DEFAULTSA{
    LPSTR         pDatatype;
    LPDEVMODEA pDevMode;
    ACCESS_MASK DesiredAccess;
} PRINTER_DEFAULTSA, *PPRINTER_DEFAULTSA, *LPPRINTER_DEFAULTSA;
typedef struct _PRINTER_DEFAULTSW{
    LPWSTR        pDatatype;
    LPDEVMODEW pDevMode;
    ACCESS_MASK DesiredAccess;
} PRINTER_DEFAULTSW, *PPRINTER_DEFAULTSW, *LPPRINTER_DEFAULTSW;
#line 643 "C:\WATCOM\H\NT\winspool.h"
typedef PRINTER_DEFAULTSA PRINTER_DEFAULTS;
typedef PPRINTER_DEFAULTSA PPRINTER_DEFAULTS;
typedef LPPRINTER_DEFAULTSA LPPRINTER_DEFAULTS;
// UNICODE

BOOL
 __stdcall 
EnumPrintersA(
    DWORD   Flags,
    LPSTR   Name,
    DWORD   Level,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
BOOL
 __stdcall 
EnumPrintersW(
    DWORD   Flags,
    LPWSTR   Name,
    DWORD   Level,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#line 673 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE























BOOL
 __stdcall 
OpenPrinterA(
   LPSTR    pPrinterName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTSA pDefault
);
BOOL
 __stdcall 
OpenPrinterW(
   LPWSTR    pPrinterName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTSW pDefault
);
#line 715 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE

BOOL
 __stdcall 
ResetPrinterA(
   HANDLE   hPrinter,
   LPPRINTER_DEFAULTSA pDefault
);
BOOL
 __stdcall 
ResetPrinterW(
   HANDLE   hPrinter,
   LPPRINTER_DEFAULTSW pDefault
);
#line 733 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE

BOOL
 __stdcall 
SetJobA(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   Command
);
BOOL
 __stdcall 
SetJobW(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   Command
);
#line 757 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE

BOOL
 __stdcall 
GetJobA(
   HANDLE   hPrinter,
   DWORD    JobId,
   DWORD    Level,
   LPBYTE   pJob,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded
);
BOOL
 __stdcall 
GetJobW(
   HANDLE   hPrinter,
   DWORD    JobId,
   DWORD    Level,
   LPBYTE   pJob,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded
);
#line 783 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE

BOOL
 __stdcall 
EnumJobsA(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
BOOL
 __stdcall 
EnumJobsW(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#line 813 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE

HANDLE
 __stdcall 
AddPrinterA(
    LPSTR   pName,
    DWORD   Level,
    LPBYTE  pPrinter
);
HANDLE
 __stdcall 
AddPrinterW(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPrinter
);
#line 833 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE

BOOL
 __stdcall 
DeletePrinter(
   HANDLE   hPrinter
);

BOOL
 __stdcall 
SetPrinterA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   Command
);
BOOL
 __stdcall 
SetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   Command
);
#line 861 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE

BOOL
 __stdcall 
GetPrinterA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
BOOL
 __stdcall 
GetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
#line 885 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE

BOOL
 __stdcall 
AddPrinterDriverA(
    LPSTR   pName,
    DWORD   Level,
    LPBYTE  pDriverInfo
);
BOOL
 __stdcall 
AddPrinterDriverW(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pDriverInfo
);
#line 905 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE

BOOL
 __stdcall 
EnumPrinterDriversA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
BOOL
 __stdcall 
EnumPrinterDriversW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#line 933 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE

BOOL
 __stdcall 
GetPrinterDriverA(
    HANDLE  hPrinter,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
BOOL
 __stdcall 
GetPrinterDriverW(
    HANDLE  hPrinter,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
#line 959 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE

BOOL
 __stdcall 
GetPrinterDriverDirectoryA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverDirectory,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
BOOL
 __stdcall 
GetPrinterDriverDirectoryW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverDirectory,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
#line 985 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE

BOOL
 __stdcall 
DeletePrinterDriverA(
   LPSTR    pName,
   LPSTR    pEnvironment,
   LPSTR    pDriverName
);
BOOL
 __stdcall 
DeletePrinterDriverW(
   LPWSTR    pName,
   LPWSTR    pEnvironment,
   LPWSTR    pDriverName
);
#line 1005 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE

BOOL
 __stdcall 
AddPrintProcessorA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    LPSTR   pPathName,
    LPSTR   pPrintProcessorName
);
BOOL
 __stdcall 
AddPrintProcessorW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pPathName,
    LPWSTR   pPrintProcessorName
);
#line 1027 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE

BOOL
 __stdcall 
EnumPrintProcessorsA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
BOOL
 __stdcall 
EnumPrintProcessorsW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#line 1055 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE



BOOL
 __stdcall 
GetPrintProcessorDirectoryA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
BOOL
 __stdcall 
GetPrintProcessorDirectoryW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
#line 1083 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE

BOOL
 __stdcall 
EnumPrintProcessorDatatypesA(
    LPSTR   pName,
    LPSTR   pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
BOOL
 __stdcall 
EnumPrintProcessorDatatypesW(
    LPWSTR   pName,
    LPWSTR   pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#line 1111 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE

BOOL
 __stdcall 
DeletePrintProcessorA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    LPSTR   pPrintProcessorName
);
BOOL
 __stdcall 
DeletePrintProcessorW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pPrintProcessorName
);
#line 1131 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE

DWORD
 __stdcall 
StartDocPrinterA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
);
DWORD
 __stdcall 
StartDocPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
);
#line 1151 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE

BOOL
 __stdcall 
StartPagePrinter(
    HANDLE  hPrinter
);

BOOL
 __stdcall 
WritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
);

BOOL
 __stdcall 
EndPagePrinter(
   HANDLE   hPrinter
);

BOOL
 __stdcall 
AbortPrinter(
   HANDLE   hPrinter
);

BOOL
 __stdcall 
ReadPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pNoBytesRead
);

BOOL
 __stdcall 
EndDocPrinter(
   HANDLE   hPrinter
);

BOOL
 __stdcall 
AddJobA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
BOOL
 __stdcall 
AddJobW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
#line 1217 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE

BOOL
 __stdcall 
ScheduleJob(
    HANDLE  hPrinter,
    DWORD   JobId
);

BOOL
 __stdcall 
PrinterProperties(
    HWND    hWnd,
    HANDLE  hPrinter
);

LONG
 __stdcall 
DocumentPropertiesA(
    HWND      hWnd,
    HANDLE    hPrinter,
    LPSTR   pDeviceName,
    PDEVMODEA pDevModeOutput,
    PDEVMODEA pDevModeInput,
    DWORD     fMode
);
LONG
 __stdcall 
DocumentPropertiesW(
    HWND      hWnd,
    HANDLE    hPrinter,
    LPWSTR   pDeviceName,
    PDEVMODEW pDevModeOutput,
    PDEVMODEW pDevModeInput,
    DWORD     fMode
);
#line 1257 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE

LONG
 __stdcall 
AdvancedDocumentPropertiesA(
    HWND    hWnd,
    HANDLE  hPrinter,
    LPSTR   pDeviceName,
    PDEVMODEA pDevModeOutput,
    PDEVMODEA pDevModeInput
);
LONG
 __stdcall 
AdvancedDocumentPropertiesW(
    HWND    hWnd,
    HANDLE  hPrinter,
    LPWSTR   pDeviceName,
    PDEVMODEW pDevModeOutput,
    PDEVMODEW pDevModeInput
);
#line 1281 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE



DWORD
 __stdcall 
GetPrinterDataA(
    HANDLE   hPrinter,
    LPSTR    pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
);
DWORD
 __stdcall 
GetPrinterDataW(
    HANDLE   hPrinter,
    LPWSTR    pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
);
#line 1309 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE



DWORD
 __stdcall 
SetPrinterDataA(
    HANDLE  hPrinter,
    LPSTR   pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
);
DWORD
 __stdcall 
SetPrinterDataW(
    HANDLE  hPrinter,
    LPWSTR   pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
);
#line 1335 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE

























































typedef struct _PRINTER_NOTIFY_OPTIONS_TYPE {
    WORD Type;
    WORD Reserved0;
    DWORD Reserved1;
    DWORD Reserved2;
    DWORD Count;
    PWORD pFields;
} PRINTER_NOTIFY_OPTIONS_TYPE, *PPRINTER_NOTIFY_OPTIONS_TYPE, *LPPRINTER_NOTIFY_OPTIONS_TYPE;




typedef struct _PRINTER_NOTIFY_OPTIONS {
    DWORD Version;
    DWORD Flags;
    DWORD Count;
    PPRINTER_NOTIFY_OPTIONS_TYPE pTypes;
} PRINTER_NOTIFY_OPTIONS, *PPRINTER_NOTIFY_OPTIONS, *LPPRINTER_NOTIFY_OPTIONS;





typedef struct _PRINTER_NOTIFY_INFO_DATA {
    WORD Type;
    WORD Field;
    DWORD Reserved;
    DWORD Id;
    union {
        DWORD adwData[2];
        struct {
            DWORD  cbBuf;
            LPVOID pBuf;
        } Data;
    } NotifyData;
} PRINTER_NOTIFY_INFO_DATA, *PPRINTER_NOTIFY_INFO_DATA, *LPPRINTER_NOTIFY_INFO_DATA;

typedef struct _PRINTER_NOTIFY_INFO {
    DWORD Version;
    DWORD Flags;
    DWORD Count;
    PRINTER_NOTIFY_INFO_DATA aData[1];
} PRINTER_NOTIFY_INFO, *PPRINTER_NOTIFY_INFO, *LPPRINTER_NOTIFY_INFO;

DWORD
 __stdcall 
WaitForPrinterChange(
    HANDLE  hPrinter,
    DWORD   Flags
);

HANDLE
 __stdcall 
FindFirstPrinterChangeNotification(
    HANDLE  hPrinter,
    DWORD   fdwFlags,
    DWORD   fdwOptions,
    LPVOID  pPrinterNotifyOptions
);


BOOL
 __stdcall 
FindNextPrinterChangeNotification(
    HANDLE hChange,
    PDWORD pdwChange,
    LPVOID pvReserved,
    LPVOID *ppPrinterNotifyInfo
);

BOOL
 __stdcall 
FreePrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pPrinterNotifyInfo
);

BOOL
 __stdcall 
FindClosePrinterChangeNotification(
    HANDLE hChange
);





























DWORD
 __stdcall 
PrinterMessageBoxA(
    HANDLE  hPrinter,
    DWORD   Error,
    HWND    hWnd,
    LPSTR   pText,
    LPSTR   pCaption,
    DWORD   dwType
);
DWORD
 __stdcall 
PrinterMessageBoxW(
    HANDLE  hPrinter,
    DWORD   Error,
    HWND    hWnd,
    LPWSTR   pText,
    LPWSTR   pCaption,
    DWORD   dwType
);
#line 1527 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE











BOOL
 __stdcall 
ClosePrinter(
    HANDLE hPrinter
);

BOOL
 __stdcall 
AddFormA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm
);
BOOL
 __stdcall 
AddFormW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm
);
#line 1563 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE



BOOL
 __stdcall 
DeleteFormA(
    HANDLE  hPrinter,
    LPSTR   pFormName
);
BOOL
 __stdcall 
DeleteFormW(
    HANDLE  hPrinter,
    LPWSTR   pFormName
);
#line 1583 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE



BOOL
 __stdcall 
GetFormA(
    HANDLE  hPrinter,
    LPSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
BOOL
 __stdcall 
GetFormW(
    HANDLE  hPrinter,
    LPWSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
#line 1611 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE



BOOL
 __stdcall 
SetFormA(
    HANDLE  hPrinter,
    LPSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm
);
BOOL
 __stdcall 
SetFormW(
    HANDLE  hPrinter,
    LPWSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm
);
#line 1635 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE



BOOL
 __stdcall 
EnumFormsA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
BOOL
 __stdcall 
EnumFormsW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#line 1663 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE



BOOL
 __stdcall 
EnumMonitorsA(
    LPSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
BOOL
 __stdcall 
EnumMonitorsW(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#line 1691 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE



BOOL
 __stdcall 
AddMonitorA(
    LPSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitors
);
BOOL
 __stdcall 
AddMonitorW(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitors
);
#line 1713 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE



BOOL
 __stdcall 
DeleteMonitorA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    LPSTR   pMonitorName
);
BOOL
 __stdcall 
DeleteMonitorW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pMonitorName
);
#line 1735 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE



BOOL
 __stdcall 
EnumPortsA(
    LPSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
BOOL
 __stdcall 
EnumPortsW(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#line 1763 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE



BOOL
 __stdcall 
AddPortA(
    LPSTR   pName,
    HWND    hWnd,
    LPSTR   pMonitorName
);
BOOL
 __stdcall 
AddPortW(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pMonitorName
);
#line 1785 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE



BOOL
 __stdcall 
ConfigurePortA(
    LPSTR   pName,
    HWND    hWnd,
    LPSTR   pPortName
);
BOOL
 __stdcall 
ConfigurePortW(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
);
#line 1807 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE



BOOL
 __stdcall 
DeletePortA(
    LPSTR   pName,
    HWND    hWnd,
    LPSTR   pPortName
);
BOOL
 __stdcall 
DeletePortW(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
);
#line 1829 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE



BOOL
 __stdcall 
AddPrinterConnectionA(
    LPSTR   pName
);
BOOL
 __stdcall 
AddPrinterConnectionW(
    LPWSTR   pName
);
#line 1847 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE



BOOL
 __stdcall 
DeletePrinterConnectionA(
    LPSTR   pName
);
BOOL
 __stdcall 
DeletePrinterConnectionW(
    LPWSTR   pName
);
#line 1865 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE



HANDLE
 __stdcall 
ConnectToPrinterDlg(
    HWND    hwnd,
    DWORD   Flags
);

typedef struct _PROVIDOR_INFO_1A{
    LPSTR     pName;
    LPSTR     pEnvironment;
    LPSTR     pDLLName;
} PROVIDOR_INFO_1A, *PPROVIDOR_INFO_1A, *LPPROVIDOR_INFO_1A;
typedef struct _PROVIDOR_INFO_1W{
    LPWSTR    pName;
    LPWSTR    pEnvironment;
    LPWSTR    pDLLName;
} PROVIDOR_INFO_1W, *PPROVIDOR_INFO_1W, *LPPROVIDOR_INFO_1W;
#line 1892 "C:\WATCOM\H\NT\winspool.h"
typedef PROVIDOR_INFO_1A PROVIDOR_INFO_1;
typedef PPROVIDOR_INFO_1A PPROVIDOR_INFO_1;
typedef LPPROVIDOR_INFO_1A LPPROVIDOR_INFO_1;
// UNICODE



BOOL
 __stdcall 
AddPrintProvidorA(
    LPSTR  pName,
    DWORD    level,
    LPBYTE   pProvidorInfo
);
BOOL
 __stdcall 
AddPrintProvidorW(
    LPWSTR  pName,
    DWORD    level,
    LPBYTE   pProvidorInfo
);
#line 1916 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE

BOOL
 __stdcall 
DeletePrintProvidorA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    LPSTR   pPrintProvidorName
);
BOOL
 __stdcall 
DeletePrintProvidorW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pPrintProvidorName
);
#line 1936 "C:\WATCOM\H\NT\winspool.h"

// !UNICODE












/*
 * Access rights for print servers
 */















/*
 * Access rights for printers
 */














/*
 * Access rights for jobs
 */















}


// _WINSPOOL_

#line 181 "C:\WATCOM\H\NT\windows.h"

#line 185 "C:\WATCOM\H\NT\windows.h"
#line 1 "C:\WATCOM\H\NT\ole2.h"
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       OLE2.h
//  Contents:   Main OLE2 header; Defines Linking and Emmebbeding interfaces, and API's.
//              Also includes .h files for the compobj, and oleauto  subcomponents.
//
//----------------------------------------------------------------------------



// Set packing to 8
#line 1 "C:\WATCOM\H\NT\pshpack8.h"
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pshpack8.h

Abstract:

    This file turns 8 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push)

#pragma pack(8)
#line 32 "C:\WATCOM\H\NT\pshpack8.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 15 "C:\WATCOM\H\NT\ole2.h"


// Make 100% sure WIN32 is defined
#line 21 "C:\WATCOM\H\NT\ole2.h"


// SET to remove _export from interface definitions


#line 1 "C:\WATCOM\H\NT\winerror.h"
/************************************************************************
*                                                                       *
*   winerror.h --  error code definitions for the Win32 API functions   *  
*                                                                       *
*   Copyright (c) 1991-1995, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/

// _WINERROR_#line 8859 "C:\WATCOM\H\NT\winerror.h"
#line 26 "C:\WATCOM\H\NT\ole2.h"


#line 1 "C:\WATCOM\H\NT\objbase.h"
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       objbase.h
//
//  Contents:   Component object model defintions.
//
//----------------------------------------------------------------------------

#line 1 "C:\WATCOM\H\NT\rpc.h"
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    rpc.h

Abstract:

    Master include file for RPC applications.

--*/


#line 1 "C:\WATCOM\H\NT\windows.h"
/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) 1985-1995, Microsoft Corporation

Module Name:


    windows.h

Abstract:

    Master include file for Windows applications.

--*/

/* _WINDOWS_ */#line 216 "C:\WATCOM\H\NT\windows.h"
#line 16 "C:\WATCOM\H\NT\rpc.h"

// RPC_NO_WINDOWS_H

// __RPC_H__#line 121 "C:\WATCOM\H\NT\rpc.h"

#line 12 "C:\WATCOM\H\NT\objbase.h"

#line 1 "C:\WATCOM\H\NT\rpcndr.h"
/*++

Copyright (c) 1992-1995 Microsoft Corporation

Module Name:

    rpcndr.h

Abstract:

    Definitions for stub data structures and prototypes of helper functions.

Environment:

    DOS, Win 3.X, and Win/NT.

--*/




//
// Set the packing level for RPC structures for Dos, Windows and Mac.
//

#line 29 "C:\WATCOM\H\NT\rpcndr.h"

#line 33 "C:\WATCOM\H\NT\rpcndr.h"

#line 1 "C:\WATCOM\H\NT\rpcnsip.h"
/*++

Copyright (c) 1992-1995 Microsoft Corporation

Module Name:

    rpcnsip.h

Abstract:

    This file contains the types and function definitions to use the
    to implement the autohandle features of the runtime.

--*/





extern "C" {


typedef struct
{
   RPC_NS_HANDLE        LookupContext;
   RPC_BINDING_HANDLE   ProposedHandle;
   RPC_BINDING_VECTOR * Bindings;

} RPC_IMPORT_CONTEXT_P, * PRPC_IMPORT_CONTEXT_P;


/* Stub Auto Binding routines. */

RPC_STATUS  __stdcall 
I_RpcNsGetBuffer(
       PRPC_MESSAGE Message
    );

RPC_STATUS  __stdcall 
I_RpcNsSendReceive(
       PRPC_MESSAGE Message,
       RPC_BINDING_HANDLE    * Handle
    );

void  __stdcall 
I_RpcNsRaiseException(
       PRPC_MESSAGE Message,
       RPC_STATUS Status
    );

RPC_STATUS  __stdcall 
I_RpcReBindBuffer(
       PRPC_MESSAGE Message
    );

RPC_STATUS  __stdcall 
I_NsServerBindSearch(
    );

RPC_STATUS  __stdcall 
I_NsClientBindSearch(
    );

void  __stdcall 
I_NsClientBindDone(
    );


}


/* __RPCNSIP_H__ */
#line 34 "C:\WATCOM\H\NT\rpcndr.h"



extern "C" {


/****************************************************************************

     Network Computing Architecture (NCA) definition:

     Network Data Representation: (NDR) Label format:
     An unsigned long (32 bits) with the following layout:

     3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
     1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
    +---------------+---------------+---------------+-------+-------+
    |   Reserved    |   Reserved    |Floating point | Int   | Char  |
    |               |               |Representation | Rep.  | Rep.  |
    +---------------+---------------+---------------+-------+-------+

     Where

         Reserved:

             Must be zero (0) for NCA 1.5 and NCA 2.0.

         Floating point Representation is:

             0 - IEEE
             1 - VAX
             2 - Cray
             3 - IBM

         Int Rep. is Integer Representation:

             0 - Big Endian
             1 - Little Endian

         Char Rep. is Character Representation:

             0 - ASCII
             1 - EBCDIC

     The Microsoft Local Data Representation (for all platforms which are
     of interest currently is edefined below:

 ****************************************************************************/














#line 99 "C:\WATCOM\H\NT\rpcndr.h"




/****************************************************************************
 *  Other MIDL base types / predefined types:
 ****************************************************************************/


typedef unsigned char byte;
typedef unsigned char boolean;




#line 118 "C:\WATCOM\H\NT\rpcndr.h"
typedef double  hyper;
typedef double MIDL_uhyper;


// _HYPER_DEFINED

#line 128 "C:\WATCOM\H\NT\rpcndr.h"


typedef unsigned int size_t;



#line 137 "C:\WATCOM\H\NT\rpcndr.h"

#line 141 "C:\WATCOM\H\NT\rpcndr.h"




#line 148 "C:\WATCOM\H\NT\rpcndr.h"


#line 153 "C:\WATCOM\H\NT\rpcndr.h"

#line 159 "C:\WATCOM\H\NT\rpcndr.h"

void    *  __stdcall  MIDL_user_allocate(size_t);
void              __stdcall  MIDL_user_free( void    * ); 

#line 166 "C:\WATCOM\H\NT\rpcndr.h"




/* winnt only */



#line 178 "C:\WATCOM\H\NT\rpcndr.h"

/****************************************************************************
 * Context handle management related definitions:
 *
 * Client and Server Contexts. 
 *
 ****************************************************************************/

typedef void    * NDR_CCONTEXT;

typedef struct
    {
    void    * pad[2];
    void    * userContext;
    }    * NDR_SCONTEXT;



/* size of context on WIRE */

typedef void ( __stdcall     * NDR_RUNDOWN)(void    * context);

typedef struct _SCONTEXT_QUEUE {
    unsigned long   NumberOfObjects;
    NDR_SCONTEXT  * ArrayOfObjects;
    } SCONTEXT_QUEUE,    * PSCONTEXT_QUEUE;

RPC_BINDING_HANDLE  __stdcall 
NDRCContextBinding (
       NDR_CCONTEXT CContext
    );

void  __stdcall 
NDRCContextMarshall (
            NDR_CCONTEXT CContext,
           void    *pBuff
        );

void  __stdcall 
NDRCContextUnmarshall (
           NDR_CCONTEXT    *pCContext,
            RPC_BINDING_HANDLE hBinding,
            void    *pBuff,
            unsigned long DataRepresentation
        );

void  __stdcall 
NDRSContextMarshall (
            NDR_SCONTEXT CContext,
           void    *pBuff,
            NDR_RUNDOWN userRunDownIn
        );

NDR_SCONTEXT  __stdcall 
NDRSContextUnmarshall (
        void    *pBuff,
        unsigned long DataRepresentation
    );

void  __stdcall 
RpcSsDestroyClientContext (
       void    *    * ContextHandle
    );


/****************************************************************************
    NDR conversion related definitions.
 ****************************************************************************/
















































/****************************************************************************
    Platform specific mapping of c-runtime functions.
 ****************************************************************************/

#line 306 "C:\WATCOM\H\NT\rpcndr.h"

#line 315 "C:\WATCOM\H\NT\rpcndr.h"










/****************************************************************************
    Ndr Library helper function prototypes for MIDL 1.0 ndr functions.
 ****************************************************************************/

void  __stdcall 
NDRcopy (
       void    *pTarget,
       void    *pSource,
       unsigned int size
    );

size_t  __stdcall 
MIDL_wchar_strlen (
       wchar_t    *   s
    );

void  __stdcall 
MIDL_wchar_strcpy (
       void    *     t,
       wchar_t    *   s
    );

void  __stdcall 
char_from_ndr (
          PRPC_MESSAGE                           SourceMessage,
       unsigned char    *                 Target
    );

void  __stdcall 
char_array_from_ndr (
          PRPC_MESSAGE                           SourceMessage,
       unsigned long                              LowerIndex,
       unsigned long                              UpperIndex,
       unsigned char    *                 Target
    );

void  __stdcall 
short_from_ndr (
          PRPC_MESSAGE                           source,
       unsigned short    *                target
    );

void  __stdcall 
short_array_from_ndr(
          PRPC_MESSAGE                           SourceMessage,
       unsigned long                              LowerIndex,
       unsigned long                              UpperIndex,
       unsigned short    *                Target
    );

void  __stdcall 
short_from_ndr_temp (
          unsigned char    *    *  source,
       unsigned short    *                target,
       unsigned long                              format
    );

void  __stdcall 
long_from_ndr (
          PRPC_MESSAGE                           source,
       unsigned long    *                 target
    );

void  __stdcall 
long_array_from_ndr(
          PRPC_MESSAGE                           SourceMessage,
       unsigned long                              LowerIndex,
       unsigned long                              UpperIndex,
       unsigned long    *                 Target
    );

void  __stdcall 
long_from_ndr_temp (
          unsigned char    *    *  source,
       unsigned long    *                 target,
       unsigned long                              format
    );

void  __stdcall 
enum_from_ndr(
          PRPC_MESSAGE                           SourceMessage,
       unsigned int    *                  Target
    );

void  __stdcall 
float_from_ndr (
          PRPC_MESSAGE                           SourceMessage,
       void    *                          Target
    );

void  __stdcall 
float_array_from_ndr (
          PRPC_MESSAGE                           SourceMessage,
       unsigned long                              LowerIndex,
       unsigned long                              UpperIndex,
       void    *                          Target
    );

void  __stdcall 
double_from_ndr (
          PRPC_MESSAGE                           SourceMessage,
       void    *                          Target
    );

void  __stdcall 
double_array_from_ndr (
          PRPC_MESSAGE                           SourceMessage,
       unsigned long                              LowerIndex,
       unsigned long                              UpperIndex,
       void    *                          Target
    );

void  __stdcall 
hyper_from_ndr (
          PRPC_MESSAGE                           source,
          hyper    *                      target
    );

void  __stdcall 
hyper_array_from_ndr(
          PRPC_MESSAGE                           SourceMessage,
       unsigned long                              LowerIndex,
       unsigned long                              UpperIndex,
                hyper    *                Target
    );

void  __stdcall 
hyper_from_ndr_temp (
          unsigned char    *    *  source,
                   hyper    *             target,
         unsigned   long                          format
    );

void  __stdcall 
data_from_ndr (
    PRPC_MESSAGE                                  source,
    void    *                              target,
    char    *                              format,
    unsigned char                                 MscPak
    );

void  __stdcall 
data_into_ndr (
    void    *                              source,
    PRPC_MESSAGE                                  target,
    char    *                              format,
    unsigned char                                 MscPak
    );

void  __stdcall 
tree_into_ndr (
    void    *                              source,
    PRPC_MESSAGE                                  target,
    char    *                              format,
    unsigned char                                 MscPak
    );

void  __stdcall 
data_size_ndr (
    void    *                              source,
    PRPC_MESSAGE                                  target,
    char    *                              format,
    unsigned char                                 MscPak
    );

void  __stdcall 
tree_size_ndr (
    void    *                              source,
    PRPC_MESSAGE                                  target,
    char    *                              format,
    unsigned char                                 MscPak
    );

void  __stdcall 
tree_peek_ndr (
    PRPC_MESSAGE                                  source,
    unsigned char    *    *         buffer,
    char    *                              format,
    unsigned char                                 MscPak
    );

void    *  __stdcall 
midl_allocate (
    size_t      size
    );

/****************************************************************************
    MIDL 2.0 ndr definitions.
 ****************************************************************************/

typedef unsigned long error_status_t;











// Some alignment specific macros.








// Marshalling macros







////////////////////////////////////////////////////////////////////////////
// Ndr macros.
////////////////////////////////////////////////////////////////////////////








        






    






#line 574 "C:\WATCOM\H\NT\rpcndr.h"



//  Mac

/////////////////////////////////////////////////////////////////////////////
// Some stub helper functions.
/////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// Stub helper structures.
////////////////////////////////////////////////////////////////////////////

struct _MIDL_STUB_MESSAGE;
struct _MIDL_STUB_DESC;
struct _FULL_PTR_XLAT_TABLES;

typedef unsigned char    * RPC_BUFPTR;
typedef unsigned long             RPC_LENGTH;

// Expression evaluation callback routine prototype.
typedef void ( __stdcall     * EXPR_EVAL)( struct _MIDL_STUB_MESSAGE    * );

typedef const unsigned char    * PFORMAT_STRING;

/*
 * Multidimensional conformant/varying array struct.
 */
typedef struct 
    {
    long                            Dimension;

    /* These fields MUST be (unsigned long *) */
    unsigned long    *       BufferConformanceMark;
    unsigned long    *       BufferVarianceMark;

    /* Count arrays, used for top level arrays in -Os stubs */
    unsigned long    *       MaxCountArray;
    unsigned long    *       OffsetArray;
    unsigned long    *       ActualCountArray;
    } ARRAY_INFO,    *PARRAY_INFO;

/*
 * MIDL Stub Message
 */

#line 1 "C:\WATCOM\H\NT\pshpack4.h"
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pshpack4.h

Abstract:

    This file turns 4 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push)

#pragma pack(4)
#line 32 "C:\WATCOM\H\NT\pshpack4.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 620 "C:\WATCOM\H\NT\rpcndr.h"



typedef struct _MIDL_STUB_MESSAGE
    {
    /* RPC message structure. */
    PRPC_MESSAGE                RpcMsg;

    /* Pointer into RPC message buffer. */
    unsigned char    *   Buffer;

    /*
     * These are used internally by the Ndr routines to mark the beginning
     * and end of an incoming RPC buffer.
     */
    unsigned char    *   BufferStart;
    unsigned char    *   BufferEnd;

    /*
     * Used internally by the Ndr routines as a place holder in the buffer.
     * On the marshalling side it's used to mark the location where conformance
     * size should be marshalled.
     * On the unmarshalling side it's used to mark the location in the buffer
     * used during pointer unmarshalling to base pointer offsets off of.
     */
    unsigned char    *   BufferMark;

    /* Set by the buffer sizing routines. */
    unsigned long               BufferLength;

    /* Set by the memory sizing routines. */
    unsigned long               MemorySize;

    /* Pointer to user memory. */
    unsigned char    *   Memory;

    /* Is the Ndr routine begin called from a client side stub. */
    int                         IsClient;

    /* Can the buffer be re-used for memory on unmarshalling. */
    int                         ReuseBuffer;    

    /* Holds the current pointer to an allocate all nodes memory block. */
    unsigned char    *   AllocAllNodesMemory;

    /* Used for debugging asserts only, remove later. */
    unsigned char    *   AllocAllNodesMemoryEnd;

    /* 
     * Stuff needed while handling complex structures 
     */

    /* Ignore imbeded pointers while computing buffer or memory sizes. */
    int                         IgnoreEmbeddedPointers;

    /* 
     * This marks the location in the buffer where pointees of a complex
     * struct reside.
     */
    unsigned char    *   PointerBufferMark;

    /*
     * Used to catch errors in SendReceive.
     */
    unsigned char               fBufferValid;

    /*
     * Obsolete unused field (formerly MaxContextHandleNumber).
     */
    unsigned char               Unused;

    /* 
     * Used internally by the Ndr routines.  Holds the max counts for 
     * a conformant array.
     */
    unsigned long               MaxCount;

    /* 
     * Used internally by the Ndr routines.  Holds the offsets for a varying
     * array.
     */
    unsigned long               Offset;

    /* 
     * Used internally by the Ndr routines.  Holds the actual counts for 
     * a varying array.
     */
    unsigned long               ActualCount;

    /* Allocation and Free routine to be used by the Ndr routines. */
    void    *    (    __stdcall  * pfnAllocate)(size_t);
    void                (    __stdcall  * pfnFree)(void    *);

    /*
     * Top of parameter stack.  Used for "single call" stubs during marshalling 
     * to hold the beginning of the parameter list on the stack.  Needed to 
     * extract parameters which hold attribute values for top level arrays and 
     * pointers. 
     */
    unsigned char    *       StackTop;

    /*
     *  Fields used for the transmit_as and represent_as objects.
     *  For represent_as the mapping is: presented=local, transmit=named.
     */
    unsigned char    *       pPresentedType;
    unsigned char    *       pTransmitType;

    /* 
     * When we first construct a binding on the client side, stick it
     * in the rpcmessage and later call RpcGetBuffer, the handle field
     * in the rpcmessage is changed. That's fine except that we need to
     * have that original handle for use in unmarshalling context handles
     * (the second argument in NDRCContextUnmarshall to be exact). So
     * stash the contructed handle here and extract it when needed.
     */
    handle_t                        SavedHandle;

    /*
     * Pointer back to the stub descriptor.  Use this to get all handle info.
     */
    const struct _MIDL_STUB_DESC    *    StubDesc;

    /*
     * Full pointer stuff.
     */
    struct _FULL_PTR_XLAT_TABLES    *    FullPtrXlatTables;

    unsigned long                   FullPtrRefId;

    /*
     * flags
     */

    int                             fCheckBounds;

    int                             fInDontFree       :1;
    int                             fDontCallFreeInst :1;
    int                             fInOnlyParam      :1;
    int                             fHasReturn        :1;

    unsigned long                   dwDestContext;
    void    *                pvDestContext;

    NDR_SCONTEXT *                  SavedContextHandles;

    long                            ParamNumber;

    struct IRpcChannelBuffer    *    pRpcChannelBuffer;

    PARRAY_INFO                     pArrayInfo;

    /* 
     * This is where the Beta2 stub message ends.
     */

    unsigned long    *       SizePtrCountArray;
    unsigned long    *       SizePtrOffsetArray;
    unsigned long    *       SizePtrLengthArray;

    /*
     * Interpreter argument queue.  Used on server side only.
     */
    void    *                pArgQueue;

    unsigned long                   dwStubPhase;

    /*
     * Reserved for future use.
     */
    
    unsigned long                   Reserved[5];

    } MIDL_STUB_MESSAGE,    *PMIDL_STUB_MESSAGE;


#line 1 "C:\WATCOM\H\NT\poppack.h"
/*++

Copyright (c) 1990,95  Microsoft Corporation

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)
#line 33 "C:\WATCOM\H\NT\poppack.h"
#line 36 "C:\WATCOM\H\NT\poppack.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 796 "C:\WATCOM\H\NT\rpcndr.h"



/*
 * Generic handle bind/unbind routine pair.
 */
typedef void    * 
        (    __stdcall  * GENERIC_BINDING_ROUTINE)
        (void    *);
typedef void             
        (    __stdcall  * GENERIC_UNBIND_ROUTINE)
        (void    *, unsigned char    *);

typedef struct _GENERIC_BINDING_ROUTINE_PAIR
    {
    GENERIC_BINDING_ROUTINE     pfnBind;
    GENERIC_UNBIND_ROUTINE      pfnUnbind;
    } GENERIC_BINDING_ROUTINE_PAIR,    *PGENERIC_BINDING_ROUTINE_PAIR;

typedef struct __GENERIC_BINDING_INFO 
    {
    void    *            pObj;
    unsigned int                Size;
    GENERIC_BINDING_ROUTINE     pfnBind;
    GENERIC_UNBIND_ROUTINE      pfnUnbind;
    } GENERIC_BINDING_INFO,    *PGENERIC_BINDING_INFO;

// typedef EXPR_EVAL - see above

typedef void (    __stdcall  * XMIT_HELPER_ROUTINE)( PMIDL_STUB_MESSAGE );

typedef struct _XMIT_ROUTINE_QUINTUPLE
    {
    XMIT_HELPER_ROUTINE     pfnTranslateToXmit;
    XMIT_HELPER_ROUTINE     pfnTranslateFromXmit;
    XMIT_HELPER_ROUTINE     pfnFreeXmit;
    XMIT_HELPER_ROUTINE     pfnFreeInst;
    } XMIT_ROUTINE_QUINTUPLE,    *PXMIT_ROUTINE_QUINTUPLE;

typedef struct _MALLOC_FREE_STRUCT
    {
    void    *	(    __stdcall  * pfnAllocate)(size_t);
    void                (    __stdcall  * pfnFree)(void    *);
    } MALLOC_FREE_STRUCT;

typedef struct _COMM_FAULT_OFFSETS
    {
    short       CommOffset;
    short       FaultOffset;
    } COMM_FAULT_OFFSETS;

/*
 * MIDL Stub Descriptor
 */
typedef struct _MIDL_STUB_DESC
    {

    void    *    RpcInterfaceInformation;

    void    *    (    __stdcall  * pfnAllocate)(size_t);
    void                (    __stdcall  * pfnFree)(void    *);

    union
        {
        handle_t    *            pAutoHandle;
        handle_t    *            pPrimitiveHandle;
        PGENERIC_BINDING_INFO           pGenericBindingInfo;
        } IMPLICIT_HANDLE_INFO;

    const NDR_RUNDOWN    *                   apfnNdrRundownRoutines;
    const GENERIC_BINDING_ROUTINE_PAIR    *  aGenericBindingRoutinePairs;

    const EXPR_EVAL    *                     apfnExprEval;

    const XMIT_ROUTINE_QUINTUPLE    *        aXmitQuintuple;

    const unsigned char    *             pFormatTypes;

    int                                 fCheckBounds;

    /* Ndr library version. */
    unsigned long                       Version;

    /*
     * Reserved for future use.
     */

    MALLOC_FREE_STRUCT    *      pMallocFreeStruct;

    long                                MIDLVersion;

    const COMM_FAULT_OFFSETS    *    CommFaultOffsets;

    } MIDL_STUB_DESC; 

typedef const MIDL_STUB_DESC    * PMIDL_STUB_DESC;

typedef void    * PMIDL_XMIT_TYPE;

/*
 * MIDL Stub Format String.  This is a const in the stub.
 */

#pragma warning( disable:4200 )

typedef struct _MIDL_FORMAT_STRING
    {
    short               Pad;
    unsigned char       Format[];
    } MIDL_FORMAT_STRING;

#pragma warning( default:4200 )


/*
 * Stub thunk used for some interpreted server stubs.
 */
typedef void (    __stdcall  * STUB_THUNK)( PMIDL_STUB_MESSAGE );

typedef long (    __stdcall  * SERVER_ROUTINE)();

/*
 * Server Interpreter's information strucuture.
 */ 
typedef struct  _MIDL_SERVER_INFO_ 
    {
    PMIDL_STUB_DESC             pStubDesc;
    const SERVER_ROUTINE *      DispatchTable;
    PFORMAT_STRING              ProcString;
    const unsigned short *      FmtStringOffset;
    const STUB_THUNK *          ThunkTable;
    } MIDL_SERVER_INFO, *PMIDL_SERVER_INFO;

/*
 * Stubless object proxy information structure.
 */
typedef struct _MIDL_STUBLESS_PROXY_INFO 
    {
    PMIDL_STUB_DESC                     pStubDesc;
    PFORMAT_STRING                      ProcFormatString;
    const unsigned short    *    FormatStringOffset;
    } MIDL_STUBLESS_PROXY_INFO;

typedef MIDL_STUBLESS_PROXY_INFO    * PMIDL_STUBLESS_PROXY_INFO;

/* 
 * This is the return value from NdrClientCall.
 */
typedef union _CLIENT_CALL_RETURN 
    {
    void    *        Pointer;
    long                    Simple;
    } CLIENT_CALL_RETURN;

/*
 * Full pointer data structures.
 */

typedef enum 
        {
        XLAT_SERVER = 1,
        XLAT_CLIENT
        } XLAT_SIDE;

/*
 * Stores the translation for the conversion from a full pointer into it's
 * corresponding ref id.
 */
typedef struct _FULL_PTR_TO_REFID_ELEMENT
    {
    struct _FULL_PTR_TO_REFID_ELEMENT    *  Next;

    void    *            Pointer;
    unsigned long       RefId;
    unsigned char       State;
    } FULL_PTR_TO_REFID_ELEMENT,    *PFULL_PTR_TO_REFID_ELEMENT;

/*
 * Full pointer translation tables.
 */
typedef struct _FULL_PTR_XLAT_TABLES
    {
    /*
     * Ref id to pointer translation information.
     */
    struct
        {
        void    *   *             XlatTable;
        unsigned char    *     StateTable;
        unsigned long       NumberOfEntries;
        } RefIdToPointer;

    /*
     * Pointer to ref id translation information.
     */
    struct
        {
        PFULL_PTR_TO_REFID_ELEMENT    *  XlatTable;
        unsigned long                   NumberOfBuckets;
        unsigned long                   HashMask;
        } PointerToRefId;

    /*
     * Next ref id to use.
     */
    unsigned long           NextRefId;

    /*
     * Keep track of the translation size we're handling : server or client.
     * This tells us when we have to do reverse translations when we insert
     * new translations.  On the server we must insert a pointer-to-refid 
     * translation whenever we insert a refid-to-pointer translation, and 
     * vica versa for the client.
     */
    XLAT_SIDE               XlatSide;
    } FULL_PTR_XLAT_TABLES,    *PFULL_PTR_XLAT_TABLES;

/***************************************************************************
 ** New MIDL 2.0 Ndr routine templates
 ***************************************************************************/

/*
 * Marshall routines
 */

void  __stdcall 
NdrSimpleTypeMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *                       pMemory, 
    unsigned char                       FormatChar   
    );

unsigned char    *  __stdcall 
NdrPointerMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Structures */

unsigned char    *  __stdcall 
NdrSimpleStructMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char    *  __stdcall 
NdrConformantStructMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char    *  __stdcall 
NdrConformantVaryingStructMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char    *  __stdcall 
NdrHardStructMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char    *  __stdcall 
NdrComplexStructMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Arrays */

unsigned char    *  __stdcall 
NdrFixedArrayMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char    *  __stdcall 
NdrConformantArrayMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char    *  __stdcall 
NdrConformantVaryingArrayMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char    *  __stdcall 
NdrVaryingArrayMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char    *  __stdcall 
NdrComplexArrayMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Strings */

unsigned char    *  __stdcall 
NdrNonConformantStringMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char    *  __stdcall 
NdrConformantStringMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Unions */

unsigned char    *  __stdcall 
NdrEncapsulatedUnionMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char    *  __stdcall 
NdrNonEncapsulatedUnionMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Byte count pointer */

unsigned char    *  __stdcall 
NdrByteCountPointerMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Transmit as and represent as*/

unsigned char    *  __stdcall 
NdrXmitOrRepAsMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Cairo interface pointer */

unsigned char    *  __stdcall 
NdrInterfacePointerMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Context handles */

void  __stdcall 
NdrClientContextMarshall( 
    PMIDL_STUB_MESSAGE    pStubMsg,
    NDR_CCONTEXT          ContextHandle,
    int                   fCheck 
    );

void  __stdcall 
NdrServerContextMarshall( 
    PMIDL_STUB_MESSAGE    pStubMsg,
    NDR_SCONTEXT          ContextHandle,
    NDR_RUNDOWN           RundownRoutine 
    );

/*
 * Unmarshall routines
 */

void  __stdcall  
NdrSimpleTypeUnmarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char    *           pMemory, 
    unsigned char                       FormatChar
    );

unsigned char    *  __stdcall  
NdrPointerUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char    *    *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Structures */

unsigned char    *  __stdcall 
NdrSimpleStructUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char    *    *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char    *  __stdcall 
NdrConformantStructUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char    *    *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char    *  __stdcall 
NdrConformantVaryingStructUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char    *    *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char    *  __stdcall  
NdrHardStructUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char    *    *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char    *  __stdcall  
NdrComplexStructUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char    *    *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

/* Arrays */

unsigned char    *  __stdcall 
NdrFixedArrayUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char    *    *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char    *  __stdcall 
NdrConformantArrayUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char    *    *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char    *  __stdcall 
NdrConformantVaryingArrayUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char    *    *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char    *  __stdcall 
NdrVaryingArrayUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char    *    *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char    *  __stdcall 
NdrComplexArrayUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char    *    *   ppMemory, 
    PFORMAT_STRING                          pFormat,   
    unsigned char                           fMustAlloc 
    );

/* Strings */

unsigned char    *  __stdcall 
NdrNonConformantStringUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char    *    *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char    *  __stdcall 
NdrConformantStringUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char    *    *   ppMemory, 
    PFORMAT_STRING                          pFormat,   
    unsigned char                           fMustAlloc 
    );

/* Unions */

unsigned char    *  __stdcall 
NdrEncapsulatedUnionUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char    *    *   ppMemory, 
    PFORMAT_STRING                          pFormat,   
    unsigned char                           fMustAlloc 
    );

unsigned char    *  __stdcall 
NdrNonEncapsulatedUnionUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char    *    *   ppMemory, 
    PFORMAT_STRING                          pFormat,   
    unsigned char                           fMustAlloc 
    );

/* Byte count pointer */

unsigned char    *  __stdcall  
NdrByteCountPointerUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char    *    *   ppMemory, 
    PFORMAT_STRING                          pFormat,   
    unsigned char                           fMustAlloc
    );

/* Transmit as and represent as*/

unsigned char    *  __stdcall  
NdrXmitOrRepAsUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char    *    *   ppMemory, 
    PFORMAT_STRING                          pFormat,   
    unsigned char                           fMustAlloc
    );

/* Cairo interface pointer */

unsigned char    *  __stdcall  
NdrInterfacePointerUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char    *    *   ppMemory, 
    PFORMAT_STRING                          pFormat,   
    unsigned char                           fMustAlloc
    );

/* Context handles */

void  __stdcall 
NdrClientContextUnmarshall( 
    PMIDL_STUB_MESSAGE          pStubMsg,
    NDR_CCONTEXT    *    pContextHandle,
    RPC_BINDING_HANDLE          BindHandle 
    );

NDR_SCONTEXT  __stdcall 
NdrServerContextUnmarshall( 
    PMIDL_STUB_MESSAGE          pStubMsg 
    );

/*
 * Buffer sizing routines
 */

void  __stdcall 
NdrPointerBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Structures */

void  __stdcall 
NdrSimpleStructBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void  __stdcall  
NdrConformantStructBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void  __stdcall  
NdrConformantVaryingStructBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void  __stdcall  
NdrHardStructBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void  __stdcall  
NdrComplexStructBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Arrays */

void  __stdcall  
NdrFixedArrayBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void  __stdcall  
NdrConformantArrayBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void  __stdcall  
NdrConformantVaryingArrayBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void  __stdcall  
NdrVaryingArrayBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void  __stdcall 
NdrComplexArrayBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Strings */

void  __stdcall  
NdrConformantStringBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void  __stdcall  
NdrNonConformantStringBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Unions */

void  __stdcall  
NdrEncapsulatedUnionBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void  __stdcall  
NdrNonEncapsulatedUnionBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Byte count pointer */

void  __stdcall 
NdrByteCountPointerBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Transmit as and represent as*/

void  __stdcall 
NdrXmitOrRepAsBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Cairo Interface pointer */

void  __stdcall 
NdrInterfacePointerBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

// Context Handle size
//
void  __stdcall 
NdrContextHandleSize(
    PMIDL_STUB_MESSAGE          pStubMsg,
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/*
 * Memory sizing routines
 */

unsigned long  __stdcall 
NdrPointerMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Structures */

unsigned long  __stdcall 
NdrSimpleStructMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long  __stdcall  
NdrConformantStructMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long  __stdcall  
NdrConformantVaryingStructMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long  __stdcall  
NdrHardStructMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long  __stdcall  
NdrComplexStructMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Arrays */

unsigned long  __stdcall  
NdrFixedArrayMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long  __stdcall  
NdrConformantArrayMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long  __stdcall  
NdrConformantVaryingArrayMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long  __stdcall  
NdrVaryingArrayMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long  __stdcall  
NdrComplexArrayMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Strings */

unsigned long  __stdcall  
NdrConformantStringMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long  __stdcall  
NdrNonConformantStringMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Unions */

unsigned long  __stdcall  
NdrEncapsulatedUnionMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long  __stdcall  
NdrNonEncapsulatedUnionMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Transmit as and represent as*/

unsigned long  __stdcall 
NdrXmitOrRepAsMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Cairo Interface pointer */

unsigned long  __stdcall 
NdrInterfacePointerMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/*
 * Freeing routines
 */

void  __stdcall 
NdrPointerFree(
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Structures */

void  __stdcall  
NdrSimpleStructFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void  __stdcall  
NdrConformantStructFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void  __stdcall  
NdrConformantVaryingStructFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void  __stdcall 
NdrHardStructFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void  __stdcall 
NdrComplexStructFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Arrays */

void  __stdcall  
NdrFixedArrayFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void  __stdcall  
NdrConformantArrayFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void  __stdcall  
NdrConformantVaryingArrayFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void  __stdcall  
NdrVaryingArrayFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void  __stdcall  
NdrComplexArrayFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Unions */

void  __stdcall  
NdrEncapsulatedUnionFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void  __stdcall  
NdrNonEncapsulatedUnionFree(  
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Byte count */

void  __stdcall  
NdrByteCountPointerFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Transmit as and represent as*/

void  __stdcall  
NdrXmitOrRepAsFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Cairo Interface pointer */

void  __stdcall  
NdrInterfacePointerFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char    *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/*
 * Endian conversion routine.
 */

void  __stdcall  
NdrConvert( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    PFORMAT_STRING                      pFormat   
    );

/* 
 * Auxilary routines
 */

void  __stdcall  
NdrClientInitializeNew( 
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    unsigned int                        ProcNum
    );

unsigned char    *  __stdcall 
NdrServerInitializeNew( 
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor
    );

void  __stdcall  
NdrClientInitialize( 
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    unsigned int                        ProcNum
    );

unsigned char    *  __stdcall 
NdrServerInitialize( 
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor
    );

unsigned char    *  __stdcall 
NdrServerInitializeUnmarshall ( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    PRPC_MESSAGE                        pRpcMsg 
    );

void  __stdcall 
NdrServerInitializeMarshall ( 
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg 
    );

unsigned char    *  __stdcall 
NdrGetBuffer( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long                       BufferLength,
    RPC_BINDING_HANDLE                  Handle
    );

unsigned char    *  __stdcall 
NdrNsGetBuffer( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long                       BufferLength,
    RPC_BINDING_HANDLE                  Handle
    );

unsigned char    *  __stdcall 
NdrSendReceive(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char   *                        pBufferEnd
    );

unsigned char    *  __stdcall 
NdrNsSendReceive(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char    *                       pBufferEnd,
    RPC_BINDING_HANDLE    *              pAutoHandle
    );

void  __stdcall 
NdrFreeBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg
    );

/* 
 * Interpeter calls.
 */

/* client */

CLIENT_CALL_RETURN  __cdecl 
NdrClientCall( 
    PMIDL_STUB_DESC                     pStubDescriptor,
    PFORMAT_STRING                      pFormat,
    ...
    );

/* server */
typedef enum {
    STUB_UNMARSHAL,
    STUB_CALL_SERVER,
    STUB_MARSHAL,
    STUB_CALL_SERVER_NO_HRESULT
}STUB_PHASE;

typedef enum {
    PROXY_CALCSIZE,
    PROXY_GETBUFFER,
    PROXY_MARSHAL,
    PROXY_SENDRECEIVE,
    PROXY_UNMARSHAL
}PROXY_PHASE;


long  __stdcall 
NdrStubCall (
    struct IRpcStubBuffer    *    pThis,
    struct IRpcChannelBuffer    * pChannel,
    PRPC_MESSAGE                         pRpcMsg,
    unsigned long    *            pdwStubPhase
    );

void  __stdcall 
NdrServerCall(
    PRPC_MESSAGE                        pRpcMsg
    );

int  __stdcall 
NdrServerUnmarshall( 
    struct IRpcChannelBuffer    * pChannel,
    PRPC_MESSAGE                         pRpcMsg,
    PMIDL_STUB_MESSAGE                   pStubMsg,
    PMIDL_STUB_DESC                      pStubDescriptor,
    PFORMAT_STRING                       pFormat,
    void    *                     pParamList
    );

void  __stdcall 
NdrServerMarshall(
    struct IRpcStubBuffer    *    pThis,
    struct IRpcChannelBuffer    * pChannel,
    PMIDL_STUB_MESSAGE                   pStubMsg,
    PFORMAT_STRING                       pFormat
    );

/* Comm and Fault status */

RPC_STATUS  __stdcall 
NdrMapCommAndFaultStatus(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long    *                       pCommStatus,
    unsigned long    *                       pFaultStatus,
    RPC_STATUS                          Status
    );

/* Helper routines */

int  __stdcall 
NdrSH_UPDecision(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char              *   *          pPtrInMem,
    RPC_BUFPTR                          pBuffer
    );

int  __stdcall 
NdrSH_TLUPDecision(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char              *   *          pPtrInMem
    );

int  __stdcall 
NdrSH_TLUPDecisionBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char              *   *          pPtrInMem
    );

int  __stdcall 
NdrSH_IfAlloc(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char              *   *          pPtrInMem,
    unsigned long                       Count
    );

int  __stdcall 
NdrSH_IfAllocRef(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char              *   *          pPtrInMem,
    unsigned long                       Count
    );

int  __stdcall 
NdrSH_IfAllocSet(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char              *   *          pPtrInMem,
    unsigned long                       Count
    );

RPC_BUFPTR  __stdcall 
NdrSH_IfCopy(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char              *   *          pPtrInMem,
    unsigned long                       Count
    );

RPC_BUFPTR  __stdcall 
NdrSH_IfAllocCopy(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char              *   *          pPtrInMem,
    unsigned long                       Count
    );

unsigned long  __stdcall 
NdrSH_Copy(
    unsigned char              *         pStubMsg,
    unsigned char              *         pPtrInMem,
    unsigned long                       Count
    );

void  __stdcall 
NdrSH_IfFree(
    PMIDL_STUB_MESSAGE                  pMessage,
    unsigned char              *         pPtr );


RPC_BUFPTR   __stdcall 
NdrSH_StringMarshall(
    PMIDL_STUB_MESSAGE                  pMessage,
    unsigned char              *         pMemory,
    unsigned long                       Count,
    int                                 Size );

RPC_BUFPTR   __stdcall 
NdrSH_StringUnMarshall(
    PMIDL_STUB_MESSAGE                  pMessage,
    unsigned char              *   *          pMemory,
    int                                 Size );

/****************************************************************************
    MIDL 2.0 memory package: rpc_ss_* rpc_sm_*
 ****************************************************************************/

typedef void    * RPC_SS_THREAD_HANDLE;

typedef void    *  __stdcall  
RPC_CLIENT_ALLOC (
       size_t Size
    );

typedef void  __stdcall  
RPC_CLIENT_FREE (
       void    * Ptr
    );

/*++
     RpcSs* package
--*/

void    *  __stdcall 
RpcSsAllocate (
       size_t Size
    );

void  __stdcall 
RpcSsDisableAllocate (
    void
    );

void  __stdcall 
RpcSsEnableAllocate (
    void
    );

void  __stdcall 
RpcSsFree (
       void    * NodeToFree
    );

RPC_SS_THREAD_HANDLE  __stdcall 
RpcSsGetThreadHandle (
    void
    );

void  __stdcall 
RpcSsSetClientAllocFree (
       RPC_CLIENT_ALLOC    * ClientAlloc,
       RPC_CLIENT_FREE    * ClientFree
    );

void  __stdcall 
RpcSsSetThreadHandle (
       RPC_SS_THREAD_HANDLE Id
    );

void  __stdcall 
RpcSsSwapClientAllocFree (
       RPC_CLIENT_ALLOC    * ClientAlloc,
       RPC_CLIENT_FREE    * ClientFree,
       RPC_CLIENT_ALLOC    *    * OldClientAlloc,
       RPC_CLIENT_FREE    *    * OldClientFree
    );

/*++
     RpcSm* package
--*/

void    *  __stdcall 
RpcSmAllocate (
        size_t          Size,
       RPC_STATUS    *    pStatus
    );

RPC_STATUS  __stdcall 
RpcSmClientFree (
        void    * pNodeToFree
    );

RPC_STATUS   __stdcall 
RpcSmDestroyClientContext (
       void    *    * ContextHandle
    );

RPC_STATUS   __stdcall 
RpcSmDisableAllocate (
    void
    );

RPC_STATUS   __stdcall 
RpcSmEnableAllocate (
    void
    );

RPC_STATUS   __stdcall 
RpcSmFree (
       void    * NodeToFree
    );

RPC_SS_THREAD_HANDLE  __stdcall 
RpcSmGetThreadHandle (
       RPC_STATUS    *    pStatus
    );

RPC_STATUS   __stdcall 
RpcSmSetClientAllocFree (
       RPC_CLIENT_ALLOC    * ClientAlloc,
       RPC_CLIENT_FREE    * ClientFree
    );

RPC_STATUS   __stdcall 
RpcSmSetThreadHandle (
       RPC_SS_THREAD_HANDLE Id
    );

RPC_STATUS   __stdcall 
RpcSmSwapClientAllocFree (
       RPC_CLIENT_ALLOC    * ClientAlloc,
       RPC_CLIENT_FREE    * ClientFree,
       RPC_CLIENT_ALLOC    *    * OldClientAlloc,
       RPC_CLIENT_FREE    *    * OldClientFree
    );

/*++
     Ndr stub entry points
--*/

void  __stdcall 
NdrRpcSsEnableAllocate(
    PMIDL_STUB_MESSAGE      pMessage );

void  __stdcall 
NdrRpcSsDisableAllocate(
    PMIDL_STUB_MESSAGE      pMessage );

void  __stdcall 
NdrRpcSmSetClientToOsf(
    PMIDL_STUB_MESSAGE      pMessage );

void    *   __stdcall 
NdrRpcSmClientAllocate (
       size_t Size
    );

void   __stdcall 
NdrRpcSmClientFree (
       void    * NodeToFree
    );

void    *   __stdcall 
NdrRpcSsDefaultAllocate (
       size_t Size
    );

void   __stdcall 
NdrRpcSsDefaultFree (
       void    * NodeToFree
    );

/****************************************************************************
    end of memory package: rpc_ss_* rpc_sm_*
 ****************************************************************************/

/****************************************************************************
 * Full Pointer APIs
 ****************************************************************************/

PFULL_PTR_XLAT_TABLES  __stdcall 
NdrFullPointerXlatInit( 
    unsigned long           NumberOfPointers,
    XLAT_SIDE               XlatSide
    );

void  __stdcall 
NdrFullPointerXlatFree( 
    PFULL_PTR_XLAT_TABLES   pXlatTables
    );

int  __stdcall 
NdrFullPointerQueryPointer( 
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    void    *                    pPointer,
    unsigned char           QueryType,
    unsigned long    *           pRefId
    );

int  __stdcall 
NdrFullPointerQueryRefId( 
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    unsigned long           RefId,
    unsigned char           QueryType,
    void    *   *                 ppPointer
    );

void  __stdcall 
NdrFullPointerInsertRefId( 
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    unsigned long           RefId,
    void    *                    pPointer
    );

int  __stdcall 
NdrFullPointerFree( 
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    void    *                    Pointer
    );

void    *   __stdcall 
NdrAllocate( 
    PMIDL_STUB_MESSAGE      pStubMsg,
    size_t                  Len 
    );

void  __stdcall 
NdrClearOutParameters(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat,
    void    *        ArgAddr
    );


/****************************************************************************
 * Proxy APIs
 ****************************************************************************/

void    *  __stdcall 
NdrOleAllocate (
       size_t Size
    );

void  __stdcall 
NdrOleFree (
       void    * NodeToFree
    );

#line 2246 "C:\WATCOM\H\NT\rpcndr.h"







}


// Reset the packing level for DOS, Windows and Mac.

#line 2261 "C:\WATCOM\H\NT\rpcndr.h"

/* __RPCNDR_H__ */
#line 13 "C:\WATCOM\H\NT\objbase.h"





#line 1 "C:\WATCOM\H\NT\pshpack8.h"
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pshpack8.h

Abstract:

    This file turns 8 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push)

#pragma pack(8)
#line 32 "C:\WATCOM\H\NT\pshpack8.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 18 "C:\WATCOM\H\NT\objbase.h"


// Component Object Model defines, and macros


    
#line 27 "C:\WATCOM\H\NT\objbase.h"



// Win32 doesn't support __export







#line 47 "C:\WATCOM\H\NT\objbase.h"








// The 'V' versions allow Variable Argument lists.







#line 67 "C:\WATCOM\H\NT\objbase.h"




/****** Interface Declaration ***********************************************/

/*
 *      These are macros for declaring interfaces.  They exist so that
 *      a single definition of the interface is simulataneously a proper
 *      declaration of the interface structures (C++ abstract classes)
 *      for both C and C++.
 *
 *      DECLARE_INTERFACE(iface) is used to declare an interface that does
 *      not derive from a base interface.
 *      DECLARE_INTERFACE_(iface, baseiface) is used to declare an interface
 *      that does derive from a base interface.
 *
 *      By default if the source file has a .c extension the C version of
 *      the interface declaratations will be expanded; if it has a .cpp
 *      extension the C++ version will be expanded. if you want to force
 *      the C version expansion even though the source file has a .cpp
 *      extension, then define the macro "CINTERFACE".
 *      eg.     cl -DCINTERFACE file.cpp
 *
 *      Example Interface declaration:
 *
 *          #undef  INTERFACE
 *          #define INTERFACE   IClassFactory
 *
 *          DECLARE_INTERFACE_(IClassFactory, IUnknown)
 *          {
 *              // *** IUnknown methods ***
 *              STDMETHOD(QueryInterface) (THIS_
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObj) PURE;
 *              STDMETHOD_(ULONG,AddRef) (THIS) PURE;
 *              STDMETHOD_(ULONG,Release) (THIS) PURE;
 *
 *              // *** IClassFactory methods ***
 *              STDMETHOD(CreateInstance) (THIS_
 *                                        LPUNKNOWN pUnkOuter,
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObject) PURE;
 *          };
 *
 *      Example C++ expansion:
 *
 *          struct FAR IClassFactory : public IUnknown
 *          {
 *              virtual HRESULT STDMETHODCALLTYPE QueryInterface(
 *                                                  IID FAR& riid,
 *                                                  LPVOID FAR* ppvObj) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE AddRef(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE Release(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE CreateInstance(
 *                                              LPUNKNOWN pUnkOuter,
 *                                              IID FAR& riid,
 *                                              LPVOID FAR* ppvObject) = 0;
 *          };
 *
 *          NOTE: Our documentation says '#define interface class' but we use
 *          'struct' instead of 'class' to keep a lot of 'public:' lines
 *          out of the interfaces.  The 'FAR' forces the 'this' pointers to
 *          be far, which is what we need.
 *
 *      Example C expansion:
 *
 *          typedef struct IClassFactory
 *          {
 *              const struct IClassFactoryVtbl FAR* lpVtbl;
 *          } IClassFactory;
 *
 *          typedef struct IClassFactoryVtbl IClassFactoryVtbl;
 *
 *          struct IClassFactoryVtbl
 *          {
 *              HRESULT (STDMETHODCALLTYPE * QueryInterface) (
 *                                                  IClassFactory FAR* This,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObj) ;
 *              HRESULT (STDMETHODCALLTYPE * AddRef) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * Release) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * CreateInstance) (
 *                                                  IClassFactory FAR* This,
 *                                                  LPUNKNOWN pUnkOuter,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObject);
 *              HRESULT (STDMETHODCALLTYPE * LockServer) (
 *                                                  IClassFactory FAR* This,
 *                                                  BOOL fLock);
 *          };
 */


#line 175 "C:\WATCOM\H\NT\objbase.h"












#line 195 "C:\WATCOM\H\NT\objbase.h"














/****** Additional basic types **********************************************/





// __cplusplus#line 218 "C:\WATCOM\H\NT\objbase.h"
// FARSTRUCT






// WIN32#line 228 "C:\WATCOM\H\NT\objbase.h"
// HUGEP


#line 1 "C:\WATCOM\H\stdlib.h"
/*
 *  stdlib.h	Standard Library functions
 *
 *  Copyright by WATCOM International Corp. 1988-1996.  All rights reserved.
 */


extern "C" {

 
#pragma pack(__push,1);
#line 15 "C:\WATCOM\H\stdlib.h"

/* macros for MS compatibility */
#line 20 "C:\WATCOM\H\stdlib.h"
#line 23 "C:\WATCOM\H\stdlib.h"
#line 26 "C:\WATCOM\H\stdlib.h"

#line 42 "C:\WATCOM\H\stdlib.h"

#line 52 "C:\WATCOM\H\stdlib.h"

#line 57 "C:\WATCOM\H\stdlib.h"

#line 65 "C:\WATCOM\H\stdlib.h"






    


typedef struct	{
	int	quot;
	int	rem;
} div_t;

typedef struct	{
	long	quot;
	long	rem;
} ldiv_t;

extern void	 abort( void );
extern int	 abs( int __j );
extern int	 atexit( register void ( *__func )( void ) );
extern double	 atof( const char *__nptr );
extern int	 atoi( const char *__nptr );
extern long int  atol( const char *__nptr );
extern void	*bsearch( const void *__key, const void *__base,
		    size_t __nmemb, size_t __size,
		    int ( *__compar )( const void *__pkey, const void *__pbase ) );
extern void	 break_on( void );
extern void	 break_off( void );
extern void	*calloc( size_t __n, size_t __size );
extern div_t	 div( int __numer, int __denom );
extern void	 exit( int __status );
extern void	 free( void *__ptr );
extern char	*getenv( const char *__name );
extern long int  labs( long int __j );
extern ldiv_t	 ldiv( long int __numer, long int __denom );
extern void	*malloc( size_t __size );
extern int	 mblen( const char *__s, size_t __n );
extern size_t	 mbstowcs( wchar_t *__pwcs, const char *__s, size_t __n );
extern int	 mbtowc( wchar_t *__pwc, const char *__s, size_t __n );
extern size_t	 wcstombs( char *__s, const wchar_t *__pwcs, size_t __n );
extern int	 wctomb( char *__s, wchar_t __wchar );
extern void	 qsort( void *__base, size_t __nmemb, size_t __size,
		    int (*__compar)( const void *, const void * ) );
extern int	 rand( void );
extern void	*realloc( void *__ptr, size_t __size );
extern void	 srand( unsigned int __seed );
extern double	 strtod( const char *__nptr, char **__endptr );
extern long int  strtol( const char *__nptr, char **__endptr, int __base );
extern unsigned long	 strtoul( const char *__nptr, char **__endptr, int __base );
extern int	 system( const char *__string );

#line 124 "C:\WATCOM\H\stdlib.h"

#line 128 "C:\WATCOM\H\stdlib.h"


/* extensions enabled */

extern void	 _exit( int __status );
extern char	*ecvt( double __val, int __ndig, int *__dec, int *__sign );
extern char	*_ecvt( double __val, int __ndig, int *__dec, int *__sign );
extern char	*fcvt( double __val, int __ndig, int *__dec, int *__sign );
extern char	*_fcvt( double __val, int __ndig, int *__dec, int *__sign );
extern char	*_fullpath( char *__buf, const char *__path, size_t __size );
extern char	*gcvt( double __val, int __ndig, char *__buf );
extern char	*_gcvt( double __val, int __ndig, char *__buf );
extern char	*itoa( int __value, char *__buf, int __radix );
extern char	*_itoa( int __value, char *__buf, int __radix );
extern unsigned long _lrotl( unsigned long __value, unsigned int __shift );
extern unsigned long _lrotr( unsigned long __value, unsigned int __shift );
extern char	*ltoa( long int __value, char *__buf, int __radix );
extern char	*_ltoa( long int __value, char *__buf, int __radix );
extern void	 _makepath( char *__path, const char *__drive,
		    const char *__dir, const char *__fname,
		    const char *__ext );
extern unsigned int _rotl( unsigned int __value, unsigned int __shift );
extern unsigned int _rotr( unsigned int __value, unsigned int __shift );
extern int	 putenv( const char *__string );
extern void	 _searchenv( const char *__name, const char *__env_var,
		    char *__buf );
extern void	 _splitpath2( const char *__inp, char *__outp,
		    char **__drive, char **__dir, char **__fn, char **__ext );
extern void	 _splitpath( const char *__path, char *__drive,
		    char *__dir, char *__fname, char *__ext );
extern void	 swab( char *__src, char *__dest, int __num );
#line 162 "C:\WATCOM\H\stdlib.h"
extern char	*ultoa( unsigned long int __value, char *__buf, int __radix );
extern char	*_utoa( unsigned int __value, char *__buf, int __radix );
extern char	*utoa( unsigned int __value, char *__buf, int __radix );

#line 172 "C:\WATCOM\H\stdlib.h"

/* min and max macros */



#line 180 "C:\WATCOM\H\stdlib.h"



#line 186 "C:\WATCOM\H\stdlib.h"

#line 210 "C:\WATCOM\H\stdlib.h"

/*
 * The following sizes are the maximum sizes of buffers used by the _fullpath()
 * _makepath() and _splitpath() functions.  They include space for the '\0'
 * terminator.
 */
#line 223 "C:\WATCOM\H\stdlib.h"
/* maximum length of full pathname */
/* maximum length of drive component */
/* maximum length of path component */
/* maximum length of file name component */
/* maximum length of extension component */

/* maximum length of file name (with extension) */



/* maximum size of output buffer
				    for _splitpath2() */

extern char **__near environ;	/*  pointer to environment table	*/ 


    

extern int  (*__get_errno_ptr()) ;

extern	int		 (*__get_doserrno_ptr()) ;	/* DOS system error code value */ 
extern	unsigned __near _psp;		/* Program Segment Prefix */ 
/* Real Address Mode */
/* Protected Address Mode */
extern	unsigned char __near _osmode;	/* DOS_MODE or OS2_MODE */ 
extern	int	__near	_fmode; 	/* default file translation mode */ 
extern char *		sys_errlist[];	/* strerror error message table */ 
extern int	__near	sys_nerr;	/* # of entries on sys_errlist array */ 
extern unsigned __near	__minreal;	/* DOS4GW var for WLINK MINREAL option*/ 
extern unsigned long __near __win_alloc_flags; /* Windows allocation flags */ 
extern unsigned long __near __win_realloc_flags;/* Windows reallocation flags */ 
extern unsigned char __near _osmajor;	/*  O/S version #		    */ 
extern unsigned char __near _osminor;	/*  O/S version #		    */ 
extern unsigned __near	    _amblksiz;	/*  mallocs done in multiples of    */ 

extern void __near *__brk(unsigned __new_brk_value);
extern void __near *sbrk(int __increment);
 typedef void (*onexit_t)();
extern onexit_t onexit(onexit_t __func);


 
#pragma pack(__pop);
#line 269 "C:\WATCOM\H\stdlib.h"


};


#line 231 "C:\WATCOM\H\NT\objbase.h"




















// class registration flags; passed to CoRegisterClassObject
typedef enum tagREGCLS
{
    REGCLS_SINGLEUSE = 0,       // class object only generates one instance 
    REGCLS_MULTIPLEUSE = 1,     // same class object genereates multiple inst. 
                                // and local automatically goes into inproc tbl.
    REGCLS_MULTI_SEPARATE = 2   // multiple use, but separate control over each 
                                // context.
} REGCLS;

// interface marshaling definitions
// minimum number of bytes for interface marshl


//
// Common typedefs for paramaters used in Storage API's, gleamed from storage.h
// Also contains Storage error codes, which should be moved into the storage
// idl files.
//




/* Storage instantiation modes */















 

/* WINVER */






/* here is where we pull in the MIDL generated headers for the interfaces */
typedef  struct     IRpcStubBuffer     IRpcStubBuffer;
typedef  struct     IRpcChannelBuffer  IRpcChannelBuffer;

#line 1 "C:\WATCOM\H\NT\wtypes.h"
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Fri Apr 28 07:02:29 1995
 */
//@@MIDL_FILE_HEADING(  )
#line 1 "C:\WATCOM\H\NT\rpc.h"
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    rpc.h

Abstract:

    Master include file for RPC applications.

--*/


#line 1 "C:\WATCOM\H\NT\windows.h"
/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) 1985-1995, Microsoft Corporation

Module Name:


    windows.h

Abstract:

    Master include file for Windows applications.

--*/

/* _WINDOWS_ */#line 216 "C:\WATCOM\H\NT\windows.h"
#line 16 "C:\WATCOM\H\NT\rpc.h"

// RPC_NO_WINDOWS_H

// __RPC_H__#line 121 "C:\WATCOM\H\NT\rpc.h"

#line 8 "C:\WATCOM\H\NT\wtypes.h"

#line 1 "C:\WATCOM\H\NT\rpcndr.h"
/*++

Copyright (c) 1992-1995 Microsoft Corporation

Module Name:

    rpcndr.h

Abstract:

    Definitions for stub data structures and prototypes of helper functions.

Environment:

    DOS, Win 3.X, and Win/NT.

--*/

/* __RPCNDR_H__ */#line 2263 "C:\WATCOM\H\NT\rpcndr.h"
#line 9 "C:\WATCOM\H\NT\wtypes.h"






extern "C"{


/* Forward Declarations */ 

void    *  __stdcall  MIDL_user_allocate(size_t);
void  __stdcall  MIDL_user_free( void    * ); 




/****************************************
 * Generated header for interface: IWinTypes
 * at Fri Apr 28 07:02:29 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [auto_handle][unique][version][uuid] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//--------------------------------------------------------------------------
			/* size is 8 */
typedef struct  tagRemHGLOBAL
    {
    long fNullHGlobal;
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    }	RemHGLOBAL;

			/* size is 16 */
typedef struct  tagRemHMETAFILEPICT
    {
    long mm;
    long xExt;
    long yExt;
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    }	RemHMETAFILEPICT;

			/* size is 4 */
typedef /* [transmit] */  void    *HMETAFILEPICT;

			/* size is 4 */
typedef struct  tagRemHENHMETAFILE
    {
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    }	RemHENHMETAFILE;

			/* size is 4 */
typedef struct  tagRemHBITMAP
    {
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    }	RemHBITMAP;

			/* size is 4 */
typedef struct  tagRemHPALETTE
    {
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    }	RemHPALETTE;

			/* size is 4 */
typedef struct  tagRemBRUSH
    {
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    }	RemHBRUSH;

// The following code is for Win16 only//!WIN32#line 436 "C:\WATCOM\H\NT\wtypes.h"

			/* size is 2 */
typedef WCHAR OLECHAR;

			/* size is 4 */
typedef /* [string] */  OLECHAR    *LPOLESTR;

			/* size is 4 */
typedef /* [string] */  const OLECHAR    *LPCOLESTR;


#line 453 "C:\WATCOM\H\NT\wtypes.h"
//_WINDEF_#line 482 "C:\WATCOM\H\NT\wtypes.h"
			/* size is 1 */
typedef unsigned char UCHAR;

			/* size is 2 */
typedef short SHORT;

			/* size is 2 */
typedef unsigned short USHORT;

			/* size is 4 */
typedef DWORD ULONG;

// #line 523 "C:\WATCOM\H\NT\wtypes.h"
//_WINBASE_#line 619 "C:\WATCOM\H\NT\wtypes.h"
			/* size is 4 */
typedef LONG SCODE;

			/* size is 4 */
typedef LONG HRESULT;

			/* size is 4 */
typedef SCODE    *PSCODE;

// !GUID_DEFINED#line 640 "C:\WATCOM\H\NT\wtypes.h"


			/* size is 4 */
typedef GUID    *LPGUID;

// !__LPGUID_DEFINED__
// !_OBJECTID_DEFINED#line 657 "C:\WATCOM\H\NT\wtypes.h"


			/* size is 16 */
typedef GUID IID;

			/* size is 4 */
typedef IID    *LPIID;



			/* size is 16 */
typedef GUID CLSID;

			/* size is 4 */
typedef CLSID    *LPCLSID;



// 0#line 686 "C:\WATCOM\H\NT\wtypes.h"




// !_REFGUID_DEFINED



// !_REFIID_DEFINED



// !_REFCLSID_DEFINED
// !__cplusplus#line 713 "C:\WATCOM\H\NT\wtypes.h"
// !__IID_DEFINED__
			/* size is 2 */
typedef 
enum tagMEMCTX
    {	MEMCTX_TASK	= 1,
	MEMCTX_SHARED	= 2,
	MEMCTX_MACSYSTEM	= 3,
	MEMCTX_UNKNOWN	= -1,
	MEMCTX_SAME	= -2
    }	MEMCTX;




// !_ROTFLAGS_DEFINED



// !_ROT_COMPARE_MAX_DEFINED
			/* size is 2 */
typedef 
enum tagCLSCTX
    {	CLSCTX_INPROC_SERVER	= 1,
	CLSCTX_INPROC_HANDLER	= 2,
	CLSCTX_LOCAL_SERVER	= 4,
	CLSCTX_INPROC_SERVER16	= 8
    }	CLSCTX;

			/* size is 2 */
typedef 
enum tagMSHLFLAGS
    {	MSHLFLAGS_NORMAL	= 0,
	MSHLFLAGS_TABLESTRONG	= 1,
	MSHLFLAGS_TABLEWEAK	= 2
    }	MSHLFLAGS;

			/* size is 2 */
typedef 
enum tagMSHCTX
    {	MSHCTX_LOCAL	= 0,
	MSHCTX_NOSHAREDMEM	= 1,
	MSHCTX_DIFFERENTMACHINE	= 2,
	MSHCTX_INPROC	= 3
    }	MSHCTX;

			/* size is 2 */
typedef 
enum tagDVASPECT
    {	DVASPECT_CONTENT	= 1,
	DVASPECT_THUMBNAIL	= 2,
	DVASPECT_ICON	= 4,
	DVASPECT_DOCPRINT	= 8
    }	DVASPECT;

			/* size is 2 */
typedef 
enum tagSTGC
    {	STGC_DEFAULT	= 0,
	STGC_OVERWRITE	= 1,
	STGC_ONLYIFCURRENT	= 2,
	STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE	= 4
    }	STGC;

			/* size is 2 */
typedef 
enum tagSTGMOVE
    {	STGMOVE_MOVE	= 0,
	STGMOVE_COPY	= 1
    }	STGMOVE;

			/* size is 2 */
typedef 
enum tagSTATFLAG
    {	STATFLAG_DEFAULT	= 0,
	STATFLAG_NONAME	= 1
    }	STATFLAG;

			/* size is 4 */
typedef /* [context_handle] */  void    *HCONTEXT;



			/* size is 4 */
typedef DWORD LCID;

// !_LCID_DEFINED
void  __stdcall  HGLOBAL_to_xmit (HGLOBAL    *, RemHGLOBAL    *    *);
void  __stdcall  HGLOBAL_from_xmit (RemHGLOBAL    *, HGLOBAL    *);
void  __stdcall  HGLOBAL_free_inst (HGLOBAL    *);
void  __stdcall  HGLOBAL_free_xmit (RemHGLOBAL    *);
void  __stdcall  HBITMAP_to_xmit (HBITMAP    *, RemHBITMAP    *    *);
void  __stdcall  HBITMAP_from_xmit (RemHBITMAP    *, HBITMAP    *);
void  __stdcall  HBITMAP_free_inst (HBITMAP    *);
void  __stdcall  HBITMAP_free_xmit (RemHBITMAP    *);
void  __stdcall  HPALETTE_to_xmit (HPALETTE    *, RemHPALETTE    *    *);
void  __stdcall  HPALETTE_from_xmit (RemHPALETTE    *, HPALETTE    *);
void  __stdcall  HPALETTE_free_inst (HPALETTE    *);
void  __stdcall  HPALETTE_free_xmit (RemHPALETTE    *);
void  __stdcall  HBRUSH_to_xmit (HBRUSH    *, RemHBRUSH    *    *);
void  __stdcall  HBRUSH_from_xmit (RemHBRUSH    *, HBRUSH    *);
void  __stdcall  HBRUSH_free_inst (HBRUSH    *);
void  __stdcall  HBRUSH_free_xmit (RemHBRUSH    *);
void  __stdcall  HMETAFILEPICT_to_xmit (HMETAFILEPICT    *, RemHMETAFILEPICT    *    *);
void  __stdcall  HMETAFILEPICT_from_xmit (RemHMETAFILEPICT    *, HMETAFILEPICT    *);
void  __stdcall  HMETAFILEPICT_free_inst (HMETAFILEPICT    *);
void  __stdcall  HMETAFILEPICT_free_xmit (RemHMETAFILEPICT    *);
void  __stdcall  HENHMETAFILE_to_xmit (HENHMETAFILE    *, RemHENHMETAFILE    *    *);
void  __stdcall  HENHMETAFILE_from_xmit (RemHENHMETAFILE    *, HENHMETAFILE    *);
void  __stdcall  HENHMETAFILE_free_inst (HENHMETAFILE    *);
void  __stdcall  HENHMETAFILE_free_xmit (RemHENHMETAFILE    *);


extern RPC_IF_HANDLE IWinTypes_v0_1_c_ifspec;
extern RPC_IF_HANDLE IWinTypes_v0_1_s_ifspec;
/* __IWinTypes_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */


}



#line 303 "C:\WATCOM\H\NT\objbase.h"

#line 1 "C:\WATCOM\H\NT\unknwn.h"
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Fri Apr 28 07:02:30 1995
 */
//@@MIDL_FILE_HEADING(  )
#line 1 "C:\WATCOM\H\NT\rpc.h"
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    rpc.h

Abstract:

    Master include file for RPC applications.

--*/


#line 1 "C:\WATCOM\H\NT\windows.h"
/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) 1985-1995, Microsoft Corporation

Module Name:


    windows.h

Abstract:

    Master include file for Windows applications.

--*/

/* _WINDOWS_ */#line 216 "C:\WATCOM\H\NT\windows.h"
#line 16 "C:\WATCOM\H\NT\rpc.h"

// RPC_NO_WINDOWS_H

// __RPC_H__#line 121 "C:\WATCOM\H\NT\rpc.h"

#line 8 "C:\WATCOM\H\NT\unknwn.h"

#line 1 "C:\WATCOM\H\NT\rpcndr.h"
/*++

Copyright (c) 1992-1995 Microsoft Corporation

Module Name:

    rpcndr.h

Abstract:

    Definitions for stub data structures and prototypes of helper functions.

Environment:

    DOS, Win 3.X, and Win/NT.

--*/

/* __RPCNDR_H__ */#line 2263 "C:\WATCOM\H\NT\rpcndr.h"
#line 9 "C:\WATCOM\H\NT\unknwn.h"


#line 1 "C:\WATCOM\H\NT\windows.h"
/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) 1985-1995, Microsoft Corporation

Module Name:


    windows.h

Abstract:

    Master include file for Windows applications.

--*/

/* _WINDOWS_ */#line 216 "C:\WATCOM\H\NT\windows.h"
#line 11 "C:\WATCOM\H\NT\unknwn.h"

#line 1 "C:\WATCOM\H\NT\ole2.h"
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       OLE2.h
//  Contents:   Main OLE2 header; Defines Linking and Emmebbeding interfaces, and API's.
//              Also includes .h files for the compobj, and oleauto  subcomponents.
//
//----------------------------------------------------------------------------
// __OLE2_H__#line 305 "C:\WATCOM\H\NT\ole2.h"

#line 12 "C:\WATCOM\H\NT\unknwn.h"

/*COM_NO_WINDOWS_H*/





extern "C"{


/* Forward Declarations */ 



typedef  struct  IUnknown IUnknown;
/* __IUnknown_FWD_DEFINED__ */




typedef  struct  IClassFactory IClassFactory;
/* __IClassFactory_FWD_DEFINED__ */


/* header files for imported files */
#line 1 "C:\WATCOM\H\NT\wtypes.h"
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Fri Apr 28 07:02:29 1995
 */
//@@MIDL_FILE_HEADING(  )
#line 1 "C:\WATCOM\H\NT\rpc.h"
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    rpc.h

Abstract:

    Master include file for RPC applications.

--*/


#line 1 "C:\WATCOM\H\NT\windows.h"
/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) 1985-1995, Microsoft Corporation

Module Name:


    windows.h

Abstract:

    Master include file for Windows applications.

--*/

/* _WINDOWS_ */#line 216 "C:\WATCOM\H\NT\windows.h"
#line 16 "C:\WATCOM\H\NT\rpc.h"

// RPC_NO_WINDOWS_H

// __RPC_H__#line 121 "C:\WATCOM\H\NT\rpc.h"

#line 8 "C:\WATCOM\H\NT\wtypes.h"

#line 1 "C:\WATCOM\H\NT\rpcndr.h"
/*++

Copyright (c) 1992-1995 Microsoft Corporation

Module Name:

    rpcndr.h

Abstract:

    Definitions for stub data structures and prototypes of helper functions.

Environment:

    DOS, Win 3.X, and Win/NT.

--*/

/* __RPCNDR_H__ */#line 2263 "C:\WATCOM\H\NT\rpcndr.h"
#line 9 "C:\WATCOM\H\NT\wtypes.h"


#line 838 "C:\WATCOM\H\NT\wtypes.h"
#line 37 "C:\WATCOM\H\NT\unknwn.h"


void    *  __stdcall  MIDL_user_allocate(size_t);
void  __stdcall  MIDL_user_free( void    * ); 




/****************************************
 * Generated header for interface: IUnknown
 * at Fri Apr 28 07:02:30 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object][local] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//--------------------------------------------------------------------------
			/* size is 4 */
typedef /* [unique] */  IUnknown    *LPUNKNOWN;

//////////////////////////////////////////////////////////////////
// IID_IUnknown and all other system IIDs are provided in UUID.LIB
// Link that library in with your proxies, clients and servers
//////////////////////////////////////////////////////////////////

 extern "C"  const IID __cdecl IID_IUnknown;

/* C style interface */#line 85 "C:\WATCOM\H\NT\unknwn.h"

    typedef struct IUnknownVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IUnknown    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IUnknown    * This);
        
        ULONG ( __stdcall    *Release )( 
            IUnknown    * This);
        
    } IUnknownVtbl;

     struct  IUnknown
    {
           struct IUnknownVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 122 "C:\WATCOM\H\NT\unknwn.h"


/* C style interface */



HRESULT __stdcall IUnknown_QueryInterface_Proxy( 
    IUnknown    * This,
    /* [in] */  const IID &  riid,
    /* [out] */ void    *   *ppvObject);


void  __stdcall  IUnknown_QueryInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG __stdcall IUnknown_AddRef_Proxy( 
    IUnknown    * This);


void  __stdcall  IUnknown_AddRef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG __stdcall IUnknown_Release_Proxy( 
    IUnknown    * This);


void  __stdcall  IUnknown_Release_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IUnknown_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IClassFactory
 * at Fri Apr 28 07:02:30 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IClassFactory    *LPCLASSFACTORY;


 extern "C"  const IID __cdecl IID_IClassFactory;

/* C style interface */#line 200 "C:\WATCOM\H\NT\unknwn.h"

    typedef struct IClassFactoryVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IClassFactory    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IClassFactory    * This);
        
        ULONG ( __stdcall    *Release )( 
            IClassFactory    * This);
        
        /* [local] */ HRESULT ( __stdcall    *CreateInstance )( 
            IClassFactory    * This,
            /* [unique][in] */ IUnknown    *pUnkOuter,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        HRESULT ( __stdcall    *LockServer )( 
            IClassFactory    * This,
            /* [in] */ BOOL fLock);
        
    } IClassFactoryVtbl;

     struct  IClassFactory
    {
           struct IClassFactoryVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 254 "C:\WATCOM\H\NT\unknwn.h"


/* C style interface */



/* [call_as] */ HRESULT __stdcall IClassFactory_RemoteCreateInstance_Proxy( 
    IClassFactory    * This,
    /* [in] */  const IID &  riid,
    /* [iid_is][out] */ IUnknown    *   *ppvObject);


void  __stdcall  IClassFactory_RemoteCreateInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IClassFactory_LockServer_Proxy( 
    IClassFactory    * This,
    /* [in] */ BOOL fLock);


void  __stdcall  IClassFactory_LockServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IClassFactory_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* [local] */ HRESULT __stdcall IClassFactory_CreateInstance_Proxy( 
    IClassFactory    * This,
    /* [unique][in] */ IUnknown    *pUnkOuter,
    /* [in] */  const IID &  riid,
    /* [out] */ void    *   *ppvObject);


/* [call_as] */ HRESULT __stdcall IClassFactory_CreateInstance_Stub( 
    IClassFactory    * This,
    /* [in] */  const IID &  riid,
    /* [iid_is][out] */ IUnknown    *   *ppvObject);



/* end of Additional Prototypes */


}



#line 304 "C:\WATCOM\H\NT\objbase.h"

#line 1 "C:\WATCOM\H\NT\objidl.h"
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Fri Apr 28 07:02:32 1995
 */
//@@MIDL_FILE_HEADING(  )
#line 1 "C:\WATCOM\H\NT\rpc.h"
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    rpc.h

Abstract:

    Master include file for RPC applications.

--*/


#line 1 "C:\WATCOM\H\NT\windows.h"
/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) 1985-1995, Microsoft Corporation

Module Name:


    windows.h

Abstract:

    Master include file for Windows applications.

--*/

/* _WINDOWS_ */#line 216 "C:\WATCOM\H\NT\windows.h"
#line 16 "C:\WATCOM\H\NT\rpc.h"

// RPC_NO_WINDOWS_H

// __RPC_H__#line 121 "C:\WATCOM\H\NT\rpc.h"

#line 8 "C:\WATCOM\H\NT\objidl.h"

#line 1 "C:\WATCOM\H\NT\rpcndr.h"
/*++

Copyright (c) 1992-1995 Microsoft Corporation

Module Name:

    rpcndr.h

Abstract:

    Definitions for stub data structures and prototypes of helper functions.

Environment:

    DOS, Win 3.X, and Win/NT.

--*/

/* __RPCNDR_H__ */#line 2263 "C:\WATCOM\H\NT\rpcndr.h"
#line 9 "C:\WATCOM\H\NT\objidl.h"


#line 1 "C:\WATCOM\H\NT\windows.h"
/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) 1985-1995, Microsoft Corporation

Module Name:


    windows.h

Abstract:

    Master include file for Windows applications.

--*/

/* _WINDOWS_ */#line 216 "C:\WATCOM\H\NT\windows.h"
#line 11 "C:\WATCOM\H\NT\objidl.h"

#line 1 "C:\WATCOM\H\NT\ole2.h"
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       OLE2.h
//  Contents:   Main OLE2 header; Defines Linking and Emmebbeding interfaces, and API's.
//              Also includes .h files for the compobj, and oleauto  subcomponents.
//
//----------------------------------------------------------------------------
// __OLE2_H__#line 305 "C:\WATCOM\H\NT\ole2.h"

#line 12 "C:\WATCOM\H\NT\objidl.h"

/*COM_NO_WINDOWS_H*/





extern "C"{


/* Forward Declarations */ 



typedef  struct  IMarshal IMarshal;
/* __IMarshal_FWD_DEFINED__ */




typedef  struct  IMalloc IMalloc;
/* __IMalloc_FWD_DEFINED__ */




typedef  struct  IMallocSpy IMallocSpy;
/* __IMallocSpy_FWD_DEFINED__ */




typedef  struct  IStdMarshalInfo IStdMarshalInfo;
/* __IStdMarshalInfo_FWD_DEFINED__ */




typedef  struct  IExternalConnection IExternalConnection;
/* __IExternalConnection_FWD_DEFINED__ */




typedef  struct  IEnumUnknown IEnumUnknown;
/* __IEnumUnknown_FWD_DEFINED__ */




typedef  struct  IBindCtx IBindCtx;
/* __IBindCtx_FWD_DEFINED__ */




typedef  struct  IEnumMoniker IEnumMoniker;
/* __IEnumMoniker_FWD_DEFINED__ */




typedef  struct  IRunnableObject IRunnableObject;
/* __IRunnableObject_FWD_DEFINED__ */




typedef  struct  IRunningObjectTable IRunningObjectTable;
/* __IRunningObjectTable_FWD_DEFINED__ */




typedef  struct  IPersist IPersist;
/* __IPersist_FWD_DEFINED__ */




typedef  struct  IPersistStream IPersistStream;
/* __IPersistStream_FWD_DEFINED__ */




typedef  struct  IMoniker IMoniker;
/* __IMoniker_FWD_DEFINED__ */




typedef  struct  IROTData IROTData;
/* __IROTData_FWD_DEFINED__ */




typedef  struct  IEnumString IEnumString;
/* __IEnumString_FWD_DEFINED__ */




typedef  struct  IStream IStream;
/* __IStream_FWD_DEFINED__ */




typedef  struct  IEnumSTATSTG IEnumSTATSTG;
/* __IEnumSTATSTG_FWD_DEFINED__ */




typedef  struct  IStorage IStorage;
/* __IStorage_FWD_DEFINED__ */




typedef  struct  IPersistFile IPersistFile;
/* __IPersistFile_FWD_DEFINED__ */




typedef  struct  IPersistStorage IPersistStorage;
/* __IPersistStorage_FWD_DEFINED__ */




typedef  struct  ILockBytes ILockBytes;
/* __ILockBytes_FWD_DEFINED__ */




typedef  struct  IEnumFORMATETC IEnumFORMATETC;
/* __IEnumFORMATETC_FWD_DEFINED__ */




typedef  struct  IEnumSTATDATA IEnumSTATDATA;
/* __IEnumSTATDATA_FWD_DEFINED__ */




typedef  struct  IRootStorage IRootStorage;
/* __IRootStorage_FWD_DEFINED__ */




typedef  struct  IAdviseSink IAdviseSink;
/* __IAdviseSink_FWD_DEFINED__ */




typedef  struct  IAdviseSink2 IAdviseSink2;
/* __IAdviseSink2_FWD_DEFINED__ */




typedef  struct  IDataObject IDataObject;
/* __IDataObject_FWD_DEFINED__ */




typedef  struct  IDataAdviseHolder IDataAdviseHolder;
/* __IDataAdviseHolder_FWD_DEFINED__ */




typedef  struct  IMessageFilter IMessageFilter;
/* __IMessageFilter_FWD_DEFINED__ */




typedef  struct  IRpcChannelBuffer IRpcChannelBuffer;
/* __IRpcChannelBuffer_FWD_DEFINED__ */




typedef  struct  IRpcProxyBuffer IRpcProxyBuffer;
/* __IRpcProxyBuffer_FWD_DEFINED__ */




typedef  struct  IRpcStubBuffer IRpcStubBuffer;
/* __IRpcStubBuffer_FWD_DEFINED__ */




typedef  struct  IPSFactoryBuffer IPSFactoryBuffer;
/* __IPSFactoryBuffer_FWD_DEFINED__ */


/* header files for imported files */
#line 1 "C:\WATCOM\H\NT\unknwn.h"
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Fri Apr 28 07:02:30 1995
 */
//@@MIDL_FILE_HEADING(  )
#line 1 "C:\WATCOM\H\NT\rpc.h"
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    rpc.h

Abstract:

    Master include file for RPC applications.

--*/


#line 1 "C:\WATCOM\H\NT\windows.h"
/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) 1985-1995, Microsoft Corporation

Module Name:


    windows.h

Abstract:

    Master include file for Windows applications.

--*/

/* _WINDOWS_ */#line 216 "C:\WATCOM\H\NT\windows.h"
#line 16 "C:\WATCOM\H\NT\rpc.h"

// RPC_NO_WINDOWS_H

// __RPC_H__#line 121 "C:\WATCOM\H\NT\rpc.h"

#line 8 "C:\WATCOM\H\NT\unknwn.h"

#line 1 "C:\WATCOM\H\NT\rpcndr.h"
/*++

Copyright (c) 1992-1995 Microsoft Corporation

Module Name:

    rpcndr.h

Abstract:

    Definitions for stub data structures and prototypes of helper functions.

Environment:

    DOS, Win 3.X, and Win/NT.

--*/

/* __RPCNDR_H__ */#line 2263 "C:\WATCOM\H\NT\rpcndr.h"
#line 9 "C:\WATCOM\H\NT\unknwn.h"


#line 1 "C:\WATCOM\H\NT\windows.h"
/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) 1985-1995, Microsoft Corporation

Module Name:


    windows.h

Abstract:

    Master include file for Windows applications.

--*/

/* _WINDOWS_ */#line 216 "C:\WATCOM\H\NT\windows.h"
#line 11 "C:\WATCOM\H\NT\unknwn.h"

#line 1 "C:\WATCOM\H\NT\ole2.h"
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       OLE2.h
//  Contents:   Main OLE2 header; Defines Linking and Emmebbeding interfaces, and API's.
//              Also includes .h files for the compobj, and oleauto  subcomponents.
//
//----------------------------------------------------------------------------
// __OLE2_H__#line 305 "C:\WATCOM\H\NT\ole2.h"

#line 12 "C:\WATCOM\H\NT\unknwn.h"

/*COM_NO_WINDOWS_H*/

#line 312 "C:\WATCOM\H\NT\unknwn.h"
#line 223 "C:\WATCOM\H\NT\objidl.h"


void    *  __stdcall  MIDL_user_allocate(size_t);
void  __stdcall  MIDL_user_free( void    * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;




/****************************************
 * Generated header for interface: IMarshal
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//--------------------------------------------------------------------------
			/* size is 4 */
typedef /* [unique] */  IMarshal    *LPMARSHAL;


 extern "C"  const IID __cdecl IID_IMarshal;

/* C style interface */#line 327 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IMarshalVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IMarshal    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IMarshal    * This);
        
        ULONG ( __stdcall    *Release )( 
            IMarshal    * This);
        
        HRESULT ( __stdcall    *GetUnmarshalClass )( 
            IMarshal    * This,
            /* [in] */  const IID &  riid,
            /* [unique][in] */ void    *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void    *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ CLSID    *pCid);
        
        HRESULT ( __stdcall    *GetMarshalSizeMax )( 
            IMarshal    * This,
            /* [in] */  const IID &  riid,
            /* [unique][in] */ void    *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void    *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ DWORD    *pSize);
        
        HRESULT ( __stdcall    *MarshalInterface )( 
            IMarshal    * This,
            /* [unique][in] */ IStream    *pStm,
            /* [in] */  const IID &  riid,
            /* [unique][in] */ void    *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void    *pvDestContext,
            /* [in] */ DWORD mshlflags);
        
        HRESULT ( __stdcall    *UnmarshalInterface )( 
            IMarshal    * This,
            /* [unique][in] */ IStream    *pStm,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppv);
        
        HRESULT ( __stdcall    *ReleaseMarshalData )( 
            IMarshal    * This,
            /* [unique][in] */ IStream    *pStm);
        
        HRESULT ( __stdcall    *DisconnectObject )( 
            IMarshal    * This,
            /* [in] */ DWORD dwReserved);
        
    } IMarshalVtbl;

     struct  IMarshal
    {
           struct IMarshalVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 424 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



HRESULT __stdcall IMarshal_GetUnmarshalClass_Proxy( 
    IMarshal    * This,
    /* [in] */  const IID &  riid,
    /* [unique][in] */ void    *pv,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void    *pvDestContext,
    /* [in] */ DWORD mshlflags,
    /* [out] */ CLSID    *pCid);


void  __stdcall  IMarshal_GetUnmarshalClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMarshal_GetMarshalSizeMax_Proxy( 
    IMarshal    * This,
    /* [in] */  const IID &  riid,
    /* [unique][in] */ void    *pv,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void    *pvDestContext,
    /* [in] */ DWORD mshlflags,
    /* [out] */ DWORD    *pSize);


void  __stdcall  IMarshal_GetMarshalSizeMax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMarshal_MarshalInterface_Proxy( 
    IMarshal    * This,
    /* [unique][in] */ IStream    *pStm,
    /* [in] */  const IID &  riid,
    /* [unique][in] */ void    *pv,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void    *pvDestContext,
    /* [in] */ DWORD mshlflags);


void  __stdcall  IMarshal_MarshalInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMarshal_UnmarshalInterface_Proxy( 
    IMarshal    * This,
    /* [unique][in] */ IStream    *pStm,
    /* [in] */  const IID &  riid,
    /* [out] */ void    *   *ppv);


void  __stdcall  IMarshal_UnmarshalInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMarshal_ReleaseMarshalData_Proxy( 
    IMarshal    * This,
    /* [unique][in] */ IStream    *pStm);


void  __stdcall  IMarshal_ReleaseMarshalData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMarshal_DisconnectObject_Proxy( 
    IMarshal    * This,
    /* [in] */ DWORD dwReserved);


void  __stdcall  IMarshal_DisconnectObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IMarshal_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IMalloc
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */  IMalloc    *LPMALLOC;


 extern "C"  const IID __cdecl IID_IMalloc;

/* C style interface */#line 566 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IMallocVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IMalloc    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IMalloc    * This);
        
        ULONG ( __stdcall    *Release )( 
            IMalloc    * This);
        
        void    *( __stdcall    *Alloc )( 
            IMalloc    * This,
            /* [in] */ ULONG cb);
        
        void    *( __stdcall    *Realloc )( 
            IMalloc    * This,
            /* [in] */ void    *pv,
            /* [in] */ ULONG cb);
        
        void ( __stdcall    *Free )( 
            IMalloc    * This,
            /* [in] */ void    *pv);
        
        ULONG ( __stdcall    *GetSize )( 
            IMalloc    * This,
            /* [in] */ void    *pv);
        
        int ( __stdcall    *DidAlloc )( 
            IMalloc    * This,
            void    *pv);
        
        void ( __stdcall    *HeapMinimize )( 
            IMalloc    * This);
        
    } IMallocVtbl;

     struct  IMalloc
    {
           struct IMallocVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 646 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



void    *__stdcall IMalloc_Alloc_Proxy( 
    IMalloc    * This,
    /* [in] */ ULONG cb);


void  __stdcall  IMalloc_Alloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void    *__stdcall IMalloc_Realloc_Proxy( 
    IMalloc    * This,
    /* [in] */ void    *pv,
    /* [in] */ ULONG cb);


void  __stdcall  IMalloc_Realloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall IMalloc_Free_Proxy( 
    IMalloc    * This,
    /* [in] */ void    *pv);


void  __stdcall  IMalloc_Free_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG __stdcall IMalloc_GetSize_Proxy( 
    IMalloc    * This,
    /* [in] */ void    *pv);


void  __stdcall  IMalloc_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


int __stdcall IMalloc_DidAlloc_Proxy( 
    IMalloc    * This,
    void    *pv);


void  __stdcall  IMalloc_DidAlloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall IMalloc_HeapMinimize_Proxy( 
    IMalloc    * This);


void  __stdcall  IMalloc_HeapMinimize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IMalloc_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IMallocSpy
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */  IMallocSpy    *LPMALLOCSPY;


 extern "C"  const IID __cdecl IID_IMallocSpy;

/* C style interface */#line 797 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IMallocSpyVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IMallocSpy    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IMallocSpy    * This);
        
        ULONG ( __stdcall    *Release )( 
            IMallocSpy    * This);
        
        ULONG ( __stdcall    *PreAlloc )( 
            IMallocSpy    * This,
            /* [in] */ ULONG cbRequest);
        
        void    *( __stdcall    *PostAlloc )( 
            IMallocSpy    * This,
            /* [in] */ void    *pActual);
        
        void    *( __stdcall    *PreFree )( 
            IMallocSpy    * This,
            /* [in] */ void    *pRequest,
            /* [in] */ BOOL fSpyed);
        
        void ( __stdcall    *PostFree )( 
            IMallocSpy    * This,
            /* [in] */ BOOL fSpyed);
        
        ULONG ( __stdcall    *PreRealloc )( 
            IMallocSpy    * This,
            /* [in] */ void    *pRequest,
            /* [in] */ ULONG cbRequest,
            /* [out] */ void    *   *ppNewRequest,
            /* [in] */ BOOL fSpyed);
        
        void    *( __stdcall    *PostRealloc )( 
            IMallocSpy    * This,
            /* [in] */ void    *pActual,
            /* [in] */ BOOL fSpyed);
        
        void    *( __stdcall    *PreGetSize )( 
            IMallocSpy    * This,
            /* [in] */ void    *pRequest,
            /* [in] */ BOOL fSpyed);
        
        ULONG ( __stdcall    *PostGetSize )( 
            IMallocSpy    * This,
            /* [in] */ ULONG cbActual,
            /* [in] */ BOOL fSpyed);
        
        void    *( __stdcall    *PreDidAlloc )( 
            IMallocSpy    * This,
            /* [in] */ void    *pRequest,
            /* [in] */ BOOL fSpyed);
        
        int ( __stdcall    *PostDidAlloc )( 
            IMallocSpy    * This,
            /* [in] */ void    *pRequest,
            /* [in] */ BOOL fSpyed,
            /* [in] */ int fActual);
        
        void ( __stdcall    *PreHeapMinimize )( 
            IMallocSpy    * This);
        
        void ( __stdcall    *PostHeapMinimize )( 
            IMallocSpy    * This);
        
    } IMallocSpyVtbl;

     struct  IMallocSpy
    {
           struct IMallocSpyVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 927 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



ULONG __stdcall IMallocSpy_PreAlloc_Proxy( 
    IMallocSpy    * This,
    /* [in] */ ULONG cbRequest);


void  __stdcall  IMallocSpy_PreAlloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void    *__stdcall IMallocSpy_PostAlloc_Proxy( 
    IMallocSpy    * This,
    /* [in] */ void    *pActual);


void  __stdcall  IMallocSpy_PostAlloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void    *__stdcall IMallocSpy_PreFree_Proxy( 
    IMallocSpy    * This,
    /* [in] */ void    *pRequest,
    /* [in] */ BOOL fSpyed);


void  __stdcall  IMallocSpy_PreFree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall IMallocSpy_PostFree_Proxy( 
    IMallocSpy    * This,
    /* [in] */ BOOL fSpyed);


void  __stdcall  IMallocSpy_PostFree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG __stdcall IMallocSpy_PreRealloc_Proxy( 
    IMallocSpy    * This,
    /* [in] */ void    *pRequest,
    /* [in] */ ULONG cbRequest,
    /* [out] */ void    *   *ppNewRequest,
    /* [in] */ BOOL fSpyed);


void  __stdcall  IMallocSpy_PreRealloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void    *__stdcall IMallocSpy_PostRealloc_Proxy( 
    IMallocSpy    * This,
    /* [in] */ void    *pActual,
    /* [in] */ BOOL fSpyed);


void  __stdcall  IMallocSpy_PostRealloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void    *__stdcall IMallocSpy_PreGetSize_Proxy( 
    IMallocSpy    * This,
    /* [in] */ void    *pRequest,
    /* [in] */ BOOL fSpyed);


void  __stdcall  IMallocSpy_PreGetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG __stdcall IMallocSpy_PostGetSize_Proxy( 
    IMallocSpy    * This,
    /* [in] */ ULONG cbActual,
    /* [in] */ BOOL fSpyed);


void  __stdcall  IMallocSpy_PostGetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void    *__stdcall IMallocSpy_PreDidAlloc_Proxy( 
    IMallocSpy    * This,
    /* [in] */ void    *pRequest,
    /* [in] */ BOOL fSpyed);


void  __stdcall  IMallocSpy_PreDidAlloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


int __stdcall IMallocSpy_PostDidAlloc_Proxy( 
    IMallocSpy    * This,
    /* [in] */ void    *pRequest,
    /* [in] */ BOOL fSpyed,
    /* [in] */ int fActual);


void  __stdcall  IMallocSpy_PostDidAlloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall IMallocSpy_PreHeapMinimize_Proxy( 
    IMallocSpy    * This);


void  __stdcall  IMallocSpy_PreHeapMinimize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall IMallocSpy_PostHeapMinimize_Proxy( 
    IMallocSpy    * This);


void  __stdcall  IMallocSpy_PostHeapMinimize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IMallocSpy_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IStdMarshalInfo
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */  IStdMarshalInfo    *LPSTDMARSHALINFO;


 extern "C"  const IID __cdecl IID_IStdMarshalInfo;

/* C style interface */#line 1119 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IStdMarshalInfoVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IStdMarshalInfo    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IStdMarshalInfo    * This);
        
        ULONG ( __stdcall    *Release )( 
            IStdMarshalInfo    * This);
        
        HRESULT ( __stdcall    *GetClassForHandler )( 
            IStdMarshalInfo    * This,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void    *pvDestContext,
            /* [out] */ CLSID    *pClsid);
        
    } IStdMarshalInfoVtbl;

     struct  IStdMarshalInfo
    {
           struct IStdMarshalInfoVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 1166 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



HRESULT __stdcall IStdMarshalInfo_GetClassForHandler_Proxy( 
    IStdMarshalInfo    * This,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void    *pvDestContext,
    /* [out] */ CLSID    *pClsid);


void  __stdcall  IStdMarshalInfo_GetClassForHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IStdMarshalInfo_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IExternalConnection
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][local][object] */ 


			/* size is 4 */
typedef /* [unique] */  IExternalConnection    *LPEXTERNALCONNECTION;

			/* size is 2 */
typedef 
enum tagEXTCONN
    {	EXTCONN_STRONG	= 0x1,
	EXTCONN_WEAK	= 0x2,
	EXTCONN_CALLABLE	= 0x4
    }	EXTCONN;


 extern "C"  const IID __cdecl IID_IExternalConnection;

/* C style interface */#line 1232 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IExternalConnectionVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IExternalConnection    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IExternalConnection    * This);
        
        ULONG ( __stdcall    *Release )( 
            IExternalConnection    * This);
        
        DWORD ( __stdcall    *AddConnection )( 
            IExternalConnection    * This,
            /* [in] */ DWORD extconn,
            /* [in] */ DWORD reserved);
        
        DWORD ( __stdcall    *ReleaseConnection )( 
            IExternalConnection    * This,
            /* [in] */ DWORD extconn,
            /* [in] */ DWORD reserved,
            /* [in] */ BOOL fLastReleaseCloses);
        
    } IExternalConnectionVtbl;

     struct  IExternalConnection
    {
           struct IExternalConnectionVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 1287 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



DWORD __stdcall IExternalConnection_AddConnection_Proxy( 
    IExternalConnection    * This,
    /* [in] */ DWORD extconn,
    /* [in] */ DWORD reserved);


void  __stdcall  IExternalConnection_AddConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD __stdcall IExternalConnection_ReleaseConnection_Proxy( 
    IExternalConnection    * This,
    /* [in] */ DWORD extconn,
    /* [in] */ DWORD reserved,
    /* [in] */ BOOL fLastReleaseCloses);


void  __stdcall  IExternalConnection_ReleaseConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IExternalConnection_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IEnumUnknown
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IEnumUnknown    *LPENUMUNKNOWN;


 extern "C"  const IID __cdecl IID_IEnumUnknown;

/* C style interface */#line 1362 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IEnumUnknownVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IEnumUnknown    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IEnumUnknown    * This);
        
        ULONG ( __stdcall    *Release )( 
            IEnumUnknown    * This);
        
        /* [local] */ HRESULT ( __stdcall    *Next )( 
            IEnumUnknown    * This,
            /* [in] */ ULONG celt,
            /* [out] */ IUnknown    *   *rgelt,
            /* [out] */ ULONG    *pceltFetched);
        
        HRESULT ( __stdcall    *Skip )( 
            IEnumUnknown    * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( __stdcall    *Reset )( 
            IEnumUnknown    * This);
        
        HRESULT ( __stdcall    *Clone )( 
            IEnumUnknown    * This,
            /* [out] */ IEnumUnknown    *   *ppenum);
        
    } IEnumUnknownVtbl;

     struct  IEnumUnknown
    {
           struct IEnumUnknownVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 1429 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumUnknown_RemoteNext_Proxy( 
    IEnumUnknown    * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IUnknown    *   *rgelt,
    /* [out] */ ULONG    *pceltFetched);


void  __stdcall  IEnumUnknown_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumUnknown_Skip_Proxy( 
    IEnumUnknown    * This,
    /* [in] */ ULONG celt);


void  __stdcall  IEnumUnknown_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumUnknown_Reset_Proxy( 
    IEnumUnknown    * This);


void  __stdcall  IEnumUnknown_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumUnknown_Clone_Proxy( 
    IEnumUnknown    * This,
    /* [out] */ IEnumUnknown    *   *ppenum);


void  __stdcall  IEnumUnknown_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IEnumUnknown_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IBindCtx
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IBindCtx    *LPBC;

			/* size is 4 */
typedef /* [unique] */  IBindCtx    *LPBINDCTX;

			/* size is 16 */
typedef struct  tagBIND_OPTS
    {
    DWORD cbStruct;
    DWORD grfFlags;
    DWORD grfMode;
    DWORD dwTickCountDeadline;
    }	BIND_OPTS;

			/* size is 4 */
typedef struct tagBIND_OPTS    *LPBIND_OPTS;

			/* size is 2 */
typedef 
enum tagBIND_FLAGS
    {	BIND_MAYBOTHERUSER	= 1,
	BIND_JUSTTESTEXISTENCE	= 2
    }	BIND_FLAGS;


 extern "C"  const IID __cdecl IID_IBindCtx;

/* C style interface */#line 1566 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IBindCtxVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IBindCtx    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IBindCtx    * This);
        
        ULONG ( __stdcall    *Release )( 
            IBindCtx    * This);
        
        HRESULT ( __stdcall    *RegisterObjectBound )( 
            IBindCtx    * This,
            /* [unique][in] */ IUnknown    *punk);
        
        HRESULT ( __stdcall    *RevokeObjectBound )( 
            IBindCtx    * This,
            /* [unique][in] */ IUnknown    *punk);
        
        HRESULT ( __stdcall    *ReleaseBoundObjects )( 
            IBindCtx    * This);
        
        HRESULT ( __stdcall    *SetBindOptions )( 
            IBindCtx    * This,
            /* [in] */ BIND_OPTS    *pbindopts);
        
        HRESULT ( __stdcall    *GetBindOptions )( 
            IBindCtx    * This,
            /* [out][in] */ BIND_OPTS    *pbindopts);
        
        HRESULT ( __stdcall    *GetRunningObjectTable )( 
            IBindCtx    * This,
            /* [out] */ IRunningObjectTable    *   *pprot);
        
        HRESULT ( __stdcall    *RegisterObjectParam )( 
            IBindCtx    * This,
            /* [in] */ LPOLESTR pszKey,
            /* [unique][in] */ IUnknown    *punk);
        
        HRESULT ( __stdcall    *GetObjectParam )( 
            IBindCtx    * This,
            /* [in] */ LPOLESTR pszKey,
            /* [out] */ IUnknown    *   *ppunk);
        
        HRESULT ( __stdcall    *EnumObjectParam )( 
            IBindCtx    * This,
            /* [out] */ IEnumString    *   *ppenum);
        
        HRESULT ( __stdcall    *RevokeObjectParam )( 
            IBindCtx    * This,
            /* [in] */ LPOLESTR pszKey);
        
    } IBindCtxVtbl;

     struct  IBindCtx
    {
           struct IBindCtxVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 1675 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



HRESULT __stdcall IBindCtx_RegisterObjectBound_Proxy( 
    IBindCtx    * This,
    /* [unique][in] */ IUnknown    *punk);


void  __stdcall  IBindCtx_RegisterObjectBound_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IBindCtx_RevokeObjectBound_Proxy( 
    IBindCtx    * This,
    /* [unique][in] */ IUnknown    *punk);


void  __stdcall  IBindCtx_RevokeObjectBound_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IBindCtx_ReleaseBoundObjects_Proxy( 
    IBindCtx    * This);


void  __stdcall  IBindCtx_ReleaseBoundObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IBindCtx_SetBindOptions_Proxy( 
    IBindCtx    * This,
    /* [in] */ BIND_OPTS    *pbindopts);


void  __stdcall  IBindCtx_SetBindOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IBindCtx_GetBindOptions_Proxy( 
    IBindCtx    * This,
    /* [out][in] */ BIND_OPTS    *pbindopts);


void  __stdcall  IBindCtx_GetBindOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IBindCtx_GetRunningObjectTable_Proxy( 
    IBindCtx    * This,
    /* [out] */ IRunningObjectTable    *   *pprot);


void  __stdcall  IBindCtx_GetRunningObjectTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IBindCtx_RegisterObjectParam_Proxy( 
    IBindCtx    * This,
    /* [in] */ LPOLESTR pszKey,
    /* [unique][in] */ IUnknown    *punk);


void  __stdcall  IBindCtx_RegisterObjectParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IBindCtx_GetObjectParam_Proxy( 
    IBindCtx    * This,
    /* [in] */ LPOLESTR pszKey,
    /* [out] */ IUnknown    *   *ppunk);


void  __stdcall  IBindCtx_GetObjectParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IBindCtx_EnumObjectParam_Proxy( 
    IBindCtx    * This,
    /* [out] */ IEnumString    *   *ppenum);


void  __stdcall  IBindCtx_EnumObjectParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IBindCtx_RevokeObjectParam_Proxy( 
    IBindCtx    * This,
    /* [in] */ LPOLESTR pszKey);


void  __stdcall  IBindCtx_RevokeObjectParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IBindCtx_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IEnumMoniker
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IEnumMoniker    *LPENUMMONIKER;


 extern "C"  const IID __cdecl IID_IEnumMoniker;

/* C style interface */#line 1844 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IEnumMonikerVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IEnumMoniker    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IEnumMoniker    * This);
        
        ULONG ( __stdcall    *Release )( 
            IEnumMoniker    * This);
        
        /* [local] */ HRESULT ( __stdcall    *Next )( 
            IEnumMoniker    * This,
            /* [in] */ ULONG celt,
            /* [out] */ IMoniker    *   *rgelt,
            /* [out] */ ULONG    *pceltFetched);
        
        HRESULT ( __stdcall    *Skip )( 
            IEnumMoniker    * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( __stdcall    *Reset )( 
            IEnumMoniker    * This);
        
        HRESULT ( __stdcall    *Clone )( 
            IEnumMoniker    * This,
            /* [out] */ IEnumMoniker    *   *ppenum);
        
    } IEnumMonikerVtbl;

     struct  IEnumMoniker
    {
           struct IEnumMonikerVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 1911 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumMoniker_RemoteNext_Proxy( 
    IEnumMoniker    * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IMoniker    *   *rgelt,
    /* [out] */ ULONG    *pceltFetched);


void  __stdcall  IEnumMoniker_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumMoniker_Skip_Proxy( 
    IEnumMoniker    * This,
    /* [in] */ ULONG celt);


void  __stdcall  IEnumMoniker_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumMoniker_Reset_Proxy( 
    IEnumMoniker    * This);


void  __stdcall  IEnumMoniker_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumMoniker_Clone_Proxy( 
    IEnumMoniker    * This,
    /* [out] */ IEnumMoniker    *   *ppenum);


void  __stdcall  IEnumMoniker_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IEnumMoniker_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IRunnableObject
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */  IRunnableObject    *LPRUNNABLEOBJECT;


 extern "C"  const IID __cdecl IID_IRunnableObject;

/* C style interface */#line 2010 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IRunnableObjectVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IRunnableObject    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IRunnableObject    * This);
        
        ULONG ( __stdcall    *Release )( 
            IRunnableObject    * This);
        
        HRESULT ( __stdcall    *GetRunningClass )( 
            IRunnableObject    * This,
            /* [out] */ LPCLSID lpClsid);
        
        HRESULT ( __stdcall    *Run )( 
            IRunnableObject    * This,
            /* [in] */ LPBINDCTX pbc);
        
        BOOL ( __stdcall    *IsRunning )( 
            IRunnableObject    * This);
        
        HRESULT ( __stdcall    *LockRunning )( 
            IRunnableObject    * This,
            /* [in] */ BOOL fLock,
            /* [in] */ BOOL fLastUnlockCloses);
        
        HRESULT ( __stdcall    *SetContainedObject )( 
            IRunnableObject    * This,
            /* [in] */ BOOL fContained);
        
    } IRunnableObjectVtbl;

     struct  IRunnableObject
    {
           struct IRunnableObjectVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 2083 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



HRESULT __stdcall IRunnableObject_GetRunningClass_Proxy( 
    IRunnableObject    * This,
    /* [out] */ LPCLSID lpClsid);


void  __stdcall  IRunnableObject_GetRunningClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRunnableObject_Run_Proxy( 
    IRunnableObject    * This,
    /* [in] */ LPBINDCTX pbc);


void  __stdcall  IRunnableObject_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL __stdcall IRunnableObject_IsRunning_Proxy( 
    IRunnableObject    * This);


void  __stdcall  IRunnableObject_IsRunning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRunnableObject_LockRunning_Proxy( 
    IRunnableObject    * This,
    /* [in] */ BOOL fLock,
    /* [in] */ BOOL fLastUnlockCloses);


void  __stdcall  IRunnableObject_LockRunning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRunnableObject_SetContainedObject_Proxy( 
    IRunnableObject    * This,
    /* [in] */ BOOL fContained);


void  __stdcall  IRunnableObject_SetContainedObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IRunnableObject_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IRunningObjectTable
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IRunningObjectTable    *LPRUNNINGOBJECTTABLE;


 extern "C"  const IID __cdecl IID_IRunningObjectTable;

/* C style interface */#line 2205 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IRunningObjectTableVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IRunningObjectTable    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IRunningObjectTable    * This);
        
        ULONG ( __stdcall    *Release )( 
            IRunningObjectTable    * This);
        
        HRESULT ( __stdcall    *Register )( 
            IRunningObjectTable    * This,
            /* [in] */ DWORD grfFlags,
            /* [unique][in] */ IUnknown    *punkObject,
            /* [unique][in] */ IMoniker    *pmkObjectName,
            /* [out] */ DWORD    *pdwRegister);
        
        HRESULT ( __stdcall    *Revoke )( 
            IRunningObjectTable    * This,
            /* [in] */ DWORD dwRegister);
        
        HRESULT ( __stdcall    *IsRunning )( 
            IRunningObjectTable    * This,
            /* [unique][in] */ IMoniker    *pmkObjectName);
        
        HRESULT ( __stdcall    * GetObjectA  )( 
            IRunningObjectTable    * This,
            /* [unique][in] */ IMoniker    *pmkObjectName,
            /* [out] */ IUnknown    *   *ppunkObject);
        
        HRESULT ( __stdcall    *NoteChangeTime )( 
            IRunningObjectTable    * This,
            /* [in] */ DWORD dwRegister,
            /* [in] */ FILETIME    *pfiletime);
        
        HRESULT ( __stdcall    *GetTimeOfLastChange )( 
            IRunningObjectTable    * This,
            /* [unique][in] */ IMoniker    *pmkObjectName,
            /* [out] */ FILETIME    *pfiletime);
        
        HRESULT ( __stdcall    *EnumRunning )( 
            IRunningObjectTable    * This,
            /* [out] */ IEnumMoniker    *   *ppenumMoniker);
        
    } IRunningObjectTableVtbl;

     struct  IRunningObjectTable
    {
           struct IRunningObjectTableVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 2298 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



HRESULT __stdcall IRunningObjectTable_Register_Proxy( 
    IRunningObjectTable    * This,
    /* [in] */ DWORD grfFlags,
    /* [unique][in] */ IUnknown    *punkObject,
    /* [unique][in] */ IMoniker    *pmkObjectName,
    /* [out] */ DWORD    *pdwRegister);


void  __stdcall  IRunningObjectTable_Register_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRunningObjectTable_Revoke_Proxy( 
    IRunningObjectTable    * This,
    /* [in] */ DWORD dwRegister);


void  __stdcall  IRunningObjectTable_Revoke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRunningObjectTable_IsRunning_Proxy( 
    IRunningObjectTable    * This,
    /* [unique][in] */ IMoniker    *pmkObjectName);


void  __stdcall  IRunningObjectTable_IsRunning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRunningObjectTable_GetObject_Proxy( 
    IRunningObjectTable    * This,
    /* [unique][in] */ IMoniker    *pmkObjectName,
    /* [out] */ IUnknown    *   *ppunkObject);


void  __stdcall  IRunningObjectTable_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRunningObjectTable_NoteChangeTime_Proxy( 
    IRunningObjectTable    * This,
    /* [in] */ DWORD dwRegister,
    /* [in] */ FILETIME    *pfiletime);


void  __stdcall  IRunningObjectTable_NoteChangeTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRunningObjectTable_GetTimeOfLastChange_Proxy( 
    IRunningObjectTable    * This,
    /* [unique][in] */ IMoniker    *pmkObjectName,
    /* [out] */ FILETIME    *pfiletime);


void  __stdcall  IRunningObjectTable_GetTimeOfLastChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRunningObjectTable_EnumRunning_Proxy( 
    IRunningObjectTable    * This,
    /* [out] */ IEnumMoniker    *   *ppenumMoniker);


void  __stdcall  IRunningObjectTable_EnumRunning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IRunningObjectTable_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IPersist
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IPersist    *LPPERSIST;


 extern "C"  const IID __cdecl IID_IPersist;

/* C style interface */#line 2426 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IPersistVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IPersist    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IPersist    * This);
        
        ULONG ( __stdcall    *Release )( 
            IPersist    * This);
        
        HRESULT ( __stdcall    *GetClassID )( 
            IPersist    * This,
            /* [out] */ CLSID    *pClassID);
        
    } IPersistVtbl;

     struct  IPersist
    {
           struct IPersistVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 2471 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



HRESULT __stdcall IPersist_GetClassID_Proxy( 
    IPersist    * This,
    /* [out] */ CLSID    *pClassID);


void  __stdcall  IPersist_GetClassID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IPersist_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IPersistStream
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IPersistStream    *LPPERSISTSTREAM;


 extern "C"  const IID __cdecl IID_IPersistStream;

/* C style interface */#line 2530 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IPersistStreamVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IPersistStream    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IPersistStream    * This);
        
        ULONG ( __stdcall    *Release )( 
            IPersistStream    * This);
        
        HRESULT ( __stdcall    *GetClassID )( 
            IPersistStream    * This,
            /* [out] */ CLSID    *pClassID);
        
        HRESULT ( __stdcall    *IsDirty )( 
            IPersistStream    * This);
        
        HRESULT ( __stdcall    *Load )( 
            IPersistStream    * This,
            /* [unique][in] */ IStream    *pStm);
        
        HRESULT ( __stdcall    *Save )( 
            IPersistStream    * This,
            /* [unique][in] */ IStream    *pStm,
            /* [in] */ BOOL fClearDirty);
        
        HRESULT ( __stdcall    *GetSizeMax )( 
            IPersistStream    * This,
            /* [out] */ ULARGE_INTEGER    *pcbSize);
        
    } IPersistStreamVtbl;

     struct  IPersistStream
    {
           struct IPersistStreamVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 2604 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



HRESULT __stdcall IPersistStream_IsDirty_Proxy( 
    IPersistStream    * This);


void  __stdcall  IPersistStream_IsDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPersistStream_Load_Proxy( 
    IPersistStream    * This,
    /* [unique][in] */ IStream    *pStm);


void  __stdcall  IPersistStream_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPersistStream_Save_Proxy( 
    IPersistStream    * This,
    /* [unique][in] */ IStream    *pStm,
    /* [in] */ BOOL fClearDirty);


void  __stdcall  IPersistStream_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPersistStream_GetSizeMax_Proxy( 
    IPersistStream    * This,
    /* [out] */ ULARGE_INTEGER    *pcbSize);


void  __stdcall  IPersistStream_GetSizeMax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IPersistStream_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IMoniker
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IMoniker    *LPMONIKER;

			/* size is 2 */
typedef 
enum tagMKSYS
    {	MKSYS_NONE	= 0,
	MKSYS_GENERICCOMPOSITE	= 1,
	MKSYS_FILEMONIKER	= 2,
	MKSYS_ANTIMONIKER	= 3,
	MKSYS_ITEMMONIKER	= 4,
	MKSYS_POINTERMONIKER	= 5
    }	MKSYS;

			/* size is 2 */
typedef /* [v1_enum] */  
enum tagMKREDUCE
    {	MKRREDUCE_ONE	= 3 << 16,
	MKRREDUCE_TOUSER	= 2 << 16,
	MKRREDUCE_THROUGHUSER	= 1 << 16,
	MKRREDUCE_ALL	= 0
    }	MKRREDUCE;


 extern "C"  const IID __cdecl IID_IMoniker;

/* C style interface */#line 2776 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IMonikerVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IMoniker    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IMoniker    * This);
        
        ULONG ( __stdcall    *Release )( 
            IMoniker    * This);
        
        HRESULT ( __stdcall    *GetClassID )( 
            IMoniker    * This,
            /* [out] */ CLSID    *pClassID);
        
        HRESULT ( __stdcall    *IsDirty )( 
            IMoniker    * This);
        
        HRESULT ( __stdcall    *Load )( 
            IMoniker    * This,
            /* [unique][in] */ IStream    *pStm);
        
        HRESULT ( __stdcall    *Save )( 
            IMoniker    * This,
            /* [unique][in] */ IStream    *pStm,
            /* [in] */ BOOL fClearDirty);
        
        HRESULT ( __stdcall    *GetSizeMax )( 
            IMoniker    * This,
            /* [out] */ ULARGE_INTEGER    *pcbSize);
        
        /* [local] */ HRESULT ( __stdcall    *BindToObject )( 
            IMoniker    * This,
            /* [unique][in] */ IBindCtx    *pbc,
            /* [unique][in] */ IMoniker    *pmkToLeft,
            /* [in] */  const IID &  riidResult,
            /* [out] */ void    *   *ppvResult);
        
        /* [local] */ HRESULT ( __stdcall    *BindToStorage )( 
            IMoniker    * This,
            /* [unique][in] */ IBindCtx    *pbc,
            /* [unique][in] */ IMoniker    *pmkToLeft,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObj);
        
        HRESULT ( __stdcall    *Reduce )( 
            IMoniker    * This,
            /* [unique][in] */ IBindCtx    *pbc,
            /* [in] */ DWORD dwReduceHowFar,
            /* [unique][out][in] */ IMoniker    *   *ppmkToLeft,
            /* [out] */ IMoniker    *   *ppmkReduced);
        
        HRESULT ( __stdcall    *ComposeWith )( 
            IMoniker    * This,
            /* [unique][in] */ IMoniker    *pmkRight,
            /* [in] */ BOOL fOnlyIfNotGeneric,
            /* [out] */ IMoniker    *   *ppmkComposite);
        
        HRESULT ( __stdcall    *Enum )( 
            IMoniker    * This,
            /* [in] */ BOOL fForward,
            /* [out] */ IEnumMoniker    *   *ppenumMoniker);
        
        HRESULT ( __stdcall    *IsEqual )( 
            IMoniker    * This,
            /* [unique][in] */ IMoniker    *pmkOtherMoniker);
        
        HRESULT ( __stdcall    *Hash )( 
            IMoniker    * This,
            /* [out] */ DWORD    *pdwHash);
        
        HRESULT ( __stdcall    *IsRunning )( 
            IMoniker    * This,
            /* [unique][in] */ IBindCtx    *pbc,
            /* [unique][in] */ IMoniker    *pmkToLeft,
            /* [unique][in] */ IMoniker    *pmkNewlyRunning);
        
        HRESULT ( __stdcall    *GetTimeOfLastChange )( 
            IMoniker    * This,
            /* [unique][in] */ IBindCtx    *pbc,
            /* [unique][in] */ IMoniker    *pmkToLeft,
            /* [out] */ FILETIME    *pFileTime);
        
        HRESULT ( __stdcall    *Inverse )( 
            IMoniker    * This,
            /* [out] */ IMoniker    *   *ppmk);
        
        HRESULT ( __stdcall    *CommonPrefixWith )( 
            IMoniker    * This,
            /* [unique][in] */ IMoniker    *pmkOther,
            /* [out] */ IMoniker    *   *ppmkPrefix);
        
        HRESULT ( __stdcall    *RelativePathTo )( 
            IMoniker    * This,
            /* [unique][in] */ IMoniker    *pmkOther,
            /* [out] */ IMoniker    *   *ppmkRelPath);
        
        HRESULT ( __stdcall    *GetDisplayName )( 
            IMoniker    * This,
            /* [unique][in] */ IBindCtx    *pbc,
            /* [unique][in] */ IMoniker    *pmkToLeft,
            /* [out] */ LPOLESTR    *ppszDisplayName);
        
        HRESULT ( __stdcall    *ParseDisplayName )( 
            IMoniker    * This,
            /* [unique][in] */ IBindCtx    *pbc,
            /* [unique][in] */ IMoniker    *pmkToLeft,
            /* [in] */ LPOLESTR pszDisplayName,
            /* [out] */ ULONG    *pchEaten,
            /* [out] */ IMoniker    *   *ppmkOut);
        
        HRESULT ( __stdcall    *IsSystemMoniker )( 
            IMoniker    * This,
            /* [out] */ DWORD    *pdwMksys);
        
    } IMonikerVtbl;

     struct  IMoniker
    {
           struct IMonikerVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 2980 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



/* [call_as] */ HRESULT __stdcall IMoniker_RemoteBindToObject_Proxy( 
    IMoniker    * This,
    /* [unique][in] */ IBindCtx    *pbc,
    /* [unique][in] */ IMoniker    *pmkToLeft,
    /* [in] */  const IID &  riidResult,
    /* [iid_is][out] */ IUnknown    *   *ppvResult);


void  __stdcall  IMoniker_RemoteBindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IMoniker_RemoteBindToStorage_Proxy( 
    IMoniker    * This,
    /* [unique][in] */ IBindCtx    *pbc,
    /* [unique][in] */ IMoniker    *pmkToLeft,
    /* [in] */  const IID &  riid,
    /* [iid_is][out] */ IUnknown    *   *ppvObj);


void  __stdcall  IMoniker_RemoteBindToStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_Reduce_Proxy( 
    IMoniker    * This,
    /* [unique][in] */ IBindCtx    *pbc,
    /* [in] */ DWORD dwReduceHowFar,
    /* [unique][out][in] */ IMoniker    *   *ppmkToLeft,
    /* [out] */ IMoniker    *   *ppmkReduced);


void  __stdcall  IMoniker_Reduce_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_ComposeWith_Proxy( 
    IMoniker    * This,
    /* [unique][in] */ IMoniker    *pmkRight,
    /* [in] */ BOOL fOnlyIfNotGeneric,
    /* [out] */ IMoniker    *   *ppmkComposite);


void  __stdcall  IMoniker_ComposeWith_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_Enum_Proxy( 
    IMoniker    * This,
    /* [in] */ BOOL fForward,
    /* [out] */ IEnumMoniker    *   *ppenumMoniker);


void  __stdcall  IMoniker_Enum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_IsEqual_Proxy( 
    IMoniker    * This,
    /* [unique][in] */ IMoniker    *pmkOtherMoniker);


void  __stdcall  IMoniker_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_Hash_Proxy( 
    IMoniker    * This,
    /* [out] */ DWORD    *pdwHash);


void  __stdcall  IMoniker_Hash_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_IsRunning_Proxy( 
    IMoniker    * This,
    /* [unique][in] */ IBindCtx    *pbc,
    /* [unique][in] */ IMoniker    *pmkToLeft,
    /* [unique][in] */ IMoniker    *pmkNewlyRunning);


void  __stdcall  IMoniker_IsRunning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_GetTimeOfLastChange_Proxy( 
    IMoniker    * This,
    /* [unique][in] */ IBindCtx    *pbc,
    /* [unique][in] */ IMoniker    *pmkToLeft,
    /* [out] */ FILETIME    *pFileTime);


void  __stdcall  IMoniker_GetTimeOfLastChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_Inverse_Proxy( 
    IMoniker    * This,
    /* [out] */ IMoniker    *   *ppmk);


void  __stdcall  IMoniker_Inverse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_CommonPrefixWith_Proxy( 
    IMoniker    * This,
    /* [unique][in] */ IMoniker    *pmkOther,
    /* [out] */ IMoniker    *   *ppmkPrefix);


void  __stdcall  IMoniker_CommonPrefixWith_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_RelativePathTo_Proxy( 
    IMoniker    * This,
    /* [unique][in] */ IMoniker    *pmkOther,
    /* [out] */ IMoniker    *   *ppmkRelPath);


void  __stdcall  IMoniker_RelativePathTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_GetDisplayName_Proxy( 
    IMoniker    * This,
    /* [unique][in] */ IBindCtx    *pbc,
    /* [unique][in] */ IMoniker    *pmkToLeft,
    /* [out] */ LPOLESTR    *ppszDisplayName);


void  __stdcall  IMoniker_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_ParseDisplayName_Proxy( 
    IMoniker    * This,
    /* [unique][in] */ IBindCtx    *pbc,
    /* [unique][in] */ IMoniker    *pmkToLeft,
    /* [in] */ LPOLESTR pszDisplayName,
    /* [out] */ ULONG    *pchEaten,
    /* [out] */ IMoniker    *   *ppmkOut);


void  __stdcall  IMoniker_ParseDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_IsSystemMoniker_Proxy( 
    IMoniker    * This,
    /* [out] */ DWORD    *pdwMksys);


void  __stdcall  IMoniker_IsSystemMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IMoniker_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IROTData
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 



 extern "C"  const IID __cdecl IID_IROTData;

/* C style interface */#line 3221 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IROTDataVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IROTData    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IROTData    * This);
        
        ULONG ( __stdcall    *Release )( 
            IROTData    * This);
        
        HRESULT ( __stdcall    *GetComparisonData )( 
            IROTData    * This,
            /* [size_is][out] */ byte    *pbData,
            /* [in] */ ULONG cbMax,
            /* [out] */ ULONG    *pcbData);
        
    } IROTDataVtbl;

     struct  IROTData
    {
           struct IROTDataVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 3268 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



HRESULT __stdcall IROTData_GetComparisonData_Proxy( 
    IROTData    * This,
    /* [size_is][out] */ byte    *pbData,
    /* [in] */ ULONG cbMax,
    /* [out] */ ULONG    *pcbData);


void  __stdcall  IROTData_GetComparisonData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IROTData_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IEnumString
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IEnumString    *LPENUMSTRING;


 extern "C"  const IID __cdecl IID_IEnumString;

/* C style interface */#line 3330 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IEnumStringVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IEnumString    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IEnumString    * This);
        
        ULONG ( __stdcall    *Release )( 
            IEnumString    * This);
        
        /* [local] */ HRESULT ( __stdcall    *Next )( 
            IEnumString    * This,
            /* [in] */ ULONG celt,
            /* [out] */ LPOLESTR    *rgelt,
            /* [out] */ ULONG    *pceltFetched);
        
        HRESULT ( __stdcall    *Skip )( 
            IEnumString    * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( __stdcall    *Reset )( 
            IEnumString    * This);
        
        HRESULT ( __stdcall    *Clone )( 
            IEnumString    * This,
            /* [out] */ IEnumString    *   *ppenum);
        
    } IEnumStringVtbl;

     struct  IEnumString
    {
           struct IEnumStringVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 3397 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumString_RemoteNext_Proxy( 
    IEnumString    * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ LPOLESTR    *rgelt,
    /* [out] */ ULONG    *pceltFetched);


void  __stdcall  IEnumString_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumString_Skip_Proxy( 
    IEnumString    * This,
    /* [in] */ ULONG celt);


void  __stdcall  IEnumString_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumString_Reset_Proxy( 
    IEnumString    * This);


void  __stdcall  IEnumString_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumString_Clone_Proxy( 
    IEnumString    * This,
    /* [out] */ IEnumString    *   *ppenum);


void  __stdcall  IEnumString_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IEnumString_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IStream
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IStream    *LPSTREAM;

			/* size is 72 */
typedef struct  tagSTATSTG
    {
    LPOLESTR pwcsName;
    DWORD type;
    ULARGE_INTEGER cbSize;
    FILETIME mtime;
    FILETIME ctime;
    FILETIME atime;
    DWORD grfMode;
    DWORD grfLocksSupported;
    CLSID clsid;
    DWORD grfStateBits;
    DWORD reserved;
    }	STATSTG;

			/* size is 2 */
typedef 
enum tagSTGTY
    {	STGTY_STORAGE	= 1,
	STGTY_STREAM	= 2,
	STGTY_LOCKBYTES	= 3,
	STGTY_PROPERTY	= 4
    }	STGTY;

			/* size is 2 */
typedef 
enum tagSTREAM_SEEK
    {	STREAM_SEEK_SET	= 0,
	STREAM_SEEK_CUR	= 1,
	STREAM_SEEK_END	= 2
    }	STREAM_SEEK;

			/* size is 2 */
typedef 
enum tagLOCKTYPE
    {	LOCK_WRITE	= 1,
	LOCK_EXCLUSIVE	= 2,
	LOCK_ONLYONCE	= 4
    }	LOCKTYPE;


 extern "C"  const IID __cdecl IID_IStream;

/* C style interface */#line 3568 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IStreamVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IStream    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IStream    * This);
        
        ULONG ( __stdcall    *Release )( 
            IStream    * This);
        
        /* [local] */ HRESULT ( __stdcall    *Read )( 
            IStream    * This,
            /* [out] */ void    *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG    *pcbRead);
        
        /* [local] */ HRESULT ( __stdcall    *Write )( 
            IStream    * This,
            /* [size_is][in] */ const void    *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG    *pcbWritten);
        
        /* [local] */ HRESULT ( __stdcall    *Seek )( 
            IStream    * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER    *plibNewPosition);
        
        HRESULT ( __stdcall    *SetSize )( 
            IStream    * This,
            /* [in] */ ULARGE_INTEGER libNewSize);
        
        /* [local] */ HRESULT ( __stdcall    *CopyTo )( 
            IStream    * This,
            /* [unique][in] */ IStream    *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [out] */ ULARGE_INTEGER    *pcbRead,
            /* [out] */ ULARGE_INTEGER    *pcbWritten);
        
        HRESULT ( __stdcall    *Commit )( 
            IStream    * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( __stdcall    *Revert )( 
            IStream    * This);
        
        HRESULT ( __stdcall    *LockRegion )( 
            IStream    * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( __stdcall    *UnlockRegion )( 
            IStream    * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( __stdcall    *Stat )( 
            IStream    * This,
            /* [out] */ STATSTG    *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
        HRESULT ( __stdcall    *Clone )( 
            IStream    * This,
            /* [out] */ IStream    *   *ppstm);
        
    } IStreamVtbl;

     struct  IStream
    {
           struct IStreamVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 3696 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



/* [call_as] */ HRESULT __stdcall IStream_RemoteRead_Proxy( 
    IStream    * This,
    /* [length_is][size_is][out] */ byte    *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG    *pcbRead);


void  __stdcall  IStream_RemoteRead_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IStream_RemoteWrite_Proxy( 
    IStream    * This,
    /* [size_is][in] */ const byte    *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG    *pcbWritten);


void  __stdcall  IStream_RemoteWrite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IStream_RemoteSeek_Proxy( 
    IStream    * This,
    /* [in] */ LARGE_INTEGER dlibMove,
    /* [in] */ DWORD dwOrigin,
    /* [out] */ ULARGE_INTEGER    *plibNewPosition);


void  __stdcall  IStream_RemoteSeek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStream_SetSize_Proxy( 
    IStream    * This,
    /* [in] */ ULARGE_INTEGER libNewSize);


void  __stdcall  IStream_SetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IStream_RemoteCopyTo_Proxy( 
    IStream    * This,
    /* [unique][in] */ IStream    *pstm,
    /* [in] */ ULARGE_INTEGER cb,
    /* [out] */ ULARGE_INTEGER    *pcbRead,
    /* [out] */ ULARGE_INTEGER    *pcbWritten);


void  __stdcall  IStream_RemoteCopyTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStream_Commit_Proxy( 
    IStream    * This,
    /* [in] */ DWORD grfCommitFlags);


void  __stdcall  IStream_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStream_Revert_Proxy( 
    IStream    * This);


void  __stdcall  IStream_Revert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStream_LockRegion_Proxy( 
    IStream    * This,
    /* [in] */ ULARGE_INTEGER libOffset,
    /* [in] */ ULARGE_INTEGER cb,
    /* [in] */ DWORD dwLockType);


void  __stdcall  IStream_LockRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStream_UnlockRegion_Proxy( 
    IStream    * This,
    /* [in] */ ULARGE_INTEGER libOffset,
    /* [in] */ ULARGE_INTEGER cb,
    /* [in] */ DWORD dwLockType);


void  __stdcall  IStream_UnlockRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStream_Stat_Proxy( 
    IStream    * This,
    /* [out] */ STATSTG    *pstatstg,
    /* [in] */ DWORD grfStatFlag);


void  __stdcall  IStream_Stat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStream_Clone_Proxy( 
    IStream    * This,
    /* [out] */ IStream    *   *ppstm);


void  __stdcall  IStream_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IStream_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IEnumSTATSTG
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IEnumSTATSTG    *LPENUMSTATSTG;


 extern "C"  const IID __cdecl IID_IEnumSTATSTG;

/* C style interface */#line 3889 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IEnumSTATSTGVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IEnumSTATSTG    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IEnumSTATSTG    * This);
        
        ULONG ( __stdcall    *Release )( 
            IEnumSTATSTG    * This);
        
        /* [local] */ HRESULT ( __stdcall    *Next )( 
            IEnumSTATSTG    * This,
            /* [in] */ ULONG celt,
            /* [in] */ STATSTG    *rgelt,
            /* [out] */ ULONG    *pceltFetched);
        
        HRESULT ( __stdcall    *Skip )( 
            IEnumSTATSTG    * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( __stdcall    *Reset )( 
            IEnumSTATSTG    * This);
        
        HRESULT ( __stdcall    *Clone )( 
            IEnumSTATSTG    * This,
            /* [out] */ IEnumSTATSTG    *   *ppenum);
        
    } IEnumSTATSTGVtbl;

     struct  IEnumSTATSTG
    {
           struct IEnumSTATSTGVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 3956 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumSTATSTG_RemoteNext_Proxy( 
    IEnumSTATSTG    * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATSTG    *rgelt,
    /* [out] */ ULONG    *pceltFetched);


void  __stdcall  IEnumSTATSTG_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumSTATSTG_Skip_Proxy( 
    IEnumSTATSTG    * This,
    /* [in] */ ULONG celt);


void  __stdcall  IEnumSTATSTG_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumSTATSTG_Reset_Proxy( 
    IEnumSTATSTG    * This);


void  __stdcall  IEnumSTATSTG_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumSTATSTG_Clone_Proxy( 
    IEnumSTATSTG    * This,
    /* [out] */ IEnumSTATSTG    *   *ppenum);


void  __stdcall  IEnumSTATSTG_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IEnumSTATSTG_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IStorage
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IStorage    *LPSTORAGE;

			/* size is 8 */
typedef struct  tagRemSNB
    {
    unsigned long ulCntStr;
    unsigned long ulCntChar;
    /* [size_is] */ OLECHAR rgString[ 1 ];
    }	RemSNB;

			/* size is 4 */
typedef /* [transmit] */  OLECHAR    *   *SNB;


 extern "C"  const IID __cdecl IID_IStorage;

/* C style interface */#line 4127 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IStorageVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IStorage    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IStorage    * This);
        
        ULONG ( __stdcall    *Release )( 
            IStorage    * This);
        
        HRESULT ( __stdcall    *CreateStream )( 
            IStorage    * This,
            /* [string][in] */ const OLECHAR    *pwcsName,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD reserved1,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStream    *   *ppstm);
        
        /* [local] */ HRESULT ( __stdcall    *OpenStream )( 
            IStorage    * This,
            /* [string][in] */ const OLECHAR    *pwcsName,
            /* [unique][in] */ void    *reserved1,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStream    *   *ppstm);
        
        HRESULT ( __stdcall    *CreateStorage )( 
            IStorage    * This,
            /* [string][in] */ const OLECHAR    *pwcsName,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD dwStgFmt,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStorage    *   *ppstg);
        
        HRESULT ( __stdcall    *OpenStorage )( 
            IStorage    * This,
            /* [string][unique][in] */ const OLECHAR    *pwcsName,
            /* [unique][in] */ IStorage    *pstgPriority,
            /* [in] */ DWORD grfMode,
            /* [unique][in] */ SNB snbExclude,
            /* [in] */ DWORD reserved,
            /* [out] */ IStorage    *   *ppstg);
        
        HRESULT ( __stdcall    *CopyTo )( 
            IStorage    * This,
            /* [in] */ DWORD ciidExclude,
            /* [size_is][unique][in] */ const IID    *rgiidExclude,
            /* [unique][in] */ SNB snbExclude,
            /* [unique][in] */ IStorage    *pstgDest);
        
        HRESULT ( __stdcall    *MoveElementTo )( 
            IStorage    * This,
            /* [string][in] */ const OLECHAR    *pwcsName,
            /* [unique][in] */ IStorage    *pstgDest,
            /* [string][in] */ const OLECHAR    *pwcsNewName,
            /* [in] */ DWORD grfFlags);
        
        HRESULT ( __stdcall    *Commit )( 
            IStorage    * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( __stdcall    *Revert )( 
            IStorage    * This);
        
        /* [local] */ HRESULT ( __stdcall    *EnumElements )( 
            IStorage    * This,
            /* [in] */ DWORD reserved1,
            /* [size_is][unique][in] */ void    *reserved2,
            /* [in] */ DWORD reserved3,
            /* [out] */ IEnumSTATSTG    *   *ppenum);
        
        HRESULT ( __stdcall    *DestroyElement )( 
            IStorage    * This,
            /* [string][in] */ const OLECHAR    *pwcsName);
        
        HRESULT ( __stdcall    *RenameElement )( 
            IStorage    * This,
            /* [string][in] */ const OLECHAR    *pwcsOldName,
            /* [string][in] */ const OLECHAR    *pwcsNewName);
        
        HRESULT ( __stdcall    *SetElementTimes )( 
            IStorage    * This,
            /* [string][in] */ const OLECHAR    *pwcsName,
            /* [in] */ const FILETIME    *pctime,
            /* [in] */ const FILETIME    *patime,
            /* [in] */ const FILETIME    *pmtime);
        
        HRESULT ( __stdcall    *SetClass )( 
            IStorage    * This,
            /* [in] */  const CLSID &  clsid);
        
        HRESULT ( __stdcall    *SetStateBits )( 
            IStorage    * This,
            /* [in] */ DWORD grfStateBits,
            /* [in] */ DWORD grfMask);
        
        HRESULT ( __stdcall    *Stat )( 
            IStorage    * This,
            /* [out] */ STATSTG    *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
    } IStorageVtbl;

     struct  IStorage
    {
           struct IStorageVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 4301 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



HRESULT __stdcall IStorage_CreateStream_Proxy( 
    IStorage    * This,
    /* [string][in] */ const OLECHAR    *pwcsName,
    /* [in] */ DWORD grfMode,
    /* [in] */ DWORD reserved1,
    /* [in] */ DWORD reserved2,
    /* [out] */ IStream    *   *ppstm);


void  __stdcall  IStorage_CreateStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IStorage_RemoteOpenStream_Proxy( 
    IStorage    * This,
    /* [string][in] */ const OLECHAR    *pwcsName,
    /* [in] */ unsigned long cbReserved1,
    /* [size_is][unique][in] */ byte    *reserved1,
    /* [in] */ DWORD grfMode,
    /* [in] */ DWORD reserved2,
    /* [out] */ IStream    *   *ppstm);


void  __stdcall  IStorage_RemoteOpenStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStorage_CreateStorage_Proxy( 
    IStorage    * This,
    /* [string][in] */ const OLECHAR    *pwcsName,
    /* [in] */ DWORD grfMode,
    /* [in] */ DWORD dwStgFmt,
    /* [in] */ DWORD reserved2,
    /* [out] */ IStorage    *   *ppstg);


void  __stdcall  IStorage_CreateStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStorage_OpenStorage_Proxy( 
    IStorage    * This,
    /* [string][unique][in] */ const OLECHAR    *pwcsName,
    /* [unique][in] */ IStorage    *pstgPriority,
    /* [in] */ DWORD grfMode,
    /* [unique][in] */ SNB snbExclude,
    /* [in] */ DWORD reserved,
    /* [out] */ IStorage    *   *ppstg);


void  __stdcall  IStorage_OpenStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStorage_CopyTo_Proxy( 
    IStorage    * This,
    /* [in] */ DWORD ciidExclude,
    /* [size_is][unique][in] */ const IID    *rgiidExclude,
    /* [unique][in] */ SNB snbExclude,
    /* [unique][in] */ IStorage    *pstgDest);


void  __stdcall  IStorage_CopyTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStorage_MoveElementTo_Proxy( 
    IStorage    * This,
    /* [string][in] */ const OLECHAR    *pwcsName,
    /* [unique][in] */ IStorage    *pstgDest,
    /* [string][in] */ const OLECHAR    *pwcsNewName,
    /* [in] */ DWORD grfFlags);


void  __stdcall  IStorage_MoveElementTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStorage_Commit_Proxy( 
    IStorage    * This,
    /* [in] */ DWORD grfCommitFlags);


void  __stdcall  IStorage_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStorage_Revert_Proxy( 
    IStorage    * This);


void  __stdcall  IStorage_Revert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IStorage_RemoteEnumElements_Proxy( 
    IStorage    * This,
    /* [in] */ DWORD reserved1,
    /* [in] */ unsigned long cbReserved2,
    /* [size_is][unique][in] */ byte    *reserved2,
    /* [in] */ DWORD reserved3,
    /* [out] */ IEnumSTATSTG    *   *ppenum);


void  __stdcall  IStorage_RemoteEnumElements_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStorage_DestroyElement_Proxy( 
    IStorage    * This,
    /* [string][in] */ const OLECHAR    *pwcsName);


void  __stdcall  IStorage_DestroyElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStorage_RenameElement_Proxy( 
    IStorage    * This,
    /* [string][in] */ const OLECHAR    *pwcsOldName,
    /* [string][in] */ const OLECHAR    *pwcsNewName);


void  __stdcall  IStorage_RenameElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStorage_SetElementTimes_Proxy( 
    IStorage    * This,
    /* [string][in] */ const OLECHAR    *pwcsName,
    /* [in] */ const FILETIME    *pctime,
    /* [in] */ const FILETIME    *patime,
    /* [in] */ const FILETIME    *pmtime);


void  __stdcall  IStorage_SetElementTimes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStorage_SetClass_Proxy( 
    IStorage    * This,
    /* [in] */  const CLSID &  clsid);


void  __stdcall  IStorage_SetClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStorage_SetStateBits_Proxy( 
    IStorage    * This,
    /* [in] */ DWORD grfStateBits,
    /* [in] */ DWORD grfMask);


void  __stdcall  IStorage_SetStateBits_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStorage_Stat_Proxy( 
    IStorage    * This,
    /* [out] */ STATSTG    *pstatstg,
    /* [in] */ DWORD grfStatFlag);


void  __stdcall  IStorage_Stat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IStorage_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IPersistFile
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IPersistFile    *LPPERSISTFILE;


 extern "C"  const IID __cdecl IID_IPersistFile;

/* C style interface */#line 4565 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IPersistFileVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IPersistFile    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IPersistFile    * This);
        
        ULONG ( __stdcall    *Release )( 
            IPersistFile    * This);
        
        HRESULT ( __stdcall    *GetClassID )( 
            IPersistFile    * This,
            /* [out] */ CLSID    *pClassID);
        
        HRESULT ( __stdcall    *IsDirty )( 
            IPersistFile    * This);
        
        HRESULT ( __stdcall    *Load )( 
            IPersistFile    * This,
            /* [in] */ LPCOLESTR pszFileName,
            /* [in] */ DWORD dwMode);
        
        HRESULT ( __stdcall    *Save )( 
            IPersistFile    * This,
            /* [unique][in] */ LPCOLESTR pszFileName,
            /* [in] */ BOOL fRemember);
        
        HRESULT ( __stdcall    *SaveCompleted )( 
            IPersistFile    * This,
            /* [unique][in] */ LPCOLESTR pszFileName);
        
        HRESULT ( __stdcall    *GetCurFile )( 
            IPersistFile    * This,
            /* [out] */ LPOLESTR    *ppszFileName);
        
    } IPersistFileVtbl;

     struct  IPersistFile
    {
           struct IPersistFileVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 4647 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



HRESULT __stdcall IPersistFile_IsDirty_Proxy( 
    IPersistFile    * This);


void  __stdcall  IPersistFile_IsDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPersistFile_Load_Proxy( 
    IPersistFile    * This,
    /* [in] */ LPCOLESTR pszFileName,
    /* [in] */ DWORD dwMode);


void  __stdcall  IPersistFile_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPersistFile_Save_Proxy( 
    IPersistFile    * This,
    /* [unique][in] */ LPCOLESTR pszFileName,
    /* [in] */ BOOL fRemember);


void  __stdcall  IPersistFile_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPersistFile_SaveCompleted_Proxy( 
    IPersistFile    * This,
    /* [unique][in] */ LPCOLESTR pszFileName);


void  __stdcall  IPersistFile_SaveCompleted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPersistFile_GetCurFile_Proxy( 
    IPersistFile    * This,
    /* [out] */ LPOLESTR    *ppszFileName);


void  __stdcall  IPersistFile_GetCurFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IPersistFile_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IPersistStorage
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IPersistStorage    *LPPERSISTSTORAGE;


 extern "C"  const IID __cdecl IID_IPersistStorage;

/* C style interface */#line 4760 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IPersistStorageVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IPersistStorage    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IPersistStorage    * This);
        
        ULONG ( __stdcall    *Release )( 
            IPersistStorage    * This);
        
        HRESULT ( __stdcall    *GetClassID )( 
            IPersistStorage    * This,
            /* [out] */ CLSID    *pClassID);
        
        HRESULT ( __stdcall    *IsDirty )( 
            IPersistStorage    * This);
        
        HRESULT ( __stdcall    *InitNew )( 
            IPersistStorage    * This,
            /* [unique][in] */ IStorage    *pStg);
        
        HRESULT ( __stdcall    *Load )( 
            IPersistStorage    * This,
            /* [unique][in] */ IStorage    *pStg);
        
        HRESULT ( __stdcall    *Save )( 
            IPersistStorage    * This,
            /* [unique][in] */ IStorage    *pStgSave,
            /* [in] */ BOOL fSameAsLoad);
        
        HRESULT ( __stdcall    *SaveCompleted )( 
            IPersistStorage    * This,
            /* [unique][in] */ IStorage    *pStgNew);
        
        HRESULT ( __stdcall    *HandsOffStorage )( 
            IPersistStorage    * This);
        
    } IPersistStorageVtbl;

     struct  IPersistStorage
    {
           struct IPersistStorageVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 4847 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



HRESULT __stdcall IPersistStorage_IsDirty_Proxy( 
    IPersistStorage    * This);


void  __stdcall  IPersistStorage_IsDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPersistStorage_InitNew_Proxy( 
    IPersistStorage    * This,
    /* [unique][in] */ IStorage    *pStg);


void  __stdcall  IPersistStorage_InitNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPersistStorage_Load_Proxy( 
    IPersistStorage    * This,
    /* [unique][in] */ IStorage    *pStg);


void  __stdcall  IPersistStorage_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPersistStorage_Save_Proxy( 
    IPersistStorage    * This,
    /* [unique][in] */ IStorage    *pStgSave,
    /* [in] */ BOOL fSameAsLoad);


void  __stdcall  IPersistStorage_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPersistStorage_SaveCompleted_Proxy( 
    IPersistStorage    * This,
    /* [unique][in] */ IStorage    *pStgNew);


void  __stdcall  IPersistStorage_SaveCompleted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPersistStorage_HandsOffStorage_Proxy( 
    IPersistStorage    * This);


void  __stdcall  IPersistStorage_HandsOffStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IPersistStorage_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: ILockBytes
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  ILockBytes    *LPLOCKBYTES;


 extern "C"  const IID __cdecl IID_ILockBytes;

/* C style interface */#line 4984 "C:\WATCOM\H\NT\objidl.h"

    typedef struct ILockBytesVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            ILockBytes    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            ILockBytes    * This);
        
        ULONG ( __stdcall    *Release )( 
            ILockBytes    * This);
        
        /* [local] */ HRESULT ( __stdcall    *ReadAt )( 
            ILockBytes    * This,
            /* [in] */ ULARGE_INTEGER ulOffset,
            /* [in] */ void    *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG    *pcbRead);
        
        /* [local] */ HRESULT ( __stdcall    *WriteAt )( 
            ILockBytes    * This,
            /* [in] */ ULARGE_INTEGER ulOffset,
            /* [in] */ const void    *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG    *pcbWritten);
        
        HRESULT ( __stdcall    *Flush )( 
            ILockBytes    * This);
        
        HRESULT ( __stdcall    *SetSize )( 
            ILockBytes    * This,
            /* [in] */ ULARGE_INTEGER cb);
        
        HRESULT ( __stdcall    *LockRegion )( 
            ILockBytes    * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( __stdcall    *UnlockRegion )( 
            ILockBytes    * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( __stdcall    *Stat )( 
            ILockBytes    * This,
            /* [out] */ STATSTG    *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
    } ILockBytesVtbl;

     struct  ILockBytes
    {
           struct ILockBytesVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 5081 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



/* [call_as] */ HRESULT __stdcall ILockBytes_RemoteReadAt_Proxy( 
    ILockBytes    * This,
    /* [in] */ ULARGE_INTEGER ulOffset,
    /* [length_is][size_is][out] */ byte    *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG    *pcbRead);


void  __stdcall  ILockBytes_RemoteReadAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall ILockBytes_RemoteWriteAt_Proxy( 
    ILockBytes    * This,
    /* [in] */ ULARGE_INTEGER ulOffset,
    /* [size_is][in] */ const byte    *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG    *pcbWritten);


void  __stdcall  ILockBytes_RemoteWriteAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ILockBytes_Flush_Proxy( 
    ILockBytes    * This);


void  __stdcall  ILockBytes_Flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ILockBytes_SetSize_Proxy( 
    ILockBytes    * This,
    /* [in] */ ULARGE_INTEGER cb);


void  __stdcall  ILockBytes_SetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ILockBytes_LockRegion_Proxy( 
    ILockBytes    * This,
    /* [in] */ ULARGE_INTEGER libOffset,
    /* [in] */ ULARGE_INTEGER cb,
    /* [in] */ DWORD dwLockType);


void  __stdcall  ILockBytes_LockRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ILockBytes_UnlockRegion_Proxy( 
    ILockBytes    * This,
    /* [in] */ ULARGE_INTEGER libOffset,
    /* [in] */ ULARGE_INTEGER cb,
    /* [in] */ DWORD dwLockType);


void  __stdcall  ILockBytes_UnlockRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ILockBytes_Stat_Proxy( 
    ILockBytes    * This,
    /* [out] */ STATSTG    *pstatstg,
    /* [in] */ DWORD grfStatFlag);


void  __stdcall  ILockBytes_Stat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __ILockBytes_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IEnumFORMATETC
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IEnumFORMATETC    *LPENUMFORMATETC;

			/* size is 12 */
typedef struct  tagDVTARGETDEVICE
    {
    DWORD tdSize;
    WORD tdDriverNameOffset;
    WORD tdDeviceNameOffset;
    WORD tdPortNameOffset;
    WORD tdExtDevmodeOffset;
    /* [size_is] */ BYTE tdData[ 1 ];
    }	DVTARGETDEVICE;

			/* size is 2 */
typedef WORD CLIPFORMAT;

			/* size is 4 */
typedef CLIPFORMAT    *LPCLIPFORMAT;

			/* size is 20 */
typedef struct  tagFORMATETC
    {
    CLIPFORMAT cfFormat;
    /* [unique] */ DVTARGETDEVICE    *ptd;
    DWORD dwAspect;
    LONG lindex;
    DWORD tymed;
    }	FORMATETC;

			/* size is 4 */
typedef struct tagFORMATETC    *LPFORMATETC;


 extern "C"  const IID __cdecl IID_IEnumFORMATETC;

/* C style interface */#line 5253 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IEnumFORMATETCVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IEnumFORMATETC    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IEnumFORMATETC    * This);
        
        ULONG ( __stdcall    *Release )( 
            IEnumFORMATETC    * This);
        
        /* [local] */ HRESULT ( __stdcall    *Next )( 
            IEnumFORMATETC    * This,
            /* [in] */ ULONG celt,
            /* [out] */ FORMATETC    *rgelt,
            /* [out] */ ULONG    *pceltFetched);
        
        HRESULT ( __stdcall    *Skip )( 
            IEnumFORMATETC    * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( __stdcall    *Reset )( 
            IEnumFORMATETC    * This);
        
        HRESULT ( __stdcall    *Clone )( 
            IEnumFORMATETC    * This,
            /* [out] */ IEnumFORMATETC    *   *ppenum);
        
    } IEnumFORMATETCVtbl;

     struct  IEnumFORMATETC
    {
           struct IEnumFORMATETCVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 5320 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumFORMATETC_RemoteNext_Proxy( 
    IEnumFORMATETC    * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ FORMATETC    *rgelt,
    /* [out] */ ULONG    *pceltFetched);


void  __stdcall  IEnumFORMATETC_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumFORMATETC_Skip_Proxy( 
    IEnumFORMATETC    * This,
    /* [in] */ ULONG celt);


void  __stdcall  IEnumFORMATETC_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumFORMATETC_Reset_Proxy( 
    IEnumFORMATETC    * This);


void  __stdcall  IEnumFORMATETC_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumFORMATETC_Clone_Proxy( 
    IEnumFORMATETC    * This,
    /* [out] */ IEnumFORMATETC    *   *ppenum);


void  __stdcall  IEnumFORMATETC_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IEnumFORMATETC_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IEnumSTATDATA
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IEnumSTATDATA    *LPENUMSTATDATA;

			/* size is 2 */
typedef 
enum tagADVF
    {	ADVF_NODATA	= 1,
	ADVF_PRIMEFIRST	= 2,
	ADVF_ONLYONCE	= 4,
	ADVF_DATAONSTOP	= 64,
	ADVFCACHE_NOHANDLER	= 8,
	ADVFCACHE_FORCEBUILTIN	= 16,
	ADVFCACHE_ONSAVE	= 32
    }	ADVF;

			/* size is 32 */
typedef struct  tagSTATDATA
    {
    FORMATETC formatetc;
    DWORD advf;
    /* [unique] */ IAdviseSink    *pAdvSink;
    DWORD dwConnection;
    }	STATDATA;

			/* size is 4 */
typedef STATDATA    *LPSTATDATA;


 extern "C"  const IID __cdecl IID_IEnumSTATDATA;

/* C style interface */#line 5441 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IEnumSTATDATAVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IEnumSTATDATA    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IEnumSTATDATA    * This);
        
        ULONG ( __stdcall    *Release )( 
            IEnumSTATDATA    * This);
        
        /* [local] */ HRESULT ( __stdcall    *Next )( 
            IEnumSTATDATA    * This,
            /* [in] */ ULONG celt,
            STATDATA    *rgelt,
            /* [out] */ ULONG    *pceltFetched);
        
        HRESULT ( __stdcall    *Skip )( 
            IEnumSTATDATA    * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( __stdcall    *Reset )( 
            IEnumSTATDATA    * This);
        
        HRESULT ( __stdcall    *Clone )( 
            IEnumSTATDATA    * This,
            /* [out] */ IEnumSTATDATA    *   *ppenum);
        
    } IEnumSTATDATAVtbl;

     struct  IEnumSTATDATA
    {
           struct IEnumSTATDATAVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 5508 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumSTATDATA_RemoteNext_Proxy( 
    IEnumSTATDATA    * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATDATA    *rgelt,
    /* [out] */ ULONG    *pceltFetched);


void  __stdcall  IEnumSTATDATA_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumSTATDATA_Skip_Proxy( 
    IEnumSTATDATA    * This,
    /* [in] */ ULONG celt);


void  __stdcall  IEnumSTATDATA_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumSTATDATA_Reset_Proxy( 
    IEnumSTATDATA    * This);


void  __stdcall  IEnumSTATDATA_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumSTATDATA_Clone_Proxy( 
    IEnumSTATDATA    * This,
    /* [out] */ IEnumSTATDATA    *   *ppenum);


void  __stdcall  IEnumSTATDATA_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IEnumSTATDATA_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IRootStorage
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IRootStorage    *LPROOTSTORAGE;


 extern "C"  const IID __cdecl IID_IRootStorage;

/* C style interface */#line 5595 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IRootStorageVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IRootStorage    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IRootStorage    * This);
        
        ULONG ( __stdcall    *Release )( 
            IRootStorage    * This);
        
        HRESULT ( __stdcall    *SwitchToFile )( 
            IRootStorage    * This,
            /* [string][in] */ LPOLESTR pszFile);
        
    } IRootStorageVtbl;

     struct  IRootStorage
    {
           struct IRootStorageVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 5640 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



HRESULT __stdcall IRootStorage_SwitchToFile_Proxy( 
    IRootStorage    * This,
    /* [string][in] */ LPOLESTR pszFile);


void  __stdcall  IRootStorage_SwitchToFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IRootStorage_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IAdviseSink
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef IAdviseSink    *LPADVISESINK;

			/* size is 2 */
typedef /* [v1_enum] */  
enum tagTYMED
    {	TYMED_HGLOBAL	= 1,
	TYMED_FILE	= 2,
	TYMED_ISTREAM	= 4,
	TYMED_ISTORAGE	= 8,
	TYMED_GDI	= 16,
	TYMED_MFPICT	= 32,
	TYMED_ENHMF	= 64,
	TYMED_NULL	= 0
    }	TYMED;


#pragma warning(disable:4200)

			/* size is 20 */
typedef struct  tagRemSTGMEDIUM
    {
    DWORD tymed;
    DWORD dwHandleType;
    unsigned long pData;
    unsigned long pUnkForRelease;
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    }	RemSTGMEDIUM;


#pragma warning(default:4200)

#line 5721 "C:\WATCOM\H\NT\objidl.h"
			/* size is 12 */
typedef struct  tagSTGMEDIUM
    {
    DWORD tymed;
    /* [switch_is][switch_type] */ union 
        {
        /* [case] */ HBITMAP hBitmap;
        /* [case] */ HMETAFILEPICT hMetaFilePict;
        /* [case] */ HENHMETAFILE hEnhMetaFile;
        /* [case] */ HGLOBAL hGlobal;
        /* [case] */ LPOLESTR lpszFileName;
        /* [case] */ IStream    *pstm;
        /* [case] */ IStorage    *pstg;
        /* [default] */  /* Empty union arm */ 
        }	;
    /* [unique] */ IUnknown    *pUnkForRelease;
    }	STGMEDIUM;

/* !NONAMELESSUNION */
			/* size is 4 */
typedef STGMEDIUM    *LPSTGMEDIUM;


 extern "C"  const IID __cdecl IID_IAdviseSink;

/* C style interface */#line 5769 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IAdviseSinkVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IAdviseSink    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IAdviseSink    * This);
        
        ULONG ( __stdcall    *Release )( 
            IAdviseSink    * This);
        
        /* [local] */ void ( __stdcall    *OnDataChange )( 
            IAdviseSink    * This,
            /* [unique][in] */ FORMATETC    *pFormatetc,
            /* [unique][in] */ STGMEDIUM    *pStgmed);
        
        /* [local] */ void ( __stdcall    *OnViewChange )( 
            IAdviseSink    * This,
            /* [in] */ DWORD dwAspect,
            /* [in] */ LONG lindex);
        
        /* [local] */ void ( __stdcall    *OnRename )( 
            IAdviseSink    * This,
            /* [in] */ IMoniker    *pmk);
        
        /* [local] */ void ( __stdcall    *OnSave )( 
            IAdviseSink    * This);
        
        /* [local] */ void ( __stdcall    *OnClose )( 
            IAdviseSink    * This);
        
    } IAdviseSinkVtbl;

     struct  IAdviseSink
    {
           struct IAdviseSinkVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 5842 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



/* [async][call_as] */ void __stdcall IAdviseSink_RemoteOnDataChange_Proxy( 
    IAdviseSink    * This,
    /* [unique][in] */ FORMATETC    *pFormatetc,
    /* [unique][in] */ RemSTGMEDIUM    *pStgmed);


void  __stdcall  IAdviseSink_RemoteOnDataChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [async][call_as] */ void __stdcall IAdviseSink_RemoteOnViewChange_Proxy( 
    IAdviseSink    * This,
    /* [in] */ DWORD dwAspect,
    /* [in] */ LONG lindex);


void  __stdcall  IAdviseSink_RemoteOnViewChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [async][call_as] */ void __stdcall IAdviseSink_RemoteOnRename_Proxy( 
    IAdviseSink    * This,
    /* [in] */ IMoniker    *pmk);


void  __stdcall  IAdviseSink_RemoteOnRename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [async][call_as] */ void __stdcall IAdviseSink_RemoteOnSave_Proxy( 
    IAdviseSink    * This);


void  __stdcall  IAdviseSink_RemoteOnSave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IAdviseSink_RemoteOnClose_Proxy( 
    IAdviseSink    * This);


void  __stdcall  IAdviseSink_RemoteOnClose_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IAdviseSink_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IAdviseSink2
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IAdviseSink2    *LPADVISESINK2;


 extern "C"  const IID __cdecl IID_IAdviseSink2;

/* C style interface */#line 5940 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IAdviseSink2Vtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IAdviseSink2    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IAdviseSink2    * This);
        
        ULONG ( __stdcall    *Release )( 
            IAdviseSink2    * This);
        
        /* [local] */ void ( __stdcall    *OnDataChange )( 
            IAdviseSink2    * This,
            /* [unique][in] */ FORMATETC    *pFormatetc,
            /* [unique][in] */ STGMEDIUM    *pStgmed);
        
        /* [local] */ void ( __stdcall    *OnViewChange )( 
            IAdviseSink2    * This,
            /* [in] */ DWORD dwAspect,
            /* [in] */ LONG lindex);
        
        /* [local] */ void ( __stdcall    *OnRename )( 
            IAdviseSink2    * This,
            /* [in] */ IMoniker    *pmk);
        
        /* [local] */ void ( __stdcall    *OnSave )( 
            IAdviseSink2    * This);
        
        /* [local] */ void ( __stdcall    *OnClose )( 
            IAdviseSink2    * This);
        
        /* [local] */ void ( __stdcall    *OnLinkSrcChange )( 
            IAdviseSink2    * This,
            /* [unique][in] */ IMoniker    *pmk);
        
    } IAdviseSink2Vtbl;

     struct  IAdviseSink2
    {
           struct IAdviseSink2Vtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 6021 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



/* [async][call_as] */ void __stdcall IAdviseSink2_RemoteOnLinkSrcChange_Proxy( 
    IAdviseSink2    * This,
    /* [unique][in] */ IMoniker    *pmk);


void  __stdcall  IAdviseSink2_RemoteOnLinkSrcChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IAdviseSink2_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IDataObject
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IDataObject    *LPDATAOBJECT;

			/* size is 2 */
typedef 
enum tagDATADIR
    {	DATADIR_GET	= 1,
	DATADIR_SET	= 2
    }	DATADIR;


 extern "C"  const IID __cdecl IID_IDataObject;

/* C style interface */#line 6111 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IDataObjectVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IDataObject    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IDataObject    * This);
        
        ULONG ( __stdcall    *Release )( 
            IDataObject    * This);
        
        /* [local] */ HRESULT ( __stdcall    *GetData )( 
            IDataObject    * This,
            /* [unique][in] */ FORMATETC    *pformatetcIn,
            /* [out] */ STGMEDIUM    *pmedium);
        
        /* [local] */ HRESULT ( __stdcall    *GetDataHere )( 
            IDataObject    * This,
            /* [unique][in] */ FORMATETC    *pformatetc,
            /* [out][in] */ STGMEDIUM    *pmedium);
        
        HRESULT ( __stdcall    *QueryGetData )( 
            IDataObject    * This,
            /* [unique][in] */ FORMATETC    *pformatetc);
        
        HRESULT ( __stdcall    *GetCanonicalFormatEtc )( 
            IDataObject    * This,
            /* [unique][in] */ FORMATETC    *pformatectIn,
            /* [out] */ FORMATETC    *pformatetcOut);
        
        /* [local] */ HRESULT ( __stdcall    *SetData )( 
            IDataObject    * This,
            /* [unique][in] */ FORMATETC    *pformatetc,
            /* [unique][in] */ STGMEDIUM    *pmedium,
            /* [in] */ BOOL fRelease);
        
        HRESULT ( __stdcall    *EnumFormatEtc )( 
            IDataObject    * This,
            /* [in] */ DWORD dwDirection,
            /* [out] */ IEnumFORMATETC    *   *ppenumFormatEtc);
        
        HRESULT ( __stdcall    *DAdvise )( 
            IDataObject    * This,
            /* [in] */ FORMATETC    *pformatetc,
            /* [in] */ DWORD advf,
            /* [unique][in] */ IAdviseSink    *pAdvSink,
            /* [out] */ DWORD    *pdwConnection);
        
        HRESULT ( __stdcall    *DUnadvise )( 
            IDataObject    * This,
            /* [in] */ DWORD dwConnection);
        
        HRESULT ( __stdcall    *EnumDAdvise )( 
            IDataObject    * This,
            /* [out] */ IEnumSTATDATA    *   *ppenumAdvise);
        
    } IDataObjectVtbl;

     struct  IDataObject
    {
           struct IDataObjectVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 6221 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



/* [call_as] */ HRESULT __stdcall IDataObject_RemoteGetData_Proxy( 
    IDataObject    * This,
    /* [unique][in] */ FORMATETC    *pformatetcIn,
    /* [out] */ RemSTGMEDIUM    *   *ppRemoteMedium);


void  __stdcall  IDataObject_RemoteGetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IDataObject_RemoteGetDataHere_Proxy( 
    IDataObject    * This,
    /* [unique][in] */ FORMATETC    *pformatetc,
    /* [out][in] */ RemSTGMEDIUM    *   *ppRemoteMedium);


void  __stdcall  IDataObject_RemoteGetDataHere_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDataObject_QueryGetData_Proxy( 
    IDataObject    * This,
    /* [unique][in] */ FORMATETC    *pformatetc);


void  __stdcall  IDataObject_QueryGetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDataObject_GetCanonicalFormatEtc_Proxy( 
    IDataObject    * This,
    /* [unique][in] */ FORMATETC    *pformatectIn,
    /* [out] */ FORMATETC    *pformatetcOut);


void  __stdcall  IDataObject_GetCanonicalFormatEtc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IDataObject_RemoteSetData_Proxy( 
    IDataObject    * This,
    /* [unique][in] */ FORMATETC    *pformatetc,
    /* [unique][in] */ RemSTGMEDIUM    *pmedium,
    /* [in] */ BOOL fRelease);


void  __stdcall  IDataObject_RemoteSetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDataObject_EnumFormatEtc_Proxy( 
    IDataObject    * This,
    /* [in] */ DWORD dwDirection,
    /* [out] */ IEnumFORMATETC    *   *ppenumFormatEtc);


void  __stdcall  IDataObject_EnumFormatEtc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDataObject_DAdvise_Proxy( 
    IDataObject    * This,
    /* [in] */ FORMATETC    *pformatetc,
    /* [in] */ DWORD advf,
    /* [unique][in] */ IAdviseSink    *pAdvSink,
    /* [out] */ DWORD    *pdwConnection);


void  __stdcall  IDataObject_DAdvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDataObject_DUnadvise_Proxy( 
    IDataObject    * This,
    /* [in] */ DWORD dwConnection);


void  __stdcall  IDataObject_DUnadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDataObject_EnumDAdvise_Proxy( 
    IDataObject    * This,
    /* [out] */ IEnumSTATDATA    *   *ppenumAdvise);


void  __stdcall  IDataObject_EnumDAdvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IDataObject_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IDataAdviseHolder
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */  IDataAdviseHolder    *LPDATAADVISEHOLDER;


 extern "C"  const IID __cdecl IID_IDataAdviseHolder;

/* C style interface */#line 6391 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IDataAdviseHolderVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IDataAdviseHolder    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IDataAdviseHolder    * This);
        
        ULONG ( __stdcall    *Release )( 
            IDataAdviseHolder    * This);
        
        HRESULT ( __stdcall    *Advise )( 
            IDataAdviseHolder    * This,
            /* [unique][in] */ IDataObject    *pDataObject,
            /* [unique][in] */ FORMATETC    *pFetc,
            /* [in] */ DWORD advf,
            /* [unique][in] */ IAdviseSink    *pAdvise,
            /* [out] */ DWORD    *pdwConnection);
        
        HRESULT ( __stdcall    *Unadvise )( 
            IDataAdviseHolder    * This,
            /* [in] */ DWORD dwConnection);
        
        HRESULT ( __stdcall    *EnumAdvise )( 
            IDataAdviseHolder    * This,
            /* [out] */ IEnumSTATDATA    *   *ppenumAdvise);
        
        HRESULT ( __stdcall    *SendOnDataChange )( 
            IDataAdviseHolder    * This,
            /* [unique][in] */ IDataObject    *pDataObject,
            /* [in] */ DWORD dwReserved,
            /* [in] */ DWORD advf);
        
    } IDataAdviseHolderVtbl;

     struct  IDataAdviseHolder
    {
           struct IDataAdviseHolderVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 6463 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



HRESULT __stdcall IDataAdviseHolder_Advise_Proxy( 
    IDataAdviseHolder    * This,
    /* [unique][in] */ IDataObject    *pDataObject,
    /* [unique][in] */ FORMATETC    *pFetc,
    /* [in] */ DWORD advf,
    /* [unique][in] */ IAdviseSink    *pAdvise,
    /* [out] */ DWORD    *pdwConnection);


void  __stdcall  IDataAdviseHolder_Advise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDataAdviseHolder_Unadvise_Proxy( 
    IDataAdviseHolder    * This,
    /* [in] */ DWORD dwConnection);


void  __stdcall  IDataAdviseHolder_Unadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDataAdviseHolder_EnumAdvise_Proxy( 
    IDataAdviseHolder    * This,
    /* [out] */ IEnumSTATDATA    *   *ppenumAdvise);


void  __stdcall  IDataAdviseHolder_EnumAdvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDataAdviseHolder_SendOnDataChange_Proxy( 
    IDataAdviseHolder    * This,
    /* [unique][in] */ IDataObject    *pDataObject,
    /* [in] */ DWORD dwReserved,
    /* [in] */ DWORD advf);


void  __stdcall  IDataAdviseHolder_SendOnDataChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IDataAdviseHolder_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IMessageFilter
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */  IMessageFilter    *LPMESSAGEFILTER;

			/* size is 2 */
typedef 
enum tagCALLTYPE
    {	CALLTYPE_TOPLEVEL	= 1,
	CALLTYPE_NESTED	= 2,
	CALLTYPE_ASYNC	= 3,
	CALLTYPE_TOPLEVEL_CALLPENDING	= 4,
	CALLTYPE_ASYNC_CALLPENDING	= 5
    }	CALLTYPE;

			/* size is 2 */
typedef 
enum tagSERVERCALL
    {	SERVERCALL_ISHANDLED	= 0,
	SERVERCALL_REJECTED	= 1,
	SERVERCALL_RETRYLATER	= 2
    }	SERVERCALL;

			/* size is 2 */
typedef 
enum tagPENDINGTYPE
    {	PENDINGTYPE_TOPLEVEL	= 1,
	PENDINGTYPE_NESTED	= 2
    }	PENDINGTYPE;

			/* size is 2 */
typedef 
enum tagPENDINGMSG
    {	PENDINGMSG_CANCELCALL	= 0,
	PENDINGMSG_WAITNOPROCESS	= 1,
	PENDINGMSG_WAITDEFPROCESS	= 2
    }	PENDINGMSG;

			/* size is 22 */
typedef struct  tagINTERFACEINFO
    {
    IUnknown    *pUnk;
    IID iid;
    WORD wMethod;
    }	INTERFACEINFO;

			/* size is 4 */
typedef struct tagINTERFACEINFO    *LPINTERFACEINFO;


 extern "C"  const IID __cdecl IID_IMessageFilter;

/* C style interface */#line 6612 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IMessageFilterVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IMessageFilter    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IMessageFilter    * This);
        
        ULONG ( __stdcall    *Release )( 
            IMessageFilter    * This);
        
        DWORD ( __stdcall    *HandleInComingCall )( 
            IMessageFilter    * This,
            /* [in] */ DWORD dwCallType,
            /* [in] */ HTASK htaskCaller,
            /* [in] */ DWORD dwTickCount,
            /* [in] */ LPINTERFACEINFO lpInterfaceInfo);
        
        DWORD ( __stdcall    *RetryRejectedCall )( 
            IMessageFilter    * This,
            /* [in] */ HTASK htaskCallee,
            /* [in] */ DWORD dwTickCount,
            /* [in] */ DWORD dwRejectType);
        
        DWORD ( __stdcall    *MessagePending )( 
            IMessageFilter    * This,
            /* [in] */ HTASK htaskCallee,
            /* [in] */ DWORD dwTickCount,
            /* [in] */ DWORD dwPendingType);
        
    } IMessageFilterVtbl;

     struct  IMessageFilter
    {
           struct IMessageFilterVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 6678 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



DWORD __stdcall IMessageFilter_HandleInComingCall_Proxy( 
    IMessageFilter    * This,
    /* [in] */ DWORD dwCallType,
    /* [in] */ HTASK htaskCaller,
    /* [in] */ DWORD dwTickCount,
    /* [in] */ LPINTERFACEINFO lpInterfaceInfo);


void  __stdcall  IMessageFilter_HandleInComingCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD __stdcall IMessageFilter_RetryRejectedCall_Proxy( 
    IMessageFilter    * This,
    /* [in] */ HTASK htaskCallee,
    /* [in] */ DWORD dwTickCount,
    /* [in] */ DWORD dwRejectType);


void  __stdcall  IMessageFilter_RetryRejectedCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD __stdcall IMessageFilter_MessagePending_Proxy( 
    IMessageFilter    * This,
    /* [in] */ HTASK htaskCallee,
    /* [in] */ DWORD dwTickCount,
    /* [in] */ DWORD dwPendingType);


void  __stdcall  IMessageFilter_MessagePending_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IMessageFilter_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IRpcChannelBuffer
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


			/* size is 4 */
typedef unsigned long RPCOLEDATAREP;

			/* size is 44 */
typedef struct  tagRPCOLEMESSAGE
    {
    void    *reserved1;
    RPCOLEDATAREP dataRepresentation;
    void    *Buffer;
    ULONG cbBuffer;
    ULONG iMethod;
    void    *reserved2[ 5 ];
    ULONG rpcFlags;
    }	RPCOLEMESSAGE;

			/* size is 4 */
typedef RPCOLEMESSAGE    *PRPCOLEMESSAGE;


 extern "C"  const IID __cdecl IID_IRpcChannelBuffer;

/* C style interface */#line 6788 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IRpcChannelBufferVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IRpcChannelBuffer    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IRpcChannelBuffer    * This);
        
        ULONG ( __stdcall    *Release )( 
            IRpcChannelBuffer    * This);
        
        HRESULT ( __stdcall    *GetBuffer )( 
            IRpcChannelBuffer    * This,
            /* [in] */ RPCOLEMESSAGE    *pMessage,
            /* [in] */  const IID &  riid);
        
        HRESULT ( __stdcall    *SendReceive )( 
            IRpcChannelBuffer    * This,
            /* [out][in] */ RPCOLEMESSAGE    *pMessage,
            /* [out] */ ULONG    *pStatus);
        
        HRESULT ( __stdcall    *FreeBuffer )( 
            IRpcChannelBuffer    * This,
            /* [in] */ RPCOLEMESSAGE    *pMessage);
        
        HRESULT ( __stdcall    *GetDestCtx )( 
            IRpcChannelBuffer    * This,
            /* [out] */ DWORD    *pdwDestContext,
            /* [out] */ void    *   *ppvDestContext);
        
        HRESULT ( __stdcall    *IsConnected )( 
            IRpcChannelBuffer    * This);
        
    } IRpcChannelBufferVtbl;

     struct  IRpcChannelBuffer
    {
           struct IRpcChannelBufferVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 6863 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



HRESULT __stdcall IRpcChannelBuffer_GetBuffer_Proxy( 
    IRpcChannelBuffer    * This,
    /* [in] */ RPCOLEMESSAGE    *pMessage,
    /* [in] */  const IID &  riid);


void  __stdcall  IRpcChannelBuffer_GetBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRpcChannelBuffer_SendReceive_Proxy( 
    IRpcChannelBuffer    * This,
    /* [out][in] */ RPCOLEMESSAGE    *pMessage,
    /* [out] */ ULONG    *pStatus);


void  __stdcall  IRpcChannelBuffer_SendReceive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRpcChannelBuffer_FreeBuffer_Proxy( 
    IRpcChannelBuffer    * This,
    /* [in] */ RPCOLEMESSAGE    *pMessage);


void  __stdcall  IRpcChannelBuffer_FreeBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRpcChannelBuffer_GetDestCtx_Proxy( 
    IRpcChannelBuffer    * This,
    /* [out] */ DWORD    *pdwDestContext,
    /* [out] */ void    *   *ppvDestContext);


void  __stdcall  IRpcChannelBuffer_GetDestCtx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRpcChannelBuffer_IsConnected_Proxy( 
    IRpcChannelBuffer    * This);


void  __stdcall  IRpcChannelBuffer_IsConnected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IRpcChannelBuffer_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IRpcProxyBuffer
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 



 extern "C"  const IID __cdecl IID_IRpcProxyBuffer;

/* C style interface */#line 6962 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IRpcProxyBufferVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IRpcProxyBuffer    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IRpcProxyBuffer    * This);
        
        ULONG ( __stdcall    *Release )( 
            IRpcProxyBuffer    * This);
        
        HRESULT ( __stdcall    *Connect )( 
            IRpcProxyBuffer    * This,
            /* [unique][in] */ IRpcChannelBuffer    *pRpcChannelBuffer);
        
        void ( __stdcall    *Disconnect )( 
            IRpcProxyBuffer    * This);
        
    } IRpcProxyBufferVtbl;

     struct  IRpcProxyBuffer
    {
           struct IRpcProxyBufferVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 7013 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



HRESULT __stdcall IRpcProxyBuffer_Connect_Proxy( 
    IRpcProxyBuffer    * This,
    /* [unique][in] */ IRpcChannelBuffer    *pRpcChannelBuffer);


void  __stdcall  IRpcProxyBuffer_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall IRpcProxyBuffer_Disconnect_Proxy( 
    IRpcProxyBuffer    * This);


void  __stdcall  IRpcProxyBuffer_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IRpcProxyBuffer_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IRpcStubBuffer
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 



 extern "C"  const IID __cdecl IID_IRpcStubBuffer;

/* C style interface */#line 7088 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IRpcStubBufferVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IRpcStubBuffer    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IRpcStubBuffer    * This);
        
        ULONG ( __stdcall    *Release )( 
            IRpcStubBuffer    * This);
        
        HRESULT ( __stdcall    *Connect )( 
            IRpcStubBuffer    * This,
            /* [in] */ IUnknown    *pUnkServer);
        
        void ( __stdcall    *Disconnect )( 
            IRpcStubBuffer    * This);
        
        HRESULT ( __stdcall    *Invoke )( 
            IRpcStubBuffer    * This,
            /* [in] */ RPCOLEMESSAGE    *_prpcmsg,
            /* [in] */ IRpcChannelBuffer    *_pRpcChannelBuffer);
        
        IRpcStubBuffer    *( __stdcall    *IsIIDSupported )( 
            IRpcStubBuffer    * This,
            /* [in] */  const IID &  riid);
        
        ULONG ( __stdcall    *CountRefs )( 
            IRpcStubBuffer    * This);
        
        HRESULT ( __stdcall    *DebugServerQueryInterface )( 
            IRpcStubBuffer    * This,
            void    *   *ppv);
        
        void ( __stdcall    *DebugServerRelease )( 
            IRpcStubBuffer    * This,
            void    *pv);
        
    } IRpcStubBufferVtbl;

     struct  IRpcStubBuffer
    {
           struct IRpcStubBufferVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 7174 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



HRESULT __stdcall IRpcStubBuffer_Connect_Proxy( 
    IRpcStubBuffer    * This,
    /* [in] */ IUnknown    *pUnkServer);


void  __stdcall  IRpcStubBuffer_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall IRpcStubBuffer_Disconnect_Proxy( 
    IRpcStubBuffer    * This);


void  __stdcall  IRpcStubBuffer_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRpcStubBuffer_Invoke_Proxy( 
    IRpcStubBuffer    * This,
    /* [in] */ RPCOLEMESSAGE    *_prpcmsg,
    /* [in] */ IRpcChannelBuffer    *_pRpcChannelBuffer);


void  __stdcall  IRpcStubBuffer_Invoke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IRpcStubBuffer    *__stdcall IRpcStubBuffer_IsIIDSupported_Proxy( 
    IRpcStubBuffer    * This,
    /* [in] */  const IID &  riid);


void  __stdcall  IRpcStubBuffer_IsIIDSupported_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG __stdcall IRpcStubBuffer_CountRefs_Proxy( 
    IRpcStubBuffer    * This);


void  __stdcall  IRpcStubBuffer_CountRefs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRpcStubBuffer_DebugServerQueryInterface_Proxy( 
    IRpcStubBuffer    * This,
    void    *   *ppv);


void  __stdcall  IRpcStubBuffer_DebugServerQueryInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall IRpcStubBuffer_DebugServerRelease_Proxy( 
    IRpcStubBuffer    * This,
    void    *pv);


void  __stdcall  IRpcStubBuffer_DebugServerRelease_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IRpcStubBuffer_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IPSFactoryBuffer
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 



 extern "C"  const IID __cdecl IID_IPSFactoryBuffer;

/* C style interface */#line 7300 "C:\WATCOM\H\NT\objidl.h"

    typedef struct IPSFactoryBufferVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IPSFactoryBuffer    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IPSFactoryBuffer    * This);
        
        ULONG ( __stdcall    *Release )( 
            IPSFactoryBuffer    * This);
        
        HRESULT ( __stdcall    *CreateProxy )( 
            IPSFactoryBuffer    * This,
            /* [in] */ IUnknown    *pUnkOuter,
            /* [in] */  const IID &  riid,
            /* [out] */ IRpcProxyBuffer    *   *ppProxy,
            /* [out] */ void    *   *ppv);
        
        HRESULT ( __stdcall    *CreateStub )( 
            IPSFactoryBuffer    * This,
            /* [in] */  const IID &  riid,
            /* [unique][in] */ IUnknown    *pUnkServer,
            /* [out] */ IRpcStubBuffer    *   *ppStub);
        
    } IPSFactoryBufferVtbl;

     struct  IPSFactoryBuffer
    {
           struct IPSFactoryBufferVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 7357 "C:\WATCOM\H\NT\objidl.h"


/* C style interface */



HRESULT __stdcall IPSFactoryBuffer_CreateProxy_Proxy( 
    IPSFactoryBuffer    * This,
    /* [in] */ IUnknown    *pUnkOuter,
    /* [in] */  const IID &  riid,
    /* [out] */ IRpcProxyBuffer    *   *ppProxy,
    /* [out] */ void    *   *ppv);


void  __stdcall  IPSFactoryBuffer_CreateProxy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPSFactoryBuffer_CreateStub_Proxy( 
    IPSFactoryBuffer    * This,
    /* [in] */  const IID &  riid,
    /* [unique][in] */ IUnknown    *pUnkServer,
    /* [out] */ IRpcStubBuffer    *   *ppStub);


void  __stdcall  IPSFactoryBuffer_CreateStub_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IPSFactoryBuffer_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */


void  __stdcall  SNB_to_xmit( SNB    *, RemSNB     *    * );
void  __stdcall  SNB_from_xmit( RemSNB     *, SNB    * );
void  __stdcall  SNB_free_inst( SNB    * );
void  __stdcall  SNB_free_xmit( RemSNB     * );

/* [local] */ HRESULT __stdcall IEnumUnknown_Next_Proxy( 
    IEnumUnknown    * This,
    /* [in] */ ULONG celt,
    /* [out] */ IUnknown    *   *rgelt,
    /* [out] */ ULONG    *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumUnknown_Next_Stub( 
    IEnumUnknown    * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IUnknown    *   *rgelt,
    /* [out] */ ULONG    *pceltFetched);

/* [local] */ HRESULT __stdcall IEnumMoniker_Next_Proxy( 
    IEnumMoniker    * This,
    /* [in] */ ULONG celt,
    /* [out] */ IMoniker    *   *rgelt,
    /* [out] */ ULONG    *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumMoniker_Next_Stub( 
    IEnumMoniker    * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IMoniker    *   *rgelt,
    /* [out] */ ULONG    *pceltFetched);

/* [local] */ HRESULT __stdcall IMoniker_BindToObject_Proxy( 
    IMoniker    * This,
    /* [unique][in] */ IBindCtx    *pbc,
    /* [unique][in] */ IMoniker    *pmkToLeft,
    /* [in] */  const IID &  riidResult,
    /* [out] */ void    *   *ppvResult);


/* [call_as] */ HRESULT __stdcall IMoniker_BindToObject_Stub( 
    IMoniker    * This,
    /* [unique][in] */ IBindCtx    *pbc,
    /* [unique][in] */ IMoniker    *pmkToLeft,
    /* [in] */  const IID &  riidResult,
    /* [iid_is][out] */ IUnknown    *   *ppvResult);

/* [local] */ HRESULT __stdcall IMoniker_BindToStorage_Proxy( 
    IMoniker    * This,
    /* [unique][in] */ IBindCtx    *pbc,
    /* [unique][in] */ IMoniker    *pmkToLeft,
    /* [in] */  const IID &  riid,
    /* [out] */ void    *   *ppvObj);


/* [call_as] */ HRESULT __stdcall IMoniker_BindToStorage_Stub( 
    IMoniker    * This,
    /* [unique][in] */ IBindCtx    *pbc,
    /* [unique][in] */ IMoniker    *pmkToLeft,
    /* [in] */  const IID &  riid,
    /* [iid_is][out] */ IUnknown    *   *ppvObj);

/* [local] */ HRESULT __stdcall IEnumString_Next_Proxy( 
    IEnumString    * This,
    /* [in] */ ULONG celt,
    /* [out] */ LPOLESTR    *rgelt,
    /* [out] */ ULONG    *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumString_Next_Stub( 
    IEnumString    * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ LPOLESTR    *rgelt,
    /* [out] */ ULONG    *pceltFetched);

/* [local] */ HRESULT __stdcall IStream_Read_Proxy( 
    IStream    * This,
    /* [out] */ void    *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG    *pcbRead);


/* [call_as] */ HRESULT __stdcall IStream_Read_Stub( 
    IStream    * This,
    /* [length_is][size_is][out] */ byte    *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG    *pcbRead);

/* [local] */ HRESULT __stdcall IStream_Write_Proxy( 
    IStream    * This,
    /* [size_is][in] */ const void    *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG    *pcbWritten);


/* [call_as] */ HRESULT __stdcall IStream_Write_Stub( 
    IStream    * This,
    /* [size_is][in] */ const byte    *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG    *pcbWritten);

/* [local] */ HRESULT __stdcall IStream_Seek_Proxy( 
    IStream    * This,
    /* [in] */ LARGE_INTEGER dlibMove,
    /* [in] */ DWORD dwOrigin,
    /* [out] */ ULARGE_INTEGER    *plibNewPosition);


/* [call_as] */ HRESULT __stdcall IStream_Seek_Stub( 
    IStream    * This,
    /* [in] */ LARGE_INTEGER dlibMove,
    /* [in] */ DWORD dwOrigin,
    /* [out] */ ULARGE_INTEGER    *plibNewPosition);

/* [local] */ HRESULT __stdcall IStream_CopyTo_Proxy( 
    IStream    * This,
    /* [unique][in] */ IStream    *pstm,
    /* [in] */ ULARGE_INTEGER cb,
    /* [out] */ ULARGE_INTEGER    *pcbRead,
    /* [out] */ ULARGE_INTEGER    *pcbWritten);


/* [call_as] */ HRESULT __stdcall IStream_CopyTo_Stub( 
    IStream    * This,
    /* [unique][in] */ IStream    *pstm,
    /* [in] */ ULARGE_INTEGER cb,
    /* [out] */ ULARGE_INTEGER    *pcbRead,
    /* [out] */ ULARGE_INTEGER    *pcbWritten);

/* [local] */ HRESULT __stdcall IEnumSTATSTG_Next_Proxy( 
    IEnumSTATSTG    * This,
    /* [in] */ ULONG celt,
    /* [in] */ STATSTG    *rgelt,
    /* [out] */ ULONG    *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumSTATSTG_Next_Stub( 
    IEnumSTATSTG    * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATSTG    *rgelt,
    /* [out] */ ULONG    *pceltFetched);

/* [local] */ HRESULT __stdcall IStorage_OpenStream_Proxy( 
    IStorage    * This,
    /* [string][in] */ const OLECHAR    *pwcsName,
    /* [unique][in] */ void    *reserved1,
    /* [in] */ DWORD grfMode,
    /* [in] */ DWORD reserved2,
    /* [out] */ IStream    *   *ppstm);


/* [call_as] */ HRESULT __stdcall IStorage_OpenStream_Stub( 
    IStorage    * This,
    /* [string][in] */ const OLECHAR    *pwcsName,
    /* [in] */ unsigned long cbReserved1,
    /* [size_is][unique][in] */ byte    *reserved1,
    /* [in] */ DWORD grfMode,
    /* [in] */ DWORD reserved2,
    /* [out] */ IStream    *   *ppstm);

/* [local] */ HRESULT __stdcall IStorage_EnumElements_Proxy( 
    IStorage    * This,
    /* [in] */ DWORD reserved1,
    /* [size_is][unique][in] */ void    *reserved2,
    /* [in] */ DWORD reserved3,
    /* [out] */ IEnumSTATSTG    *   *ppenum);


/* [call_as] */ HRESULT __stdcall IStorage_EnumElements_Stub( 
    IStorage    * This,
    /* [in] */ DWORD reserved1,
    /* [in] */ unsigned long cbReserved2,
    /* [size_is][unique][in] */ byte    *reserved2,
    /* [in] */ DWORD reserved3,
    /* [out] */ IEnumSTATSTG    *   *ppenum);

/* [local] */ HRESULT __stdcall ILockBytes_ReadAt_Proxy( 
    ILockBytes    * This,
    /* [in] */ ULARGE_INTEGER ulOffset,
    /* [in] */ void    *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG    *pcbRead);


/* [call_as] */ HRESULT __stdcall ILockBytes_ReadAt_Stub( 
    ILockBytes    * This,
    /* [in] */ ULARGE_INTEGER ulOffset,
    /* [length_is][size_is][out] */ byte    *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG    *pcbRead);

/* [local] */ HRESULT __stdcall ILockBytes_WriteAt_Proxy( 
    ILockBytes    * This,
    /* [in] */ ULARGE_INTEGER ulOffset,
    /* [in] */ const void    *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG    *pcbWritten);


/* [call_as] */ HRESULT __stdcall ILockBytes_WriteAt_Stub( 
    ILockBytes    * This,
    /* [in] */ ULARGE_INTEGER ulOffset,
    /* [size_is][in] */ const byte    *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG    *pcbWritten);

/* [local] */ HRESULT __stdcall IEnumFORMATETC_Next_Proxy( 
    IEnumFORMATETC    * This,
    /* [in] */ ULONG celt,
    /* [out] */ FORMATETC    *rgelt,
    /* [out] */ ULONG    *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumFORMATETC_Next_Stub( 
    IEnumFORMATETC    * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ FORMATETC    *rgelt,
    /* [out] */ ULONG    *pceltFetched);

/* [local] */ HRESULT __stdcall IEnumSTATDATA_Next_Proxy( 
    IEnumSTATDATA    * This,
    /* [in] */ ULONG celt,
    STATDATA    *rgelt,
    /* [out] */ ULONG    *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumSTATDATA_Next_Stub( 
    IEnumSTATDATA    * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATDATA    *rgelt,
    /* [out] */ ULONG    *pceltFetched);

/* [local] */ void __stdcall IAdviseSink_OnDataChange_Proxy( 
    IAdviseSink    * This,
    /* [unique][in] */ FORMATETC    *pFormatetc,
    /* [unique][in] */ STGMEDIUM    *pStgmed);


/* [async][call_as] */ void __stdcall IAdviseSink_OnDataChange_Stub( 
    IAdviseSink    * This,
    /* [unique][in] */ FORMATETC    *pFormatetc,
    /* [unique][in] */ RemSTGMEDIUM    *pStgmed);

/* [local] */ void __stdcall IAdviseSink_OnViewChange_Proxy( 
    IAdviseSink    * This,
    /* [in] */ DWORD dwAspect,
    /* [in] */ LONG lindex);


/* [async][call_as] */ void __stdcall IAdviseSink_OnViewChange_Stub( 
    IAdviseSink    * This,
    /* [in] */ DWORD dwAspect,
    /* [in] */ LONG lindex);

/* [local] */ void __stdcall IAdviseSink_OnRename_Proxy( 
    IAdviseSink    * This,
    /* [in] */ IMoniker    *pmk);


/* [async][call_as] */ void __stdcall IAdviseSink_OnRename_Stub( 
    IAdviseSink    * This,
    /* [in] */ IMoniker    *pmk);

/* [local] */ void __stdcall IAdviseSink_OnSave_Proxy( 
    IAdviseSink    * This);


/* [async][call_as] */ void __stdcall IAdviseSink_OnSave_Stub( 
    IAdviseSink    * This);

/* [local] */ void __stdcall IAdviseSink_OnClose_Proxy( 
    IAdviseSink    * This);


/* [call_as] */ HRESULT __stdcall IAdviseSink_OnClose_Stub( 
    IAdviseSink    * This);

/* [local] */ void __stdcall IAdviseSink2_OnLinkSrcChange_Proxy( 
    IAdviseSink2    * This,
    /* [unique][in] */ IMoniker    *pmk);


/* [async][call_as] */ void __stdcall IAdviseSink2_OnLinkSrcChange_Stub( 
    IAdviseSink2    * This,
    /* [unique][in] */ IMoniker    *pmk);

/* [local] */ HRESULT __stdcall IDataObject_GetData_Proxy( 
    IDataObject    * This,
    /* [unique][in] */ FORMATETC    *pformatetcIn,
    /* [out] */ STGMEDIUM    *pmedium);


/* [call_as] */ HRESULT __stdcall IDataObject_GetData_Stub( 
    IDataObject    * This,
    /* [unique][in] */ FORMATETC    *pformatetcIn,
    /* [out] */ RemSTGMEDIUM    *   *ppRemoteMedium);

/* [local] */ HRESULT __stdcall IDataObject_GetDataHere_Proxy( 
    IDataObject    * This,
    /* [unique][in] */ FORMATETC    *pformatetc,
    /* [out][in] */ STGMEDIUM    *pmedium);


/* [call_as] */ HRESULT __stdcall IDataObject_GetDataHere_Stub( 
    IDataObject    * This,
    /* [unique][in] */ FORMATETC    *pformatetc,
    /* [out][in] */ RemSTGMEDIUM    *   *ppRemoteMedium);

/* [local] */ HRESULT __stdcall IDataObject_SetData_Proxy( 
    IDataObject    * This,
    /* [unique][in] */ FORMATETC    *pformatetc,
    /* [unique][in] */ STGMEDIUM    *pmedium,
    /* [in] */ BOOL fRelease);


/* [call_as] */ HRESULT __stdcall IDataObject_SetData_Stub( 
    IDataObject    * This,
    /* [unique][in] */ FORMATETC    *pformatetc,
    /* [unique][in] */ RemSTGMEDIUM    *pmedium,
    /* [in] */ BOOL fRelease);



/* end of Additional Prototypes */


}



#line 305 "C:\WATCOM\H\NT\objbase.h"



// macros to define byte pattern for a GUID.
//      Example: DEFINE_GUID(GUID_XXX, a, b, c, ...);
//
// Each dll/exe must initialize the GUIDs once.  This is done in one of
// two ways.  If you are not using precompiled headers for the file(s) which
// initializes the GUIDs, define INITGUID before including objbase.h.  This
// is how OLE builds the initialized versions of the GUIDs which are included
// in ole2.lib.  The GUIDs in ole2.lib are all defined in the same text
// segment GUID_TEXT.
//
// The alternative (which some versions of the compiler don't handle properly;
// they wind up with the initialized GUIDs in a data, not a text segment),
// is to use a precompiled version of objbase.h and then include initguid.h
// after objbase.h followed by one or more of the guid defintion files.




// INITGUID#line 332 "C:\WATCOM\H\NT\objbase.h"





inline BOOL IsEqualGUID( const GUID &  rguid1,  const GUID &  rguid2)
{
    return !memcmp(&rguid1, &rguid2, sizeof(GUID));
}
//  __cplusplus#line 344 "C:\WATCOM\H\NT\objbase.h"






// because GUID is defined elsewhere in WIN32 land, the operator == and !=
// are moved outside the class to global scope.

inline BOOL operator==(const GUID& guidOne, const GUID& guidOther)
{

    return !memcmp(&guidOne,&guidOther,sizeof(GUID));
#line 360 "C:\WATCOM\H\NT\objbase.h"
}

inline BOOL operator!=(const GUID& guidOne, const GUID& guidOther)
{
    return !(guidOne == guidOther);
}

// __cpluscplus



#line 1 "C:\WATCOM\H\NT\cguid.h"
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cguid.h
//
//--------------------------------------------------------------------------





extern "C" {


extern const IID __cdecl GUID_NULL;
extern const IID __cdecl IID_IRpcChannel;
extern const IID __cdecl IID_IRpcStub;
extern const IID __cdecl IID_IStubManager;
extern const IID __cdecl IID_IRpcProxy;
extern const IID __cdecl IID_IProxyManager;
extern const IID __cdecl IID_IPSFactory;
extern const IID __cdecl IID_IInternalMoniker;
extern const IID __cdecl IID_IDfReserved1;
extern const IID __cdecl IID_IDfReserved2;
extern const IID __cdecl IID_IDfReserved3;
extern const CLSID __cdecl CLSID_StdMarshal;
extern const IID __cdecl IID_IStub;
extern const IID __cdecl IID_IProxy;
extern const IID __cdecl IID_IEnumGeneric;
extern const IID __cdecl IID_IEnumHolder;
extern const IID __cdecl IID_IEnumCallback;
extern const IID __cdecl IID_IOleManager;
extern const IID __cdecl IID_IOlePresObj;
extern const IID __cdecl IID_IDebug;
extern const IID __cdecl IID_IDebugStream;
extern const CLSID __cdecl CLSID_PSGenObject;
extern const CLSID __cdecl CLSID_PSClientSite;
extern const CLSID __cdecl CLSID_PSClassObject;
extern const CLSID __cdecl CLSID_PSInPlaceActive;
extern const CLSID __cdecl CLSID_PSInPlaceFrame;
extern const CLSID __cdecl CLSID_PSDragDrop;
extern const CLSID __cdecl CLSID_PSBindCtx;
extern const CLSID __cdecl CLSID_PSEnumerators;
extern const CLSID __cdecl CLSID_StaticMetafile;
extern const CLSID __cdecl CLSID_StaticDib;
extern const CLSID __cdecl CID_CDfsVolume;

//********************************************
//
// CD Forms CLSIDs
//
//********************************************

//
// Form Kernel objects
//
extern const CLSID __cdecl CLSID_CCDFormKrnl;
extern const CLSID __cdecl CLSID_CCDPropertyPage;
extern const CLSID __cdecl CLSID_CCDFormDialog;

//
// Control objects
//
extern const CLSID __cdecl CLSID_CCDCommandButton;
extern const CLSID __cdecl CLSID_CCDComboBox;
extern const CLSID __cdecl CLSID_CCDTextBox;
extern const CLSID __cdecl CLSID_CCDCheckBox;
extern const CLSID __cdecl CLSID_CCDLabel;
extern const CLSID __cdecl CLSID_CCDOptionButton;
extern const CLSID __cdecl CLSID_CCDListBox;
extern const CLSID __cdecl CLSID_CCDScrollBar;
extern const CLSID __cdecl CLSID_CCDGroupBox;

//
// Property Pages
//
extern const CLSID __cdecl CLSID_CCDGeneralPropertyPage;
extern const CLSID __cdecl CLSID_CCDGenericPropertyPage;
extern const CLSID __cdecl CLSID_CCDFontPropertyPage;
extern const CLSID __cdecl CLSID_CCDColorPropertyPage;
extern const CLSID __cdecl CLSID_CCDLabelPropertyPage;
extern const CLSID __cdecl CLSID_CCDCheckBoxPropertyPage;
extern const CLSID __cdecl CLSID_CCDTextBoxPropertyPage;
extern const CLSID __cdecl CLSID_CCDOptionButtonPropertyPage;
extern const CLSID __cdecl CLSID_CCDListBoxPropertyPage;
extern const CLSID __cdecl CLSID_CCDCommandButtonPropertyPage;
extern const CLSID __cdecl CLSID_CCDComboBoxPropertyPage;
extern const CLSID __cdecl CLSID_CCDScrollBarPropertyPage;
extern const CLSID __cdecl CLSID_CCDGroupBoxPropertyPage;
extern const CLSID __cdecl CLSID_CCDXObjectPropertyPage;

extern const CLSID __cdecl CLSID_CStdPropertyFrame;

extern const CLSID __cdecl CLSID_CFormPropertyPage;
extern const CLSID __cdecl CLSID_CGridPropertyPage;

extern const CLSID __cdecl CLSID_CWSJArticlePage;
extern const CLSID __cdecl CLSID_CSystemPage;

extern const CLSID __cdecl CLSID_IdentityUnmarshal;
extern const CLSID __cdecl CLSID_InProcFreeMarshaler;

extern const CLSID __cdecl CLSID_Picture_Metafile;
extern const CLSID __cdecl CLSID_Picture_EnhMetafile;
extern const CLSID __cdecl CLSID_Picture_Dib;

//
// Enumerations
//
extern const GUID __cdecl GUID_TRISTATE;


}



// __CGUID_H__
#line 371 "C:\WATCOM\H\NT\objbase.h"





/****** STD Object API Prototypes *****************************************/

 extern "C" __declspec(dllimport) DWORD __stdcall  CoBuildVersion(  void  );

/* init/uninit */

 extern "C" __declspec(dllimport) HRESULT __stdcall   CoInitialize(LPVOID pvReserved);
 extern "C" __declspec(dllimport) void __stdcall   CoUninitialize(void);
 extern "C" __declspec(dllimport) HRESULT __stdcall   CoGetMalloc(DWORD dwMemContext, LPMALLOC   * ppMalloc);
 extern "C" __declspec(dllimport) DWORD __stdcall  CoGetCurrentProcess(void);
 extern "C" __declspec(dllimport) HRESULT __stdcall   CoRegisterMallocSpy(LPMALLOCSPY pMallocSpy);
 extern "C" __declspec(dllimport) HRESULT __stdcall   CoRevokeMallocSpy(void);
 extern "C" __declspec(dllimport) HRESULT __stdcall   CoCreateStandardMalloc(DWORD memctx, IMalloc   *   * ppMalloc);

#line 396 "C:\WATCOM\H\NT\objbase.h"

/* register/revoke/get class objects */

 extern "C" __declspec(dllimport) HRESULT __stdcall   CoGetClassObject( const CLSID &  rclsid, DWORD dwClsContext, LPVOID pvReserved,
                     const IID &  riid, LPVOID   * ppv);
 extern "C" __declspec(dllimport) HRESULT __stdcall   CoRegisterClassObject( const CLSID &  rclsid, LPUNKNOWN pUnk,
                    DWORD dwClsContext, DWORD flags, LPDWORD lpdwRegister);
 extern "C" __declspec(dllimport) HRESULT __stdcall   CoRevokeClassObject(DWORD dwRegister);


/* marshaling interface pointers */

 extern "C" __declspec(dllimport) HRESULT __stdcall  CoGetMarshalSizeMax(ULONG *pulSize,  const IID &  riid, LPUNKNOWN pUnk,
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags);
 extern "C" __declspec(dllimport) HRESULT __stdcall  CoMarshalInterface(LPSTREAM pStm,  const IID &  riid, LPUNKNOWN pUnk,
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags);
 extern "C" __declspec(dllimport) HRESULT __stdcall  CoUnmarshalInterface(LPSTREAM pStm,  const IID &  riid, LPVOID   * ppv);
 extern "C" __declspec(dllimport) HRESULT __stdcall  CoMarshalHresult(LPSTREAM pstm, HRESULT hresult);
 extern "C" __declspec(dllimport) HRESULT __stdcall  CoUnmarshalHresult(LPSTREAM pstm, HRESULT    * phresult);
 extern "C" __declspec(dllimport) HRESULT __stdcall  CoReleaseMarshalData(LPSTREAM pStm);
 extern "C" __declspec(dllimport) HRESULT __stdcall  CoDisconnectObject(LPUNKNOWN pUnk, DWORD dwReserved);
 extern "C" __declspec(dllimport) HRESULT __stdcall  CoLockObjectExternal(LPUNKNOWN pUnk, BOOL fLock, BOOL fLastUnlockReleases);
 extern "C" __declspec(dllimport) HRESULT __stdcall  CoGetStandardMarshal( const IID &  riid, LPUNKNOWN pUnk,
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags,
                    LPMARSHAL   * ppMarshal);

 extern "C" __declspec(dllimport) BOOL __stdcall  CoIsHandlerConnected(LPUNKNOWN pUnk);
 extern "C" __declspec(dllimport) BOOL __stdcall  CoHasStrongExternalConnections(LPUNKNOWN pUnk);

// Apartment model inter-thread interface passing helpers
 extern "C" __declspec(dllimport) HRESULT __stdcall  CoMarshalInterThreadInterfaceInStream( const IID &  riid, LPUNKNOWN pUnk,
                    LPSTREAM *ppStm);

 extern "C" __declspec(dllimport) HRESULT __stdcall  CoGetInterfaceAndReleaseStream(LPSTREAM pStm,  const IID &  iid,
                    LPVOID   * ppv);

 extern "C" __declspec(dllimport) HRESULT __stdcall  CoCreateFreeThreadedMarshaler(LPUNKNOWN  punkOuter,
                    LPUNKNOWN *ppunkMarshal);

/* dll loading helpers; keeps track of ref counts and unloads all on exit */

 extern "C" __declspec(dllimport) HINSTANCE __stdcall  CoLoadLibrary(LPOLESTR lpszLibName, BOOL bAutoFree);
 extern "C" __declspec(dllimport) void __stdcall  CoFreeLibrary(HINSTANCE hInst);
 extern "C" __declspec(dllimport) void __stdcall  CoFreeAllLibraries(void);
 extern "C" __declspec(dllimport) void __stdcall  CoFreeUnusedLibraries(void);


/* helper for creating instances */

 extern "C" __declspec(dllimport) HRESULT __stdcall  CoCreateInstance( const CLSID &  rclsid, LPUNKNOWN pUnkOuter,
                    DWORD dwClsContext,  const IID &  riid, LPVOID   * ppv);


/* other helpers */

 extern "C" __declspec(dllimport) HRESULT __stdcall  StringFromCLSID( const CLSID &  rclsid, LPOLESTR   * lplpsz);
 extern "C" __declspec(dllimport) HRESULT __stdcall  CLSIDFromString(LPOLESTR lpsz, LPCLSID pclsid);
 extern "C" __declspec(dllimport) HRESULT __stdcall  StringFromIID( const IID &  rclsid, LPOLESTR   * lplpsz);
 extern "C" __declspec(dllimport) HRESULT __stdcall  IIDFromString(LPOLESTR lpsz, LPIID lpiid);
 extern "C" __declspec(dllimport) BOOL __stdcall  CoIsOle1Class( const CLSID &  rclsid);
 extern "C" __declspec(dllimport) HRESULT __stdcall  ProgIDFromCLSID ( const CLSID &  clsid, LPOLESTR   * lplpszProgID);
 extern "C" __declspec(dllimport) HRESULT __stdcall  CLSIDFromProgID (LPCOLESTR lpszProgID, LPCLSID lpclsid);
 extern "C" __declspec(dllimport) int __stdcall  StringFromGUID2( const GUID &  rguid, LPOLESTR lpsz, int cbMax);

 extern "C" __declspec(dllimport) HRESULT __stdcall  CoCreateGuid(GUID    *pguid);

 extern "C" __declspec(dllimport) BOOL __stdcall  CoFileTimeToDosDateTime(
                 FILETIME   * lpFileTime, LPWORD lpDosDate, LPWORD lpDosTime);
 extern "C" __declspec(dllimport) BOOL __stdcall  CoDosDateTimeToFileTime(
                       WORD nDosDate, WORD nDosTime, FILETIME   * lpFileTime);
 extern "C" __declspec(dllimport) HRESULT __stdcall   CoFileTimeNow( FILETIME   * lpFileTime );


 extern "C" __declspec(dllimport) HRESULT __stdcall  CoRegisterMessageFilter( LPMESSAGEFILTER lpMessageFilter,
                                LPMESSAGEFILTER   * lplpMessageFilter );


/* TreatAs APIS */

 extern "C" __declspec(dllimport) HRESULT __stdcall  CoGetTreatAsClass( const CLSID &  clsidOld, LPCLSID pClsidNew);
 extern "C" __declspec(dllimport) HRESULT __stdcall  CoTreatAsClass( const CLSID &  clsidOld,  const CLSID &  clsidNew);


/* the server dlls must define their DllGetClassObject and DllCanUnloadNow
 * to match these; the typedefs are located here to ensure all are changed at
 * the same time.
 */

#line 487 "C:\WATCOM\H\NT\objbase.h"
typedef HRESULT ( __stdcall  * LPFNGETCLASSOBJECT) ( const CLSID & ,  const IID & , LPVOID *);


#line 493 "C:\WATCOM\H\NT\objbase.h"
typedef HRESULT ( __stdcall  * LPFNCANUNLOADNOW)(void);


 extern "C" HRESULT __stdcall   DllGetClassObject( const CLSID &  rclsid,  const IID &  riid, LPVOID   * ppv);

 extern "C" HRESULT __stdcall   DllCanUnloadNow(void);


/****** Default Memory Allocation ******************************************/
 extern "C" __declspec(dllimport) LPVOID __stdcall  CoTaskMemAlloc(ULONG cb);
 extern "C" __declspec(dllimport) LPVOID __stdcall  CoTaskMemRealloc(LPVOID pv, ULONG cb);
 extern "C" __declspec(dllimport) void __stdcall    CoTaskMemFree(LPVOID pv);

/****** DV APIs ***********************************************************/


 extern "C" __declspec(dllimport) HRESULT __stdcall  CreateDataAdviseHolder(LPDATAADVISEHOLDER   * ppDAHolder);

 extern "C" __declspec(dllimport) HRESULT __stdcall  CreateDataCache(LPUNKNOWN pUnkOuter,  const CLSID &  rclsid,
                                         const IID &  iid, LPVOID   * ppv);




/****** Storage API Prototypes ********************************************/


 extern "C" __declspec(dllimport) HRESULT __stdcall  StgCreateDocfile(const OLECHAR   * pwcsName,
            DWORD grfMode,
            DWORD reserved,
            IStorage    *    *ppstgOpen);

 extern "C" __declspec(dllimport) HRESULT __stdcall  StgCreateDocfileOnILockBytes(ILockBytes    *plkbyt,
                    DWORD grfMode,
                    DWORD reserved,
                    IStorage    *    *ppstgOpen);

 extern "C" __declspec(dllimport) HRESULT __stdcall  StgOpenStorage(const OLECHAR   * pwcsName,
              IStorage    *pstgPriority,
              DWORD grfMode,
              SNB snbExclude,
              DWORD reserved,
              IStorage    *    *ppstgOpen);
 extern "C" __declspec(dllimport) HRESULT __stdcall  StgOpenStorageOnILockBytes(ILockBytes    *plkbyt,
                  IStorage    *pstgPriority,
                  DWORD grfMode,
                  SNB snbExclude,
                  DWORD reserved,
                  IStorage    *    *ppstgOpen);

 extern "C" __declspec(dllimport) HRESULT __stdcall  StgIsStorageFile(const OLECHAR   * pwcsName);
 extern "C" __declspec(dllimport) HRESULT __stdcall  StgIsStorageILockBytes(ILockBytes   * plkbyt);

 extern "C" __declspec(dllimport) HRESULT __stdcall  StgSetTimes(OLECHAR const   * lpszName,
                   FILETIME const   * pctime,
                   FILETIME const   * patime,
                   FILETIME const   * pmtime);


//
//  Moniker APIs
//

 extern "C" __declspec(dllimport) HRESULT __stdcall   BindMoniker(LPMONIKER pmk, DWORD grfOpt,  const IID &  iidResult, LPVOID   * ppvResult);
 extern "C" __declspec(dllimport) HRESULT __stdcall   MkParseDisplayName(LPBC pbc, LPCOLESTR szUserName,
                ULONG    * pchEaten, LPMONIKER    * ppmk);
 extern "C" __declspec(dllimport) HRESULT __stdcall   MonikerRelativePathTo(LPMONIKER pmkSrc, LPMONIKER pmkDest, LPMONIKER
                  * ppmkRelPath, BOOL dwReserved);
 extern "C" __declspec(dllimport) HRESULT __stdcall   MonikerCommonPrefixWith(LPMONIKER pmkThis, LPMONIKER pmkOther,
                LPMONIKER   * ppmkCommon);
 extern "C" __declspec(dllimport) HRESULT __stdcall   CreateBindCtx(DWORD reserved, LPBC   * ppbc);
 extern "C" __declspec(dllimport) HRESULT __stdcall   CreateGenericComposite(LPMONIKER pmkFirst, LPMONIKER pmkRest,
    LPMONIKER   * ppmkComposite);
 extern "C" __declspec(dllimport) HRESULT __stdcall   GetClassFile (LPCOLESTR szFilename, CLSID   * pclsid);

 extern "C" __declspec(dllimport) HRESULT __stdcall   CreateFileMoniker(LPCOLESTR lpszPathName, LPMONIKER   * ppmk);

 extern "C" __declspec(dllimport) HRESULT __stdcall   CreateItemMoniker(LPCOLESTR lpszDelim, LPCOLESTR lpszItem,
    LPMONIKER   * ppmk);
 extern "C" __declspec(dllimport) HRESULT __stdcall   CreateAntiMoniker(LPMONIKER   * ppmk);
 extern "C" __declspec(dllimport) HRESULT __stdcall   CreatePointerMoniker(LPUNKNOWN punk, LPMONIKER   * ppmk);

 extern "C" __declspec(dllimport) HRESULT __stdcall   GetRunningObjectTable( DWORD reserved, LPRUNNINGOBJECTTABLE   * pprot);


#line 1 "C:\WATCOM\H\NT\poppack.h"
/*++

Copyright (c) 1990,95  Microsoft Corporation

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)
#line 33 "C:\WATCOM\H\NT\poppack.h"
#line 36 "C:\WATCOM\H\NT\poppack.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 578 "C:\WATCOM\H\NT\objbase.h"

// RC_INVOKED

// __OBJBASE_H__
#line 28 "C:\WATCOM\H\NT\ole2.h"

#line 1 "C:\WATCOM\H\NT\oleauto.h"
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       oleauto.h
//
//  Contents:   Defines the Ole Automation interfaces and APIs.
//
//  Interfaces:
//      IDispatch;
//      ITypeInfo;
//      ITypeLib;
//      ITypeComp;
//      ICreateTypeInfo;
//      ICreateTypeLib;
//      IErrorInfo;
//      ICreateErrorInfo;
//      ISupportErrorInfo;
//
//  Functions:  SysAllocString         BSTR API
//      SysReAllocString
//      SysAllocStringLen
//      SysReAllocStringLen
//      SysFreeString
//      SysStringLen
//      DosDateTimeToVariantTime    Time API
//      VariantTimeToDosDateTime
//      SafeArrayCreate         Safe Array API
//      SafeArrayDestroy
//      SafeArrayGetDim
//      SafeArrayGetElemsize
//      SafeArrayGetUBound
//      SafeArrayGetLBound
//      SafeArrayLock
//      SafeArrayUnlock
//      SafeArrayAccessData
//      SafeArrayUnaccessData
//      SafeArrayGetElement
//      SafeArrayPutElement
//      SafeArrayCopy
//      VariantInit         Variant API
//      VariantClear
//      VariantCopy
//      VariantCopyInd
//      VariantChangeType
//      LHashValOfName          TypeInfo API
//      LoadTypeLib
//      LoadRegTypeLib
//      RegisterTypeLib
//      DeregisterTypeLib
//      CreateTypeLib
//      DispGetParam            Dispatch API
//      DispGetIDsOfNames
//      DispInvoke
//      CreateDispTypeInfo
//      CreateStdDispatch
//      RegisterActiveObject        Active Object Registration API
//      RevokeActiveObject
//      GetActiveObject
//      OaBuildVersion
//
//----------------------------------------------------------------------------




// Set packing to 8 for ISV, and Win95 support

#line 1 "C:\WATCOM\H\NT\pshpack8.h"
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pshpack8.h

Abstract:

    This file turns 8 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push)

#pragma pack(8)
#line 32 "C:\WATCOM\H\NT\pshpack8.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 70 "C:\WATCOM\H\NT\oleauto.h"

// RC_INVOKED

//  Definition of the OLE Automation APIs, and macros.

#line 79 "C:\WATCOM\H\NT\oleauto.h"








/* if not already picked up from olenls.h */
#line 92 "C:\WATCOM\H\NT\oleauto.h"

/* pull in the MIDL generated header */
#line 1 "C:\WATCOM\H\NT\oaidl.h"
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Fri Apr 28 07:02:38 1995
 */
//@@MIDL_FILE_HEADING(  )
#line 1 "C:\WATCOM\H\NT\rpc.h"
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    rpc.h

Abstract:

    Master include file for RPC applications.

--*/


#line 1 "C:\WATCOM\H\NT\windows.h"
/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) 1985-1995, Microsoft Corporation

Module Name:


    windows.h

Abstract:

    Master include file for Windows applications.

--*/

/* _WINDOWS_ */#line 216 "C:\WATCOM\H\NT\windows.h"
#line 16 "C:\WATCOM\H\NT\rpc.h"

// RPC_NO_WINDOWS_H

// __RPC_H__#line 121 "C:\WATCOM\H\NT\rpc.h"

#line 8 "C:\WATCOM\H\NT\oaidl.h"

#line 1 "C:\WATCOM\H\NT\rpcndr.h"
/*++

Copyright (c) 1992-1995 Microsoft Corporation

Module Name:

    rpcndr.h

Abstract:

    Definitions for stub data structures and prototypes of helper functions.

Environment:

    DOS, Win 3.X, and Win/NT.

--*/

/* __RPCNDR_H__ */#line 2263 "C:\WATCOM\H\NT\rpcndr.h"
#line 9 "C:\WATCOM\H\NT\oaidl.h"


#line 1 "C:\WATCOM\H\NT\windows.h"
/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) 1985-1995, Microsoft Corporation

Module Name:


    windows.h

Abstract:

    Master include file for Windows applications.

--*/

/* _WINDOWS_ */#line 216 "C:\WATCOM\H\NT\windows.h"
#line 11 "C:\WATCOM\H\NT\oaidl.h"

#line 1 "C:\WATCOM\H\NT\ole2.h"
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       OLE2.h
//  Contents:   Main OLE2 header; Defines Linking and Emmebbeding interfaces, and API's.
//              Also includes .h files for the compobj, and oleauto  subcomponents.
//
//----------------------------------------------------------------------------
// __OLE2_H__#line 305 "C:\WATCOM\H\NT\ole2.h"

#line 12 "C:\WATCOM\H\NT\oaidl.h"

/*COM_NO_WINDOWS_H*/





extern "C"{


/* Forward Declarations */ 



typedef  struct  ICreateTypeInfo ICreateTypeInfo;
/* __ICreateTypeInfo_FWD_DEFINED__ */




typedef  struct  ICreateTypeLib ICreateTypeLib;
/* __ICreateTypeLib_FWD_DEFINED__ */




typedef  struct  IDispatch IDispatch;
/* __IDispatch_FWD_DEFINED__ */




typedef  struct  IEnumVARIANT IEnumVARIANT;
/* __IEnumVARIANT_FWD_DEFINED__ */




typedef  struct  ITypeComp ITypeComp;
/* __ITypeComp_FWD_DEFINED__ */




typedef  struct  ITypeInfo ITypeInfo;
/* __ITypeInfo_FWD_DEFINED__ */




typedef  struct  ITypeLib ITypeLib;
/* __ITypeLib_FWD_DEFINED__ */




typedef  struct  IErrorInfo IErrorInfo;
/* __IErrorInfo_FWD_DEFINED__ */




typedef  struct  ICreateErrorInfo ICreateErrorInfo;
/* __ICreateErrorInfo_FWD_DEFINED__ */




typedef  struct  ISupportErrorInfo ISupportErrorInfo;
/* __ISupportErrorInfo_FWD_DEFINED__ */


/* header files for imported files */
#line 1 "C:\WATCOM\H\NT\objidl.h"
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Fri Apr 28 07:02:32 1995
 */
//@@MIDL_FILE_HEADING(  )
#line 1 "C:\WATCOM\H\NT\rpc.h"
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    rpc.h

Abstract:

    Master include file for RPC applications.

--*/


#line 1 "C:\WATCOM\H\NT\windows.h"
/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) 1985-1995, Microsoft Corporation

Module Name:


    windows.h

Abstract:

    Master include file for Windows applications.

--*/

/* _WINDOWS_ */#line 216 "C:\WATCOM\H\NT\windows.h"
#line 16 "C:\WATCOM\H\NT\rpc.h"

// RPC_NO_WINDOWS_H

// __RPC_H__#line 121 "C:\WATCOM\H\NT\rpc.h"

#line 8 "C:\WATCOM\H\NT\objidl.h"

#line 1 "C:\WATCOM\H\NT\rpcndr.h"
/*++

Copyright (c) 1992-1995 Microsoft Corporation

Module Name:

    rpcndr.h

Abstract:

    Definitions for stub data structures and prototypes of helper functions.

Environment:

    DOS, Win 3.X, and Win/NT.

--*/

/* __RPCNDR_H__ */#line 2263 "C:\WATCOM\H\NT\rpcndr.h"
#line 9 "C:\WATCOM\H\NT\objidl.h"


#line 1 "C:\WATCOM\H\NT\windows.h"
/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) 1985-1995, Microsoft Corporation

Module Name:


    windows.h

Abstract:

    Master include file for Windows applications.

--*/

/* _WINDOWS_ */#line 216 "C:\WATCOM\H\NT\windows.h"
#line 11 "C:\WATCOM\H\NT\objidl.h"

#line 1 "C:\WATCOM\H\NT\ole2.h"
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       OLE2.h
//  Contents:   Main OLE2 header; Defines Linking and Emmebbeding interfaces, and API's.
//              Also includes .h files for the compobj, and oleauto  subcomponents.
//
//----------------------------------------------------------------------------
// __OLE2_H__#line 305 "C:\WATCOM\H\NT\ole2.h"

#line 12 "C:\WATCOM\H\NT\objidl.h"

/*COM_NO_WINDOWS_H*/

#line 7728 "C:\WATCOM\H\NT\objidl.h"
#line 85 "C:\WATCOM\H\NT\oaidl.h"


void    *  __stdcall  MIDL_user_allocate(size_t);
void  __stdcall  MIDL_user_free( void    * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;




/****************************************
 * Generated header for interface: RemVariant
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][version] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//--------------------------------------------------------------------------
/* XBSTR is for internal use only, it is subject to change */
			/* size is 4 */
typedef struct  tagXBSTR
    {
    ULONG cbSize;
    /* [size_is] */ OLECHAR rgBstrData[ 1 ];
    }	XBSTR;

			/* size is 4 */
typedef OLECHAR    *BSTR;

			/* size is 4 */
typedef BSTR    *LPBSTR;





			/* size is 8 */
typedef struct  tagBLOB
    {
    ULONG cbSize;
    /* [size_is] */ BYTE    *pBlobData;
    }	BLOB;

			/* size is 4 */
typedef struct tagBLOB    *LPBLOB;





			/* size is 12 */
typedef struct  tagCLIPDATA
    {
    ULONG cbSize;
    long ulClipFmt;
    /* [size_is] */ BYTE    *pClipData;
    }	CLIPDATA;






			/* size is 8 */
typedef struct  tagSAFEARRAYBOUND
    {
    ULONG cElements;
    LONG lLbound;
    }	SAFEARRAYBOUND;

			/* size is 4 */
typedef struct tagSAFEARRAYBOUND    *LPSAFEARRAYBOUND;






#line 207 "C:\WATCOM\H\NT\oaidl.h"
typedef struct    tagSAFEARRAY {
    unsigned short cDims;
    unsigned short fFeatures;

    unsigned long cbElements;
    unsigned long cLocks;
#line 218 "C:\WATCOM\H\NT\oaidl.h"
    void   * pvData;
    SAFEARRAYBOUND rgsabound[1];
} SAFEARRAY,   * LPSAFEARRAY;


			/* size is 2 */


			/* size is 2 */


			/* size is 2 */


			/* size is 2 */


			/* size is 2 */


			/* size is 2 */


			/* size is 2 */


			/* size is 2 */


			/* size is 2 */


			/* size is 8 */
typedef double DATE;




#line 266 "C:\WATCOM\H\NT\oaidl.h"
/* real definition that makes the C++ compiler happy */
typedef union tagCY {
    struct {         
#line 273 "C:\WATCOM\H\NT\oaidl.h"
        unsigned long Lo;
        long      Hi;

    };               
    LONGLONG int64;  
} CY;                


			/* size is 8 */
typedef CY CURRENCY;

/* 0 == FALSE, -1 == TRUE */
			/* size is 2 */
typedef short VARIANT_BOOL;









/*
 * VARENUM usage key,
 *
 * * [V] - may appear in a VARIANT
 * * [T] - may appear in a TYPEDESC
 * * [P] - may appear in an OLE property set
 * * [S] - may appear in a Safe Array
 *
 *
 *  VT_EMPTY            [V]   [P]     nothing                     
 *  VT_NULL             [V]           SQL style Null              
 *  VT_I2               [V][T][P][S]  2 byte signed int           
 *  VT_I4               [V][T][P][S]  4 byte signed int           
 *  VT_R4               [V][T][P][S]  4 byte real                 
 *  VT_R8               [V][T][P][S]  8 byte real                 
 *  VT_CY               [V][T][P][S]  currency                    
 *  VT_DATE             [V][T][P][S]  date                        
 *  VT_BSTR             [V][T][P][S]  OLE Automation string       
 *  VT_DISPATCH         [V][T]   [S]  IDispatch FAR*              
 *  VT_ERROR            [V][T]   [S]  SCODE                       
 *  VT_BOOL             [V][T][P][S]  True=-1, False=0            
 *  VT_VARIANT          [V][T][P][S]  VARIANT FAR*                
 *  VT_UNKNOWN          [V][T]   [S]  IUnknown FAR*               
 *  VT_I1                  [T]        signed char                 
 *  VT_UI1              [V][T]   [S]  unsigned char               
 *  VT_UI2                 [T]        unsigned short              
 *  VT_UI4                 [T]        unsigned short              
 *  VT_I8                  [T][P]     signed 64-bit int           
 *  VT_UI8                 [T]        unsigned 64-bit int         
 *  VT_INT                 [T]        signed machine int          
 *  VT_UINT                [T]        unsigned machine int        
 *  VT_VOID                [T]        C style void                
 *  VT_HRESULT             [T]                                    
 *  VT_PTR                 [T]        pointer type                
 *  VT_SAFEARRAY           [T]        (use VT_ARRAY in VARIANT)   
 *  VT_CARRAY              [T]        C style array               
 *  VT_USERDEFINED         [T]        user defined type           
 *  VT_LPSTR               [T][P]     null terminated string      
 *  VT_LPWSTR              [T][P]     wide null terminated string 
 *  VT_FILETIME               [P]     FILETIME                    
 *  VT_BLOB                   [P]     Length prefixed bytes       
 *  VT_STREAM                 [P]     Name of the stream follows  
 *  VT_STORAGE                [P]     Name of the storage follows 
 *  VT_STREAMED_OBJECT        [P]     Stream contains an object   
 *  VT_STORED_OBJECT          [P]     Storage contains an object  
 *  VT_BLOB_OBJECT            [P]     Blob contains an object     
 *  VT_CF                     [P]     Clipboard format            
 *  VT_CLSID                  [P]     A Class ID                  
 *  VT_VECTOR                 [P]     simple counted array        
 *  VT_ARRAY            [V]           SAFEARRAY*                  
 *  VT_BYREF            [V]                                       
 */
			/* size is 2 */

enum VARENUM
    {	VT_EMPTY	= 0,
	VT_NULL	= 1,
	VT_I2	= 2,
	VT_I4	= 3,
	VT_R4	= 4,
	VT_R8	= 5,
	VT_CY	= 6,
	VT_DATE	= 7,
	VT_BSTR	= 8,
	VT_DISPATCH	= 9,
	VT_ERROR	= 10,
	VT_BOOL	= 11,
	VT_VARIANT	= 12,
	VT_UNKNOWN	= 13,
	VT_I1	= 16,
	VT_UI1	= 17,
	VT_UI2	= 18,
	VT_UI4	= 19,
	VT_I8	= 20,
	VT_UI8	= 21,
	VT_INT	= 22,
	VT_UINT	= 23,
	VT_VOID	= 24,
	VT_HRESULT	= 25,
	VT_PTR	= 26,
	VT_SAFEARRAY	= 27,
	VT_CARRAY	= 28,
	VT_USERDEFINED	= 29,
	VT_LPSTR	= 30,
	VT_LPWSTR	= 31,
	VT_FILETIME	= 64,
	VT_BLOB	= 65,
	VT_STREAM	= 66,
	VT_STORAGE	= 67,
	VT_STREAMED_OBJECT	= 68,
	VT_STORED_OBJECT	= 69,
	VT_BLOB_OBJECT	= 70,
	VT_CF	= 71,
	VT_CLSID	= 72
    };

			/* size is 2 */


			/* size is 2 */


			/* size is 2 */


			/* size is 2 */




			/* size is 2 */
typedef unsigned short VARTYPE;


			/* size is 0 */
typedef struct tagVARIANT VARIANT;

/* forward declare IDispatch */
typedef  struct  IDispatch IDispatch;
/* VARIANT STRUCTURE
 *
 *  VARTYPE vt;
 *  unsigned short wReserved1;
 *  unsigned short wReserved2;
 *  unsigned short wReserved3;
 *  union {
 *    unsigned char        VT_UI1               
 *    short                VT_I2                
 *    long                 VT_I4                
 *    float                VT_R4                
 *    double               VT_R8                
 *    VARIANT_BOOL         VT_BOOL              
 *    SCODE                VT_ERROR             
 *    CY                   VT_CY                
 *    DATE                 VT_DATE              
 *    BSTR                 VT_BSTR              
 *    IUnknown FAR*        VT_UNKNOWN           
 *    IDispatch FAR*       VT_DISPATCH          
 *    SAFEARRAY FAR*       VT_ARRAY|*           
 *    short FAR*           VT_BYREF|VT_I2       
 *    long FAR*            VT_BYREF|VT_I4       
 *    float FAR*           VT_BYREF|VT_R4       
 *    double FAR*          VT_BYREF|VT_R8       
 *    VARIANT_BOOL FAR*    VT_BYREF|VT_BOOL     
 *    SCODE FAR*           VT_BYREF|VT_ERROR    
 *    CY FAR*              VT_BYREF|VT_CY       
 *    DATE FAR*            VT_BYREF|VT_DATE     
 *    BSTR FAR*            VT_BYREF|VT_BSTR     
 *    IUnknown FAR* FAR*   VT_BYREF|VT_UNKNOWN  
 *    IDispatch FAR* FAR*  VT_BYREF|VT_DISPATCH 
 *    SAFEARRAY FAR* FAR*  VT_BYREF|VT_ARRAY|*  
 *    VARIANT FAR*         VT_BYREF|VT_VARIANT  
 *    void FAR*            Generic ByRef        
 */


#line 492 "C:\WATCOM\H\NT\oaidl.h"
struct tagVARIANT{
    VARTYPE vt;
    WORD wReserved1;
    WORD wReserved2;
    WORD wReserved3;
    union
    {
      long          lVal;           /* VT_I4                */ 
      unsigned char bVal;           /* VT_UI1               */ 
      short         iVal;           /* VT_I2                */ 
      float         fltVal;         /* VT_R4                */ 
      double        dblVal;         /* VT_R8                */ 
      VARIANT_BOOL  bool;           /* VT_BOOL              */ 
      SCODE         scode;          /* VT_ERROR             */ 
      CY            cyVal;          /* VT_CY                */ 
      DATE          date;           /* VT_DATE              */ 
      BSTR          bstrVal;        /* VT_BSTR              */ 
      IUnknown      *punkVal;       /* VT_UNKNOWN           */ 
      IDispatch     *pdispVal;      /* VT_DISPATCH          */ 
      SAFEARRAY     *parray;        /* VT_ARRAY|*           */ 
      unsigned char *pbVal;         /* VT_BYREF|VT_UI1      */ 
      short         *piVal;         /* VT_BYREF|VT_I2       */ 
      long          *plVal;         /* VT_BYREF|VT_I4       */ 
      float         *pfltVal;       /* VT_BYREF|VT_R4       */ 
      double        *pdblVal;       /* VT_BYREF|VT_R8       */ 
      VARIANT_BOOL  *pbool;         /* VT_BYREF|VT_BOOL     */ 
      SCODE         *pscode;        /* VT_BYREF|VT_ERROR    */ 
      CY            *pcyVal;        /* VT_BYREF|VT_CY       */ 
      DATE          *pdate;         /* VT_BYREF|VT_DATE     */ 
      BSTR          *pbstrVal;      /* VT_BYREF|VT_BSTR     */ 
      IUnknown      **ppunkVal;     /* VT_BYREF|VT_UNKNOWN  */ 
      IDispatch     **ppdispVal;    /* VT_BYREF|VT_DISPATCH */ 
      SAFEARRAY     **pparray;      /* VT_BYREF|VT_ARRAY|*  */ 
      VARIANT       *pvarVal;       /* VT_BYREF|VT_VARIANT  */ 
      void     * byref;             /* Generic ByRef        */ 
    }
#line 531 "C:\WATCOM\H\NT\oaidl.h"
     ;
};



			/* size is 4 */
typedef struct tagVARIANT    *LPVARIANT;




			/* size is 16 */
typedef struct tagVARIANT VARIANTARG;




			/* size is 4 */
typedef struct tagVARIANT    *LPVARIANTARG;




			/* size is 4 */
typedef LONG DISPID;




			/* size is 4 */
typedef DISPID MEMBERID;




			/* size is 4 */
typedef DWORD HREFTYPE;


			/* size is 4 */
typedef ULONG PROPID;

			/* size is 2 */
typedef /* [transmit] */  
enum tagTYPEKIND
    {	TKIND_ENUM	= 0,
	TKIND_RECORD	= TKIND_ENUM + 1,
	TKIND_MODULE	= TKIND_RECORD + 1,
	TKIND_INTERFACE	= TKIND_MODULE + 1,
	TKIND_DISPATCH	= TKIND_INTERFACE + 1,
	TKIND_COCLASS	= TKIND_DISPATCH + 1,
	TKIND_ALIAS	= TKIND_COCLASS + 1,
	TKIND_UNION	= TKIND_ALIAS + 1,
	TKIND_MAX	= TKIND_UNION + 1
    }	TYPEKIND;








/* VT_PTR - lptdesc, the pointed at type */
/* VT_CARRAY - lpadesc */
/* VT_USERDEFINED - hreftype, used to get the UDT typeinfo */
			/* size is 6 */
typedef struct  tagTYPEDESC
    {
    /* [switch_is][switch_type] */ union 
        {
        /* [case] */ struct tagTYPEDESC    *lptdesc;
        /* [case] */ struct tagARRAYDESC    *lpadesc;
        /* [case] */ HREFTYPE hreftype;
        }	;
    VARTYPE vt;
    }	TYPEDESC;





#line 623 "C:\WATCOM\H\NT\oaidl.h"
typedef struct tagARRAYDESC {
    TYPEDESC tdescElem;     /* element type */ 
    USHORT cDims;       /* dimension count */ 
    SAFEARRAYBOUND rgbounds[1]; /* variable length array of bounds */ 
} ARRAYDESC;







			/* size is 6 */
typedef struct  tagIDLDESC
    {
    unsigned long dwReserved;
    unsigned short wIDLFlags;
    }	IDLDESC;

			/* size is 4 */
typedef struct tagIDLDESC    *LPIDLDESC;

#line 656 "C:\WATCOM\H\NT\oaidl.h"





			/* size is 14 */
typedef struct  tagELEMDESC
    {
    TYPEDESC tdesc;
    IDLDESC idldesc;
    }	ELEMDESC;

			/* size is 4 */
typedef struct tagELEMDESC    *LPELEMDESC;






			/* size is 74 */
typedef struct  tagTYPEATTR
    {
    GUID guid;
    LCID lcid;
    DWORD dwReserved;
    MEMBERID memidConstructor;
    MEMBERID memidDestructor;
    LPOLESTR lpstrSchema;
    ULONG cbSizeInstance;
    TYPEKIND typekind;
    WORD cFuncs;
    WORD cVars;
    WORD cImplTypes;
    WORD cbSizeVft;
    WORD cbAlignment;
    WORD wTypeFlags;
    WORD wMajorVerNum;
    WORD wMinorVerNum;
    TYPEDESC tdescAlias;
    IDLDESC idldescType;
    }	TYPEATTR;

			/* size is 4 */
typedef struct tagTYPEATTR    *LPTYPEATTR;


			/* size is 16 */
typedef struct  tagDISPPARAMS
    {
    /* [size_is] */ VARIANTARG    *rgvarg;
    /* [size_is] */ DISPID    *rgdispidNamedArgs;
    UINT cArgs;
    UINT cNamedArgs;
    }	DISPPARAMS;

			/* size is 24 */
typedef struct  tagRemEXCEPINFO
    {
    WORD wCode;
    WORD wReserved;
    DWORD dwHelpContext;
    DWORD scode;
    DWORD cSource;
    DWORD cDescription;
    DWORD cHelpFile;
    /* [size_is] */ OLECHAR strings[ 1 ];
    }	RemEXCEPINFO;

#line 745 "C:\WATCOM\H\NT\oaidl.h"
typedef struct tagEXCEPINFO {
    WORD wCode;
    WORD wReserved;
    BSTR bstrSource;
    BSTR bstrDescription;
    BSTR bstrHelpFile;
    DWORD dwHelpContext;
    void    * pvReserved;
    HRESULT (__stdcall    * pfnDeferredFillIn)(struct tagEXCEPINFO    *);
    SCODE scode;
}  EXCEPINFO,    * LPEXCEPINFO;

			/* size is 2 */
typedef /* [transmit] */  
enum tagCALLCONV
    {	CC_CDECL	= 1,
	CC_MSCPASCAL	= CC_CDECL + 1,
	CC_PASCAL	= CC_MSCPASCAL,
	CC_MACPASCAL	= CC_PASCAL + 1,
	CC_STDCALL	= CC_MACPASCAL + 1,
	CC_RESERVED	= CC_STDCALL + 1,
	CC_SYSCALL	= CC_RESERVED + 1,
	CC_MPWCDECL	= CC_SYSCALL + 1,
	CC_MPWPASCAL	= CC_MPWCDECL + 1,
	CC_MAX	= CC_MPWPASCAL + 1
    }	CALLCONV;





			/* size is 2 */
typedef /* [transmit] */  
enum tagFUNCKIND
    {	FUNC_VIRTUAL	= 0,
	FUNC_PUREVIRTUAL	= FUNC_VIRTUAL + 1,
	FUNC_NONVIRTUAL	= FUNC_PUREVIRTUAL + 1,
	FUNC_STATIC	= FUNC_NONVIRTUAL + 1,
	FUNC_DISPATCH	= FUNC_STATIC + 1
    }	FUNCKIND;





			/* size is 2 */
typedef /* [transmit] */  
enum tagINVOKEKIND
    {	INVOKE_FUNC	= 1,
	INVOKE_PROPERTYGET	= 2,
	INVOKE_PROPERTYPUT	= 4,
	INVOKE_PROPERTYPUTREF	= 8
    }	INVOKEKIND;





			/* size is 44 */
typedef struct  tagFUNCDESC
    {
    MEMBERID memid;
    /* [size_is] */ SCODE    *lprgscode;
    /* [size_is] */ ELEMDESC    *lprgelemdescParam;
    FUNCKIND funckind;
    INVOKEKIND invkind;
    CALLCONV callconv;
    SHORT cParams;
    SHORT cParamsOpt;
    SHORT oVft;
    SHORT cScodes;
    ELEMDESC elemdescFunc;
    WORD wFuncFlags;
    }	FUNCDESC;

			/* size is 4 */
typedef struct tagFUNCDESC    *LPFUNCDESC;

			/* size is 2 */
typedef /* [transmit] */  
enum tagVARKIND
    {	VAR_PERINSTANCE	= 0,
	VAR_STATIC	= VAR_PERINSTANCE + 1,
	VAR_CONST	= VAR_STATIC + 1,
	VAR_DISPATCH	= VAR_CONST + 1
    }	VARKIND;





			/* size is 2 */


			/* size is 2 */


			/* size is 2 */


			/* size is 30 */
typedef struct  tagVARDESC
    {
    MEMBERID memid;
    LPOLESTR lpstrSchema;
    /* [switch_is][switch_type] */ union 
        {
        /* [case] */ ULONG oInst;
        /* [case] */ VARIANT    *lpvarValue;
        }	;
    ELEMDESC elemdescVar;
    WORD wVarFlags;
    VARKIND varkind;
    }	VARDESC;

			/* size is 4 */
typedef struct tagVARDESC    *LPVARDESC;




			/* size is 2 */
typedef 
enum tagTYPEFLAGS
    {	TYPEFLAG_FAPPOBJECT	= 0x1,
	TYPEFLAG_FCANCREATE	= 0x2,
	TYPEFLAG_FLICENSED	= 0x4,
	TYPEFLAG_FPREDECLID	= 0x8,
	TYPEFLAG_FHIDDEN	= 0x10,
	TYPEFLAG_FCONTROL	= 0x20,
	TYPEFLAG_FDUAL	= 0x40,
	TYPEFLAG_FNONEXTENSIBLE	= 0x80,
	TYPEFLAG_FOLEAUTOMATION	= 0x100,
	TYPEFLAG_FRESTRICTED	= 0x200
    }	TYPEFLAGS;





			/* size is 2 */
typedef 
enum tagFUNCFLAGS
    {	FUNCFLAG_FRESTRICTED	= 1,
	FUNCFLAG_FSOURCE	= 0x2,
	FUNCFLAG_FBINDABLE	= 0x4,
	FUNCFLAG_FREQUESTEDIT	= 0x8,
	FUNCFLAG_FDISPLAYBIND	= 0x10,
	FUNCFLAG_FDEFAULTBIND	= 0x20,
	FUNCFLAG_FHIDDEN	= 0x40,
	FUNCFLAG_FUSESGETLASTERROR	= 0x80
    }	FUNCFLAGS;





			/* size is 2 */
typedef 
enum tagVARFLAGS
    {	VARFLAG_FREADONLY	= 1,
	VARFLAG_FSOURCE	= 0x2,
	VARFLAG_FBINDABLE	= 0x4,
	VARFLAG_FREQUESTEDIT	= 0x8,
	VARFLAG_FDISPLAYBIND	= 0x10,
	VARFLAG_FDEFAULTBIND	= 0x20,
	VARFLAG_FHIDDEN	= 0x40
    }	VARFLAGS;




extern RPC_IF_HANDLE RemVariant_v0_1_c_ifspec;
extern RPC_IF_HANDLE RemVariant_v0_1_s_ifspec;
/* __RemVariant_INTERFACE_DEFINED__ */




/****************************************
 * Generated header for interface: ICreateTypeInfo
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  ICreateTypeInfo    *LPCREATETYPEINFO;


 extern "C"  const IID __cdecl IID_ICreateTypeInfo;

/* C style interface */#line 1030 "C:\WATCOM\H\NT\oaidl.h"

    typedef struct ICreateTypeInfoVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            ICreateTypeInfo    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            ICreateTypeInfo    * This);
        
        ULONG ( __stdcall    *Release )( 
            ICreateTypeInfo    * This);
        
        HRESULT ( __stdcall    *SetGuid )( 
            ICreateTypeInfo    * This,
            /* [in] */  const GUID &  guid);
        
        HRESULT ( __stdcall    *SetTypeFlags )( 
            ICreateTypeInfo    * This,
            /* [in] */ UINT uTypeFlags);
        
        HRESULT ( __stdcall    *SetDocString )( 
            ICreateTypeInfo    * This,
            /* [in] */ LPOLESTR lpstrDoc);
        
        HRESULT ( __stdcall    *SetHelpContext )( 
            ICreateTypeInfo    * This,
            /* [in] */ DWORD dwHelpContext);
        
        HRESULT ( __stdcall    *SetVersion )( 
            ICreateTypeInfo    * This,
            /* [in] */ WORD wMajorVerNum,
            /* [in] */ WORD wMinorVerNum);
        
        HRESULT ( __stdcall    *AddRefTypeInfo )( 
            ICreateTypeInfo    * This,
            /* [in] */ ITypeInfo    *ptinfo,
            /* [in] */ HREFTYPE    *phreftype);
        
        HRESULT ( __stdcall    *AddFuncDesc )( 
            ICreateTypeInfo    * This,
            /* [in] */ UINT index,
            /* [in] */ FUNCDESC    *pfuncdesc);
        
        HRESULT ( __stdcall    *AddImplType )( 
            ICreateTypeInfo    * This,
            /* [in] */ UINT index,
            /* [in] */ HREFTYPE hreftype);
        
        HRESULT ( __stdcall    *SetImplTypeFlags )( 
            ICreateTypeInfo    * This,
            /* [in] */ UINT index,
            /* [in] */ INT impltypeflags);
        
        HRESULT ( __stdcall    *SetAlignment )( 
            ICreateTypeInfo    * This,
            /* [in] */ WORD cbAlignment);
        
        HRESULT ( __stdcall    *SetSchema )( 
            ICreateTypeInfo    * This,
            /* [in] */ LPOLESTR lpstrSchema);
        
        HRESULT ( __stdcall    *AddVarDesc )( 
            ICreateTypeInfo    * This,
            /* [in] */ UINT index,
            /* [in] */ VARDESC    *pvardesc);
        
        HRESULT ( __stdcall    *SetFuncAndParamNames )( 
            ICreateTypeInfo    * This,
            /* [in] */ UINT index,
            /* [in][size_is][in] */ LPOLESTR    *rgszNames,
            /* [in] */ UINT cNames);
        
        HRESULT ( __stdcall    *SetVarName )( 
            ICreateTypeInfo    * This,
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szName);
        
        HRESULT ( __stdcall    *SetTypeDescAlias )( 
            ICreateTypeInfo    * This,
            /* [in] */ TYPEDESC    *ptdescAlias);
        
        HRESULT ( __stdcall    *DefineFuncAsDllEntry )( 
            ICreateTypeInfo    * This,
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szDllName,
            /* [in] */ LPOLESTR szProcName);
        
        HRESULT ( __stdcall    *SetFuncDocString )( 
            ICreateTypeInfo    * This,
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szDocString);
        
        HRESULT ( __stdcall    *SetVarDocString )( 
            ICreateTypeInfo    * This,
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szDocString);
        
        HRESULT ( __stdcall    *SetFuncHelpContext )( 
            ICreateTypeInfo    * This,
            /* [in] */ UINT index,
            /* [in] */ DWORD dwHelpContext);
        
        HRESULT ( __stdcall    *SetVarHelpContext )( 
            ICreateTypeInfo    * This,
            /* [in] */ UINT index,
            /* [in] */ DWORD dwHelpContext);
        
        HRESULT ( __stdcall    *SetMops )( 
            ICreateTypeInfo    * This,
            /* [in] */ UINT index,
            /* [in] */ BSTR bstrMops);
        
        HRESULT ( __stdcall    *SetTypeIdldesc )( 
            ICreateTypeInfo    * This,
            /* [in] */ IDLDESC    *pidldesc);
        
        HRESULT ( __stdcall    *LayOut )( 
            ICreateTypeInfo    * This);
        
    } ICreateTypeInfoVtbl;

     struct  ICreateTypeInfo
    {
           struct ICreateTypeInfoVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 1244 "C:\WATCOM\H\NT\oaidl.h"


/* C style interface */



HRESULT __stdcall ICreateTypeInfo_SetGuid_Proxy( 
    ICreateTypeInfo    * This,
    /* [in] */  const GUID &  guid);


void  __stdcall  ICreateTypeInfo_SetGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetTypeFlags_Proxy( 
    ICreateTypeInfo    * This,
    /* [in] */ UINT uTypeFlags);


void  __stdcall  ICreateTypeInfo_SetTypeFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetDocString_Proxy( 
    ICreateTypeInfo    * This,
    /* [in] */ LPOLESTR lpstrDoc);


void  __stdcall  ICreateTypeInfo_SetDocString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetHelpContext_Proxy( 
    ICreateTypeInfo    * This,
    /* [in] */ DWORD dwHelpContext);


void  __stdcall  ICreateTypeInfo_SetHelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetVersion_Proxy( 
    ICreateTypeInfo    * This,
    /* [in] */ WORD wMajorVerNum,
    /* [in] */ WORD wMinorVerNum);


void  __stdcall  ICreateTypeInfo_SetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_AddRefTypeInfo_Proxy( 
    ICreateTypeInfo    * This,
    /* [in] */ ITypeInfo    *ptinfo,
    /* [in] */ HREFTYPE    *phreftype);


void  __stdcall  ICreateTypeInfo_AddRefTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_AddFuncDesc_Proxy( 
    ICreateTypeInfo    * This,
    /* [in] */ UINT index,
    /* [in] */ FUNCDESC    *pfuncdesc);


void  __stdcall  ICreateTypeInfo_AddFuncDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_AddImplType_Proxy( 
    ICreateTypeInfo    * This,
    /* [in] */ UINT index,
    /* [in] */ HREFTYPE hreftype);


void  __stdcall  ICreateTypeInfo_AddImplType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetImplTypeFlags_Proxy( 
    ICreateTypeInfo    * This,
    /* [in] */ UINT index,
    /* [in] */ INT impltypeflags);


void  __stdcall  ICreateTypeInfo_SetImplTypeFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetAlignment_Proxy( 
    ICreateTypeInfo    * This,
    /* [in] */ WORD cbAlignment);


void  __stdcall  ICreateTypeInfo_SetAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetSchema_Proxy( 
    ICreateTypeInfo    * This,
    /* [in] */ LPOLESTR lpstrSchema);


void  __stdcall  ICreateTypeInfo_SetSchema_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_AddVarDesc_Proxy( 
    ICreateTypeInfo    * This,
    /* [in] */ UINT index,
    /* [in] */ VARDESC    *pvardesc);


void  __stdcall  ICreateTypeInfo_AddVarDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetFuncAndParamNames_Proxy( 
    ICreateTypeInfo    * This,
    /* [in] */ UINT index,
    /* [in][size_is][in] */ LPOLESTR    *rgszNames,
    /* [in] */ UINT cNames);


void  __stdcall  ICreateTypeInfo_SetFuncAndParamNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetVarName_Proxy( 
    ICreateTypeInfo    * This,
    /* [in] */ UINT index,
    /* [in] */ LPOLESTR szName);


void  __stdcall  ICreateTypeInfo_SetVarName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetTypeDescAlias_Proxy( 
    ICreateTypeInfo    * This,
    /* [in] */ TYPEDESC    *ptdescAlias);


void  __stdcall  ICreateTypeInfo_SetTypeDescAlias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_DefineFuncAsDllEntry_Proxy( 
    ICreateTypeInfo    * This,
    /* [in] */ UINT index,
    /* [in] */ LPOLESTR szDllName,
    /* [in] */ LPOLESTR szProcName);


void  __stdcall  ICreateTypeInfo_DefineFuncAsDllEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetFuncDocString_Proxy( 
    ICreateTypeInfo    * This,
    /* [in] */ UINT index,
    /* [in] */ LPOLESTR szDocString);


void  __stdcall  ICreateTypeInfo_SetFuncDocString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetVarDocString_Proxy( 
    ICreateTypeInfo    * This,
    /* [in] */ UINT index,
    /* [in] */ LPOLESTR szDocString);


void  __stdcall  ICreateTypeInfo_SetVarDocString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetFuncHelpContext_Proxy( 
    ICreateTypeInfo    * This,
    /* [in] */ UINT index,
    /* [in] */ DWORD dwHelpContext);


void  __stdcall  ICreateTypeInfo_SetFuncHelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetVarHelpContext_Proxy( 
    ICreateTypeInfo    * This,
    /* [in] */ UINT index,
    /* [in] */ DWORD dwHelpContext);


void  __stdcall  ICreateTypeInfo_SetVarHelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetMops_Proxy( 
    ICreateTypeInfo    * This,
    /* [in] */ UINT index,
    /* [in] */ BSTR bstrMops);


void  __stdcall  ICreateTypeInfo_SetMops_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetTypeIdldesc_Proxy( 
    ICreateTypeInfo    * This,
    /* [in] */ IDLDESC    *pidldesc);


void  __stdcall  ICreateTypeInfo_SetTypeIdldesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_LayOut_Proxy( 
    ICreateTypeInfo    * This);


void  __stdcall  ICreateTypeInfo_LayOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __ICreateTypeInfo_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: ICreateTypeLib
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  ICreateTypeLib    *LPCREATETYPELIB;


 extern "C"  const IID __cdecl IID_ICreateTypeLib;

/* C style interface */#line 1602 "C:\WATCOM\H\NT\oaidl.h"

    typedef struct ICreateTypeLibVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            ICreateTypeLib    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            ICreateTypeLib    * This);
        
        ULONG ( __stdcall    *Release )( 
            ICreateTypeLib    * This);
        
        HRESULT ( __stdcall    *CreateTypeInfo )( 
            ICreateTypeLib    * This,
            /* [in] */ LPOLESTR szName,
            /* [in] */ TYPEKIND tkind,
            /* [out] */ ICreateTypeInfo    *   *lplpictinfo);
        
        HRESULT ( __stdcall    *SetName )( 
            ICreateTypeLib    * This,
            LPOLESTR szName);
        
        HRESULT ( __stdcall    *SetVersion )( 
            ICreateTypeLib    * This,
            /* [in] */ WORD wMajorVerNum,
            /* [in] */ WORD wMinorVerNum);
        
        HRESULT ( __stdcall    *SetGuid )( 
            ICreateTypeLib    * This,
            /* [in] */  const GUID &  guid);
        
        HRESULT ( __stdcall    *SetDocString )( 
            ICreateTypeLib    * This,
            /* [in] */ LPOLESTR szDoc);
        
        HRESULT ( __stdcall    *SetHelpFileName )( 
            ICreateTypeLib    * This,
            /* [in] */ LPOLESTR szHelpFileName);
        
        HRESULT ( __stdcall    *SetHelpContext )( 
            ICreateTypeLib    * This,
            /* [in] */ DWORD dwHelpContext);
        
        HRESULT ( __stdcall    *SetLcid )( 
            ICreateTypeLib    * This,
            /* [in] */ LCID lcid);
        
        HRESULT ( __stdcall    *SetLibFlags )( 
            ICreateTypeLib    * This,
            /* [in] */ UINT uLibFlags);
        
        HRESULT ( __stdcall    *SaveAllChanges )( 
            ICreateTypeLib    * This);
        
    } ICreateTypeLibVtbl;

     struct  ICreateTypeLib
    {
           struct ICreateTypeLibVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 1712 "C:\WATCOM\H\NT\oaidl.h"


/* C style interface */



HRESULT __stdcall ICreateTypeLib_CreateTypeInfo_Proxy( 
    ICreateTypeLib    * This,
    /* [in] */ LPOLESTR szName,
    /* [in] */ TYPEKIND tkind,
    /* [out] */ ICreateTypeInfo    *   *lplpictinfo);


void  __stdcall  ICreateTypeLib_CreateTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SetName_Proxy( 
    ICreateTypeLib    * This,
    LPOLESTR szName);


void  __stdcall  ICreateTypeLib_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SetVersion_Proxy( 
    ICreateTypeLib    * This,
    /* [in] */ WORD wMajorVerNum,
    /* [in] */ WORD wMinorVerNum);


void  __stdcall  ICreateTypeLib_SetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SetGuid_Proxy( 
    ICreateTypeLib    * This,
    /* [in] */  const GUID &  guid);


void  __stdcall  ICreateTypeLib_SetGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SetDocString_Proxy( 
    ICreateTypeLib    * This,
    /* [in] */ LPOLESTR szDoc);


void  __stdcall  ICreateTypeLib_SetDocString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SetHelpFileName_Proxy( 
    ICreateTypeLib    * This,
    /* [in] */ LPOLESTR szHelpFileName);


void  __stdcall  ICreateTypeLib_SetHelpFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SetHelpContext_Proxy( 
    ICreateTypeLib    * This,
    /* [in] */ DWORD dwHelpContext);


void  __stdcall  ICreateTypeLib_SetHelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SetLcid_Proxy( 
    ICreateTypeLib    * This,
    /* [in] */ LCID lcid);


void  __stdcall  ICreateTypeLib_SetLcid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SetLibFlags_Proxy( 
    ICreateTypeLib    * This,
    /* [in] */ UINT uLibFlags);


void  __stdcall  ICreateTypeLib_SetLibFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SaveAllChanges_Proxy( 
    ICreateTypeLib    * This);


void  __stdcall  ICreateTypeLib_SaveAllChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __ICreateTypeLib_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IDispatch
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IDispatch    *LPDISPATCH;

/* DISPID reserved to indicate an "unknown" name */
/* only reserved for data members (properties); reused as a method dispid below */
			/* size is 4 */


/* DISPID reserved for the "value" property */
			/* size is 4 */


/* The following DISPID is reserved to indicate the param
 * that is the right-hand-side (or "put" value) of a PropertyPut
 */
			/* size is 4 */


/* DISPID reserved for the standard "NewEnum" method */
			/* size is 4 */


/* DISPID reserved for the standard "Evaluate" method */
			/* size is 4 */


			/* size is 4 */


			/* size is 4 */


			/* size is 4 */


/* The range -500 through -999 is reserved for Controls */
/* The range 0x80010000 through 0x8001FFFF is reserved for Controls */
/* The remainder of the negative DISPIDs are reserved for future use */

 extern "C"  const IID __cdecl IID_IDispatch;

/* C style interface */#line 1929 "C:\WATCOM\H\NT\oaidl.h"

    typedef struct IDispatchVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IDispatch    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IDispatch    * This);
        
        ULONG ( __stdcall    *Release )( 
            IDispatch    * This);
        
        HRESULT ( __stdcall    *GetTypeInfoCount )( 
            IDispatch    * This,
            /* [out] */ UINT    *pctinfo);
        
        HRESULT ( __stdcall    *GetTypeInfo )( 
            IDispatch    * This,
            /* [in] */ UINT itinfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo    *   *pptinfo);
        
        HRESULT ( __stdcall    *GetIDsOfNames )( 
            IDispatch    * This,
            /* [in] */  const IID &  riid,
            /* [size_is][in] */ LPOLESTR    *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out][in] */ DISPID    *rgdispid);
        
        HRESULT ( __stdcall    *Invoke )( 
            IDispatch    * This,
            /* [in] */ DISPID dispidMember,
            /* [in] */  const IID &  riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [unique][in] */ DISPPARAMS    *pdispparams,
            /* [unique][out][in] */ VARIANT    *pvarResult,
            /* [out] */ EXCEPINFO    *pexcepinfo,
            /* [out] */ UINT    *puArgErr);
        
    } IDispatchVtbl;

     struct  IDispatch
    {
           struct IDispatchVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 2008 "C:\WATCOM\H\NT\oaidl.h"


/* C style interface */



HRESULT __stdcall IDispatch_GetTypeInfoCount_Proxy( 
    IDispatch    * This,
    /* [out] */ UINT    *pctinfo);


void  __stdcall  IDispatch_GetTypeInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDispatch_GetTypeInfo_Proxy( 
    IDispatch    * This,
    /* [in] */ UINT itinfo,
    /* [in] */ LCID lcid,
    /* [out] */ ITypeInfo    *   *pptinfo);


void  __stdcall  IDispatch_GetTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDispatch_GetIDsOfNames_Proxy( 
    IDispatch    * This,
    /* [in] */  const IID &  riid,
    /* [size_is][in] */ LPOLESTR    *rgszNames,
    /* [in] */ UINT cNames,
    /* [in] */ LCID lcid,
    /* [size_is][out][in] */ DISPID    *rgdispid);


void  __stdcall  IDispatch_GetIDsOfNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDispatch_Invoke_Proxy( 
    IDispatch    * This,
    /* [in] */ DISPID dispidMember,
    /* [in] */  const IID &  riid,
    /* [in] */ LCID lcid,
    /* [in] */ WORD wFlags,
    /* [unique][in] */ DISPPARAMS    *pdispparams,
    /* [unique][out][in] */ VARIANT    *pvarResult,
    /* [out] */ EXCEPINFO    *pexcepinfo,
    /* [out] */ UINT    *puArgErr);


void  __stdcall  IDispatch_Invoke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IDispatch_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IEnumVARIANT
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][local][object] */ 


			/* size is 4 */
typedef /* [unique] */  IEnumVARIANT    *LPENUMVARIANT;


 extern "C"  const IID __cdecl IID_IEnumVARIANT;

/* C style interface */#line 2117 "C:\WATCOM\H\NT\oaidl.h"

    typedef struct IEnumVARIANTVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IEnumVARIANT    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IEnumVARIANT    * This);
        
        ULONG ( __stdcall    *Release )( 
            IEnumVARIANT    * This);
        
        HRESULT ( __stdcall    *Next )( 
            IEnumVARIANT    * This,
            /* [in] */ unsigned long celt,
            /* [out] */ VARIANT    *rgvar,
            /* [out] */ unsigned long    *pceltFetched);
        
        HRESULT ( __stdcall    *Skip )( 
            IEnumVARIANT    * This,
            /* [in] */ unsigned long celt);
        
        HRESULT ( __stdcall    *Reset )( 
            IEnumVARIANT    * This);
        
        HRESULT ( __stdcall    *Clone )( 
            IEnumVARIANT    * This,
            /* [out] */ IEnumVARIANT    *   *ppenum);
        
    } IEnumVARIANTVtbl;

     struct  IEnumVARIANT
    {
           struct IEnumVARIANTVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 2184 "C:\WATCOM\H\NT\oaidl.h"


/* C style interface */



HRESULT __stdcall IEnumVARIANT_Next_Proxy( 
    IEnumVARIANT    * This,
    /* [in] */ unsigned long celt,
    /* [out] */ VARIANT    *rgvar,
    /* [out] */ unsigned long    *pceltFetched);


void  __stdcall  IEnumVARIANT_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumVARIANT_Skip_Proxy( 
    IEnumVARIANT    * This,
    /* [in] */ unsigned long celt);


void  __stdcall  IEnumVARIANT_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumVARIANT_Reset_Proxy( 
    IEnumVARIANT    * This);


void  __stdcall  IEnumVARIANT_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumVARIANT_Clone_Proxy( 
    IEnumVARIANT    * This,
    /* [out] */ IEnumVARIANT    *   *ppenum);


void  __stdcall  IEnumVARIANT_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IEnumVARIANT_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: ITypeComp
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  ITypeComp    *LPTYPECOMP;

			/* size is 2 */
typedef /* [v1_enum] */  
enum tagDESCKIND
    {	DESCKIND_NONE	= 0,
	DESCKIND_FUNCDESC	= DESCKIND_NONE + 1,
	DESCKIND_VARDESC	= DESCKIND_FUNCDESC + 1,
	DESCKIND_TYPECOMP	= DESCKIND_VARDESC + 1,
	DESCKIND_IMPLICITAPPOBJ	= DESCKIND_TYPECOMP + 1,
	DESCKIND_MAX	= DESCKIND_IMPLICITAPPOBJ + 1
    }	DESCKIND;





			/* size is 4 */
/* [switch_type] */ union tagBINDPTR
    {
    /* [case] */ FUNCDESC    *lpfuncdesc;
    /* [case] */ VARDESC    *lpvardesc;
    /* [case][unique] */ ITypeComp    *lptcomp;
    /* [default] */  /* Empty union arm */ 
    };
			/* size is 4 */
typedef union tagBINDPTR BINDPTR;

			/* size is 4 */
typedef BINDPTR    *LPBINDPTR;


 extern "C"  const IID __cdecl IID_ITypeComp;

/* C style interface */#line 2311 "C:\WATCOM\H\NT\oaidl.h"

    typedef struct ITypeCompVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            ITypeComp    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            ITypeComp    * This);
        
        ULONG ( __stdcall    *Release )( 
            ITypeComp    * This);
        
        HRESULT ( __stdcall    *Bind )( 
            ITypeComp    * This,
            /* [in] */ LPOLESTR szName,
            /* [in] */ ULONG lHashVal,
            /* [in] */ WORD fFlags,
            /* [out] */ ITypeInfo    *   *pptinfo,
            /* [out] */ DESCKIND    *pdesckind,
            /* [switch_is][out] */ BINDPTR    *pbindptr);
        
        HRESULT ( __stdcall    *BindType )( 
            ITypeComp    * This,
            /* [in] */ LPOLESTR szName,
            /* [in] */ ULONG lHashVal,
            /* [out] */ ITypeInfo    *   *pptinfo,
            /* [out] */ ITypeComp    *   *pptcomp);
        
    } ITypeCompVtbl;

     struct  ITypeComp
    {
           struct ITypeCompVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 2371 "C:\WATCOM\H\NT\oaidl.h"


/* C style interface */



HRESULT __stdcall ITypeComp_Bind_Proxy( 
    ITypeComp    * This,
    /* [in] */ LPOLESTR szName,
    /* [in] */ ULONG lHashVal,
    /* [in] */ WORD fFlags,
    /* [out] */ ITypeInfo    *   *pptinfo,
    /* [out] */ DESCKIND    *pdesckind,
    /* [switch_is][out] */ BINDPTR    *pbindptr);


void  __stdcall  ITypeComp_Bind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeComp_BindType_Proxy( 
    ITypeComp    * This,
    /* [in] */ LPOLESTR szName,
    /* [in] */ ULONG lHashVal,
    /* [out] */ ITypeInfo    *   *pptinfo,
    /* [out] */ ITypeComp    *   *pptcomp);


void  __stdcall  ITypeComp_BindType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __ITypeComp_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: ITypeInfo
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  ITypeInfo    *LPTYPEINFO;


 extern "C"  const IID __cdecl IID_ITypeInfo;

/* C style interface */#line 2525 "C:\WATCOM\H\NT\oaidl.h"

    typedef struct ITypeInfoVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            ITypeInfo    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            ITypeInfo    * This);
        
        ULONG ( __stdcall    *Release )( 
            ITypeInfo    * This);
        
        HRESULT ( __stdcall    *GetTypeAttr )( 
            ITypeInfo    * This,
            /* [out] */ TYPEATTR    *   *pptypeattr);
        
        HRESULT ( __stdcall    *GetTypeComp )( 
            ITypeInfo    * This,
            /* [out] */ ITypeComp    *   *pptcomp);
        
        HRESULT ( __stdcall    *GetFuncDesc )( 
            ITypeInfo    * This,
            /* [in] */ UINT index,
            /* [out] */ FUNCDESC    *   *pppfuncdesc);
        
        HRESULT ( __stdcall    *GetVarDesc )( 
            ITypeInfo    * This,
            /* [in] */ UINT index,
            /* [out] */ VARDESC    *   *ppvardesc);
        
        HRESULT ( __stdcall    *GetNames )( 
            ITypeInfo    * This,
            /* [in] */ MEMBERID memid,
            /* [length_is][size_is][out] */ BSTR    *rgbstrNames,
            /* [in] */ UINT cMaxNames,
            /* [out] */ UINT    *pcNames);
        
        HRESULT ( __stdcall    *GetRefTypeOfImplType )( 
            ITypeInfo    * This,
            /* [in] */ UINT index,
            /* [out] */ HREFTYPE    *hpreftype);
        
        HRESULT ( __stdcall    *GetImplTypeFlags )( 
            ITypeInfo    * This,
            /* [in] */ UINT index,
            /* [out] */ INT    *pimpltypeflags);
        
        HRESULT ( __stdcall    *GetIDsOfNames )( 
            ITypeInfo    * This,
            /* [size_is][in] */ OLECHAR    *   *rglpszNames,
            /* [in] */ UINT cNames,
            /* [size_is][out] */ MEMBERID    *rgmemid);
        
        HRESULT ( __stdcall    *Invoke )( 
            ITypeInfo    * This,
            /* [unique][in] */ void    *pvInstance,
            /* [in] */ MEMBERID memid,
            /* [in] */ WORD wFlags,
            /* [in] */ DISPPARAMS    *pdispparams,
            /* [out] */ VARIANT    *pvarResult,
            /* [out] */ EXCEPINFO    *pexcepinfo,
            /* [out] */ UINT    *puArgErr);
        
        HRESULT ( __stdcall    *GetDocumentation )( 
            ITypeInfo    * This,
            /* [in] */ MEMBERID memid,
            /* [out] */ BSTR    *pbstrName,
            /* [out] */ BSTR    *pbstrDocString,
            /* [out] */ DWORD    *pdwHelpContext,
            /* [out] */ BSTR    *pbstrHelpFile);
        
        HRESULT ( __stdcall    *GetDllEntry )( 
            ITypeInfo    * This,
            /* [in] */ MEMBERID memid,
            /* [in] */ INVOKEKIND invkind,
            /* [out] */ BSTR    *pbstrDllName,
            /* [out] */ BSTR    *pbstrName,
            /* [out] */ WORD    *pwOrdinal);
        
        HRESULT ( __stdcall    *GetRefTypeInfo )( 
            ITypeInfo    * This,
            /* [in] */ HREFTYPE hreftype,
            /* [out] */ ITypeInfo    *   *pptinfo);
        
        HRESULT ( __stdcall    *AddressOfMember )( 
            ITypeInfo    * This,
            /* [in] */ MEMBERID memid,
            /* [in] */ INVOKEKIND invkind,
            /* [out] */ void    *   *ppv);
        
        HRESULT ( __stdcall    *CreateInstance )( 
            ITypeInfo    * This,
            /* [in] */ IUnknown    *puncOuter,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObj);
        
        HRESULT ( __stdcall    *GetMops )( 
            ITypeInfo    * This,
            /* [in] */ MEMBERID memid,
            /* [out] */ BSTR    *pbstrMops);
        
        HRESULT ( __stdcall    *GetContainingTypeLib )( 
            ITypeInfo    * This,
            /* [out] */ ITypeLib    *   *pptlib,
            /* [out] */ UINT    *pindex);
        
        void ( __stdcall    *ReleaseTypeAttr )( 
            ITypeInfo    * This,
            /* [in] */ TYPEATTR    *ptypeattr);
        
        void ( __stdcall    *ReleaseFuncDesc )( 
            ITypeInfo    * This,
            /* [in] */ FUNCDESC    *pfuncdesc);
        
        void ( __stdcall    *ReleaseVarDesc )( 
            ITypeInfo    * This,
            /* [in] */ VARDESC    *pvardesc);
        
    } ITypeInfoVtbl;

     struct  ITypeInfo
    {
           struct ITypeInfoVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 2726 "C:\WATCOM\H\NT\oaidl.h"


/* C style interface */



HRESULT __stdcall ITypeInfo_GetTypeAttr_Proxy( 
    ITypeInfo    * This,
    /* [out] */ TYPEATTR    *   *pptypeattr);


void  __stdcall  ITypeInfo_GetTypeAttr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetTypeComp_Proxy( 
    ITypeInfo    * This,
    /* [out] */ ITypeComp    *   *pptcomp);


void  __stdcall  ITypeInfo_GetTypeComp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetFuncDesc_Proxy( 
    ITypeInfo    * This,
    /* [in] */ UINT index,
    /* [out] */ FUNCDESC    *   *pppfuncdesc);


void  __stdcall  ITypeInfo_GetFuncDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetVarDesc_Proxy( 
    ITypeInfo    * This,
    /* [in] */ UINT index,
    /* [out] */ VARDESC    *   *ppvardesc);


void  __stdcall  ITypeInfo_GetVarDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetNames_Proxy( 
    ITypeInfo    * This,
    /* [in] */ MEMBERID memid,
    /* [length_is][size_is][out] */ BSTR    *rgbstrNames,
    /* [in] */ UINT cMaxNames,
    /* [out] */ UINT    *pcNames);


void  __stdcall  ITypeInfo_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetRefTypeOfImplType_Proxy( 
    ITypeInfo    * This,
    /* [in] */ UINT index,
    /* [out] */ HREFTYPE    *hpreftype);


void  __stdcall  ITypeInfo_GetRefTypeOfImplType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetImplTypeFlags_Proxy( 
    ITypeInfo    * This,
    /* [in] */ UINT index,
    /* [out] */ INT    *pimpltypeflags);


void  __stdcall  ITypeInfo_GetImplTypeFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetIDsOfNames_Proxy( 
    ITypeInfo    * This,
    /* [size_is][in] */ OLECHAR    *   *rglpszNames,
    /* [in] */ UINT cNames,
    /* [size_is][out] */ MEMBERID    *rgmemid);


void  __stdcall  ITypeInfo_GetIDsOfNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_Invoke_Proxy( 
    ITypeInfo    * This,
    /* [unique][in] */ void    *pvInstance,
    /* [in] */ MEMBERID memid,
    /* [in] */ WORD wFlags,
    /* [in] */ DISPPARAMS    *pdispparams,
    /* [out] */ VARIANT    *pvarResult,
    /* [out] */ EXCEPINFO    *pexcepinfo,
    /* [out] */ UINT    *puArgErr);


void  __stdcall  ITypeInfo_Invoke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetDocumentation_Proxy( 
    ITypeInfo    * This,
    /* [in] */ MEMBERID memid,
    /* [out] */ BSTR    *pbstrName,
    /* [out] */ BSTR    *pbstrDocString,
    /* [out] */ DWORD    *pdwHelpContext,
    /* [out] */ BSTR    *pbstrHelpFile);


void  __stdcall  ITypeInfo_GetDocumentation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetDllEntry_Proxy( 
    ITypeInfo    * This,
    /* [in] */ MEMBERID memid,
    /* [in] */ INVOKEKIND invkind,
    /* [out] */ BSTR    *pbstrDllName,
    /* [out] */ BSTR    *pbstrName,
    /* [out] */ WORD    *pwOrdinal);


void  __stdcall  ITypeInfo_GetDllEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetRefTypeInfo_Proxy( 
    ITypeInfo    * This,
    /* [in] */ HREFTYPE hreftype,
    /* [out] */ ITypeInfo    *   *pptinfo);


void  __stdcall  ITypeInfo_GetRefTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_AddressOfMember_Proxy( 
    ITypeInfo    * This,
    /* [in] */ MEMBERID memid,
    /* [in] */ INVOKEKIND invkind,
    /* [out] */ void    *   *ppv);


void  __stdcall  ITypeInfo_AddressOfMember_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_CreateInstance_Proxy( 
    ITypeInfo    * This,
    /* [in] */ IUnknown    *puncOuter,
    /* [in] */  const IID &  riid,
    /* [out] */ void    *   *ppvObj);


void  __stdcall  ITypeInfo_CreateInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetMops_Proxy( 
    ITypeInfo    * This,
    /* [in] */ MEMBERID memid,
    /* [out] */ BSTR    *pbstrMops);


void  __stdcall  ITypeInfo_GetMops_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetContainingTypeLib_Proxy( 
    ITypeInfo    * This,
    /* [out] */ ITypeLib    *   *pptlib,
    /* [out] */ UINT    *pindex);


void  __stdcall  ITypeInfo_GetContainingTypeLib_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall ITypeInfo_ReleaseTypeAttr_Proxy( 
    ITypeInfo    * This,
    /* [in] */ TYPEATTR    *ptypeattr);


void  __stdcall  ITypeInfo_ReleaseTypeAttr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall ITypeInfo_ReleaseFuncDesc_Proxy( 
    ITypeInfo    * This,
    /* [in] */ FUNCDESC    *pfuncdesc);


void  __stdcall  ITypeInfo_ReleaseFuncDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall ITypeInfo_ReleaseVarDesc_Proxy( 
    ITypeInfo    * This,
    /* [in] */ VARDESC    *pvardesc);


void  __stdcall  ITypeInfo_ReleaseVarDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __ITypeInfo_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: ITypeLib
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 2 */
typedef /* [transmit] */  
enum tagSYSKIND
    {	SYS_WIN16	= 0,
	SYS_WIN32	= SYS_WIN16 + 1,
	SYS_MAC	= SYS_WIN32 + 1
    }	SYSKIND;

			/* size is 2 */
typedef /* [transmit] */  
enum tagLIBFLAGS
    {	LIBFLAG_FRESTRICTED	= 0x1,
	LIBFLAG_FCONTROL	= 0x2,
	LIBFLAG_FHIDDEN	= 0x4
    }	LIBFLAGS;





			/* size is 4 */
typedef /* [unique] */  ITypeLib    *LPTYPELIB;

			/* size is 28 */
typedef struct  tagTLIBATTR
    {
    GUID guid;
    LCID lcid;
    SYSKIND syskind;
    WORD wMajorVerNum;
    WORD wMinorVerNum;
    WORD wLibFlags;
    }	TLIBATTR;

			/* size is 4 */
typedef TLIBATTR    *LPTLIBATTR;


 extern "C"  const IID __cdecl IID_ITypeLib;

/* C style interface */#line 3095 "C:\WATCOM\H\NT\oaidl.h"

    typedef struct ITypeLibVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            ITypeLib    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            ITypeLib    * This);
        
        ULONG ( __stdcall    *Release )( 
            ITypeLib    * This);
        
        UINT ( __stdcall    *GetTypeInfoCount )( 
            ITypeLib    * This);
        
        HRESULT ( __stdcall    *GetTypeInfo )( 
            ITypeLib    * This,
            /* [in] */ UINT index,
            /* [out] */ ITypeInfo    *   *ppitinfo);
        
        HRESULT ( __stdcall    *GetTypeInfoType )( 
            ITypeLib    * This,
            /* [in] */ UINT index,
            /* [out] */ TYPEKIND    *ptkind);
        
        HRESULT ( __stdcall    *GetTypeInfoOfGuid )( 
            ITypeLib    * This,
            /* [in] */  const GUID &  guid,
            /* [out] */ ITypeInfo    *   *pptinfo);
        
        HRESULT ( __stdcall    *GetLibAttr )( 
            ITypeLib    * This,
            /* [out] */ TLIBATTR    *   *pptlibattr);
        
        HRESULT ( __stdcall    *GetTypeComp )( 
            ITypeLib    * This,
            /* [out] */ ITypeComp    *   *pptcomp);
        
        HRESULT ( __stdcall    *GetDocumentation )( 
            ITypeLib    * This,
            /* [in] */ INT index,
            /* [out] */ BSTR    *pbstrName,
            /* [out] */ BSTR    *pbstrDocString,
            /* [out] */ DWORD    *pdwHelpContext,
            /* [out] */ BSTR    *pbstrHelpFile);
        
        HRESULT ( __stdcall    *IsName )( 
            ITypeLib    * This,
            /* [in] */ LPOLESTR szNameBuf,
            /* [in] */ ULONG lHashVal,
            /* [out] */ BOOL    *pfName);
        
        HRESULT ( __stdcall    *FindName )( 
            ITypeLib    * This,
            /* [in] */ LPOLESTR szNameBuf,
            /* [in] */ ULONG lHashVal,
            /* [length_is][size_is][out] */ ITypeInfo    *   *rgptinfo,
            /* [length_is][size_is][out] */ MEMBERID    *rgmemid,
            /* [out][in] */ USHORT    *pcFound);
        
        void ( __stdcall    *ReleaseTLibAttr )( 
            ITypeLib    * This,
            /* [in] */ TLIBATTR    *ptlibattr);
        
    } ITypeLibVtbl;

     struct  ITypeLib
    {
           struct ITypeLibVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 3215 "C:\WATCOM\H\NT\oaidl.h"


/* C style interface */



UINT __stdcall ITypeLib_GetTypeInfoCount_Proxy( 
    ITypeLib    * This);


void  __stdcall  ITypeLib_GetTypeInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLib_GetTypeInfo_Proxy( 
    ITypeLib    * This,
    /* [in] */ UINT index,
    /* [out] */ ITypeInfo    *   *ppitinfo);


void  __stdcall  ITypeLib_GetTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLib_GetTypeInfoType_Proxy( 
    ITypeLib    * This,
    /* [in] */ UINT index,
    /* [out] */ TYPEKIND    *ptkind);


void  __stdcall  ITypeLib_GetTypeInfoType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLib_GetTypeInfoOfGuid_Proxy( 
    ITypeLib    * This,
    /* [in] */  const GUID &  guid,
    /* [out] */ ITypeInfo    *   *pptinfo);


void  __stdcall  ITypeLib_GetTypeInfoOfGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLib_GetLibAttr_Proxy( 
    ITypeLib    * This,
    /* [out] */ TLIBATTR    *   *pptlibattr);


void  __stdcall  ITypeLib_GetLibAttr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLib_GetTypeComp_Proxy( 
    ITypeLib    * This,
    /* [out] */ ITypeComp    *   *pptcomp);


void  __stdcall  ITypeLib_GetTypeComp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLib_GetDocumentation_Proxy( 
    ITypeLib    * This,
    /* [in] */ INT index,
    /* [out] */ BSTR    *pbstrName,
    /* [out] */ BSTR    *pbstrDocString,
    /* [out] */ DWORD    *pdwHelpContext,
    /* [out] */ BSTR    *pbstrHelpFile);


void  __stdcall  ITypeLib_GetDocumentation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLib_IsName_Proxy( 
    ITypeLib    * This,
    /* [in] */ LPOLESTR szNameBuf,
    /* [in] */ ULONG lHashVal,
    /* [out] */ BOOL    *pfName);


void  __stdcall  ITypeLib_IsName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLib_FindName_Proxy( 
    ITypeLib    * This,
    /* [in] */ LPOLESTR szNameBuf,
    /* [in] */ ULONG lHashVal,
    /* [length_is][size_is][out] */ ITypeInfo    *   *rgptinfo,
    /* [length_is][size_is][out] */ MEMBERID    *rgmemid,
    /* [out][in] */ USHORT    *pcFound);


void  __stdcall  ITypeLib_FindName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall ITypeLib_ReleaseTLibAttr_Proxy( 
    ITypeLib    * This,
    /* [in] */ TLIBATTR    *ptlibattr);


void  __stdcall  ITypeLib_ReleaseTLibAttr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __ITypeLib_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IErrorInfo
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IErrorInfo    *LPERRORINFO;


 extern "C"  const IID __cdecl IID_IErrorInfo;

/* C style interface */#line 3397 "C:\WATCOM\H\NT\oaidl.h"

    typedef struct IErrorInfoVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IErrorInfo    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IErrorInfo    * This);
        
        ULONG ( __stdcall    *Release )( 
            IErrorInfo    * This);
        
        HRESULT ( __stdcall    *GetGUID )( 
            IErrorInfo    * This,
            /* [out] */ GUID    *pguid);
        
        HRESULT ( __stdcall    *GetSource )( 
            IErrorInfo    * This,
            /* [out] */ BSTR    *pbstrSource);
        
        HRESULT ( __stdcall    *GetDescription )( 
            IErrorInfo    * This,
            /* [out] */ BSTR    *pbstrDescription);
        
        HRESULT ( __stdcall    *GetHelpFile )( 
            IErrorInfo    * This,
            /* [out] */ BSTR    *pbstrHelpFile);
        
        HRESULT ( __stdcall    *GetHelpContext )( 
            IErrorInfo    * This,
            /* [out] */ DWORD    *pdwHelpContext);
        
    } IErrorInfoVtbl;

     struct  IErrorInfo
    {
           struct IErrorInfoVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 3470 "C:\WATCOM\H\NT\oaidl.h"


/* C style interface */



HRESULT __stdcall IErrorInfo_GetGUID_Proxy( 
    IErrorInfo    * This,
    /* [out] */ GUID    *pguid);


void  __stdcall  IErrorInfo_GetGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IErrorInfo_GetSource_Proxy( 
    IErrorInfo    * This,
    /* [out] */ BSTR    *pbstrSource);


void  __stdcall  IErrorInfo_GetSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IErrorInfo_GetDescription_Proxy( 
    IErrorInfo    * This,
    /* [out] */ BSTR    *pbstrDescription);


void  __stdcall  IErrorInfo_GetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IErrorInfo_GetHelpFile_Proxy( 
    IErrorInfo    * This,
    /* [out] */ BSTR    *pbstrHelpFile);


void  __stdcall  IErrorInfo_GetHelpFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IErrorInfo_GetHelpContext_Proxy( 
    IErrorInfo    * This,
    /* [out] */ DWORD    *pdwHelpContext);


void  __stdcall  IErrorInfo_GetHelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IErrorInfo_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: ICreateErrorInfo
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  ICreateErrorInfo    *LPCREATEERRORINFO;


 extern "C"  const IID __cdecl IID_ICreateErrorInfo;

/* C style interface */#line 3580 "C:\WATCOM\H\NT\oaidl.h"

    typedef struct ICreateErrorInfoVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            ICreateErrorInfo    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            ICreateErrorInfo    * This);
        
        ULONG ( __stdcall    *Release )( 
            ICreateErrorInfo    * This);
        
        HRESULT ( __stdcall    *SetGUID )( 
            ICreateErrorInfo    * This,
            /* [in] */  const GUID &  rguid);
        
        HRESULT ( __stdcall    *SetSource )( 
            ICreateErrorInfo    * This,
            /* [in] */ LPOLESTR szSource);
        
        HRESULT ( __stdcall    *SetDescription )( 
            ICreateErrorInfo    * This,
            /* [in] */ LPOLESTR szDescription);
        
        HRESULT ( __stdcall    *SetHelpFile )( 
            ICreateErrorInfo    * This,
            /* [in] */ LPOLESTR szHelpFile);
        
        HRESULT ( __stdcall    *SetHelpContext )( 
            ICreateErrorInfo    * This,
            /* [in] */ DWORD dwHelpContext);
        
    } ICreateErrorInfoVtbl;

     struct  ICreateErrorInfo
    {
           struct ICreateErrorInfoVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 3653 "C:\WATCOM\H\NT\oaidl.h"


/* C style interface */



HRESULT __stdcall ICreateErrorInfo_SetGUID_Proxy( 
    ICreateErrorInfo    * This,
    /* [in] */  const GUID &  rguid);


void  __stdcall  ICreateErrorInfo_SetGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateErrorInfo_SetSource_Proxy( 
    ICreateErrorInfo    * This,
    /* [in] */ LPOLESTR szSource);


void  __stdcall  ICreateErrorInfo_SetSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateErrorInfo_SetDescription_Proxy( 
    ICreateErrorInfo    * This,
    /* [in] */ LPOLESTR szDescription);


void  __stdcall  ICreateErrorInfo_SetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateErrorInfo_SetHelpFile_Proxy( 
    ICreateErrorInfo    * This,
    /* [in] */ LPOLESTR szHelpFile);


void  __stdcall  ICreateErrorInfo_SetHelpFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateErrorInfo_SetHelpContext_Proxy( 
    ICreateErrorInfo    * This,
    /* [in] */ DWORD dwHelpContext);


void  __stdcall  ICreateErrorInfo_SetHelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __ICreateErrorInfo_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: ISupportErrorInfo
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  ISupportErrorInfo    *LPSUPPORTERRORINFO;


 extern "C"  const IID __cdecl IID_ISupportErrorInfo;

/* C style interface */#line 3751 "C:\WATCOM\H\NT\oaidl.h"

    typedef struct ISupportErrorInfoVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            ISupportErrorInfo    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            ISupportErrorInfo    * This);
        
        ULONG ( __stdcall    *Release )( 
            ISupportErrorInfo    * This);
        
        HRESULT ( __stdcall    *InterfaceSupportsErrorInfo )( 
            ISupportErrorInfo    * This,
            /* [in] */  const IID &  riid);
        
    } ISupportErrorInfoVtbl;

     struct  ISupportErrorInfo
    {
           struct ISupportErrorInfoVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 3796 "C:\WATCOM\H\NT\oaidl.h"


/* C style interface */



HRESULT __stdcall ISupportErrorInfo_InterfaceSupportsErrorInfo_Proxy( 
    ISupportErrorInfo    * This,
    /* [in] */  const IID &  riid);


void  __stdcall  ISupportErrorInfo_InterfaceSupportsErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __ISupportErrorInfo_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */


}



#line 94 "C:\WATCOM\H\NT\oleauto.h"



/*---------------------------------------------------------------------*/
/*                            BSTR API                                 */
/*---------------------------------------------------------------------*/

 extern "C" __declspec(dllimport) BSTR __stdcall  SysAllocString(const OLECHAR   *);
 extern "C" __declspec(dllimport) int __stdcall   SysReAllocString(BSTR   *, const OLECHAR   *);
 extern "C" __declspec(dllimport) BSTR __stdcall  SysAllocStringLen(const OLECHAR   *, unsigned int);
 extern "C" __declspec(dllimport) int __stdcall   SysReAllocStringLen(BSTR   *, const OLECHAR   *, unsigned int);
 extern "C" __declspec(dllimport) void __stdcall  SysFreeString(BSTR);
 extern "C" __declspec(dllimport) unsigned int __stdcall  SysStringLen(BSTR);


 extern "C" __declspec(dllimport) unsigned int __stdcall  SysStringByteLen(BSTR bstr);
 extern "C" __declspec(dllimport) BSTR __stdcall  SysAllocStringByteLen(const char   * psz, unsigned int len);


/*---------------------------------------------------------------------*/
/*                            Time API                                 */
/*---------------------------------------------------------------------*/

 extern "C" __declspec(dllimport) int __stdcall 
DosDateTimeToVariantTime(
    unsigned short wDosDate,
    unsigned short wDosTime,
    double   * pvtime);

 extern "C" __declspec(dllimport) int __stdcall 
VariantTimeToDosDateTime(
    double vtime,
    unsigned short   * pwDosDate,
    unsigned short   * pwDosTime);

/*---------------------------------------------------------------------*/
/*                          SafeArray API                              */
/*---------------------------------------------------------------------*/

 extern "C" __declspec(dllimport) HRESULT __stdcall 
SafeArrayAllocDescriptor(unsigned int cDims, SAFEARRAY   *   * ppsaOut);

 extern "C" __declspec(dllimport) HRESULT __stdcall  SafeArrayAllocData(SAFEARRAY   * psa);

 extern "C" __declspec(dllimport) SAFEARRAY * __stdcall 
SafeArrayCreate(
    VARTYPE vt,
    unsigned int cDims,
    SAFEARRAYBOUND   * rgsabound);

 extern "C" __declspec(dllimport) HRESULT __stdcall  SafeArrayDestroyDescriptor(SAFEARRAY   * psa);

 extern "C" __declspec(dllimport) HRESULT __stdcall  SafeArrayDestroyData(SAFEARRAY   * psa);

 extern "C" __declspec(dllimport) HRESULT __stdcall  SafeArrayDestroy(SAFEARRAY   * psa);

 extern "C" __declspec(dllimport) HRESULT __stdcall  SafeArrayRedim(SAFEARRAY   * psa, SAFEARRAYBOUND   * psaboundNew);

 extern "C" __declspec(dllimport) unsigned int __stdcall  SafeArrayGetDim(SAFEARRAY   * psa);

 extern "C" __declspec(dllimport) unsigned int __stdcall  SafeArrayGetElemsize(SAFEARRAY   * psa);

 extern "C" __declspec(dllimport) HRESULT __stdcall 
SafeArrayGetUBound(SAFEARRAY   * psa, unsigned int nDim, long   * plUbound);

 extern "C" __declspec(dllimport) HRESULT __stdcall 
SafeArrayGetLBound(SAFEARRAY   * psa, unsigned int nDim, long   * plLbound);

 extern "C" __declspec(dllimport) HRESULT __stdcall  SafeArrayLock(SAFEARRAY   * psa);

 extern "C" __declspec(dllimport) HRESULT __stdcall  SafeArrayUnlock(SAFEARRAY   * psa);

 extern "C" __declspec(dllimport) HRESULT __stdcall  SafeArrayAccessData(SAFEARRAY   * psa, void   *   * ppvData);

 extern "C" __declspec(dllimport) HRESULT __stdcall  SafeArrayUnaccessData(SAFEARRAY   * psa);

 extern "C" __declspec(dllimport) HRESULT __stdcall 
SafeArrayGetElement(
    SAFEARRAY   * psa,
    long   * rgIndices,
    void   * pv);

 extern "C" __declspec(dllimport) HRESULT __stdcall 
SafeArrayPutElement(
    SAFEARRAY   * psa,
    long   * rgIndices,
    void   * pv);

 extern "C" __declspec(dllimport) HRESULT __stdcall 
SafeArrayCopy(
    SAFEARRAY   * psa,
    SAFEARRAY   *   * ppsaOut);

 extern "C" __declspec(dllimport) HRESULT __stdcall 
SafeArrayPtrOfIndex(
    SAFEARRAY   * psa,
    long   * rgIndices,
    void   *   * ppvData);


/*---------------------------------------------------------------------*/
/*                           VARIANT API                               */
/*---------------------------------------------------------------------*/

 extern "C" __declspec(dllimport) void __stdcall 
VariantInit(VARIANTARG   * pvarg);

 extern "C" __declspec(dllimport) HRESULT __stdcall 
VariantClear(VARIANTARG   * pvarg);

 extern "C" __declspec(dllimport) HRESULT __stdcall 
VariantCopy(
    VARIANTARG   * pvargDest,
    VARIANTARG   * pvargSrc);

 extern "C" __declspec(dllimport) HRESULT __stdcall 
VariantCopyInd(
    VARIANT   * pvarDest,
    VARIANTARG   * pvargSrc);

 extern "C" __declspec(dllimport) HRESULT __stdcall 
VariantChangeType(
    VARIANTARG   * pvargDest,
    VARIANTARG   * pvarSrc,
    unsigned short wFlags,
    VARTYPE vt);

 extern "C" __declspec(dllimport) HRESULT __stdcall 
VariantChangeTypeEx(
    VARIANTARG   * pvargDest,
    VARIANTARG   * pvarSrc,
    LCID lcid,
    unsigned short wFlags,
    VARTYPE vt);




/*---------------------------------------------------------------------*/
/*                     VARTYPE Coercion API                            */
/*---------------------------------------------------------------------*/

/* Note: The routines that convert *from* a string are defined
 * to take a OLECHAR* rather than a BSTR because no allocation is
 * required, and this makes the routines a bit more generic.
 * They may of course still be passed a BSTR as the strIn param.
 */


/* Any of the coersion functions that converts either from or to a string
 * takes an additional lcid and dwFlags arguments. The lcid argument allows
 * locale specific parsing to occur.  The dwFlags allow additional function
 * specific condition to occur.  All function that accept the dwFlags argument
 * can include either 0 or LOCALE_NOUSEROVERRIDE flag. In addition, the
 * VarDateFromStr functions also accepts the VAR_TIMEVALUEONLY and
 * VAR_DATEVALUEONLY flags
 */

/* return time value */
/* return date value */


 extern "C" __declspec(dllimport) HRESULT __stdcall  VarUI1FromI2(short sIn, unsigned char   * pbOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarUI1FromI4(long lIn, unsigned char   * pbOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarUI1FromR4(float fltIn, unsigned char   * pbOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarUI1FromR8(double dblIn, unsigned char   * pbOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarUI1FromCy(CY cyIn, unsigned char   * pbOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarUI1FromDate(DATE dateIn, unsigned char   * pbOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarUI1FromStr(OLECHAR   * strIn, LCID lcid, unsigned long dwFlags, unsigned char   * pbOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarUI1FromDisp(IDispatch   * pdispIn, LCID lcid, unsigned char   * pbOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarUI1FromBool(VARIANT_BOOL boolIn, unsigned char   * pbOut);

 extern "C" __declspec(dllimport) HRESULT __stdcall  VarI2FromUI1(unsigned char bIn, short   * psOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarI2FromI4(long lIn, short   * psOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarI2FromR4(float fltIn, short   * psOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarI2FromR8(double dblIn, short   * psOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarI2FromCy(CY cyIn, short   * psOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarI2FromDate(DATE dateIn, short   * psOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarI2FromStr(OLECHAR   * strIn, LCID lcid, unsigned long dwFlags, short   * psOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarI2FromDisp(IDispatch   * pdispIn, LCID lcid, short   * psOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarI2FromBool(VARIANT_BOOL boolIn, short   * psOut);

 extern "C" __declspec(dllimport) HRESULT __stdcall  VarI4FromUI1(unsigned char bIn, long   * plOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarI4FromI2(short sIn, long   * plOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarI4FromR4(float fltIn, long   * plOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarI4FromR8(double dblIn, long   * plOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarI4FromCy(CY cyIn, long   * plOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarI4FromDate(DATE dateIn, long   * plOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarI4FromStr(OLECHAR   * strIn, LCID lcid, unsigned long dwFlags, long   * plOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarI4FromDisp(IDispatch   * pdispIn, LCID lcid, long   * plOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarI4FromBool(VARIANT_BOOL boolIn, long   * plOut);

 extern "C" __declspec(dllimport) HRESULT __stdcall  VarR4FromUI1(unsigned char bIn, float   * pfltOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarR4FromI2(short sIn, float   * pfltOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarR4FromI4(long lIn, float   * pfltOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarR4FromR8(double dblIn, float   * pfltOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarR4FromCy(CY cyIn, float   * pfltOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarR4FromDate(DATE dateIn, float   * pfltOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarR4FromStr(OLECHAR   * strIn, LCID lcid, unsigned long dwFlags, float   * pfltOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarR4FromDisp(IDispatch   * pdispIn, LCID lcid, float   * pfltOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarR4FromBool(VARIANT_BOOL boolIn, float   * pfltOut);

 extern "C" __declspec(dllimport) HRESULT __stdcall  VarR8FromUI1(unsigned char bIn, double   * pdblOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarR8FromI2(short sIn, double   * pdblOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarR8FromI4(long lIn, double   * pdblOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarR8FromR4(float fltIn, double   * pdblOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarR8FromCy(CY cyIn, double   * pdblOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarR8FromDate(DATE dateIn, double   * pdblOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarR8FromStr(OLECHAR   * strIn, LCID lcid, unsigned long dwFlags, double   * pdblOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarR8FromDisp(IDispatch   * pdispIn, LCID lcid, double   * pdblOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarR8FromBool(VARIANT_BOOL boolIn, double   * pdblOut);

 extern "C" __declspec(dllimport) HRESULT __stdcall  VarDateFromUI1(unsigned char bIn, DATE   * pdateOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarDateFromI2(short sIn, DATE   * pdateOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarDateFromI4(long lIn, DATE   * pdateOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarDateFromR4(float fltIn, DATE   * pdateOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarDateFromR8(double dblIn, DATE   * pdateOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarDateFromCy(CY cyIn, DATE   * pdateOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarDateFromStr(OLECHAR   * strIn, LCID lcid, unsigned long dwFlags, DATE   * pdateOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarDateFromDisp(IDispatch   * pdispIn, LCID lcid, DATE   * pdateOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarDateFromBool(VARIANT_BOOL boolIn, DATE   * pdateOut);

 extern "C" __declspec(dllimport) HRESULT __stdcall  VarCyFromUI1(unsigned char bIn, CY   * pcyOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarCyFromI2(short sIn, CY   * pcyOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarCyFromI4(long lIn, CY   * pcyOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarCyFromR4(float fltIn, CY   * pcyOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarCyFromR8(double dblIn, CY   * pcyOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarCyFromDate(DATE dateIn, CY   * pcyOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarCyFromStr(OLECHAR   * strIn, LCID lcid, unsigned long dwFlags, CY   * pcyOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarCyFromDisp(IDispatch   * pdispIn, LCID lcid, CY   * pcyOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarCyFromBool(VARIANT_BOOL boolIn, CY   * pcyOut);

 extern "C" __declspec(dllimport) HRESULT __stdcall  VarBstrFromUI1(unsigned char bVal, LCID lcid, unsigned long dwFlags, BSTR   * pbstrOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarBstrFromI2(short iVal, LCID lcid, unsigned long dwFlags, BSTR   * pbstrOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarBstrFromI4(long lIn, LCID lcid, unsigned long dwFlags, BSTR   * pbstrOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarBstrFromR4(float fltIn, LCID lcid, unsigned long dwFlags, BSTR   * pbstrOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarBstrFromR8(double dblIn, LCID lcid, unsigned long dwFlags, BSTR   * pbstrOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarBstrFromCy(CY cyIn, LCID lcid, unsigned long dwFlags, BSTR   * pbstrOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarBstrFromDate(DATE dateIn, LCID lcid, unsigned long dwFlags, BSTR   * pbstrOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarBstrFromDisp(IDispatch   * pdispIn, LCID lcid, unsigned long dwFlags, BSTR   * pbstrOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarBstrFromBool(VARIANT_BOOL boolIn, LCID lcid, unsigned long dwFlags, BSTR   * pbstrOut);

 extern "C" __declspec(dllimport) HRESULT __stdcall  VarBoolFromUI1(unsigned char bIn, VARIANT_BOOL   * pboolOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarBoolFromI2(short sIn, VARIANT_BOOL   * pboolOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarBoolFromI4(long lIn, VARIANT_BOOL   * pboolOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarBoolFromR4(float fltIn, VARIANT_BOOL   * pboolOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarBoolFromR8(double dblIn, VARIANT_BOOL   * pboolOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarBoolFromDate(DATE dateIn, VARIANT_BOOL   * pboolOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarBoolFromCy(CY cyIn, VARIANT_BOOL   * pboolOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarBoolFromStr(OLECHAR   * strIn, LCID lcid, unsigned long dwFlags, VARIANT_BOOL   * pboolOut);
 extern "C" __declspec(dllimport) HRESULT __stdcall  VarBoolFromDisp(IDispatch   * pdispIn, LCID lcid, VARIANT_BOOL   * pboolOut);


/* Mac Note: On the Mac, the coersion functions support the
 * Symantec C++ calling convention for float/double. To support
 * float/double arguments compiled with the MPW C compiler,
 * use the following APIs to move MPW float/double values into
 * a VARIANT.
 */

/*---------------------------------------------------------------------*/
/*                 ITypeLib                    */
/*---------------------------------------------------------------------*/


typedef ITypeLib   * LPTYPELIB;


/*---------------------------------------------------------------------*/
/*                ITypeInfo                    */
/*---------------------------------------------------------------------*/


typedef LONG DISPID;
typedef DISPID MEMBERID;












/* Flags for IDispatch::Invoke */






typedef ITypeInfo   * LPTYPEINFO;


/*---------------------------------------------------------------------*/
/*                ITypeComp                    */
/*---------------------------------------------------------------------*/

typedef ITypeComp   * LPTYPECOMP;


/*---------------------------------------------------------------------*/
/*             ICreateTypeLib                  */
/*---------------------------------------------------------------------*/

typedef ICreateTypeLib   * LPCREATETYPELIB;


typedef ICreateTypeInfo   * LPCREATETYPEINFO;

/*---------------------------------------------------------------------*/
/*             TypeInfo API                    */
/*---------------------------------------------------------------------*/

/* compute a 16bit hash value for the given name
 */

 extern "C" __declspec(dllimport) ULONG __stdcall 
LHashValOfNameSysA(SYSKIND syskind, LCID lcid, const char   * szName);


 extern "C" __declspec(dllimport) ULONG __stdcall 
LHashValOfNameSys(SYSKIND syskind, LCID lcid, const OLECHAR   * szName);










/* load the typelib from the file with the given filename
 */
 extern "C" __declspec(dllimport) HRESULT __stdcall 
LoadTypeLib(const OLECHAR    *szFile, ITypeLib   *   * pptlib);

/* load registered typelib
 */
 extern "C" __declspec(dllimport) HRESULT __stdcall 
LoadRegTypeLib(
     const GUID &  rguid,
    WORD wVerMajor,
    WORD wVerMinor,
    LCID lcid,
    ITypeLib   *   * pptlib);

/* get path to registered typelib
 */
 extern "C" __declspec(dllimport) HRESULT __stdcall 
QueryPathOfRegTypeLib(
     const GUID &  guid,
    unsigned short wMaj,
    unsigned short wMin,
    LCID lcid,
    LPBSTR lpbstrPathName);

/* add typelib to registry
 */
 extern "C" __declspec(dllimport) HRESULT __stdcall 
RegisterTypeLib(ITypeLib   * ptlib, OLECHAR    *szFullPath,
        OLECHAR    *szHelpDir);

/* remove typelib from registry
 */
 extern "C" __declspec(dllimport) HRESULT __stdcall 
DeregisterTypeLib( const GUID &  rguid, WORD wVerMajor, WORD wVerMinor, LCID lcid);

 extern "C" __declspec(dllimport) HRESULT __stdcall 
CreateTypeLib(SYSKIND syskind, const OLECHAR    *szFile,
        ICreateTypeLib   *   * ppctlib);

/*---------------------------------------------------------------------*/

/*---------------------------------------------------------------------*/
/*                 IDispatch                   */
/*---------------------------------------------------------------------*/

typedef IDispatch   * LPDISPATCH;



/*---------------------------------------------------------------------*/
/*           IDispatch implementation support              */
/*---------------------------------------------------------------------*/

typedef struct    tagPARAMDATA {
    OLECHAR   * szName;    /* parameter name */ 
    VARTYPE vt;         /* parameter type */ 
} PARAMDATA,   * LPPARAMDATA;

typedef struct    tagMETHODDATA {
    OLECHAR   * szName;    /* method name */ 
    PARAMDATA   * ppdata;  /* pointer to an array of PARAMDATAs */ 
    DISPID dispid;      /* method ID */ 
    UINT iMeth;         /* method index */ 
    CALLCONV cc;        /* calling convention */ 
    UINT cArgs;         /* count of arguments */ 
    WORD wFlags;        /* same wFlags as on IDispatch::Invoke() */ 
    VARTYPE vtReturn;
} METHODDATA,   * LPMETHODDATA;

typedef struct    tagINTERFACEDATA {
    METHODDATA   * pmethdata;  /* pointer to an array of METHODDATAs */ 
    UINT cMembers;      /* count of members */ 
} INTERFACEDATA,   * LPINTERFACEDATA;



/* Locate the parameter indicated by the given position, and
 * return it coerced to the given target VARTYPE (vtTarg).
 */
 extern "C" __declspec(dllimport) HRESULT __stdcall 
DispGetParam(
    DISPPARAMS   * pdispparams,
    UINT position,
    VARTYPE vtTarg,
    VARIANT   * pvarResult,
    UINT   * puArgErr);

/* Automatic TypeInfo driven implementation of IDispatch::GetIDsOfNames()
 */
 extern "C" __declspec(dllimport) HRESULT __stdcall 
DispGetIDsOfNames(
    ITypeInfo   * ptinfo,
    OLECHAR   *   * rgszNames,
    UINT cNames,
    DISPID   * rgdispid);

/* Automatic TypeInfo driven implementation of IDispatch::Invoke()
 */
 extern "C" __declspec(dllimport) HRESULT __stdcall 
DispInvoke(
    void   * _this,
    ITypeInfo   * ptinfo,
    DISPID dispidMember,
    WORD wFlags,
    DISPPARAMS   * pparams,
    VARIANT   * pvarResult,
    EXCEPINFO   * pexcepinfo,
    UINT   * puArgErr);

/* Construct a TypeInfo from an interface data description
 */
 extern "C" __declspec(dllimport) HRESULT __stdcall 
CreateDispTypeInfo(
    INTERFACEDATA   * pidata,
    LCID lcid,
    ITypeInfo   *   * pptinfo);

/* Create an instance of the standard TypeInfo driven IDispatch
 * implementation.
 */
 extern "C" __declspec(dllimport) HRESULT __stdcall 
CreateStdDispatch(
    IUnknown   * punkOuter,
    void   * pvThis,
    ITypeInfo   * ptinfo,
    IUnknown   *   * ppunkStdDisp);


/*---------------------------------------------------------------------*/
/*            Active Object Registration API               */
/*---------------------------------------------------------------------*/

/* flags for RegisterActiveObject */



 extern "C" __declspec(dllimport) HRESULT __stdcall 
RegisterActiveObject(
   IUnknown   * punk,
    const CLSID &  rclsid,
   DWORD dwFlags,
   DWORD   * pdwRegister);

 extern "C" __declspec(dllimport) HRESULT __stdcall 
RevokeActiveObject(
    DWORD dwRegister,
    void   * pvReserved);

 extern "C" __declspec(dllimport) HRESULT __stdcall 
GetActiveObject(
     const CLSID &  rclsid,
    void   * pvReserved,
    IUnknown   *   * ppunk);

/*---------------------------------------------------------------------*/
/*                           ErrorInfo API                             */
/*---------------------------------------------------------------------*/

 extern "C" __declspec(dllimport) HRESULT __stdcall  SetErrorInfo(unsigned long dwReserved, IErrorInfo   * perrinfo);
 extern "C" __declspec(dllimport) HRESULT __stdcall  GetErrorInfo(unsigned long dwReserved, IErrorInfo   *   * pperrinfo);
 extern "C" __declspec(dllimport) HRESULT __stdcall  CreateErrorInfo(ICreateErrorInfo   *   * pperrinfo);

/*---------------------------------------------------------------------*/
/*                           MISC API                                  */
/*---------------------------------------------------------------------*/

 extern "C" __declspec(dllimport) unsigned long __stdcall  OaBuildVersion(void);

// Declare variant access functions.



#line 606 "C:\WATCOM\H\NT\oleauto.h"



/* Variant access macros */





































































#line 1 "C:\WATCOM\H\NT\poppack.h"
/*++

Copyright (c) 1990,95  Microsoft Corporation

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)
#line 33 "C:\WATCOM\H\NT\poppack.h"
#line 36 "C:\WATCOM\H\NT\poppack.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 679 "C:\WATCOM\H\NT\oleauto.h"

// RC_INVOKED

// __OLEAUTO_H__

#line 29 "C:\WATCOM\H\NT\ole2.h"


// View OBJECT Error Codes



// IDataObject Error Codes






// Common stuff gleamed from OLE.2,

/* verbs */








// for OleCreateEmbeddingHelper flags; roles in low word; options in high word





/* pull in the MIDL generated header */

#line 1 "C:\WATCOM\H\NT\oleidl.h"
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Fri Apr 28 07:02:35 1995
 */
//@@MIDL_FILE_HEADING(  )
#line 1 "C:\WATCOM\H\NT\rpc.h"
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    rpc.h

Abstract:

    Master include file for RPC applications.

--*/


#line 1 "C:\WATCOM\H\NT\windows.h"
/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) 1985-1995, Microsoft Corporation

Module Name:


    windows.h

Abstract:

    Master include file for Windows applications.

--*/

/* _WINDOWS_ */#line 216 "C:\WATCOM\H\NT\windows.h"
#line 16 "C:\WATCOM\H\NT\rpc.h"

// RPC_NO_WINDOWS_H

// __RPC_H__#line 121 "C:\WATCOM\H\NT\rpc.h"

#line 8 "C:\WATCOM\H\NT\oleidl.h"

#line 1 "C:\WATCOM\H\NT\rpcndr.h"
/*++

Copyright (c) 1992-1995 Microsoft Corporation

Module Name:

    rpcndr.h

Abstract:

    Definitions for stub data structures and prototypes of helper functions.

Environment:

    DOS, Win 3.X, and Win/NT.

--*/

/* __RPCNDR_H__ */#line 2263 "C:\WATCOM\H\NT\rpcndr.h"
#line 9 "C:\WATCOM\H\NT\oleidl.h"


#line 1 "C:\WATCOM\H\NT\windows.h"
/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) 1985-1995, Microsoft Corporation

Module Name:


    windows.h

Abstract:

    Master include file for Windows applications.

--*/

/* _WINDOWS_ */#line 216 "C:\WATCOM\H\NT\windows.h"
#line 11 "C:\WATCOM\H\NT\oleidl.h"

#line 1 "C:\WATCOM\H\NT\ole2.h"
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       OLE2.h
//  Contents:   Main OLE2 header; Defines Linking and Emmebbeding interfaces, and API's.
//              Also includes .h files for the compobj, and oleauto  subcomponents.
//
//----------------------------------------------------------------------------
// __OLE2_H__#line 305 "C:\WATCOM\H\NT\ole2.h"

#line 12 "C:\WATCOM\H\NT\oleidl.h"

/*COM_NO_WINDOWS_H*/





extern "C"{


/* Forward Declarations */ 



typedef  struct  IOleAdviseHolder IOleAdviseHolder;
/* __IOleAdviseHolder_FWD_DEFINED__ */




typedef  struct  IOleCache IOleCache;
/* __IOleCache_FWD_DEFINED__ */




typedef  struct  IOleCache2 IOleCache2;
/* __IOleCache2_FWD_DEFINED__ */




typedef  struct  IOleCacheControl IOleCacheControl;
/* __IOleCacheControl_FWD_DEFINED__ */




typedef  struct  IParseDisplayName IParseDisplayName;
/* __IParseDisplayName_FWD_DEFINED__ */




typedef  struct  IOleContainer IOleContainer;
/* __IOleContainer_FWD_DEFINED__ */




typedef  struct  IOleClientSite IOleClientSite;
/* __IOleClientSite_FWD_DEFINED__ */




typedef  struct  IOleObject IOleObject;
/* __IOleObject_FWD_DEFINED__ */




typedef  struct  IOleWindow IOleWindow;
/* __IOleWindow_FWD_DEFINED__ */




typedef  struct  IOleLink IOleLink;
/* __IOleLink_FWD_DEFINED__ */




typedef  struct  IOleItemContainer IOleItemContainer;
/* __IOleItemContainer_FWD_DEFINED__ */




typedef  struct  IOleInPlaceUIWindow IOleInPlaceUIWindow;
/* __IOleInPlaceUIWindow_FWD_DEFINED__ */




typedef  struct  IOleInPlaceActiveObject IOleInPlaceActiveObject;
/* __IOleInPlaceActiveObject_FWD_DEFINED__ */




typedef  struct  IOleInPlaceFrame IOleInPlaceFrame;
/* __IOleInPlaceFrame_FWD_DEFINED__ */




typedef  struct  IOleInPlaceObject IOleInPlaceObject;
/* __IOleInPlaceObject_FWD_DEFINED__ */




typedef  struct  IOleInPlaceSite IOleInPlaceSite;
/* __IOleInPlaceSite_FWD_DEFINED__ */




typedef  struct  IViewObject IViewObject;
/* __IViewObject_FWD_DEFINED__ */




typedef  struct  IViewObject2 IViewObject2;
/* __IViewObject2_FWD_DEFINED__ */




typedef  struct  IDropSource IDropSource;
/* __IDropSource_FWD_DEFINED__ */




typedef  struct  IDropTarget IDropTarget;
/* __IDropTarget_FWD_DEFINED__ */




typedef  struct  IEnumOLEVERB IEnumOLEVERB;
/* __IEnumOLEVERB_FWD_DEFINED__ */


/* header files for imported files */
#line 1 "C:\WATCOM\H\NT\objidl.h"
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Fri Apr 28 07:02:32 1995
 */
//@@MIDL_FILE_HEADING(  )
#line 1 "C:\WATCOM\H\NT\rpc.h"
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    rpc.h

Abstract:

    Master include file for RPC applications.

--*/


#line 1 "C:\WATCOM\H\NT\windows.h"
/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) 1985-1995, Microsoft Corporation

Module Name:


    windows.h

Abstract:

    Master include file for Windows applications.

--*/

/* _WINDOWS_ */#line 216 "C:\WATCOM\H\NT\windows.h"
#line 16 "C:\WATCOM\H\NT\rpc.h"

// RPC_NO_WINDOWS_H

// __RPC_H__#line 121 "C:\WATCOM\H\NT\rpc.h"

#line 8 "C:\WATCOM\H\NT\objidl.h"

#line 1 "C:\WATCOM\H\NT\rpcndr.h"
/*++

Copyright (c) 1992-1995 Microsoft Corporation

Module Name:

    rpcndr.h

Abstract:

    Definitions for stub data structures and prototypes of helper functions.

Environment:

    DOS, Win 3.X, and Win/NT.

--*/

/* __RPCNDR_H__ */#line 2263 "C:\WATCOM\H\NT\rpcndr.h"
#line 9 "C:\WATCOM\H\NT\objidl.h"


#line 1 "C:\WATCOM\H\NT\windows.h"
/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) 1985-1995, Microsoft Corporation

Module Name:


    windows.h

Abstract:

    Master include file for Windows applications.

--*/

/* _WINDOWS_ */#line 216 "C:\WATCOM\H\NT\windows.h"
#line 11 "C:\WATCOM\H\NT\objidl.h"

#line 1 "C:\WATCOM\H\NT\ole2.h"
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       OLE2.h
//  Contents:   Main OLE2 header; Defines Linking and Emmebbeding interfaces, and API's.
//              Also includes .h files for the compobj, and oleauto  subcomponents.
//
//----------------------------------------------------------------------------
// __OLE2_H__#line 305 "C:\WATCOM\H\NT\ole2.h"

#line 12 "C:\WATCOM\H\NT\objidl.h"

/*COM_NO_WINDOWS_H*/

#line 7728 "C:\WATCOM\H\NT\objidl.h"
#line 151 "C:\WATCOM\H\NT\oleidl.h"


void    *  __stdcall  MIDL_user_allocate(size_t);
void  __stdcall  MIDL_user_free( void    * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


			/* size is 0 */

			/* size is 0 */



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;




/****************************************
 * Generated header for interface: IOleAdviseHolder
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//--------------------------------------------------------------------------
			/* size is 4 */
typedef /* [unique] */  IOleAdviseHolder    *LPOLEADVISEHOLDER;


 extern "C"  const IID __cdecl IID_IOleAdviseHolder;

/* C style interface */#line 221 "C:\WATCOM\H\NT\oleidl.h"

    typedef struct IOleAdviseHolderVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IOleAdviseHolder    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IOleAdviseHolder    * This);
        
        ULONG ( __stdcall    *Release )( 
            IOleAdviseHolder    * This);
        
        HRESULT ( __stdcall    *Advise )( 
            IOleAdviseHolder    * This,
            /* [unique][in] */ IAdviseSink    *pAdvise,
            /* [out] */ DWORD    *pdwConnection);
        
        HRESULT ( __stdcall    *Unadvise )( 
            IOleAdviseHolder    * This,
            /* [in] */ DWORD dwConnection);
        
        HRESULT ( __stdcall    *EnumAdvise )( 
            IOleAdviseHolder    * This,
            /* [out] */ IEnumSTATDATA    *   *ppenumAdvise);
        
        HRESULT ( __stdcall    *SendOnRename )( 
            IOleAdviseHolder    * This,
            /* [unique][in] */ IMoniker    *pmk);
        
        HRESULT ( __stdcall    *SendOnSave )( 
            IOleAdviseHolder    * This);
        
        HRESULT ( __stdcall    *SendOnClose )( 
            IOleAdviseHolder    * This);
        
    } IOleAdviseHolderVtbl;

     struct  IOleAdviseHolder
    {
           struct IOleAdviseHolderVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 300 "C:\WATCOM\H\NT\oleidl.h"


/* C style interface */



HRESULT __stdcall IOleAdviseHolder_Advise_Proxy( 
    IOleAdviseHolder    * This,
    /* [unique][in] */ IAdviseSink    *pAdvise,
    /* [out] */ DWORD    *pdwConnection);


void  __stdcall  IOleAdviseHolder_Advise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleAdviseHolder_Unadvise_Proxy( 
    IOleAdviseHolder    * This,
    /* [in] */ DWORD dwConnection);


void  __stdcall  IOleAdviseHolder_Unadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleAdviseHolder_EnumAdvise_Proxy( 
    IOleAdviseHolder    * This,
    /* [out] */ IEnumSTATDATA    *   *ppenumAdvise);


void  __stdcall  IOleAdviseHolder_EnumAdvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleAdviseHolder_SendOnRename_Proxy( 
    IOleAdviseHolder    * This,
    /* [unique][in] */ IMoniker    *pmk);


void  __stdcall  IOleAdviseHolder_SendOnRename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleAdviseHolder_SendOnSave_Proxy( 
    IOleAdviseHolder    * This);


void  __stdcall  IOleAdviseHolder_SendOnSave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleAdviseHolder_SendOnClose_Proxy( 
    IOleAdviseHolder    * This);


void  __stdcall  IOleAdviseHolder_SendOnClose_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IOleAdviseHolder_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IOleCache
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */  IOleCache    *LPOLECACHE;


 extern "C"  const IID __cdecl IID_IOleCache;

/* C style interface */#line 425 "C:\WATCOM\H\NT\oleidl.h"

    typedef struct IOleCacheVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IOleCache    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IOleCache    * This);
        
        ULONG ( __stdcall    *Release )( 
            IOleCache    * This);
        
        HRESULT ( __stdcall    *Cache )( 
            IOleCache    * This,
            /* [unique][in] */ FORMATETC    *pformatetc,
            /* [in] */ DWORD advf,
            /* [out] */ DWORD    *pdwConnection);
        
        HRESULT ( __stdcall    *Uncache )( 
            IOleCache    * This,
            /* [in] */ DWORD dwConnection);
        
        HRESULT ( __stdcall    *EnumCache )( 
            IOleCache    * This,
            /* [out] */ IEnumSTATDATA    *   *ppenumSTATDATA);
        
        HRESULT ( __stdcall    *InitCache )( 
            IOleCache    * This,
            /* [unique][in] */ IDataObject    *pDataObject);
        
        HRESULT ( __stdcall    *SetData )( 
            IOleCache    * This,
            /* [unique][in] */ FORMATETC    *pformatetc,
            /* [unique][in] */ STGMEDIUM    *pmedium,
            /* [in] */ BOOL fRelease);
        
    } IOleCacheVtbl;

     struct  IOleCache
    {
           struct IOleCacheVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 502 "C:\WATCOM\H\NT\oleidl.h"


/* C style interface */



HRESULT __stdcall IOleCache_Cache_Proxy( 
    IOleCache    * This,
    /* [unique][in] */ FORMATETC    *pformatetc,
    /* [in] */ DWORD advf,
    /* [out] */ DWORD    *pdwConnection);


void  __stdcall  IOleCache_Cache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleCache_Uncache_Proxy( 
    IOleCache    * This,
    /* [in] */ DWORD dwConnection);


void  __stdcall  IOleCache_Uncache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleCache_EnumCache_Proxy( 
    IOleCache    * This,
    /* [out] */ IEnumSTATDATA    *   *ppenumSTATDATA);


void  __stdcall  IOleCache_EnumCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleCache_InitCache_Proxy( 
    IOleCache    * This,
    /* [unique][in] */ IDataObject    *pDataObject);


void  __stdcall  IOleCache_InitCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleCache_SetData_Proxy( 
    IOleCache    * This,
    /* [unique][in] */ FORMATETC    *pformatetc,
    /* [unique][in] */ STGMEDIUM    *pmedium,
    /* [in] */ BOOL fRelease);


void  __stdcall  IOleCache_SetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IOleCache_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IOleCache2
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][local][object] */ 


			/* size is 4 */
typedef /* [unique] */  IOleCache2    *LPOLECACHE2;

			/* size is 4 */


			/* size is 4 */


			/* size is 4 */


			/* size is 4 */


			/* size is 4 */


			/* size is 4 */


			/* size is 4 */


			/* size is 4 */


			/* size is 4 */


			/* size is 2 */
typedef /* [transmit] */  
enum tagDISCARDCACHE
    {	DISCARDCACHE_SAVEIFDIRTY	= 0,
	DISCARDCACHE_NOSAVE	= 1
    }	DISCARDCACHE;






 extern "C"  const IID __cdecl IID_IOleCache2;

/* C style interface */#line 647 "C:\WATCOM\H\NT\oleidl.h"

    typedef struct IOleCache2Vtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IOleCache2    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IOleCache2    * This);
        
        ULONG ( __stdcall    *Release )( 
            IOleCache2    * This);
        
        HRESULT ( __stdcall    *Cache )( 
            IOleCache2    * This,
            /* [unique][in] */ FORMATETC    *pformatetc,
            /* [in] */ DWORD advf,
            /* [out] */ DWORD    *pdwConnection);
        
        HRESULT ( __stdcall    *Uncache )( 
            IOleCache2    * This,
            /* [in] */ DWORD dwConnection);
        
        HRESULT ( __stdcall    *EnumCache )( 
            IOleCache2    * This,
            /* [out] */ IEnumSTATDATA    *   *ppenumSTATDATA);
        
        HRESULT ( __stdcall    *InitCache )( 
            IOleCache2    * This,
            /* [unique][in] */ IDataObject    *pDataObject);
        
        HRESULT ( __stdcall    *SetData )( 
            IOleCache2    * This,
            /* [unique][in] */ FORMATETC    *pformatetc,
            /* [unique][in] */ STGMEDIUM    *pmedium,
            /* [in] */ BOOL fRelease);
        
        HRESULT ( __stdcall    *UpdateCache )( 
            IOleCache2    * This,
            /* [in] */ LPDATAOBJECT pDataObject,
            /* [in] */ DWORD grfUpdf,
            /* [in] */ LPVOID pReserved);
        
        HRESULT ( __stdcall    *DiscardCache )( 
            IOleCache2    * This,
            /* [in] */ DWORD dwDiscardOptions);
        
    } IOleCache2Vtbl;

     struct  IOleCache2
    {
           struct IOleCache2Vtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 741 "C:\WATCOM\H\NT\oleidl.h"


/* C style interface */



HRESULT __stdcall IOleCache2_UpdateCache_Proxy( 
    IOleCache2    * This,
    /* [in] */ LPDATAOBJECT pDataObject,
    /* [in] */ DWORD grfUpdf,
    /* [in] */ LPVOID pReserved);


void  __stdcall  IOleCache2_UpdateCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleCache2_DiscardCache_Proxy( 
    IOleCache2    * This,
    /* [in] */ DWORD dwDiscardOptions);


void  __stdcall  IOleCache2_DiscardCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IOleCache2_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IOleCacheControl
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][local][object] */ 


			/* size is 4 */
typedef /* [unique] */  IOleCacheControl    *LPOLECACHECONTROL;


 extern "C"  const IID __cdecl IID_IOleCacheControl;

/* C style interface */#line 807 "C:\WATCOM\H\NT\oleidl.h"

    typedef struct IOleCacheControlVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IOleCacheControl    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IOleCacheControl    * This);
        
        ULONG ( __stdcall    *Release )( 
            IOleCacheControl    * This);
        
        HRESULT ( __stdcall    *OnRun )( 
            IOleCacheControl    * This,
            LPDATAOBJECT pDataObject);
        
        HRESULT ( __stdcall    *OnStop )( 
            IOleCacheControl    * This);
        
    } IOleCacheControlVtbl;

     struct  IOleCacheControl
    {
           struct IOleCacheControlVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 858 "C:\WATCOM\H\NT\oleidl.h"


/* C style interface */



HRESULT __stdcall IOleCacheControl_OnRun_Proxy( 
    IOleCacheControl    * This,
    LPDATAOBJECT pDataObject);


void  __stdcall  IOleCacheControl_OnRun_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleCacheControl_OnStop_Proxy( 
    IOleCacheControl    * This);


void  __stdcall  IOleCacheControl_OnStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IOleCacheControl_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IParseDisplayName
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IParseDisplayName    *LPPARSEDISPLAYNAME;


 extern "C"  const IID __cdecl IID_IParseDisplayName;

/* C style interface */#line 922 "C:\WATCOM\H\NT\oleidl.h"

    typedef struct IParseDisplayNameVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IParseDisplayName    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IParseDisplayName    * This);
        
        ULONG ( __stdcall    *Release )( 
            IParseDisplayName    * This);
        
        HRESULT ( __stdcall    *ParseDisplayName )( 
            IParseDisplayName    * This,
            /* [unique][in] */ IBindCtx    *pbc,
            /* [in] */ LPOLESTR pszDisplayName,
            /* [out] */ ULONG    *pchEaten,
            /* [out] */ IMoniker    *   *ppmkOut);
        
    } IParseDisplayNameVtbl;

     struct  IParseDisplayName
    {
           struct IParseDisplayNameVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 970 "C:\WATCOM\H\NT\oleidl.h"


/* C style interface */



HRESULT __stdcall IParseDisplayName_ParseDisplayName_Proxy( 
    IParseDisplayName    * This,
    /* [unique][in] */ IBindCtx    *pbc,
    /* [in] */ LPOLESTR pszDisplayName,
    /* [out] */ ULONG    *pchEaten,
    /* [out] */ IMoniker    *   *ppmkOut);


void  __stdcall  IParseDisplayName_ParseDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IParseDisplayName_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IOleContainer
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IOleContainer    *LPOLECONTAINER;


 extern "C"  const IID __cdecl IID_IOleContainer;

/* C style interface */#line 1027 "C:\WATCOM\H\NT\oleidl.h"

    typedef struct IOleContainerVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IOleContainer    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IOleContainer    * This);
        
        ULONG ( __stdcall    *Release )( 
            IOleContainer    * This);
        
        HRESULT ( __stdcall    *ParseDisplayName )( 
            IOleContainer    * This,
            /* [unique][in] */ IBindCtx    *pbc,
            /* [in] */ LPOLESTR pszDisplayName,
            /* [out] */ ULONG    *pchEaten,
            /* [out] */ IMoniker    *   *ppmkOut);
        
        HRESULT ( __stdcall    *EnumObjects )( 
            IOleContainer    * This,
            /* [in] */ DWORD grfFlags,
            /* [out] */ IEnumUnknown    *   *ppenum);
        
        HRESULT ( __stdcall    *LockContainer )( 
            IOleContainer    * This,
            /* [in] */ BOOL fLock);
        
    } IOleContainerVtbl;

     struct  IOleContainer
    {
           struct IOleContainerVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 1091 "C:\WATCOM\H\NT\oleidl.h"


/* C style interface */



HRESULT __stdcall IOleContainer_EnumObjects_Proxy( 
    IOleContainer    * This,
    /* [in] */ DWORD grfFlags,
    /* [out] */ IEnumUnknown    *   *ppenum);


void  __stdcall  IOleContainer_EnumObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleContainer_LockContainer_Proxy( 
    IOleContainer    * This,
    /* [in] */ BOOL fLock);


void  __stdcall  IOleContainer_LockContainer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IOleContainer_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IOleClientSite
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IOleClientSite    *LPOLECLIENTSITE;


 extern "C"  const IID __cdecl IID_IOleClientSite;

/* C style interface */#line 1168 "C:\WATCOM\H\NT\oleidl.h"

    typedef struct IOleClientSiteVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IOleClientSite    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IOleClientSite    * This);
        
        ULONG ( __stdcall    *Release )( 
            IOleClientSite    * This);
        
        HRESULT ( __stdcall    *SaveObject )( 
            IOleClientSite    * This);
        
        HRESULT ( __stdcall    *GetMoniker )( 
            IOleClientSite    * This,
            /* [in] */ DWORD dwAssign,
            /* [in] */ DWORD dwWhichMoniker,
            /* [out] */ IMoniker    *   *ppmk);
        
        HRESULT ( __stdcall    *GetContainer )( 
            IOleClientSite    * This,
            /* [out] */ IOleContainer    *   *ppContainer);
        
        HRESULT ( __stdcall    *ShowObject )( 
            IOleClientSite    * This);
        
        HRESULT ( __stdcall    *OnShowWindow )( 
            IOleClientSite    * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( __stdcall    *RequestNewObjectLayout )( 
            IOleClientSite    * This);
        
    } IOleClientSiteVtbl;

     struct  IOleClientSite
    {
           struct IOleClientSiteVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 1247 "C:\WATCOM\H\NT\oleidl.h"


/* C style interface */



HRESULT __stdcall IOleClientSite_SaveObject_Proxy( 
    IOleClientSite    * This);


void  __stdcall  IOleClientSite_SaveObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleClientSite_GetMoniker_Proxy( 
    IOleClientSite    * This,
    /* [in] */ DWORD dwAssign,
    /* [in] */ DWORD dwWhichMoniker,
    /* [out] */ IMoniker    *   *ppmk);


void  __stdcall  IOleClientSite_GetMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleClientSite_GetContainer_Proxy( 
    IOleClientSite    * This,
    /* [out] */ IOleContainer    *   *ppContainer);


void  __stdcall  IOleClientSite_GetContainer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleClientSite_ShowObject_Proxy( 
    IOleClientSite    * This);


void  __stdcall  IOleClientSite_ShowObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleClientSite_OnShowWindow_Proxy( 
    IOleClientSite    * This,
    /* [in] */ BOOL fShow);


void  __stdcall  IOleClientSite_OnShowWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleClientSite_RequestNewObjectLayout_Proxy( 
    IOleClientSite    * This);


void  __stdcall  IOleClientSite_RequestNewObjectLayout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IOleClientSite_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IOleObject
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IOleObject    *LPOLEOBJECT;

			/* size is 2 */
typedef 
enum tagOLEGETMONIKER
    {	OLEGETMONIKER_ONLYIFTHERE	= 1,
	OLEGETMONIKER_FORCEASSIGN	= 2,
	OLEGETMONIKER_UNASSIGN	= 3,
	OLEGETMONIKER_TEMPFORUSER	= 4
    }	OLEGETMONIKER;

			/* size is 2 */
typedef 
enum tagOLEWHICHMK
    {	OLEWHICHMK_CONTAINER	= 1,
	OLEWHICHMK_OBJREL	= 2,
	OLEWHICHMK_OBJFULL	= 3
    }	OLEWHICHMK;

			/* size is 2 */
typedef 
enum tagUSERCLASSTYPE
    {	USERCLASSTYPE_FULL	= 1,
	USERCLASSTYPE_SHORT	= 2,
	USERCLASSTYPE_APPNAME	= 3
    }	USERCLASSTYPE;

			/* size is 2 */
typedef 
enum tagOLEMISC
    {	OLEMISC_RECOMPOSEONRESIZE	= 1,
	OLEMISC_ONLYICONIC	= 2,
	OLEMISC_INSERTNOTREPLACE	= 4,
	OLEMISC_STATIC	= 8,
	OLEMISC_CANTLINKINSIDE	= 16,
	OLEMISC_CANLINKBYOLE1	= 32,
	OLEMISC_ISLINKOBJECT	= 64,
	OLEMISC_INSIDEOUT	= 128,
	OLEMISC_ACTIVATEWHENVISIBLE	= 256,
	OLEMISC_RENDERINGISDEVICEINDEPENDENT	= 512
    }	OLEMISC;

			/* size is 2 */
typedef 
enum tagOLECLOSE
    {	OLECLOSE_SAVEIFDIRTY	= 0,
	OLECLOSE_NOSAVE	= 1,
	OLECLOSE_PROMPTSAVE	= 2
    }	OLECLOSE;


 extern "C"  const IID __cdecl IID_IOleObject;

/* C style interface */#line 1479 "C:\WATCOM\H\NT\oleidl.h"

    typedef struct IOleObjectVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IOleObject    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IOleObject    * This);
        
        ULONG ( __stdcall    *Release )( 
            IOleObject    * This);
        
        HRESULT ( __stdcall    *SetClientSite )( 
            IOleObject    * This,
            /* [unique][in] */ IOleClientSite    *pClientSite);
        
        HRESULT ( __stdcall    *GetClientSite )( 
            IOleObject    * This,
            /* [out] */ IOleClientSite    *   *ppClientSite);
        
        HRESULT ( __stdcall    *SetHostNames )( 
            IOleObject    * This,
            /* [in] */ LPCOLESTR szContainerApp,
            /* [unique][in] */ LPCOLESTR szContainerObj);
        
        HRESULT ( __stdcall    *Close )( 
            IOleObject    * This,
            /* [in] */ DWORD dwSaveOption);
        
        HRESULT ( __stdcall    *SetMoniker )( 
            IOleObject    * This,
            /* [in] */ DWORD dwWhichMoniker,
            /* [unique][in] */ IMoniker    *pmk);
        
        HRESULT ( __stdcall    *GetMoniker )( 
            IOleObject    * This,
            /* [in] */ DWORD dwAssign,
            /* [in] */ DWORD dwWhichMoniker,
            /* [out] */ IMoniker    *   *ppmk);
        
        HRESULT ( __stdcall    *InitFromData )( 
            IOleObject    * This,
            /* [unique][in] */ IDataObject    *pDataObject,
            /* [in] */ BOOL fCreation,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( __stdcall    *GetClipboardData )( 
            IOleObject    * This,
            /* [in] */ DWORD dwReserved,
            /* [out] */ IDataObject    *   *ppDataObject);
        
        HRESULT ( __stdcall    *DoVerb )( 
            IOleObject    * This,
            /* [in] */ LONG iVerb,
            /* [unique][in] */ LPMSG lpmsg,
            /* [unique][in] */ IOleClientSite    *pActiveSite,
            /* [in] */ LONG lindex,
            /* [in] */ HWND hwndParent,
            /* [unique][in] */ LPCRECT lprcPosRect);
        
        HRESULT ( __stdcall    *EnumVerbs )( 
            IOleObject    * This,
            /* [out] */ IEnumOLEVERB    *   *ppEnumOleVerb);
        
        HRESULT ( __stdcall    *Update )( 
            IOleObject    * This);
        
        HRESULT ( __stdcall    *IsUpToDate )( 
            IOleObject    * This);
        
        HRESULT ( __stdcall    *GetUserClassID )( 
            IOleObject    * This,
            /* [out] */ CLSID    *pClsid);
        
        HRESULT ( __stdcall    *GetUserType )( 
            IOleObject    * This,
            /* [in] */ DWORD dwFormOfType,
            /* [out] */ LPOLESTR    *pszUserType);
        
        HRESULT ( __stdcall    *SetExtent )( 
            IOleObject    * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ SIZEL    *psizel);
        
        HRESULT ( __stdcall    *GetExtent )( 
            IOleObject    * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [out] */ SIZEL    *psizel);
        
        HRESULT ( __stdcall    *Advise )( 
            IOleObject    * This,
            /* [unique][in] */ IAdviseSink    *pAdvSink,
            /* [out] */ DWORD    *pdwConnection);
        
        HRESULT ( __stdcall    *Unadvise )( 
            IOleObject    * This,
            /* [in] */ DWORD dwConnection);
        
        HRESULT ( __stdcall    *EnumAdvise )( 
            IOleObject    * This,
            /* [out] */ IEnumSTATDATA    *   *ppenumAdvise);
        
        HRESULT ( __stdcall    *GetMiscStatus )( 
            IOleObject    * This,
            /* [in] */ DWORD dwAspect,
            /* [out] */ DWORD    *pdwStatus);
        
        HRESULT ( __stdcall    *SetColorScheme )( 
            IOleObject    * This,
            /* [in] */ LOGPALETTE    *pLogpal);
        
    } IOleObjectVtbl;

     struct  IOleObject
    {
           struct IOleObjectVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 1679 "C:\WATCOM\H\NT\oleidl.h"


/* C style interface */



HRESULT __stdcall IOleObject_SetClientSite_Proxy( 
    IOleObject    * This,
    /* [unique][in] */ IOleClientSite    *pClientSite);


void  __stdcall  IOleObject_SetClientSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_GetClientSite_Proxy( 
    IOleObject    * This,
    /* [out] */ IOleClientSite    *   *ppClientSite);


void  __stdcall  IOleObject_GetClientSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_SetHostNames_Proxy( 
    IOleObject    * This,
    /* [in] */ LPCOLESTR szContainerApp,
    /* [unique][in] */ LPCOLESTR szContainerObj);


void  __stdcall  IOleObject_SetHostNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_Close_Proxy( 
    IOleObject    * This,
    /* [in] */ DWORD dwSaveOption);


void  __stdcall  IOleObject_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_SetMoniker_Proxy( 
    IOleObject    * This,
    /* [in] */ DWORD dwWhichMoniker,
    /* [unique][in] */ IMoniker    *pmk);


void  __stdcall  IOleObject_SetMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_GetMoniker_Proxy( 
    IOleObject    * This,
    /* [in] */ DWORD dwAssign,
    /* [in] */ DWORD dwWhichMoniker,
    /* [out] */ IMoniker    *   *ppmk);


void  __stdcall  IOleObject_GetMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_InitFromData_Proxy( 
    IOleObject    * This,
    /* [unique][in] */ IDataObject    *pDataObject,
    /* [in] */ BOOL fCreation,
    /* [in] */ DWORD dwReserved);


void  __stdcall  IOleObject_InitFromData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_GetClipboardData_Proxy( 
    IOleObject    * This,
    /* [in] */ DWORD dwReserved,
    /* [out] */ IDataObject    *   *ppDataObject);


void  __stdcall  IOleObject_GetClipboardData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_DoVerb_Proxy( 
    IOleObject    * This,
    /* [in] */ LONG iVerb,
    /* [unique][in] */ LPMSG lpmsg,
    /* [unique][in] */ IOleClientSite    *pActiveSite,
    /* [in] */ LONG lindex,
    /* [in] */ HWND hwndParent,
    /* [unique][in] */ LPCRECT lprcPosRect);


void  __stdcall  IOleObject_DoVerb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_EnumVerbs_Proxy( 
    IOleObject    * This,
    /* [out] */ IEnumOLEVERB    *   *ppEnumOleVerb);


void  __stdcall  IOleObject_EnumVerbs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_Update_Proxy( 
    IOleObject    * This);


void  __stdcall  IOleObject_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_IsUpToDate_Proxy( 
    IOleObject    * This);


void  __stdcall  IOleObject_IsUpToDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_GetUserClassID_Proxy( 
    IOleObject    * This,
    /* [out] */ CLSID    *pClsid);


void  __stdcall  IOleObject_GetUserClassID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_GetUserType_Proxy( 
    IOleObject    * This,
    /* [in] */ DWORD dwFormOfType,
    /* [out] */ LPOLESTR    *pszUserType);


void  __stdcall  IOleObject_GetUserType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_SetExtent_Proxy( 
    IOleObject    * This,
    /* [in] */ DWORD dwDrawAspect,
    /* [in] */ SIZEL    *psizel);


void  __stdcall  IOleObject_SetExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_GetExtent_Proxy( 
    IOleObject    * This,
    /* [in] */ DWORD dwDrawAspect,
    /* [out] */ SIZEL    *psizel);


void  __stdcall  IOleObject_GetExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_Advise_Proxy( 
    IOleObject    * This,
    /* [unique][in] */ IAdviseSink    *pAdvSink,
    /* [out] */ DWORD    *pdwConnection);


void  __stdcall  IOleObject_Advise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_Unadvise_Proxy( 
    IOleObject    * This,
    /* [in] */ DWORD dwConnection);


void  __stdcall  IOleObject_Unadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_EnumAdvise_Proxy( 
    IOleObject    * This,
    /* [out] */ IEnumSTATDATA    *   *ppenumAdvise);


void  __stdcall  IOleObject_EnumAdvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_GetMiscStatus_Proxy( 
    IOleObject    * This,
    /* [in] */ DWORD dwAspect,
    /* [out] */ DWORD    *pdwStatus);


void  __stdcall  IOleObject_GetMiscStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_SetColorScheme_Proxy( 
    IOleObject    * This,
    /* [in] */ LOGPALETTE    *pLogpal);


void  __stdcall  IOleObject_SetColorScheme_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IOleObject_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IOLETypes
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [auto_handle][uuid] */ 


			/* size is 2 */
typedef 
enum tagOLERENDER
    {	OLERENDER_NONE	= 0,
	OLERENDER_DRAW	= 1,
	OLERENDER_FORMAT	= 2,
	OLERENDER_ASIS	= 3
    }	OLERENDER;

			/* size is 4 */
typedef OLERENDER    *LPOLERENDER;

			/* size is 52 */
typedef struct  tagOBJECTDESCRIPTOR
    {
    ULONG cbSize;
    CLSID clsid;
    DWORD dwDrawAspect;
    SIZEL sizel;
    POINTL pointl;
    DWORD dwStatus;
    DWORD dwFullUserTypeName;
    DWORD dwSrcOfCopy;
    }	OBJECTDESCRIPTOR;

			/* size is 4 */
typedef struct tagOBJECTDESCRIPTOR    *POBJECTDESCRIPTOR;

			/* size is 4 */
typedef struct tagOBJECTDESCRIPTOR    *LPOBJECTDESCRIPTOR;

			/* size is 52 */
typedef struct tagOBJECTDESCRIPTOR LINKSRCDESCRIPTOR;

			/* size is 4 */
typedef struct tagOBJECTDESCRIPTOR    *PLINKSRCDESCRIPTOR;

			/* size is 4 */
typedef struct tagOBJECTDESCRIPTOR    *LPLINKSRCDESCRIPTOR;



extern RPC_IF_HANDLE IOLETypes_v0_0_c_ifspec;
extern RPC_IF_HANDLE IOLETypes_v0_0_s_ifspec;
/* __IOLETypes_INTERFACE_DEFINED__ */




/****************************************
 * Generated header for interface: IOleWindow
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IOleWindow    *LPOLEWINDOW;


 extern "C"  const IID __cdecl IID_IOleWindow;

/* C style interface */#line 2044 "C:\WATCOM\H\NT\oleidl.h"

    typedef struct IOleWindowVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IOleWindow    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IOleWindow    * This);
        
        ULONG ( __stdcall    *Release )( 
            IOleWindow    * This);
        
        /* [input_sync] */ HRESULT ( __stdcall    *GetWindow )( 
            IOleWindow    * This,
            /* [out] */ HWND    *phwnd);
        
        HRESULT ( __stdcall    *ContextSensitiveHelp )( 
            IOleWindow    * This,
            /* [in] */ BOOL fEnterMode);
        
    } IOleWindowVtbl;

     struct  IOleWindow
    {
           struct IOleWindowVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 2096 "C:\WATCOM\H\NT\oleidl.h"


/* C style interface */



/* [input_sync] */ HRESULT __stdcall IOleWindow_GetWindow_Proxy( 
    IOleWindow    * This,
    /* [out] */ HWND    *phwnd);


void  __stdcall  IOleWindow_GetWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleWindow_ContextSensitiveHelp_Proxy( 
    IOleWindow    * This,
    /* [in] */ BOOL fEnterMode);


void  __stdcall  IOleWindow_ContextSensitiveHelp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IOleWindow_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IOleLink
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */  IOleLink    *LPOLELINK;

			/* size is 2 */
typedef 
enum tagOLEUPDATE
    {	OLEUPDATE_ALWAYS	= 1,
	OLEUPDATE_ONCALL	= 3
    }	OLEUPDATE;

			/* size is 4 */
typedef OLEUPDATE    *LPOLEUPDATE;

			/* size is 4 */
typedef OLEUPDATE    *POLEUPDATE;

			/* size is 2 */
typedef 
enum tagOLELINKBIND
    {	OLELINKBIND_EVENIFCLASSDIFF	= 1
    }	OLELINKBIND;


 extern "C"  const IID __cdecl IID_IOleLink;

/* C style interface */#line 2207 "C:\WATCOM\H\NT\oleidl.h"

    typedef struct IOleLinkVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IOleLink    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IOleLink    * This);
        
        ULONG ( __stdcall    *Release )( 
            IOleLink    * This);
        
        HRESULT ( __stdcall    *SetUpdateOptions )( 
            IOleLink    * This,
            /* [in] */ DWORD dwUpdateOpt);
        
        HRESULT ( __stdcall    *GetUpdateOptions )( 
            IOleLink    * This,
            /* [out] */ DWORD    *pdwUpdateOpt);
        
        HRESULT ( __stdcall    *SetSourceMoniker )( 
            IOleLink    * This,
            /* [unique][in] */ IMoniker    *pmk,
            /* [in] */  const CLSID &  rclsid);
        
        HRESULT ( __stdcall    *GetSourceMoniker )( 
            IOleLink    * This,
            /* [out] */ IMoniker    *   *ppmk);
        
        HRESULT ( __stdcall    *SetSourceDisplayName )( 
            IOleLink    * This,
            /* [in] */ LPCOLESTR pszStatusText);
        
        HRESULT ( __stdcall    *GetSourceDisplayName )( 
            IOleLink    * This,
            /* [out] */ LPOLESTR    *ppszDisplayName);
        
        HRESULT ( __stdcall    *BindToSource )( 
            IOleLink    * This,
            /* [in] */ DWORD bindflags,
            /* [unique][in] */ IBindCtx    *pbc);
        
        HRESULT ( __stdcall    *BindIfRunning )( 
            IOleLink    * This);
        
        HRESULT ( __stdcall    *GetBoundSource )( 
            IOleLink    * This,
            /* [out] */ IUnknown    *   *ppunk);
        
        HRESULT ( __stdcall    *UnbindSource )( 
            IOleLink    * This);
        
        HRESULT ( __stdcall    *Update )( 
            IOleLink    * This,
            /* [unique][in] */ IBindCtx    *pbc);
        
    } IOleLinkVtbl;

     struct  IOleLink
    {
           struct IOleLinkVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 2322 "C:\WATCOM\H\NT\oleidl.h"


/* C style interface */



HRESULT __stdcall IOleLink_SetUpdateOptions_Proxy( 
    IOleLink    * This,
    /* [in] */ DWORD dwUpdateOpt);


void  __stdcall  IOleLink_SetUpdateOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleLink_GetUpdateOptions_Proxy( 
    IOleLink    * This,
    /* [out] */ DWORD    *pdwUpdateOpt);


void  __stdcall  IOleLink_GetUpdateOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleLink_SetSourceMoniker_Proxy( 
    IOleLink    * This,
    /* [unique][in] */ IMoniker    *pmk,
    /* [in] */  const CLSID &  rclsid);


void  __stdcall  IOleLink_SetSourceMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleLink_GetSourceMoniker_Proxy( 
    IOleLink    * This,
    /* [out] */ IMoniker    *   *ppmk);


void  __stdcall  IOleLink_GetSourceMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleLink_SetSourceDisplayName_Proxy( 
    IOleLink    * This,
    /* [in] */ LPCOLESTR pszStatusText);


void  __stdcall  IOleLink_SetSourceDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleLink_GetSourceDisplayName_Proxy( 
    IOleLink    * This,
    /* [out] */ LPOLESTR    *ppszDisplayName);


void  __stdcall  IOleLink_GetSourceDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleLink_BindToSource_Proxy( 
    IOleLink    * This,
    /* [in] */ DWORD bindflags,
    /* [unique][in] */ IBindCtx    *pbc);


void  __stdcall  IOleLink_BindToSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleLink_BindIfRunning_Proxy( 
    IOleLink    * This);


void  __stdcall  IOleLink_BindIfRunning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleLink_GetBoundSource_Proxy( 
    IOleLink    * This,
    /* [out] */ IUnknown    *   *ppunk);


void  __stdcall  IOleLink_GetBoundSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleLink_UnbindSource_Proxy( 
    IOleLink    * This);


void  __stdcall  IOleLink_UnbindSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleLink_Update_Proxy( 
    IOleLink    * This,
    /* [unique][in] */ IBindCtx    *pbc);


void  __stdcall  IOleLink_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IOleLink_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IOleItemContainer
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IOleItemContainer    *LPOLEITEMCONTAINER;

			/* size is 2 */
typedef 
enum tagBINDSPEED
    {	BINDSPEED_INDEFINITE	= 1,
	BINDSPEED_MODERATE	= 2,
	BINDSPEED_IMMEDIATE	= 3
    }	BINDSPEED;

			/* size is 2 */
typedef /* [v1_enum] */  
enum tagOLECONTF
    {	OLECONTF_EMBEDDINGS	= 1,
	OLECONTF_LINKS	= 2,
	OLECONTF_OTHERS	= 4,
	OLECONTF_ONLYUSER	= 8,
	OLECONTF_ONLYIFRUNNING	= 16
    }	OLECONTF;


 extern "C"  const IID __cdecl IID_IOleItemContainer;

/* C style interface */#line 2523 "C:\WATCOM\H\NT\oleidl.h"

    typedef struct IOleItemContainerVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IOleItemContainer    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IOleItemContainer    * This);
        
        ULONG ( __stdcall    *Release )( 
            IOleItemContainer    * This);
        
        HRESULT ( __stdcall    *ParseDisplayName )( 
            IOleItemContainer    * This,
            /* [unique][in] */ IBindCtx    *pbc,
            /* [in] */ LPOLESTR pszDisplayName,
            /* [out] */ ULONG    *pchEaten,
            /* [out] */ IMoniker    *   *ppmkOut);
        
        HRESULT ( __stdcall    *EnumObjects )( 
            IOleItemContainer    * This,
            /* [in] */ DWORD grfFlags,
            /* [out] */ IEnumUnknown    *   *ppenum);
        
        HRESULT ( __stdcall    *LockContainer )( 
            IOleItemContainer    * This,
            /* [in] */ BOOL fLock);
        
        /* [local] */ HRESULT ( __stdcall    * GetObjectA  )( 
            IOleItemContainer    * This,
            /* [in] */ LPOLESTR pszItem,
            /* [in] */ DWORD dwSpeedNeeded,
            /* [unique][in] */ IBindCtx    *pbc,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        /* [local] */ HRESULT ( __stdcall    *GetObjectStorage )( 
            IOleItemContainer    * This,
            /* [in] */ LPOLESTR pszItem,
            /* [unique][in] */ IBindCtx    *pbc,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvStorage);
        
        HRESULT ( __stdcall    *IsRunning )( 
            IOleItemContainer    * This,
            /* [in] */ LPOLESTR pszItem);
        
    } IOleItemContainerVtbl;

     struct  IOleItemContainer
    {
           struct IOleItemContainerVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 2616 "C:\WATCOM\H\NT\oleidl.h"


/* C style interface */



/* [call_as] */ HRESULT __stdcall IOleItemContainer_RemoteGetObject_Proxy( 
    IOleItemContainer    * This,
    /* [in] */ LPOLESTR pszItem,
    /* [in] */ DWORD dwSpeedNeeded,
    /* [unique][in] */ IBindCtx    *pbc,
    /* [in] */  const IID &  riid,
    /* [iid_is][out] */ IUnknown    *   *ppvObject);


void  __stdcall  IOleItemContainer_RemoteGetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IOleItemContainer_RemoteGetObjectStorage_Proxy( 
    IOleItemContainer    * This,
    /* [in] */ LPOLESTR pszItem,
    /* [unique][in] */ IBindCtx    *pbc,
    /* [in] */  const IID &  riid,
    /* [iid_is][out] */ IUnknown    *   *ppvStorage);


void  __stdcall  IOleItemContainer_RemoteGetObjectStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleItemContainer_IsRunning_Proxy( 
    IOleItemContainer    * This,
    /* [in] */ LPOLESTR pszItem);


void  __stdcall  IOleItemContainer_IsRunning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IOleItemContainer_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IOleInPlaceUIWindow
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IOleInPlaceUIWindow    *LPOLEINPLACEUIWINDOW;

			/* size is 16 */
typedef RECT BORDERWIDTHS;

			/* size is 4 */
typedef LPRECT LPBORDERWIDTHS;

			/* size is 4 */
typedef LPCRECT LPCBORDERWIDTHS;


 extern "C"  const IID __cdecl IID_IOleInPlaceUIWindow;

/* C style interface */#line 2716 "C:\WATCOM\H\NT\oleidl.h"

    typedef struct IOleInPlaceUIWindowVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IOleInPlaceUIWindow    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IOleInPlaceUIWindow    * This);
        
        ULONG ( __stdcall    *Release )( 
            IOleInPlaceUIWindow    * This);
        
        /* [input_sync] */ HRESULT ( __stdcall    *GetWindow )( 
            IOleInPlaceUIWindow    * This,
            /* [out] */ HWND    *phwnd);
        
        HRESULT ( __stdcall    *ContextSensitiveHelp )( 
            IOleInPlaceUIWindow    * This,
            /* [in] */ BOOL fEnterMode);
        
        /* [input_sync] */ HRESULT ( __stdcall    *GetBorder )( 
            IOleInPlaceUIWindow    * This,
            /* [out] */ LPRECT lprectBorder);
        
        /* [input_sync] */ HRESULT ( __stdcall    *RequestBorderSpace )( 
            IOleInPlaceUIWindow    * This,
            /* [unique][in] */ LPCBORDERWIDTHS pborderwidths);
        
        /* [input_sync] */ HRESULT ( __stdcall    *SetBorderSpace )( 
            IOleInPlaceUIWindow    * This,
            /* [unique][in] */ LPCBORDERWIDTHS pborderwidths);
        
        HRESULT ( __stdcall    *SetActiveObject )( 
            IOleInPlaceUIWindow    * This,
            /* [unique][in] */ IOleInPlaceActiveObject    *pActiveObject,
            /* [unique][string][in] */ LPCOLESTR pszObjName);
        
    } IOleInPlaceUIWindowVtbl;

     struct  IOleInPlaceUIWindow
    {
           struct IOleInPlaceUIWindowVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 2798 "C:\WATCOM\H\NT\oleidl.h"


/* C style interface */



/* [input_sync] */ HRESULT __stdcall IOleInPlaceUIWindow_GetBorder_Proxy( 
    IOleInPlaceUIWindow    * This,
    /* [out] */ LPRECT lprectBorder);


void  __stdcall  IOleInPlaceUIWindow_GetBorder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [input_sync] */ HRESULT __stdcall IOleInPlaceUIWindow_RequestBorderSpace_Proxy( 
    IOleInPlaceUIWindow    * This,
    /* [unique][in] */ LPCBORDERWIDTHS pborderwidths);


void  __stdcall  IOleInPlaceUIWindow_RequestBorderSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [input_sync] */ HRESULT __stdcall IOleInPlaceUIWindow_SetBorderSpace_Proxy( 
    IOleInPlaceUIWindow    * This,
    /* [unique][in] */ LPCBORDERWIDTHS pborderwidths);


void  __stdcall  IOleInPlaceUIWindow_SetBorderSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceUIWindow_SetActiveObject_Proxy( 
    IOleInPlaceUIWindow    * This,
    /* [unique][in] */ IOleInPlaceActiveObject    *pActiveObject,
    /* [unique][string][in] */ LPCOLESTR pszObjName);


void  __stdcall  IOleInPlaceUIWindow_SetActiveObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IOleInPlaceUIWindow_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IOleInPlaceActiveObject
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IOleInPlaceActiveObject    *LPOLEINPLACEACTIVEOBJECT;


 extern "C"  const IID __cdecl IID_IOleInPlaceActiveObject;

/* C style interface */#line 2899 "C:\WATCOM\H\NT\oleidl.h"

    typedef struct IOleInPlaceActiveObjectVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IOleInPlaceActiveObject    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IOleInPlaceActiveObject    * This);
        
        ULONG ( __stdcall    *Release )( 
            IOleInPlaceActiveObject    * This);
        
        /* [input_sync] */ HRESULT ( __stdcall    *GetWindow )( 
            IOleInPlaceActiveObject    * This,
            /* [out] */ HWND    *phwnd);
        
        HRESULT ( __stdcall    *ContextSensitiveHelp )( 
            IOleInPlaceActiveObject    * This,
            /* [in] */ BOOL fEnterMode);
        
        /* [local] */ HRESULT ( __stdcall    * TranslateAcceleratorA  )( 
            IOleInPlaceActiveObject    * This,
            /* [in] */ LPMSG lpmsg);
        
        /* [input_sync] */ HRESULT ( __stdcall    *OnFrameWindowActivate )( 
            IOleInPlaceActiveObject    * This,
            /* [in] */ BOOL fActivate);
        
        /* [input_sync] */ HRESULT ( __stdcall    *OnDocWindowActivate )( 
            IOleInPlaceActiveObject    * This,
            /* [in] */ BOOL fActivate);
        
        /* [local] */ HRESULT ( __stdcall    *ResizeBorder )( 
            IOleInPlaceActiveObject    * This,
            /* [in] */ LPCRECT prcBorder,
            /* [unique][in] */ IOleInPlaceUIWindow    *pUIWindow,
            /* [in] */ BOOL fFrameWindow);
        
        HRESULT ( __stdcall    *EnableModeless )( 
            IOleInPlaceActiveObject    * This,
            /* [in] */ BOOL fEnable);
        
    } IOleInPlaceActiveObjectVtbl;

     struct  IOleInPlaceActiveObject
    {
           struct IOleInPlaceActiveObjectVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 2989 "C:\WATCOM\H\NT\oleidl.h"


/* C style interface */



/* [call_as] */ HRESULT __stdcall IOleInPlaceActiveObject_RemoteTranslateAccelerator_Proxy( 
    IOleInPlaceActiveObject    * This);


void  __stdcall  IOleInPlaceActiveObject_RemoteTranslateAccelerator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [input_sync] */ HRESULT __stdcall IOleInPlaceActiveObject_OnFrameWindowActivate_Proxy( 
    IOleInPlaceActiveObject    * This,
    /* [in] */ BOOL fActivate);


void  __stdcall  IOleInPlaceActiveObject_OnFrameWindowActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [input_sync] */ HRESULT __stdcall IOleInPlaceActiveObject_OnDocWindowActivate_Proxy( 
    IOleInPlaceActiveObject    * This,
    /* [in] */ BOOL fActivate);


void  __stdcall  IOleInPlaceActiveObject_OnDocWindowActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [input_sync][call_as] */ HRESULT __stdcall IOleInPlaceActiveObject_RemoteResizeBorder_Proxy( 
    IOleInPlaceActiveObject    * This,
    /* [in] */ LPCRECT prcBorder,
    /* [in] */  const IID &  riid,
    /* [iid_is][unique][in] */ IOleInPlaceUIWindow    *pUIWindow,
    /* [in] */ BOOL fFrameWindow);


void  __stdcall  IOleInPlaceActiveObject_RemoteResizeBorder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceActiveObject_EnableModeless_Proxy( 
    IOleInPlaceActiveObject    * This,
    /* [in] */ BOOL fEnable);


void  __stdcall  IOleInPlaceActiveObject_EnableModeless_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IOleInPlaceActiveObject_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IOleInPlaceFrame
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IOleInPlaceFrame    *LPOLEINPLACEFRAME;

			/* size is 20 */
typedef struct  tagOIFI
    {
    UINT cb;
    BOOL fMDIApp;
    HWND hwndFrame;
    HACCEL haccel;
    UINT cAccelEntries;
    }	OLEINPLACEFRAMEINFO;

			/* size is 4 */
typedef struct tagOIFI    *LPOLEINPLACEFRAMEINFO;

			/* size is 24 */
typedef struct  tagOleMenuGroupWidths
    {
    LONG width[ 6 ];
    }	OLEMENUGROUPWIDTHS;

			/* size is 4 */
typedef struct tagOleMenuGroupWidths    *LPOLEMENUGROUPWIDTHS;

			/* size is 4 */
typedef HGLOBAL HOLEMENU;


 extern "C"  const IID __cdecl IID_IOleInPlaceFrame;

/* C style interface */#line 3133 "C:\WATCOM\H\NT\oleidl.h"

    typedef struct IOleInPlaceFrameVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IOleInPlaceFrame    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IOleInPlaceFrame    * This);
        
        ULONG ( __stdcall    *Release )( 
            IOleInPlaceFrame    * This);
        
        /* [input_sync] */ HRESULT ( __stdcall    *GetWindow )( 
            IOleInPlaceFrame    * This,
            /* [out] */ HWND    *phwnd);
        
        HRESULT ( __stdcall    *ContextSensitiveHelp )( 
            IOleInPlaceFrame    * This,
            /* [in] */ BOOL fEnterMode);
        
        /* [input_sync] */ HRESULT ( __stdcall    *GetBorder )( 
            IOleInPlaceFrame    * This,
            /* [out] */ LPRECT lprectBorder);
        
        /* [input_sync] */ HRESULT ( __stdcall    *RequestBorderSpace )( 
            IOleInPlaceFrame    * This,
            /* [unique][in] */ LPCBORDERWIDTHS pborderwidths);
        
        /* [input_sync] */ HRESULT ( __stdcall    *SetBorderSpace )( 
            IOleInPlaceFrame    * This,
            /* [unique][in] */ LPCBORDERWIDTHS pborderwidths);
        
        HRESULT ( __stdcall    *SetActiveObject )( 
            IOleInPlaceFrame    * This,
            /* [unique][in] */ IOleInPlaceActiveObject    *pActiveObject,
            /* [unique][string][in] */ LPCOLESTR pszObjName);
        
        HRESULT ( __stdcall    *InsertMenus )( 
            IOleInPlaceFrame    * This,
            /* [in] */ HMENU hmenuShared,
            /* [out][in] */ LPOLEMENUGROUPWIDTHS lpMenuWidths);
        
        /* [input_sync] */ HRESULT ( __stdcall    *SetMenu )( 
            IOleInPlaceFrame    * This,
            /* [in] */ HMENU hmenuShared,
            /* [in] */ HOLEMENU holemenu,
            /* [in] */ HWND hwndActiveObject);
        
        HRESULT ( __stdcall    *RemoveMenus )( 
            IOleInPlaceFrame    * This,
            /* [in] */ HMENU hmenuShared);
        
        /* [input_sync] */ HRESULT ( __stdcall    *SetStatusText )( 
            IOleInPlaceFrame    * This,
            /* [in] */ LPCOLESTR pszStatusText);
        
        HRESULT ( __stdcall    *EnableModeless )( 
            IOleInPlaceFrame    * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( __stdcall    * TranslateAcceleratorA  )( 
            IOleInPlaceFrame    * This,
            /* [in] */ LPMSG lpmsg,
            /* [in] */ WORD wID);
        
    } IOleInPlaceFrameVtbl;

     struct  IOleInPlaceFrame
    {
           struct IOleInPlaceFrameVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 3262 "C:\WATCOM\H\NT\oleidl.h"


/* C style interface */



HRESULT __stdcall IOleInPlaceFrame_InsertMenus_Proxy( 
    IOleInPlaceFrame    * This,
    /* [in] */ HMENU hmenuShared,
    /* [out][in] */ LPOLEMENUGROUPWIDTHS lpMenuWidths);


void  __stdcall  IOleInPlaceFrame_InsertMenus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [input_sync] */ HRESULT __stdcall IOleInPlaceFrame_SetMenu_Proxy( 
    IOleInPlaceFrame    * This,
    /* [in] */ HMENU hmenuShared,
    /* [in] */ HOLEMENU holemenu,
    /* [in] */ HWND hwndActiveObject);


void  __stdcall  IOleInPlaceFrame_SetMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceFrame_RemoveMenus_Proxy( 
    IOleInPlaceFrame    * This,
    /* [in] */ HMENU hmenuShared);


void  __stdcall  IOleInPlaceFrame_RemoveMenus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [input_sync] */ HRESULT __stdcall IOleInPlaceFrame_SetStatusText_Proxy( 
    IOleInPlaceFrame    * This,
    /* [in] */ LPCOLESTR pszStatusText);


void  __stdcall  IOleInPlaceFrame_SetStatusText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceFrame_EnableModeless_Proxy( 
    IOleInPlaceFrame    * This,
    /* [in] */ BOOL fEnable);


void  __stdcall  IOleInPlaceFrame_EnableModeless_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceFrame_TranslateAccelerator_Proxy( 
    IOleInPlaceFrame    * This,
    /* [in] */ LPMSG lpmsg,
    /* [in] */ WORD wID);


void  __stdcall  IOleInPlaceFrame_TranslateAccelerator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IOleInPlaceFrame_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IOleInPlaceObject
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IOleInPlaceObject    *LPOLEINPLACEOBJECT;


 extern "C"  const IID __cdecl IID_IOleInPlaceObject;

/* C style interface */#line 3383 "C:\WATCOM\H\NT\oleidl.h"

    typedef struct IOleInPlaceObjectVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IOleInPlaceObject    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IOleInPlaceObject    * This);
        
        ULONG ( __stdcall    *Release )( 
            IOleInPlaceObject    * This);
        
        /* [input_sync] */ HRESULT ( __stdcall    *GetWindow )( 
            IOleInPlaceObject    * This,
            /* [out] */ HWND    *phwnd);
        
        HRESULT ( __stdcall    *ContextSensitiveHelp )( 
            IOleInPlaceObject    * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( __stdcall    *InPlaceDeactivate )( 
            IOleInPlaceObject    * This);
        
        HRESULT ( __stdcall    *UIDeactivate )( 
            IOleInPlaceObject    * This);
        
        /* [input_sync] */ HRESULT ( __stdcall    *SetObjectRects )( 
            IOleInPlaceObject    * This,
            /* [in] */ LPCRECT lprcPosRect,
            /* [in] */ LPCRECT lprcClipRect);
        
        HRESULT ( __stdcall    *ReactivateAndUndo )( 
            IOleInPlaceObject    * This);
        
    } IOleInPlaceObjectVtbl;

     struct  IOleInPlaceObject
    {
           struct IOleInPlaceObjectVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 3462 "C:\WATCOM\H\NT\oleidl.h"


/* C style interface */



HRESULT __stdcall IOleInPlaceObject_InPlaceDeactivate_Proxy( 
    IOleInPlaceObject    * This);


void  __stdcall  IOleInPlaceObject_InPlaceDeactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceObject_UIDeactivate_Proxy( 
    IOleInPlaceObject    * This);


void  __stdcall  IOleInPlaceObject_UIDeactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [input_sync] */ HRESULT __stdcall IOleInPlaceObject_SetObjectRects_Proxy( 
    IOleInPlaceObject    * This,
    /* [in] */ LPCRECT lprcPosRect,
    /* [in] */ LPCRECT lprcClipRect);


void  __stdcall  IOleInPlaceObject_SetObjectRects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceObject_ReactivateAndUndo_Proxy( 
    IOleInPlaceObject    * This);


void  __stdcall  IOleInPlaceObject_ReactivateAndUndo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IOleInPlaceObject_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IOleInPlaceSite
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IOleInPlaceSite    *LPOLEINPLACESITE;


 extern "C"  const IID __cdecl IID_IOleInPlaceSite;

/* C style interface */#line 3571 "C:\WATCOM\H\NT\oleidl.h"

    typedef struct IOleInPlaceSiteVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IOleInPlaceSite    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IOleInPlaceSite    * This);
        
        ULONG ( __stdcall    *Release )( 
            IOleInPlaceSite    * This);
        
        /* [input_sync] */ HRESULT ( __stdcall    *GetWindow )( 
            IOleInPlaceSite    * This,
            /* [out] */ HWND    *phwnd);
        
        HRESULT ( __stdcall    *ContextSensitiveHelp )( 
            IOleInPlaceSite    * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( __stdcall    *CanInPlaceActivate )( 
            IOleInPlaceSite    * This);
        
        HRESULT ( __stdcall    *OnInPlaceActivate )( 
            IOleInPlaceSite    * This);
        
        HRESULT ( __stdcall    *OnUIActivate )( 
            IOleInPlaceSite    * This);
        
        HRESULT ( __stdcall    *GetWindowContext )( 
            IOleInPlaceSite    * This,
            /* [out] */ IOleInPlaceFrame    *   *ppFrame,
            /* [out] */ IOleInPlaceUIWindow    *   *ppDoc,
            /* [out] */ LPRECT lprcPosRect,
            /* [out] */ LPRECT lprcClipRect,
            /* [out][in] */ LPOLEINPLACEFRAMEINFO lpFrameInfo);
        
        HRESULT ( __stdcall    *Scroll )( 
            IOleInPlaceSite    * This,
            /* [in] */ SIZE scrollExtant);
        
        HRESULT ( __stdcall    *OnUIDeactivate )( 
            IOleInPlaceSite    * This,
            /* [in] */ BOOL fUndoable);
        
        HRESULT ( __stdcall    *OnInPlaceDeactivate )( 
            IOleInPlaceSite    * This);
        
        HRESULT ( __stdcall    *DiscardUndoState )( 
            IOleInPlaceSite    * This);
        
        HRESULT ( __stdcall    *DeactivateAndUndo )( 
            IOleInPlaceSite    * This);
        
        HRESULT ( __stdcall    *OnPosRectChange )( 
            IOleInPlaceSite    * This,
            /* [in] */ LPCRECT lprcPosRect);
        
    } IOleInPlaceSiteVtbl;

     struct  IOleInPlaceSite
    {
           struct IOleInPlaceSiteVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 3692 "C:\WATCOM\H\NT\oleidl.h"


/* C style interface */



HRESULT __stdcall IOleInPlaceSite_CanInPlaceActivate_Proxy( 
    IOleInPlaceSite    * This);


void  __stdcall  IOleInPlaceSite_CanInPlaceActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceSite_OnInPlaceActivate_Proxy( 
    IOleInPlaceSite    * This);


void  __stdcall  IOleInPlaceSite_OnInPlaceActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceSite_OnUIActivate_Proxy( 
    IOleInPlaceSite    * This);


void  __stdcall  IOleInPlaceSite_OnUIActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceSite_GetWindowContext_Proxy( 
    IOleInPlaceSite    * This,
    /* [out] */ IOleInPlaceFrame    *   *ppFrame,
    /* [out] */ IOleInPlaceUIWindow    *   *ppDoc,
    /* [out] */ LPRECT lprcPosRect,
    /* [out] */ LPRECT lprcClipRect,
    /* [out][in] */ LPOLEINPLACEFRAMEINFO lpFrameInfo);


void  __stdcall  IOleInPlaceSite_GetWindowContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceSite_Scroll_Proxy( 
    IOleInPlaceSite    * This,
    /* [in] */ SIZE scrollExtant);


void  __stdcall  IOleInPlaceSite_Scroll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceSite_OnUIDeactivate_Proxy( 
    IOleInPlaceSite    * This,
    /* [in] */ BOOL fUndoable);


void  __stdcall  IOleInPlaceSite_OnUIDeactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceSite_OnInPlaceDeactivate_Proxy( 
    IOleInPlaceSite    * This);


void  __stdcall  IOleInPlaceSite_OnInPlaceDeactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceSite_DiscardUndoState_Proxy( 
    IOleInPlaceSite    * This);


void  __stdcall  IOleInPlaceSite_DiscardUndoState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceSite_DeactivateAndUndo_Proxy( 
    IOleInPlaceSite    * This);


void  __stdcall  IOleInPlaceSite_DeactivateAndUndo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceSite_OnPosRectChange_Proxy( 
    IOleInPlaceSite    * This,
    /* [in] */ LPCRECT lprcPosRect);


void  __stdcall  IOleInPlaceSite_OnPosRectChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IOleInPlaceSite_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IViewObject
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */  IViewObject    *LPVIEWOBJECT;


 extern "C"  const IID __cdecl IID_IViewObject;

/* C style interface */#line 3885 "C:\WATCOM\H\NT\oleidl.h"

    typedef struct IViewObjectVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IViewObject    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IViewObject    * This);
        
        ULONG ( __stdcall    *Release )( 
            IViewObject    * This);
        
        HRESULT ( __stdcall    *Draw )( 
            IViewObject    * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void    *pvAspect,
            /* [unique][in] */ DVTARGETDEVICE    *ptd,
            /* [in] */ HDC hdcTargetDev,
            /* [in] */ HDC hdcDraw,
            /* [in] */ LPCRECTL lprcBounds,
            /* [in] */ LPCRECTL lprcWBounds,
            /* [in] */ BOOL ( __stdcall    *pfnContinue )( 
                DWORD dwContinue),
            /* [in] */ DWORD dwContinue);
        
        HRESULT ( __stdcall    *GetColorSet )( 
            IViewObject    * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void    *pvAspect,
            /* [in] */ DVTARGETDEVICE    *ptd,
            /* [in] */ HDC hicTargetDev,
            /* [out] */ LOGPALETTE    *   *ppColorSet);
        
        HRESULT ( __stdcall    *Freeze )( 
            IViewObject    * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void    *pvAspect,
            /* [out] */ DWORD    *pdwFreeze);
        
        HRESULT ( __stdcall    *Unfreeze )( 
            IViewObject    * This,
            /* [in] */ DWORD dwFreeze);
        
        HRESULT ( __stdcall    *SetAdvise )( 
            IViewObject    * This,
            /* [in] */ DWORD aspects,
            /* [in] */ DWORD advf,
            /* [unique][in] */ IAdviseSink    *pAdvSink);
        
        HRESULT ( __stdcall    *GetAdvise )( 
            IViewObject    * This,
            /* [out] */ DWORD    *pAspects,
            /* [out] */ DWORD    *pAdvf,
            /* [out] */ IAdviseSink    *   *ppAdvSink);
        
    } IViewObjectVtbl;

     struct  IViewObject
    {
           struct IViewObjectVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 3987 "C:\WATCOM\H\NT\oleidl.h"


/* C style interface */



HRESULT __stdcall IViewObject_Draw_Proxy( 
    IViewObject    * This,
    /* [in] */ DWORD dwDrawAspect,
    /* [in] */ LONG lindex,
    /* [unique][in] */ void    *pvAspect,
    /* [unique][in] */ DVTARGETDEVICE    *ptd,
    /* [in] */ HDC hdcTargetDev,
    /* [in] */ HDC hdcDraw,
    /* [in] */ LPCRECTL lprcBounds,
    /* [in] */ LPCRECTL lprcWBounds,
    /* [in] */ BOOL ( __stdcall    *pfnContinue )( 
        DWORD dwContinue),
    /* [in] */ DWORD dwContinue);


void  __stdcall  IViewObject_Draw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IViewObject_GetColorSet_Proxy( 
    IViewObject    * This,
    /* [in] */ DWORD dwDrawAspect,
    /* [in] */ LONG lindex,
    /* [unique][in] */ void    *pvAspect,
    /* [in] */ DVTARGETDEVICE    *ptd,
    /* [in] */ HDC hicTargetDev,
    /* [out] */ LOGPALETTE    *   *ppColorSet);


void  __stdcall  IViewObject_GetColorSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IViewObject_Freeze_Proxy( 
    IViewObject    * This,
    /* [in] */ DWORD dwDrawAspect,
    /* [in] */ LONG lindex,
    /* [unique][in] */ void    *pvAspect,
    /* [out] */ DWORD    *pdwFreeze);


void  __stdcall  IViewObject_Freeze_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IViewObject_Unfreeze_Proxy( 
    IViewObject    * This,
    /* [in] */ DWORD dwFreeze);


void  __stdcall  IViewObject_Unfreeze_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IViewObject_SetAdvise_Proxy( 
    IViewObject    * This,
    /* [in] */ DWORD aspects,
    /* [in] */ DWORD advf,
    /* [unique][in] */ IAdviseSink    *pAdvSink);


void  __stdcall  IViewObject_SetAdvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IViewObject_GetAdvise_Proxy( 
    IViewObject    * This,
    /* [out] */ DWORD    *pAspects,
    /* [out] */ DWORD    *pAdvf,
    /* [out] */ IAdviseSink    *   *ppAdvSink);


void  __stdcall  IViewObject_GetAdvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IViewObject_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IViewObject2
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */  IViewObject2    *LPVIEWOBJECT2;


 extern "C"  const IID __cdecl IID_IViewObject2;

/* C style interface */#line 4122 "C:\WATCOM\H\NT\oleidl.h"

    typedef struct IViewObject2Vtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IViewObject2    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IViewObject2    * This);
        
        ULONG ( __stdcall    *Release )( 
            IViewObject2    * This);
        
        HRESULT ( __stdcall    *Draw )( 
            IViewObject2    * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void    *pvAspect,
            /* [unique][in] */ DVTARGETDEVICE    *ptd,
            /* [in] */ HDC hdcTargetDev,
            /* [in] */ HDC hdcDraw,
            /* [in] */ LPCRECTL lprcBounds,
            /* [in] */ LPCRECTL lprcWBounds,
            /* [in] */ BOOL ( __stdcall    *pfnContinue )( 
                DWORD dwContinue),
            /* [in] */ DWORD dwContinue);
        
        HRESULT ( __stdcall    *GetColorSet )( 
            IViewObject2    * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void    *pvAspect,
            /* [in] */ DVTARGETDEVICE    *ptd,
            /* [in] */ HDC hicTargetDev,
            /* [out] */ LOGPALETTE    *   *ppColorSet);
        
        HRESULT ( __stdcall    *Freeze )( 
            IViewObject2    * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void    *pvAspect,
            /* [out] */ DWORD    *pdwFreeze);
        
        HRESULT ( __stdcall    *Unfreeze )( 
            IViewObject2    * This,
            /* [in] */ DWORD dwFreeze);
        
        HRESULT ( __stdcall    *SetAdvise )( 
            IViewObject2    * This,
            /* [in] */ DWORD aspects,
            /* [in] */ DWORD advf,
            /* [unique][in] */ IAdviseSink    *pAdvSink);
        
        HRESULT ( __stdcall    *GetAdvise )( 
            IViewObject2    * This,
            /* [out] */ DWORD    *pAspects,
            /* [out] */ DWORD    *pAdvf,
            /* [out] */ IAdviseSink    *   *ppAdvSink);
        
        HRESULT ( __stdcall    *GetExtent )( 
            IViewObject2    * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [in] */ DVTARGETDEVICE    *ptd,
            /* [out] */ LPSIZEL lpsizel);
        
    } IViewObject2Vtbl;

     struct  IViewObject2
    {
           struct IViewObject2Vtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 4235 "C:\WATCOM\H\NT\oleidl.h"


/* C style interface */



HRESULT __stdcall IViewObject2_GetExtent_Proxy( 
    IViewObject2    * This,
    /* [in] */ DWORD dwDrawAspect,
    /* [in] */ LONG lindex,
    /* [in] */ DVTARGETDEVICE    *ptd,
    /* [out] */ LPSIZEL lpsizel);


void  __stdcall  IViewObject2_GetExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IViewObject2_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IDropSource
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */  IDropSource    *LPDROPSOURCE;


 extern "C"  const IID __cdecl IID_IDropSource;

/* C style interface */#line 4292 "C:\WATCOM\H\NT\oleidl.h"

    typedef struct IDropSourceVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IDropSource    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IDropSource    * This);
        
        ULONG ( __stdcall    *Release )( 
            IDropSource    * This);
        
        HRESULT ( __stdcall    *QueryContinueDrag )( 
            IDropSource    * This,
            /* [in] */ BOOL fEscapePressed,
            /* [in] */ DWORD grfKeyState);
        
        HRESULT ( __stdcall    *GiveFeedback )( 
            IDropSource    * This,
            /* [in] */ DWORD dwEffect);
        
    } IDropSourceVtbl;

     struct  IDropSource
    {
           struct IDropSourceVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 4345 "C:\WATCOM\H\NT\oleidl.h"


/* C style interface */



HRESULT __stdcall IDropSource_QueryContinueDrag_Proxy( 
    IDropSource    * This,
    /* [in] */ BOOL fEscapePressed,
    /* [in] */ DWORD grfKeyState);


void  __stdcall  IDropSource_QueryContinueDrag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDropSource_GiveFeedback_Proxy( 
    IDropSource    * This,
    /* [in] */ DWORD dwEffect);


void  __stdcall  IDropSource_GiveFeedback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IDropSource_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IDropTarget
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IDropTarget    *LPDROPTARGET;

			/* size is 4 */


			/* size is 4 */


			/* size is 4 */


			/* size is 4 */


			/* size is 4 */


			/* size is 4 */


// default inset-width of the hot zone, in pixels
//   typical use: GetProfileInt("windows","DragScrollInset",DD_DEFSCROLLINSET)
			/* size is 4 */


// default delay before scrolling, in milliseconds
//   typical use: GetProfileInt("windows","DragScrollDelay",DD_DEFSCROLLDELAY)
			/* size is 4 */


// default scroll interval, in milliseconds
//   typical use: GetProfileInt("windows","DragScrollInterval", DD_DEFSCROLLINTERVAL)
			/* size is 4 */


// default delay before dragging should start, in milliseconds
//   typical use: GetProfileInt("windows", "DragDelay", DD_DEFDRAGDELAY)
			/* size is 4 */


// default minimum distance (radius) before dragging should start, in pixels
//   typical use: GetProfileInt("windows", "DragMinDist", DD_DEFDRAGMINDIST)
			/* size is 4 */



 extern "C"  const IID __cdecl IID_IDropTarget;

/* C style interface */#line 4467 "C:\WATCOM\H\NT\oleidl.h"

    typedef struct IDropTargetVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IDropTarget    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IDropTarget    * This);
        
        ULONG ( __stdcall    *Release )( 
            IDropTarget    * This);
        
        HRESULT ( __stdcall    *DragEnter )( 
            IDropTarget    * This,
            /* [unique][in] */ IDataObject    *pDataObj,
            /* [in] */ DWORD grfKeyState,
            /* [in] */ POINTL pt,
            /* [out][in] */ DWORD    *pdwEffect);
        
        HRESULT ( __stdcall    *DragOver )( 
            IDropTarget    * This,
            /* [in] */ DWORD grfKeyState,
            /* [in] */ POINTL pt,
            /* [out][in] */ DWORD    *pdwEffect);
        
        HRESULT ( __stdcall    *DragLeave )( 
            IDropTarget    * This);
        
        HRESULT ( __stdcall    *Drop )( 
            IDropTarget    * This,
            /* [unique][in] */ IDataObject    *pDataObj,
            /* [in] */ DWORD grfKeyState,
            /* [in] */ POINTL pt,
            /* [out][in] */ DWORD    *pdwEffect);
        
    } IDropTargetVtbl;

     struct  IDropTarget
    {
           struct IDropTargetVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 4540 "C:\WATCOM\H\NT\oleidl.h"


/* C style interface */



HRESULT __stdcall IDropTarget_DragEnter_Proxy( 
    IDropTarget    * This,
    /* [unique][in] */ IDataObject    *pDataObj,
    /* [in] */ DWORD grfKeyState,
    /* [in] */ POINTL pt,
    /* [out][in] */ DWORD    *pdwEffect);


void  __stdcall  IDropTarget_DragEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDropTarget_DragOver_Proxy( 
    IDropTarget    * This,
    /* [in] */ DWORD grfKeyState,
    /* [in] */ POINTL pt,
    /* [out][in] */ DWORD    *pdwEffect);


void  __stdcall  IDropTarget_DragOver_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDropTarget_DragLeave_Proxy( 
    IDropTarget    * This);


void  __stdcall  IDropTarget_DragLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDropTarget_Drop_Proxy( 
    IDropTarget    * This,
    /* [unique][in] */ IDataObject    *pDataObj,
    /* [in] */ DWORD grfKeyState,
    /* [in] */ POINTL pt,
    /* [out][in] */ DWORD    *pdwEffect);


void  __stdcall  IDropTarget_Drop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IDropTarget_INTERFACE_DEFINED__ */





/****************************************
 * Generated header for interface: IEnumOLEVERB
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */  IEnumOLEVERB    *LPENUMOLEVERB;

			/* size is 16 */
typedef struct  tagOLEVERB
    {
    LONG lVerb;
    LPOLESTR lpszVerbName;
    DWORD fuFlags;
    DWORD grfAttribs;
    }	OLEVERB;

			/* size is 4 */
typedef struct tagOLEVERB    *LPOLEVERB;

			/* size is 2 */
typedef /* [v1_enum] */  
enum tagOLEVERBATTRIB
    {	OLEVERBATTRIB_NEVERDIRTIES	= 1,
	OLEVERBATTRIB_ONCONTAINERMENU	= 2
    }	OLEVERBATTRIB;


 extern "C"  const IID __cdecl IID_IEnumOLEVERB;

/* C style interface */#line 4662 "C:\WATCOM\H\NT\oleidl.h"

    typedef struct IEnumOLEVERBVtbl
    {
        
        HRESULT ( __stdcall    *QueryInterface )( 
            IEnumOLEVERB    * This,
            /* [in] */  const IID &  riid,
            /* [out] */ void    *   *ppvObject);
        
        ULONG ( __stdcall    *AddRef )( 
            IEnumOLEVERB    * This);
        
        ULONG ( __stdcall    *Release )( 
            IEnumOLEVERB    * This);
        
        /* [local] */ HRESULT ( __stdcall    *Next )( 
            IEnumOLEVERB    * This,
            /* [in] */ ULONG celt,
            /* [out] */ LPOLEVERB rgelt,
            /* [out] */ ULONG    *pceltFetched);
        
        HRESULT ( __stdcall    *Skip )( 
            IEnumOLEVERB    * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( __stdcall    *Reset )( 
            IEnumOLEVERB    * This);
        
        HRESULT ( __stdcall    *Clone )( 
            IEnumOLEVERB    * This,
            /* [out] */ IEnumOLEVERB    *   *ppenum);
        
    } IEnumOLEVERBVtbl;

     struct  IEnumOLEVERB
    {
           struct IEnumOLEVERBVtbl    *lpVtbl;
    };

    

/* COBJMACROS */#line 4729 "C:\WATCOM\H\NT\oleidl.h"


/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumOLEVERB_RemoteNext_Proxy( 
    IEnumOLEVERB    * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ LPOLEVERB rgelt,
    /* [out] */ ULONG    *pceltFetched);


void  __stdcall  IEnumOLEVERB_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumOLEVERB_Skip_Proxy( 
    IEnumOLEVERB    * This,
    /* [in] */ ULONG celt);


void  __stdcall  IEnumOLEVERB_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumOLEVERB_Reset_Proxy( 
    IEnumOLEVERB    * This);


void  __stdcall  IEnumOLEVERB_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumOLEVERB_Clone_Proxy( 
    IEnumOLEVERB    * This,
    /* [out] */ IEnumOLEVERB    *   *ppenum);


void  __stdcall  IEnumOLEVERB_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



/* __IEnumOLEVERB_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */


void  __stdcall  UINT_to_xmit( UINT    *, unsigned long     *    * );
void  __stdcall  UINT_from_xmit( unsigned long     *, UINT    * );
void  __stdcall  UINT_free_inst( UINT    * );
void  __stdcall  UINT_free_xmit( unsigned long     * );

void  __stdcall  WPARAM_to_xmit( WPARAM    *, unsigned long     *    * );
void  __stdcall  WPARAM_from_xmit( unsigned long     *, WPARAM    * );
void  __stdcall  WPARAM_free_inst( WPARAM    * );
void  __stdcall  WPARAM_free_xmit( unsigned long     * );

void  __stdcall  HWND_to_xmit( HWND    *, long     *    * );
void  __stdcall  HWND_from_xmit( long     *, HWND    * );
void  __stdcall  HWND_free_inst( HWND    * );
void  __stdcall  HWND_free_xmit( long     * );

void  __stdcall  HMENU_to_xmit( HMENU    *, long     *    * );
void  __stdcall  HMENU_from_xmit( long     *, HMENU    * );
void  __stdcall  HMENU_free_inst( HMENU    * );
void  __stdcall  HMENU_free_xmit( long     * );

void  __stdcall  HACCEL_to_xmit( HACCEL    *, long     *    * );
void  __stdcall  HACCEL_from_xmit( long     *, HACCEL    * );
void  __stdcall  HACCEL_free_inst( HACCEL    * );
void  __stdcall  HACCEL_free_xmit( long     * );

void  __stdcall  HOLEMENU_to_xmit( HOLEMENU    *, RemHGLOBAL     *    * );
void  __stdcall  HOLEMENU_from_xmit( RemHGLOBAL     *, HOLEMENU    * );
void  __stdcall  HOLEMENU_free_inst( HOLEMENU    * );
void  __stdcall  HOLEMENU_free_xmit( RemHGLOBAL     * );

/* [local] */ HRESULT __stdcall IOleItemContainer_GetObject_Proxy( 
    IOleItemContainer    * This,
    /* [in] */ LPOLESTR pszItem,
    /* [in] */ DWORD dwSpeedNeeded,
    /* [unique][in] */ IBindCtx    *pbc,
    /* [in] */  const IID &  riid,
    /* [out] */ void    *   *ppvObject);


/* [call_as] */ HRESULT __stdcall IOleItemContainer_GetObject_Stub( 
    IOleItemContainer    * This,
    /* [in] */ LPOLESTR pszItem,
    /* [in] */ DWORD dwSpeedNeeded,
    /* [unique][in] */ IBindCtx    *pbc,
    /* [in] */  const IID &  riid,
    /* [iid_is][out] */ IUnknown    *   *ppvObject);

/* [local] */ HRESULT __stdcall IOleItemContainer_GetObjectStorage_Proxy( 
    IOleItemContainer    * This,
    /* [in] */ LPOLESTR pszItem,
    /* [unique][in] */ IBindCtx    *pbc,
    /* [in] */  const IID &  riid,
    /* [out] */ void    *   *ppvStorage);


/* [call_as] */ HRESULT __stdcall IOleItemContainer_GetObjectStorage_Stub( 
    IOleItemContainer    * This,
    /* [in] */ LPOLESTR pszItem,
    /* [unique][in] */ IBindCtx    *pbc,
    /* [in] */  const IID &  riid,
    /* [iid_is][out] */ IUnknown    *   *ppvStorage);

/* [local] */ HRESULT __stdcall IOleInPlaceActiveObject_TranslateAccelerator_Proxy( 
    IOleInPlaceActiveObject    * This,
    /* [in] */ LPMSG lpmsg);


/* [call_as] */ HRESULT __stdcall IOleInPlaceActiveObject_TranslateAccelerator_Stub( 
    IOleInPlaceActiveObject    * This);

/* [local] */ HRESULT __stdcall IOleInPlaceActiveObject_ResizeBorder_Proxy( 
    IOleInPlaceActiveObject    * This,
    /* [in] */ LPCRECT prcBorder,
    /* [unique][in] */ IOleInPlaceUIWindow    *pUIWindow,
    /* [in] */ BOOL fFrameWindow);


/* [input_sync][call_as] */ HRESULT __stdcall IOleInPlaceActiveObject_ResizeBorder_Stub( 
    IOleInPlaceActiveObject    * This,
    /* [in] */ LPCRECT prcBorder,
    /* [in] */  const IID &  riid,
    /* [iid_is][unique][in] */ IOleInPlaceUIWindow    *pUIWindow,
    /* [in] */ BOOL fFrameWindow);

/* [local] */ HRESULT __stdcall IEnumOLEVERB_Next_Proxy( 
    IEnumOLEVERB    * This,
    /* [in] */ ULONG celt,
    /* [out] */ LPOLEVERB rgelt,
    /* [out] */ ULONG    *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumOLEVERB_Next_Stub( 
    IEnumOLEVERB    * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ LPOLEVERB rgelt,
    /* [out] */ ULONG    *pceltFetched);



/* end of Additional Prototypes */


}



#line 61 "C:\WATCOM\H\NT\ole2.h"







/****** DV APIs ***********************************************************/


 extern "C" __declspec(dllimport) HRESULT __stdcall  CreateDataAdviseHolder(LPDATAADVISEHOLDER   * ppDAHolder);







/****** OLE API Prototypes ************************************************/

 extern "C" __declspec(dllimport) DWORD __stdcall  OleBuildVersion(  void  );

/* helper functions */
 extern "C" __declspec(dllimport) HRESULT __stdcall  ReadClassStg(LPSTORAGE pStg, CLSID   * pclsid);
 extern "C" __declspec(dllimport) HRESULT __stdcall  WriteClassStg(LPSTORAGE pStg,  const CLSID &  rclsid);
 extern "C" __declspec(dllimport) HRESULT __stdcall  ReadClassStm(LPSTREAM pStm, CLSID   * pclsid);
 extern "C" __declspec(dllimport) HRESULT __stdcall  WriteClassStm(LPSTREAM pStm,  const CLSID &  rclsid);
 extern "C" __declspec(dllimport) HRESULT __stdcall  WriteFmtUserTypeStg (LPSTORAGE pstg, CLIPFORMAT cf, LPOLESTR lpszUserType);
 extern "C" __declspec(dllimport) HRESULT __stdcall  ReadFmtUserTypeStg (LPSTORAGE pstg, CLIPFORMAT   * pcf, LPOLESTR   * lplpszUserType);


/* init/term */

 extern "C" __declspec(dllimport) HRESULT __stdcall  OleInitialize(LPVOID pvReserved);
 extern "C" __declspec(dllimport) void __stdcall  OleUninitialize(void);


/* APIs to query whether (Embedded/Linked) object can be created from
   the data object */

 extern "C" __declspec(dllimport) HRESULT __stdcall   OleQueryLinkFromData(LPDATAOBJECT pSrcDataObject);
 extern "C" __declspec(dllimport) HRESULT __stdcall   OleQueryCreateFromData(LPDATAOBJECT pSrcDataObject);


/* Object creation APIs */

 extern "C" __declspec(dllimport) HRESULT __stdcall   OleCreate( const CLSID &  rclsid,  const IID &  riid, DWORD renderopt,
                LPFORMATETC pFormatEtc, LPOLECLIENTSITE pClientSite,
                LPSTORAGE pStg, LPVOID   * ppvObj);

 extern "C" __declspec(dllimport) HRESULT __stdcall   OleCreateFromData(LPDATAOBJECT pSrcDataObj,  const IID &  riid,
                DWORD renderopt, LPFORMATETC pFormatEtc,
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg,
                LPVOID   * ppvObj);

 extern "C" __declspec(dllimport) HRESULT __stdcall   OleCreateLinkFromData(LPDATAOBJECT pSrcDataObj,  const IID &  riid,
                DWORD renderopt, LPFORMATETC pFormatEtc,
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg,
                LPVOID   * ppvObj);

 extern "C" __declspec(dllimport) HRESULT __stdcall   OleCreateStaticFromData(LPDATAOBJECT pSrcDataObj,  const IID &  iid,
                DWORD renderopt, LPFORMATETC pFormatEtc,
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg,
                LPVOID   * ppvObj);


 extern "C" __declspec(dllimport) HRESULT __stdcall   OleCreateLink(LPMONIKER pmkLinkSrc,  const IID &  riid,
            DWORD renderopt, LPFORMATETC lpFormatEtc,
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID   * ppvObj);

 extern "C" __declspec(dllimport) HRESULT __stdcall   OleCreateLinkToFile(LPCOLESTR lpszFileName,  const IID &  riid,
            DWORD renderopt, LPFORMATETC lpFormatEtc,
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID   * ppvObj);

 extern "C" __declspec(dllimport) HRESULT __stdcall   OleCreateFromFile( const CLSID &  rclsid, LPCOLESTR lpszFileName,  const IID &  riid,
            DWORD renderopt, LPFORMATETC lpFormatEtc,
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID   * ppvObj);

 extern "C" __declspec(dllimport) HRESULT __stdcall   OleLoad(LPSTORAGE pStg,  const IID &  riid, LPOLECLIENTSITE pClientSite,
            LPVOID   * ppvObj);

 extern "C" __declspec(dllimport) HRESULT __stdcall   OleSave(LPPERSISTSTORAGE pPS, LPSTORAGE pStg, BOOL fSameAsLoad);

 extern "C" __declspec(dllimport) HRESULT __stdcall   OleLoadFromStream( LPSTREAM pStm,  const IID &  iidInterface, LPVOID   * ppvObj);
 extern "C" __declspec(dllimport) HRESULT __stdcall   OleSaveToStream( LPPERSISTSTREAM pPStm, LPSTREAM pStm );


 extern "C" __declspec(dllimport) HRESULT __stdcall   OleSetContainedObject(LPUNKNOWN pUnknown, BOOL fContained);
 extern "C" __declspec(dllimport) HRESULT __stdcall   OleNoteObjectVisible(LPUNKNOWN pUnknown, BOOL fVisible);


/* Drag/Drop APIs */

 extern "C" __declspec(dllimport) HRESULT __stdcall   RegisterDragDrop(HWND hwnd, LPDROPTARGET pDropTarget);
 extern "C" __declspec(dllimport) HRESULT __stdcall   RevokeDragDrop(HWND hwnd);
 extern "C" __declspec(dllimport) HRESULT __stdcall   DoDragDrop(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource,
            DWORD dwOKEffects, LPDWORD pdwEffect);

/* Clipboard APIs */

 extern "C" __declspec(dllimport) HRESULT __stdcall   OleSetClipboard(LPDATAOBJECT pDataObj);
 extern "C" __declspec(dllimport) HRESULT __stdcall   OleGetClipboard(LPDATAOBJECT   * ppDataObj);
 extern "C" __declspec(dllimport) HRESULT __stdcall   OleFlushClipboard(void);
 extern "C" __declspec(dllimport) HRESULT __stdcall   OleIsCurrentClipboard(LPDATAOBJECT pDataObj);


/* InPlace Editing APIs */

 extern "C" __declspec(dllimport) HOLEMENU __stdcall    OleCreateMenuDescriptor (HMENU hmenuCombined,
                                LPOLEMENUGROUPWIDTHS lpMenuWidths);
 extern "C" __declspec(dllimport) HRESULT __stdcall               OleSetMenuDescriptor (HOLEMENU holemenu, HWND hwndFrame,
                                HWND hwndActiveObject,
                                LPOLEINPLACEFRAME lpFrame,
                                LPOLEINPLACEACTIVEOBJECT lpActiveObj);
 extern "C" __declspec(dllimport) HRESULT __stdcall               OleDestroyMenuDescriptor (HOLEMENU holemenu);

 extern "C" __declspec(dllimport) HRESULT __stdcall               OleTranslateAccelerator (LPOLEINPLACEFRAME lpFrame,
                            LPOLEINPLACEFRAMEINFO lpFrameInfo, LPMSG lpmsg);


/* Helper APIs */
 extern "C" __declspec(dllimport) HANDLE __stdcall  OleDuplicateData (HANDLE hSrc, CLIPFORMAT cfFormat,
                        UINT uiFlags);

 extern "C" __declspec(dllimport) HRESULT __stdcall           OleDraw (LPUNKNOWN pUnknown, DWORD dwAspect, HDC hdcDraw,
                    LPCRECT lprcBounds);

 extern "C" __declspec(dllimport) HRESULT __stdcall           OleRun(LPUNKNOWN pUnknown);
 extern "C" __declspec(dllimport) BOOL __stdcall    OleIsRunning(LPOLEOBJECT pObject);
 extern "C" __declspec(dllimport) HRESULT __stdcall           OleLockRunning(LPUNKNOWN pUnknown, BOOL fLock, BOOL fLastUnlockCloses);
 extern "C" __declspec(dllimport) void __stdcall    ReleaseStgMedium(LPSTGMEDIUM);
 extern "C" __declspec(dllimport) HRESULT __stdcall           CreateOleAdviseHolder(LPOLEADVISEHOLDER   * ppOAHolder);

 extern "C" __declspec(dllimport) HRESULT __stdcall           OleCreateDefaultHandler( const CLSID &  clsid, LPUNKNOWN pUnkOuter,
                     const IID &  riid, LPVOID   * lplpObj);

 extern "C" __declspec(dllimport) HRESULT __stdcall           OleCreateEmbeddingHelper( const CLSID &  clsid, LPUNKNOWN pUnkOuter,
                    DWORD flags, LPCLASSFACTORY pCF,
                                         const IID &  riid, LPVOID   * lplpObj);

 extern "C" __declspec(dllimport) BOOL __stdcall    IsAccelerator(HACCEL hAccel, int cAccelEntries, LPMSG lpMsg,
                                        WORD   * lpwCmd);
/* Icon extraction Helper APIs */

 extern "C" __declspec(dllimport) HGLOBAL __stdcall  OleGetIconOfFile(LPOLESTR lpszPath, BOOL fUseFileAsLabel);

 extern "C" __declspec(dllimport) HGLOBAL __stdcall  OleGetIconOfClass( const CLSID &  rclsid,     LPOLESTR lpszLabel,
                                        BOOL fUseTypeAsLabel);

 extern "C" __declspec(dllimport) HGLOBAL __stdcall  OleMetafilePictFromIconAndLabel(HICON hIcon, LPOLESTR lpszLabel,
                                        LPOLESTR lpszSourceFile, UINT iIconIndex);



/* Registration Database Helper APIs */

 extern "C" __declspec(dllimport) HRESULT __stdcall                   OleRegGetUserType ( const CLSID &  clsid, DWORD dwFormOfType,
                                        LPOLESTR   * pszUserType);

 extern "C" __declspec(dllimport) HRESULT __stdcall                   OleRegGetMiscStatus     ( const CLSID &  clsid, DWORD dwAspect,
                                        DWORD   * pdwStatus);

 extern "C" __declspec(dllimport) HRESULT __stdcall                   OleRegEnumFormatEtc     ( const CLSID &  clsid, DWORD dwDirection,
                                        LPENUMFORMATETC   * ppenum);

 extern "C" __declspec(dllimport) HRESULT __stdcall                   OleRegEnumVerbs ( const CLSID &  clsid, LPENUMOLEVERB   * ppenum);





/* OLE 1.0 conversion APIS */

/***** OLE 1.0 OLESTREAM declarations *************************************/

typedef struct _OLESTREAM   *  LPOLESTREAM;

typedef struct _OLESTREAMVTBL
{
    DWORD ( __stdcall * Get)(LPOLESTREAM, void   *, DWORD);
    DWORD ( __stdcall * Put)(LPOLESTREAM, const void   *, DWORD);
} OLESTREAMVTBL;
typedef  OLESTREAMVTBL   *  LPOLESTREAMVTBL;

typedef struct _OLESTREAM
{
    LPOLESTREAMVTBL lpstbl;
} OLESTREAM;


 extern "C" __declspec(dllimport) HRESULT __stdcall  OleConvertOLESTREAMToIStorage
    (LPOLESTREAM                lpolestream,
    LPSTORAGE                   pstg,
    const DVTARGETDEVICE   *   ptd);

 extern "C" __declspec(dllimport) HRESULT __stdcall  OleConvertIStorageToOLESTREAM
    (LPSTORAGE      pstg,
    LPOLESTREAM     lpolestream);


/* Storage Utility APIs */
 extern "C" __declspec(dllimport) HRESULT __stdcall  GetHGlobalFromILockBytes (LPLOCKBYTES plkbyt, HGLOBAL   * phglobal);
 extern "C" __declspec(dllimport) HRESULT __stdcall  CreateILockBytesOnHGlobal (HGLOBAL hGlobal, BOOL fDeleteOnRelease,
                                    LPLOCKBYTES   * pplkbyt);

 extern "C" __declspec(dllimport) HRESULT __stdcall  GetHGlobalFromStream (LPSTREAM pstm, HGLOBAL   * phglobal);
 extern "C" __declspec(dllimport) HRESULT __stdcall  CreateStreamOnHGlobal (HGLOBAL hGlobal, BOOL fDeleteOnRelease,
                                LPSTREAM   * ppstm);


/* ConvertTo APIS */

 extern "C" __declspec(dllimport) HRESULT __stdcall  OleDoAutoConvert(LPSTORAGE pStg, LPCLSID pClsidNew);
 extern "C" __declspec(dllimport) HRESULT __stdcall  OleGetAutoConvert( const CLSID &  clsidOld, LPCLSID pClsidNew);
 extern "C" __declspec(dllimport) HRESULT __stdcall  OleSetAutoConvert( const CLSID &  clsidOld,  const CLSID &  clsidNew);
 extern "C" __declspec(dllimport) HRESULT __stdcall  GetConvertStg(LPSTORAGE pStg);
 extern "C" __declspec(dllimport) HRESULT __stdcall  SetConvertStg(LPSTORAGE pStg, BOOL fConvert);


 extern "C" __declspec(dllimport) HRESULT __stdcall  OleConvertIStorageToOLESTREAMEx
    (LPSTORAGE          pstg,
                                    // Presentation data to OLESTREAM
     CLIPFORMAT         cfFormat,   //      format 
     LONG               lWidth,     //      width 
     LONG               lHeight,    //      height 
     DWORD              dwSize,     //      size in bytes 
     LPSTGMEDIUM        pmedium,    //      bits 
     LPOLESTREAM        polestm);

 extern "C" __declspec(dllimport) HRESULT __stdcall  OleConvertOLESTREAMToIStorageEx
    (LPOLESTREAM        polestm,
     LPSTORAGE          pstg,
                                    // Presentation data from OLESTREAM
     CLIPFORMAT   *    pcfFormat,  //      format 
     LONG   *          plwWidth,   //      width 
     LONG   *          plHeight,   //      height 
     DWORD   *         pdwSize,    //      size in bytes 
     LPSTGMEDIUM        pmedium);   //      bits 


#line 1 "C:\WATCOM\H\NT\poppack.h"
/*++

Copyright (c) 1990,95  Microsoft Corporation

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)
#line 33 "C:\WATCOM\H\NT\poppack.h"
#line 36 "C:\WATCOM\H\NT\poppack.h"
// ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#line 301 "C:\WATCOM\H\NT\ole2.h"

// RC_INVOKED

// __OLE2_H__

#line 185 "C:\WATCOM\H\NT\windows.h"

/* !INC_OLE1 */
/* !NOGDI */
/* WIN32_LEAN_AND_MEAN */

/* INC_OLE2 */#line 193 "C:\WATCOM\H\NT\windows.h"


#line 1 "C:\WATCOM\H\NT\winsvc.h"
/*++ BUILD Version: 0010    // Increment this if a change has global effects

Copyright (c) 1995  Microsoft Corporation

Module Name:

    winsvc.h

Abstract:

    Header file for the Service Control Manager

Environment:

    User Mode - Win32

--*/



//
// Define API decoration for direct importing of DLL references.
//

#line 32 "C:\WATCOM\H\NT\winsvc.h"


extern "C" {


//
// Constants
//

//
// Service database names
//







//
// Character to designate that a name is a group
//




// ndef UNICODE#line 67 "C:\WATCOM\H\NT\winsvc.h"





// ndef UNICODE


//
// Value to indicate no change to an optional parameter
//


//
// Service State -- for Enum Requests (Bit Mask)
//





//
// Controls
//






//
// Service State -- for CurrentState
//








//
// Controls Accepted  (Bit Mask)
//




//
// Service Control Manager object specific access types
//

















//
// Service object specific access type
//






















//
// Handle Types
//

typedef HANDLE      SC_HANDLE;
typedef SC_HANDLE   *LPSC_HANDLE;

typedef DWORD       SERVICE_STATUS_HANDLE;

//
// Service Status Structure
//

typedef struct _SERVICE_STATUS {
    DWORD   dwServiceType;
    DWORD   dwCurrentState;
    DWORD   dwControlsAccepted;
    DWORD   dwWin32ExitCode;
    DWORD   dwServiceSpecificExitCode;
    DWORD   dwCheckPoint;
    DWORD   dwWaitHint;
} SERVICE_STATUS, *LPSERVICE_STATUS;



//
// Service Status Enumeration Structure
//

typedef struct _ENUM_SERVICE_STATUSA {
    LPSTR          lpServiceName;
    LPSTR          lpDisplayName;
    SERVICE_STATUS ServiceStatus;
} ENUM_SERVICE_STATUSA, *LPENUM_SERVICE_STATUSA;
typedef struct _ENUM_SERVICE_STATUSW {
    LPWSTR         lpServiceName;
    LPWSTR         lpDisplayName;
    SERVICE_STATUS ServiceStatus;
} ENUM_SERVICE_STATUSW, *LPENUM_SERVICE_STATUSW;
#line 203 "C:\WATCOM\H\NT\winsvc.h"
typedef ENUM_SERVICE_STATUSA ENUM_SERVICE_STATUS;
typedef LPENUM_SERVICE_STATUSA LPENUM_SERVICE_STATUS;
// UNICODE


//
// Structures for the Lock API functions
//

typedef LPVOID  SC_LOCK;

typedef struct _QUERY_SERVICE_LOCK_STATUSA {
    DWORD   fIsLocked;
    LPSTR   lpLockOwner;
    DWORD   dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSA, *LPQUERY_SERVICE_LOCK_STATUSA;
typedef struct _QUERY_SERVICE_LOCK_STATUSW {
    DWORD   fIsLocked;
    LPWSTR  lpLockOwner;
    DWORD   dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSW, *LPQUERY_SERVICE_LOCK_STATUSW;
#line 228 "C:\WATCOM\H\NT\winsvc.h"
typedef QUERY_SERVICE_LOCK_STATUSA QUERY_SERVICE_LOCK_STATUS;
typedef LPQUERY_SERVICE_LOCK_STATUSA LPQUERY_SERVICE_LOCK_STATUS;
// UNICODE



//
// Query Service Configuration Structure
//

typedef struct _QUERY_SERVICE_CONFIGA {
    DWORD   dwServiceType;
    DWORD   dwStartType;
    DWORD   dwErrorControl;
    LPSTR   lpBinaryPathName;
    LPSTR   lpLoadOrderGroup;
    DWORD   dwTagId;
    LPSTR   lpDependencies;
    LPSTR   lpServiceStartName;
    LPSTR   lpDisplayName;
} QUERY_SERVICE_CONFIGA, *LPQUERY_SERVICE_CONFIGA;
typedef struct _QUERY_SERVICE_CONFIGW {
    DWORD   dwServiceType;
    DWORD   dwStartType;
    DWORD   dwErrorControl;
    LPWSTR  lpBinaryPathName;
    LPWSTR  lpLoadOrderGroup;
    DWORD   dwTagId;
    LPWSTR  lpDependencies;
    LPWSTR  lpServiceStartName;
    LPWSTR  lpDisplayName;
} QUERY_SERVICE_CONFIGW, *LPQUERY_SERVICE_CONFIGW;
#line 264 "C:\WATCOM\H\NT\winsvc.h"
typedef QUERY_SERVICE_CONFIGA QUERY_SERVICE_CONFIG;
typedef LPQUERY_SERVICE_CONFIGA LPQUERY_SERVICE_CONFIG;
// UNICODE



//
// Function Prototype for the Service Main Function
//

typedef  void  ( __stdcall  *LPSERVICE_MAIN_FUNCTIONW)(
    DWORD   dwNumServicesArgs,
    LPWSTR  *lpServiceArgVectors
    );

typedef  void  ( __stdcall  *LPSERVICE_MAIN_FUNCTIONA)(
    DWORD   dwNumServicesArgs,
    LPSTR   *lpServiceArgVectors
    );

#line 287 "C:\WATCOM\H\NT\winsvc.h"

//UNICODE


//
// Service Start Table
//

typedef struct _SERVICE_TABLE_ENTRYA {
    LPSTR                       lpServiceName;
    LPSERVICE_MAIN_FUNCTIONA    lpServiceProc;
}SERVICE_TABLE_ENTRYA, *LPSERVICE_TABLE_ENTRYA;
typedef struct _SERVICE_TABLE_ENTRYW {
    LPWSTR                      lpServiceName;
    LPSERVICE_MAIN_FUNCTIONW    lpServiceProc;
}SERVICE_TABLE_ENTRYW, *LPSERVICE_TABLE_ENTRYW;
#line 307 "C:\WATCOM\H\NT\winsvc.h"
typedef SERVICE_TABLE_ENTRYA SERVICE_TABLE_ENTRY;
typedef LPSERVICE_TABLE_ENTRYA LPSERVICE_TABLE_ENTRY;
// UNICODE

//
// Prototype for the Service Control Handler Function
//

typedef  void  ( __stdcall  *LPHANDLER_FUNCTION)(
    DWORD    dwControl
    );



///////////////////////////////////////////////////////////////////////////
// API Function Prototypes
///////////////////////////////////////////////////////////////////////////

 __declspec(dllimport) 
BOOL
 __stdcall 
ChangeServiceConfigA(
    SC_HANDLE    hService,
    DWORD        dwServiceType,
    DWORD        dwStartType,
    DWORD        dwErrorControl,
    LPCSTR     lpBinaryPathName,
    LPCSTR     lpLoadOrderGroup,
    LPDWORD      lpdwTagId,
    LPCSTR     lpDependencies,
    LPCSTR     lpServiceStartName,
    LPCSTR     lpPassword,
    LPCSTR     lpDisplayName
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
ChangeServiceConfigW(
    SC_HANDLE    hService,
    DWORD        dwServiceType,
    DWORD        dwStartType,
    DWORD        dwErrorControl,
    LPCWSTR     lpBinaryPathName,
    LPCWSTR     lpLoadOrderGroup,
    LPDWORD      lpdwTagId,
    LPCWSTR     lpDependencies,
    LPCWSTR     lpServiceStartName,
    LPCWSTR     lpPassword,
    LPCWSTR     lpDisplayName
    );
#line 360 "C:\WATCOM\H\NT\winsvc.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
CloseServiceHandle(
    SC_HANDLE   hSCObject
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
ControlService(
    SC_HANDLE           hService,
    DWORD               dwControl,
    LPSERVICE_STATUS    lpServiceStatus
    );

 __declspec(dllimport) 
SC_HANDLE
 __stdcall 
CreateServiceA(
    SC_HANDLE    hSCManager,
    LPCSTR     lpServiceName,
    LPCSTR     lpDisplayName,
    DWORD        dwDesiredAccess,
    DWORD        dwServiceType,
    DWORD        dwStartType,
    DWORD        dwErrorControl,
    LPCSTR     lpBinaryPathName,
    LPCSTR     lpLoadOrderGroup,
    LPDWORD      lpdwTagId,
    LPCSTR     lpDependencies,
    LPCSTR     lpServiceStartName,
    LPCSTR     lpPassword
    );
 __declspec(dllimport) 
SC_HANDLE
 __stdcall 
CreateServiceW(
    SC_HANDLE    hSCManager,
    LPCWSTR     lpServiceName,
    LPCWSTR     lpDisplayName,
    DWORD        dwDesiredAccess,
    DWORD        dwServiceType,
    DWORD        dwStartType,
    DWORD        dwErrorControl,
    LPCWSTR     lpBinaryPathName,
    LPCWSTR     lpLoadOrderGroup,
    LPDWORD      lpdwTagId,
    LPCWSTR     lpDependencies,
    LPCWSTR     lpServiceStartName,
    LPCWSTR     lpPassword
    );
#line 418 "C:\WATCOM\H\NT\winsvc.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
DeleteService(
    SC_HANDLE   hService
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
EnumDependentServicesA(
    SC_HANDLE               hService,
    DWORD                   dwServiceState,
    LPENUM_SERVICE_STATUSA  lpServices,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded,
    LPDWORD                 lpServicesReturned
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
EnumDependentServicesW(
    SC_HANDLE               hService,
    DWORD                   dwServiceState,
    LPENUM_SERVICE_STATUSW  lpServices,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded,
    LPDWORD                 lpServicesReturned
    );
#line 453 "C:\WATCOM\H\NT\winsvc.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
EnumServicesStatusA(
    SC_HANDLE               hSCManager,
    DWORD                   dwServiceType,
    DWORD                   dwServiceState,
    LPENUM_SERVICE_STATUSA  lpServices,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded,
    LPDWORD                 lpServicesReturned,
    LPDWORD                 lpResumeHandle
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
EnumServicesStatusW(
    SC_HANDLE               hSCManager,
    DWORD                   dwServiceType,
    DWORD                   dwServiceState,
    LPENUM_SERVICE_STATUSW  lpServices,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded,
    LPDWORD                 lpServicesReturned,
    LPDWORD                 lpResumeHandle
    );
#line 485 "C:\WATCOM\H\NT\winsvc.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
GetServiceKeyNameA(
    SC_HANDLE               hSCManager,
    LPCSTR                lpDisplayName,
    LPSTR                 lpServiceName,
    LPDWORD                 lpcchBuffer
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
GetServiceKeyNameW(
    SC_HANDLE               hSCManager,
    LPCWSTR                lpDisplayName,
    LPWSTR                 lpServiceName,
    LPDWORD                 lpcchBuffer
    );
#line 509 "C:\WATCOM\H\NT\winsvc.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
GetServiceDisplayNameA(
    SC_HANDLE               hSCManager,
    LPCSTR                lpServiceName,
    LPSTR                 lpDisplayName,
    LPDWORD                 lpcchBuffer
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
GetServiceDisplayNameW(
    SC_HANDLE               hSCManager,
    LPCWSTR                lpServiceName,
    LPWSTR                 lpDisplayName,
    LPDWORD                 lpcchBuffer
    );
#line 533 "C:\WATCOM\H\NT\winsvc.h"

// !UNICODE

 __declspec(dllimport) 
SC_LOCK
 __stdcall 
LockServiceDatabase(
    SC_HANDLE   hSCManager
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
NotifyBootConfigStatus(
    BOOL     BootAcceptable
    );

 __declspec(dllimport) 
SC_HANDLE
 __stdcall 
OpenSCManagerA(
    LPCSTR lpMachineName,
    LPCSTR lpDatabaseName,
    DWORD   dwDesiredAccess
    );
 __declspec(dllimport) 
SC_HANDLE
 __stdcall 
OpenSCManagerW(
    LPCWSTR lpMachineName,
    LPCWSTR lpDatabaseName,
    DWORD   dwDesiredAccess
    );
#line 569 "C:\WATCOM\H\NT\winsvc.h"

// !UNICODE

 __declspec(dllimport) 
SC_HANDLE
 __stdcall 
OpenServiceA(
    SC_HANDLE   hSCManager,
    LPCSTR    lpServiceName,
    DWORD       dwDesiredAccess
    );
 __declspec(dllimport) 
SC_HANDLE
 __stdcall 
OpenServiceW(
    SC_HANDLE   hSCManager,
    LPCWSTR    lpServiceName,
    DWORD       dwDesiredAccess
    );
#line 591 "C:\WATCOM\H\NT\winsvc.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
QueryServiceConfigA(
    SC_HANDLE               hService,
    LPQUERY_SERVICE_CONFIGA lpServiceConfig,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
QueryServiceConfigW(
    SC_HANDLE               hService,
    LPQUERY_SERVICE_CONFIGW lpServiceConfig,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded
    );
#line 615 "C:\WATCOM\H\NT\winsvc.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
QueryServiceLockStatusA(
    SC_HANDLE                       hSCManager,
    LPQUERY_SERVICE_LOCK_STATUSA    lpLockStatus,
    DWORD                           cbBufSize,
    LPDWORD                         pcbBytesNeeded
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
QueryServiceLockStatusW(
    SC_HANDLE                       hSCManager,
    LPQUERY_SERVICE_LOCK_STATUSW    lpLockStatus,
    DWORD                           cbBufSize,
    LPDWORD                         pcbBytesNeeded
    );
#line 639 "C:\WATCOM\H\NT\winsvc.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
QueryServiceObjectSecurity(
    SC_HANDLE               hService,
    SECURITY_INFORMATION    dwSecurityInformation,
    PSECURITY_DESCRIPTOR    lpSecurityDescriptor,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
QueryServiceStatus(
    SC_HANDLE           hService,
    LPSERVICE_STATUS    lpServiceStatus
    );

 __declspec(dllimport) 
SERVICE_STATUS_HANDLE
 __stdcall 
RegisterServiceCtrlHandlerA(
    LPCSTR             lpServiceName,
    LPHANDLER_FUNCTION   lpHandlerProc
    );
 __declspec(dllimport) 
SERVICE_STATUS_HANDLE
 __stdcall 
RegisterServiceCtrlHandlerW(
    LPCWSTR             lpServiceName,
    LPHANDLER_FUNCTION   lpHandlerProc
    );
#line 678 "C:\WATCOM\H\NT\winsvc.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
SetServiceObjectSecurity(
    SC_HANDLE               hService,
    SECURITY_INFORMATION    dwSecurityInformation,
    PSECURITY_DESCRIPTOR    lpSecurityDescriptor
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
SetServiceStatus(
    SERVICE_STATUS_HANDLE   hServiceStatus,
    LPSERVICE_STATUS        lpServiceStatus
    );

 __declspec(dllimport) 
BOOL
 __stdcall 
StartServiceCtrlDispatcherA(
    LPSERVICE_TABLE_ENTRYA    lpServiceStartTable
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
StartServiceCtrlDispatcherW(
    LPSERVICE_TABLE_ENTRYW    lpServiceStartTable
    );
#line 713 "C:\WATCOM\H\NT\winsvc.h"

// !UNICODE


 __declspec(dllimport) 
BOOL
 __stdcall 
StartServiceA(
    SC_HANDLE            hService,
    DWORD                dwNumServiceArgs,
    LPCSTR             *lpServiceArgVectors
    );
 __declspec(dllimport) 
BOOL
 __stdcall 
StartServiceW(
    SC_HANDLE            hService,
    DWORD                dwNumServiceArgs,
    LPCWSTR             *lpServiceArgVectors
    );
#line 736 "C:\WATCOM\H\NT\winsvc.h"

// !UNICODE

 __declspec(dllimport) 
BOOL
 __stdcall 
UnlockServiceDatabase(
    SC_LOCK     ScLock
    );



}


// _WINSVC_
#line 195 "C:\WATCOM\H\NT\windows.h"



 

#line 1 "C:\WATCOM\H\NT\mcx.h"
/************************************************************************
*                                                                       *
*   mcx.h -- This module defines the 32-Bit Windows MCX APIs            *
*                                                                       *
*   Copyright (c) 1990-1995, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/




typedef struct _MODEMDEVCAPS {
    DWORD   dwActualSize;
    DWORD   dwRequiredSize;
    DWORD   dwDevSpecificOffset;
    DWORD   dwDevSpecificSize;

    // product and version identification
    DWORD   dwModemProviderVersion;
    DWORD   dwModemManufacturerOffset;
    DWORD   dwModemManufacturerSize;
    DWORD   dwModemModelOffset;
    DWORD   dwModemModelSize;
    DWORD   dwModemVersionOffset;
    DWORD   dwModemVersionSize;

    // local option capabilities
    DWORD   dwDialOptions;          // bitmap of supported values 
    DWORD   dwCallSetupFailTimer;   // maximum in seconds 
    DWORD   dwInactivityTimeout;    // maximum in seconds 
    DWORD   dwSpeakerVolume;        // bitmap of supported values 
    DWORD   dwSpeakerMode;          // bitmap of supported values 
    DWORD   dwModemOptions;         // bitmap of supported values 
    DWORD   dwMaxDTERate;           // maximum value in bit/s 
    DWORD   dwMaxDCERate;           // maximum value in bit/s 

    // Variable portion for proprietary expansion
    BYTE    abVariablePortion [1];
} MODEMDEVCAPS, *PMODEMDEVCAPS, *LPMODEMDEVCAPS;

typedef struct _MODEMSETTINGS {
    DWORD   dwActualSize;
    DWORD   dwRequiredSize;
    DWORD   dwDevSpecificOffset;
    DWORD   dwDevSpecificSize;

    // static local options (read/write)
    DWORD   dwCallSetupFailTimer;       // seconds 
    DWORD   dwInactivityTimeout;        // seconds 
    DWORD   dwSpeakerVolume;            // level 
    DWORD   dwSpeakerMode;              // mode 
    DWORD   dwPreferredModemOptions;    // bitmap 
    
    // negotiated options (read only) for current or last call
    DWORD   dwNegotiatedModemOptions;   // bitmap 
    DWORD   dwNegotiatedDCERate;        // bit/s 

    // Variable portion for proprietary expansion
    BYTE    abVariablePortion [1];
} MODEMSETTINGS, *PMODEMSETTINGS, *LPMODEMSETTINGS;

// Dial Options
// Supports wait for bong "$"
// Supports wait for quiet "@"
// Supports wait for dial tone "W"

// SpeakerVolume for MODEMDEVCAPS




// SpeakerVolume for MODEMSETTINGS




// SpeakerMode for MODEMDEVCAPS





// SpeakerMode for MODEMSETTINGS




 
// Modem Options












/* _MCX_H_ */
#line 200 "C:\WATCOM\H\NT\windows.h"
      
/* NOMCX */
                        

#line 1 "C:\WATCOM\H\NT\imm.h"
/**********************************************************************/
/*      IMM.H - Input Method Manager definitions                      */
/*                                                                    */
/*      Copyright (c) 1993-1995  Microsoft Corporation                */
/**********************************************************************/


// defined if IMM.H has been included


extern "C" {


#line 17 "C:\WATCOM\H\NT\imm.h"

typedef DWORD     HIMC;
typedef DWORD     HIMCC;

typedef HKL     *LPHKL;
typedef UINT    *LPUINT;

typedef struct tagCOMPOSITIONFORM {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} COMPOSITIONFORM, *PCOMPOSITIONFORM,    *NPCOMPOSITIONFORM,    *LPCOMPOSITIONFORM;

typedef struct tagCANDIDATEFORM {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} CANDIDATEFORM, *PCANDIDATEFORM,    *NPCANDIDATEFORM,    *LPCANDIDATEFORM;

typedef struct tagCANDIDATELIST {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[1];
} CANDIDATELIST, *PCANDIDATELIST,    *NPCANDIDATELIST,    *LPCANDIDATELIST;

typedef struct tagREGISTERWORDA {
    LPSTR   lpReading;
    LPSTR   lpWord;
} REGISTERWORDA, *PREGISTERWORDA,    *NPREGISTERWORDA,    *LPREGISTERWORDA;
typedef struct tagREGISTERWORDW {
    LPWSTR  lpReading;
    LPWSTR  lpWord;
} REGISTERWORDW, *PREGISTERWORDW,    *NPREGISTERWORDW,    *LPREGISTERWORDW;
#line 61 "C:\WATCOM\H\NT\imm.h"
typedef REGISTERWORDA REGISTERWORD;
typedef PREGISTERWORDA PREGISTERWORD;
typedef NPREGISTERWORDA NPREGISTERWORD;
typedef LPREGISTERWORDA LPREGISTERWORD;
// UNICODE



typedef struct tagSTYLEBUFA {
    DWORD       dwStyle;
    CHAR        szDescription[ 32 ];
} STYLEBUFA, *PSTYLEBUFA,    *NPSTYLEBUFA,    *LPSTYLEBUFA;
typedef struct tagSTYLEBUFW {
    DWORD       dwStyle;
    WCHAR       szDescription[ 32 ];
} STYLEBUFW, *PSTYLEBUFW,    *NPSTYLEBUFW,    *LPSTYLEBUFW;
#line 83 "C:\WATCOM\H\NT\imm.h"
typedef STYLEBUFA STYLEBUF;
typedef PSTYLEBUFA PSTYLEBUF;
typedef NPSTYLEBUFA NPSTYLEBUF;
typedef LPSTYLEBUFA LPSTYLEBUF;
// UNICODE

// prototype of IMM API

HKL   __stdcall  ImmInstallIMEA(LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText);
HKL   __stdcall  ImmInstallIMEW(LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText);
#line 96 "C:\WATCOM\H\NT\imm.h"

// !UNICODE

HWND  __stdcall  ImmGetDefaultIMEWnd(HWND);

UINT  __stdcall  ImmGetDescriptionA(HKL, LPSTR, UINT uBufLen);
UINT  __stdcall  ImmGetDescriptionW(HKL, LPWSTR, UINT uBufLen);
#line 106 "C:\WATCOM\H\NT\imm.h"

// !UNICODE

UINT  __stdcall  ImmGetIMEFileNameA(HKL, LPSTR, UINT uBufLen);
UINT  __stdcall  ImmGetIMEFileNameW(HKL, LPWSTR, UINT uBufLen);
#line 114 "C:\WATCOM\H\NT\imm.h"

// !UNICODE

DWORD  __stdcall  ImmGetProperty(HKL, DWORD);

BOOL  __stdcall  ImmIsIME(HKL);

BOOL  __stdcall  ImmSimulateHotKey(HWND, DWORD);

HIMC  __stdcall  ImmCreateContext(void);
BOOL  __stdcall  ImmDestroyContext(HIMC);
HIMC  __stdcall  ImmGetContext(HWND);
BOOL  __stdcall  ImmReleaseContext(HWND, HIMC);
HIMC  __stdcall  ImmAssociateContext(HWND, HIMC);

LONG   __stdcall  ImmGetCompositionStringA(HIMC, DWORD, LPVOID, DWORD);
LONG   __stdcall  ImmGetCompositionStringW(HIMC, DWORD, LPVOID, DWORD);
#line 134 "C:\WATCOM\H\NT\imm.h"

// !UNICODE

BOOL   __stdcall  ImmSetCompositionStringA(HIMC, DWORD dwIndex, LPCVOID lpComp, DWORD, LPCVOID lpRead, DWORD);
BOOL   __stdcall  ImmSetCompositionStringW(HIMC, DWORD dwIndex, LPCVOID lpComp, DWORD, LPCVOID lpRead, DWORD);
#line 142 "C:\WATCOM\H\NT\imm.h"

// !UNICODE

DWORD  __stdcall  ImmGetCandidateListCountA(HIMC, LPDWORD lpdwListCount);
DWORD  __stdcall  ImmGetCandidateListCountW(HIMC, LPDWORD lpdwListCount);
#line 150 "C:\WATCOM\H\NT\imm.h"

// !UNICODE

DWORD  __stdcall  ImmGetCandidateListA(HIMC, DWORD deIndex, LPCANDIDATELIST, DWORD dwBufLen);
DWORD  __stdcall  ImmGetCandidateListW(HIMC, DWORD deIndex, LPCANDIDATELIST, DWORD dwBufLen);
#line 158 "C:\WATCOM\H\NT\imm.h"

// !UNICODE

DWORD  __stdcall  ImmGetGuideLineA(HIMC, DWORD dwIndex, LPSTR, DWORD dwBufLen);
DWORD  __stdcall  ImmGetGuideLineW(HIMC, DWORD dwIndex, LPWSTR, DWORD dwBufLen);
#line 166 "C:\WATCOM\H\NT\imm.h"

// !UNICODE

BOOL  __stdcall  ImmGetConversionStatus(HIMC, LPDWORD, LPDWORD);
BOOL  __stdcall  ImmSetConversionStatus(HIMC, DWORD, DWORD);
BOOL  __stdcall  ImmGetOpenStatus(HIMC);
BOOL  __stdcall  ImmSetOpenStatus(HIMC, BOOL);

BOOL  __stdcall  ImmGetCompositionFontA(HIMC, LPLOGFONTA);
BOOL  __stdcall  ImmGetCompositionFontW(HIMC, LPLOGFONTW);
#line 179 "C:\WATCOM\H\NT\imm.h"

// !UNICODE

BOOL  __stdcall  ImmSetCompositionFontA(HIMC, LPLOGFONTA);
BOOL  __stdcall  ImmSetCompositionFontW(HIMC, LPLOGFONTW);
#line 187 "C:\WATCOM\H\NT\imm.h"

// !UNICODE

#line 193 "C:\WATCOM\H\NT\imm.h"

// !UNICODE
BOOL     __stdcall  ImmConfigureIMEA(HKL, HWND, DWORD, LPVOID);
BOOL     __stdcall  ImmConfigureIMEW(HKL, HWND, DWORD, LPVOID);
#line 200 "C:\WATCOM\H\NT\imm.h"

// !UNICODE

LRESULT  __stdcall  ImmEscapeA(HKL, HIMC, UINT, LPVOID);
LRESULT  __stdcall  ImmEscapeW(HKL, HIMC, UINT, LPVOID);
#line 208 "C:\WATCOM\H\NT\imm.h"

// !UNICODE

DWORD    __stdcall  ImmGetConversionListA(HKL, HIMC, LPCSTR, LPCANDIDATELIST, DWORD dwBufLen, UINT uFlag);
DWORD    __stdcall  ImmGetConversionListW(HKL, HIMC, LPCWSTR, LPCANDIDATELIST, DWORD dwBufLen, UINT uFlag);
#line 216 "C:\WATCOM\H\NT\imm.h"

// !UNICODE

BOOL     __stdcall  ImmNotifyIME(HIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue);

BOOL  __stdcall  ImmGetStatusWindowPos(HIMC, LPPOINT);
BOOL  __stdcall  ImmSetStatusWindowPos(HIMC, LPPOINT);
BOOL  __stdcall  ImmGetCompositionWindow(HIMC, LPCOMPOSITIONFORM);
BOOL  __stdcall  ImmSetCompositionWindow(HIMC, LPCOMPOSITIONFORM);
BOOL  __stdcall  ImmGetCandidateWindow(HIMC, DWORD, LPCANDIDATEFORM);
BOOL  __stdcall  ImmSetCandidateWindow(HIMC, LPCANDIDATEFORM);

BOOL  __stdcall  ImmIsUIMessageA(HWND, UINT, WPARAM, LPARAM);
BOOL  __stdcall  ImmIsUIMessageW(HWND, UINT, WPARAM, LPARAM);
#line 233 "C:\WATCOM\H\NT\imm.h"

// !UNICODE

UINT  __stdcall  ImmGetVirtualKey(HWND);

typedef int ( __stdcall  *REGISTERWORDENUMPROCA)(LPCSTR, DWORD, LPCSTR, LPVOID);
typedef int ( __stdcall  *REGISTERWORDENUMPROCW)(LPCWSTR, DWORD, LPCWSTR, LPVOID);
#line 243 "C:\WATCOM\H\NT\imm.h"

// !UNICODE

BOOL  __stdcall  ImmRegisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister);
BOOL  __stdcall  ImmRegisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister);
#line 251 "C:\WATCOM\H\NT\imm.h"

// !UNICODE

BOOL  __stdcall  ImmUnregisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszUnregister);
BOOL  __stdcall  ImmUnregisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszUnregister);
#line 259 "C:\WATCOM\H\NT\imm.h"

// !UNICODE

UINT  __stdcall  ImmGetRegisterWordStyleA(HKL, UINT nItem, LPSTYLEBUFA);
UINT  __stdcall  ImmGetRegisterWordStyleW(HKL, UINT nItem, LPSTYLEBUFW);
#line 267 "C:\WATCOM\H\NT\imm.h"

// !UNICODE

UINT  __stdcall  ImmEnumRegisterWordA(HKL, REGISTERWORDENUMPROCA, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister, LPVOID);
UINT  __stdcall  ImmEnumRegisterWordW(HKL, REGISTERWORDENUMPROCW, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister, LPVOID);
#line 275 "C:\WATCOM\H\NT\imm.h"

// !UNICODE

/* !_WINUSER_ */#line 309 "C:\WATCOM\H\NT\imm.h"

// wParam for WM_IME_CONTROL to the soft keyboard
// dwAction for ImmNotifyIME









// lParam for WM_IME_SETCONTEXT






// dwIndex for ImmNotifyIME/NI_COMPOSITIONSTR





// the modifiers of hot key










// Windows for Simplified Chinese Edition hot key ID from 0x10 - 0x2F




// Windows for Japanese Edition hot key ID from 0x30 - 0x4F


// Windows for Korean Edition hot key ID from 0x50 - 0x6F




// Windows for Tranditional Chinese Edition hot key ID from 0x70 - 0x8F




// direct switch hot key ID from 0x100 - 0x11F



// IME private hot key from 0x200 - 0x21F




// parameter of ImmGetCompositionString













// style bit flags for WM_IME_COMPOSITION



// bits of fdwInit of INPUTCONTEXT
// IME version constants



// IME property bits





// IME UICapability bits




// ImmSetCompositionString Capability bits



// IME WM_IME_SELECT inheritance Capability bits



// ID for deIndex of ImmGetGuideLine





// ID for dwLevel of GUIDELINE Structure






// ID for dwIndex of GUIDELINE Structure

















// ID for dwIndex of ImmGetProperty








// dwIndex for ImmSetCompositionString API




// attribute for COMPOSITIONSTRING Structure






// bit field for IMC_SETCOMPOSITIONWINDOW, IMC_SETCANDIDATEWINDOW








// conversion direction for ImmGetConversionList




// bit field for conversion mode





// only effect under IME_CMODE_NATIVE
















// style of candidate







#line 528 "C:\WATCOM\H\NT\imm.h"

// error code of ImmGetCompositionString



// dialog mode of ImmConfigureIME




// dialog mode of ImmEscape














// style of word registration




// type of soft keyboard
// for Windows Tranditional Chinese Edition

// for Windows Simplified Chinese Edition



}


// _IMM_
#line 204 "C:\WATCOM\H\NT\windows.h"
        

/* WINVER >= 0x0400 */


#line 212 "C:\WATCOM\H\NT\windows.h"
/* RC_INVOKED */

/* _INC_WINDOWS */
/* _WINDOWS_ */
#line 9 ".\winsys\ddraw.cpp"


#line 1 "system.h"
/* =======================================================================
   Copyright (c) 1990,1995   Synergistic Software
   All Rights Reserved.
   =======================================================================
   Filename: SYSTEM.H   -Header file for all source files
   Author: Chris Phillips & Wes Cumberland
   ========================================================================
   Contains the following internal functions: 
   Contains the following general functions:
   ======================================================================== */



/* ------------------------------------------------------------------------
	Type defines
   ------------------------------------------------------------------------ */
#line 1 "C:\WATCOM\H\stdio.h"
/*
 *  stdio.h	Standard I/O functions
 *
 *  Copyright by WATCOM International Corp. 1988-1996.  All rights reserved.
 */


extern "C" {

 
#pragma pack(__push,1);
#line 15 "C:\WATCOM\H\stdio.h"

/* macros for MS compatibility */
#line 20 "C:\WATCOM\H\stdio.h"
#line 23 "C:\WATCOM\H\stdio.h"
#line 26 "C:\WATCOM\H\stdio.h"

#line 42 "C:\WATCOM\H\stdio.h"

#line 52 "C:\WATCOM\H\stdio.h"

#line 57 "C:\WATCOM\H\stdio.h"

#line 65 "C:\WATCOM\H\stdio.h"


 #line 70 "C:\WATCOM\H\stdio.h"
  typedef char *__va_list[1];
 
 



 
#line 80 "C:\WATCOM\H\stdio.h"
/* number of files that can be handled */


typedef struct	__iobuf {
	unsigned char	*_ptr;		/* next character position */ 
	int		_cnt;		/* number of characters left */ 
	unsigned char	*_base; 	/* location of buffer */ 
	unsigned	_flag;		/* mode of file access */ 
	int		_handle;	/* file handle */ 
	unsigned	_bufsize;	/* size of buffer */ 
	unsigned char	_ungotten;	/* character placed here by ungetc */ 
	unsigned char	_tmpfchar;	/* tmpfile number */ 
} FILE;

typedef long	fpos_t;

/* extensions enabled */
 
 
 #line 102 "C:\WATCOM\H\stdio.h"
  /* maximum length of full pathname excl. '\0' */
 
#line 107 "C:\WATCOM\H\stdio.h"

#line 111 "C:\WATCOM\H\stdio.h"
extern	FILE   __near __iob[];

/*
 *  Define macros to access the three default file pointer (and descriptors)
 *  provided to each process by default.  They will always occupy the
 *  first three file pointers in each processes' table.
 */
/* standard input file	*/
/* standard output file */
/* standard error file	*/
/* extensions enabled */

/* standard auxiliary file  */
/* standard printer file  */



/* values for _flag field in FILE struct and _iomode array */

/* file opened for reading */
/* file opened for writing */
/* ungetc has been done */
/* big buffer allocated */
/* EOF has occurred */
/* error has occurred on this file */
/* file opened for append */
/* file is binary, skip CRLF processing */
/* full buffering */
/* line buffering */
/* no buffering */
/* this is a temporary file */
/* buffer has been modified */
/* is console device */
/*  FILE is dynamically allocated   */

/*  End of File/Error return code   */

/*  Seek relative to start of file  */
/*  Seek relative to current positn */
/*  Seek relative to end of file    */


/*  Max times tmpnam can be called  */

extern void	clearerr( FILE *__fp );
extern int	fclose( FILE *__fp );
extern int	feof( FILE *__fp );
extern int	ferror( FILE *__fp );
extern int	fflush( FILE *__fp );
extern int	fgetc( FILE *__fp );
extern int	fgetpos( FILE *__fp, fpos_t *__pos );
extern char	*fgets( char *__s, int __n, FILE *__fp );
extern FILE	*fopen( const char *__filename, const char *__mode );
extern int	fprintf( FILE *__fp, const char *__format, ... );
extern int	fputc( int __c, FILE *__fp );
extern int	fputs( const char *__s, FILE *__fp );
extern size_t	fread( void *__ptr, size_t __size, size_t __n, FILE *__fp );
extern FILE	*freopen( const char *__filename, const char *__mode, FILE *__fp );
extern int	fscanf( FILE*__fp, const char *__format, ... );
extern int	fseek( FILE *__fp, long int __offset, int __whence );
extern int	fsetpos( FILE *__fp, const fpos_t *__pos );
extern long int ftell( FILE *__fp );
extern size_t	fwrite( const void *__ptr, size_t __size, size_t __n, FILE *__fp );
extern int	getc( FILE *__fp );
extern int	getchar( void );
extern char	*gets( char *__s );
extern void	perror( const char *__s );
extern int	printf( const char *__format, ... );
extern int	putc( int __c, FILE *__fp );
extern int	putchar( int __c );
extern int	puts( const char *__s );
extern int	remove( const char *__filename );
extern int	rename( const char *__old, const char *__new );
extern void	rewind( FILE *__fp );
extern int	scanf( const char *__format, ... );
extern void	setbuf( FILE *__fp, char *__buf );
extern int	setvbuf( FILE *__fp, char *__buf, int __mode, size_t __size );
extern int	sprintf( char *__s, const char *__format, ... );
extern int	sscanf( const char *__s, const char *__format, ... );
extern FILE	*tmpfile( void );
extern char	*tmpnam( char *__s );
extern int	ungetc( int __c, FILE *__fp );
extern int	vfprintf( FILE *__fp, const char *__format, __va_list __arg );
extern int	vprintf( const char *__format, __va_list __arg );
extern int	vsprintf( char *__s, const char *__format, __va_list __arg );

/* extensions enabled */
extern int	fcloseall( void );
extern FILE	*fdopen( int __handle, const char *__mode );
extern FILE	*_fdopen( int __handle, const char *__mode );
extern int	_grow_handles( int __new_count );
extern int	fgetchar( void );
extern int	fputchar( int __c );
extern FILE	*_fsopen( const char *__filename, const char *__mode, int __shflag );
extern int	flushall( void );
extern int	vfscanf( FILE *__fp, const char *__format, __va_list __arg );
extern int	vscanf( const char *__format, __va_list __arg );
extern int	vsscanf( const char *__s, const char *__format, __va_list __arg );
extern int	_bprintf( char *__buf, unsigned int __bufsize, const char *__fmt, ... );
extern int	_vbprintf( char *__s, unsigned int __bufsize, const char *__format, __va_list __arg );
#line 247 "C:\WATCOM\H\stdio.h"








#line 259 "C:\WATCOM\H\stdio.h"


















 
#pragma pack(__pop);
#line 282 "C:\WATCOM\H\stdio.h"


};


#line 17 "system.h"
		// for FILE*.
#line 1 "C:\WATCOM\H\stdlib.h"
/*
 *  stdlib.h	Standard Library functions
 *
 *  Copyright by WATCOM International Corp. 1988-1996.  All rights reserved.
 */
#line 274 "C:\WATCOM\H\stdlib.h"
#line 18 "system.h"
		// for rand.


//#include <windows.h>


#line 1 "typedefs.h"
/* =======================================================================
   Copyright (c) 1990,1995   Synergistic Software
   All Rights Reserved.
   =======================================================================
   Filename: TYPEDEFS.H   -Header file for all core types
   Author: Everyone
   ======================================================================== */




	typedef signed long		LONG;


//#ifndef _WINDOWS
//ypedef signed long		LONG;

	typedef int	BOOL;
#line 22 "typedefs.h"
//#endif

#line 27 "typedefs.h"

#line 31 "typedefs.h"

#line 35 "typedefs.h"

// only use for data
typedef signed char		SBYTE;
typedef unsigned char	UBYTE;
typedef signed short	SHORT;
typedef unsigned short	USHORT;
typedef signed short	ERRCODE;
typedef unsigned long	ULONG;
typedef unsigned char *	PTR;
typedef PTR	*			HDL;

// only use for strings
typedef char			CHAR;
typedef unsigned char	UCHAR;
typedef char *			CSTRPTR;

// function prototype types
typedef void	(*PFV)(void);
typedef LONG	(*PFLV)(void);
typedef LONG	(*PFLL)(LONG);
typedef void	(*PFVL)(LONG);
typedef int		(*PFIL)(LONG);
typedef void	(*PFVLLL)(LONG,LONG,LONG);
typedef void	(*PFVLL)(LONG,LONG);
typedef void	(*PFVLLB)(LONG,LONG,BOOL);
typedef LONG	(*PFLLLL)(LONG,LONG,LONG);

// match graphics structs
//#ifndef _WINDOWS
#line 83 "typedefs.h"

 /* Flic File Header */
 typedef struct
 {
 	LONG		size;				/* Size of flic including this header. */ 
 	USHORT	type;				/* Either FLI_TYPE or FLC_TYPE below. */ 
 	USHORT	frames;			/* Number of frames in flic. */ 
 	USHORT	width;			/* Flic width in pixels. */ 
 	USHORT	height;			/* Flic height in pixels. */ 
 	USHORT	depth;			/* Bits per pixel.	(Always 8 now.) */ 
 	USHORT	flags;			/* FLI_FINISHED | FLI_LOOPED ideally. */ 
 	LONG		speed;			/* Delay between frames. */ 
 	USHORT	scale;			/* Set to zero. */ 
 	SHORT		xCenter;			/* */ 
 	SHORT		yCenter;			/* */ 
 //!! fix padding bug in visual c++ !!!!!!!!!!!!!!!!!!!!!
 //	ULONG		creator;			/* Serial # of flic creator. (FLC only.) */
 //	ULONG		updated;			/* Date of flic update. (FLC only.) */
 //	ULONG		updater;			/* Serial # of flic updater. (FLC only.) */
 	USHORT	creator1;		/* Serial # of flic creator. (FLC only.) */ 
 	USHORT	creator2;		/* Serial # of flic creator. (FLC only.) */ 
 	USHORT	updated1;		/* Date of flic update. (FLC only.) */ 
 	USHORT	updated2;		/* Date of flic update. (FLC only.) */ 
 	USHORT	updater1;		/* Serial # of flic updater. (FLC only.) */ 
 	USHORT	updater2;		/* Serial # of flic updater. (FLC only.) */ 
 //!! fix padding bug in visual c++ !!!!!!!!!!!!!!!!!!!!!
 	USHORT	aspect_dx;		/* Width of square rectangle. (FLC only.) */ 
 	USHORT	aspect_dy;		/* Height of square rectangle. (FLC only.) */ 
 	UBYTE		reserved2[38];	/* Set to zero. */ 
 	ULONG		oframe1;			/* Offset to frame 1. (FLC only.) */ 
 	ULONG		oframe2;			/* Offset to frame 2. (FLC only.) */ 
 	UBYTE		reserved3[40];	/* Set to zero. */ 
 } FLICHEAD, *FLICHEADPTR;



// Note: X & Y for the 3D POINT & VECTOR types must be the first
//       two data items so we can call the 2D rotate point fns on them.

typedef struct _POINT_3D
{
	LONG x;
	LONG y;
	LONG z;
} POINT_3D, *PTR_POINT_3D;

typedef struct _VECTOR
{
	LONG dx;
	LONG dy;
} VECTOR, *PTR_VECTOR;

typedef struct _VECTOR_3D
{
	LONG dx;
	LONG dy;
	LONG dz;
} VECTOR_3D, *PTR_VECTOR_3D;


typedef struct
{
	POINT a,b;
} LINE2D;

typedef POINT 		FIXED_POINT;       	// For 24.8 fixed point math points. 
typedef POINT_3D	FIXED_POINT_3D;		// x & y are 28.8 and z is LONG 
typedef VECTOR		FIXED_VECTOR;   	// a pair of 24.8 delta values. 
typedef VECTOR_3D	FIXED_VECTOR_3D;	// x & y are 24.8 and z is a LONG. 

/* -----------------------------------------------------------------
   Pragmas
   ----------------------------------------------------------------- */
// init cont problems with shorts
#pragma warning 389 4
// unused variables
#pragma warning  14 4


// _TYPEDEFS_H

#line 24 "system.h"
 
#line 1 "colors.h"













#line 25 "system.h"

#line 1 "memmanag.h"
/* ========================================================================
   Copyright (c) 1990,1996	Synergistic Software
   All Rights Reserved
   Author: G. Powell
   ======================================================================== */



/* ------------------------------------------------------------------------
   Sub Includes
   ------------------------------------------------------------------------ */
#line 1 "typedefs.h"
/* =======================================================================
   Copyright (c) 1990,1995   Synergistic Software
   All Rights Reserved.
   =======================================================================
   Filename: TYPEDEFS.H   -Header file for all core types
   Author: Everyone
   ======================================================================== */
// _TYPEDEFS_H#line 163 "typedefs.h"

#line 12 "memmanag.h"
 

/* ------------------------------------------------------------------------
   Defines and Compile Flags
   ------------------------------------------------------------------------ */



/* Equates for memory manager block attributes */
// Note: UNUSED, FREEMEM, BLKINUSE, BLKTYPE3, BLKTYPE4, STARTBLK, ENDBLK
//       are all mutually exclusive states, not bits.









// Note : CLASSPERM, CLASS1, CLASS2, CLASSTEMP are mutually exclusive states,
//		  not bits.






// Note: LOCKED, PURABLE, MODLY, MODIFABLE are all bits, not states.

// Used by Dispose when called from PurgeMem_


// Set this render frame if touched by BLKPTR.
// The previous state of MOLDYBIT, last frame.

#line 51 "memmanag.h"

// Note: The Resource Id Bit is set on the resource handle itself.



/* ------------------------------------------------------------------------
   Enums
   ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------
   Typedefs
   ------------------------------------------------------------------------ */
typedef USHORT ATTR_BLK_TYPE;

/* ------------------------------------------------------------------------
   Macros
   ------------------------------------------------------------------------ */
/* These macros set or clear attribute bits in the memory manager */
// Fragments memory if left on.





















#line 94 "memmanag.h"







	


/* ------------------------------------------------------------------------
   Global Variables
   ------------------------------------------------------------------------ */

extern "C" {


extern ULONG *				apBlocks;				/* memmanag.c */ 
extern SHORT *				aiNextBlk;				/* memmanag.c */ 
extern SHORT *				aiPrevBlk;				/* memmanag.c */ 
extern ATTR_BLK_TYPE *		abBlockAttr;			/* memmanag.c */ 
extern USHORT				cNumBlkHeads;			/* memmanag.c */ 
extern BOOL					fReport;				/* memmanag.c */ 


}


/* ------------------------------------------------------------------------
   Prototypes
   ------------------------------------------------------------------------ */

extern "C" {


void *BLKPTR(LONG);
void * _zalloc(char * /* Name */ , LONG /* lineNo */ , LONG i);
void * _zone_alloc(LONG i);
ULONG InitMemManag (ULONG cbMinMemoryNeeded,
					USHORT cNumBlkHeads_,
					USHORT cNumResHeads_,
					BOOL fReport_);
void QuitMemManag (void);
ULONG get_free_mem(void);
SHORT NewExternalBlock (PTR p);
SHORT SetBlockAttr (SHORT i, ATTR_BLK_TYPE mask, ATTR_BLK_TYPE value);
ATTR_BLK_TYPE GetBlockAttr (SHORT i);
ULONG GetBlockSize (LONG i);
ULONG GetDataBlkSize (LONG i);
SHORT _NewBlock (ULONG cBytes);
SHORT _NewBlockHigh (ULONG cBytes);
SHORT _SetPurge (SHORT );
SHORT _ClrPurge (SHORT );
SHORT DisposBlock (SHORT i);
SHORT DisposClass (UBYTE );
SHORT SetPurgeClass (UBYTE );
ULONG ReportFreeMem (ULONG fPurgable);
ULONG ReportInUse (ULONG fPurgable);
SHORT SetBlockSize (SHORT i, ULONG cBytes);
SHORT SetLock (SHORT i);
SHORT HandleOutOfMemory (void);
void PrintMemList (void);
PTR  _GetBlockPtr(SHORT hdl);
void ClearAllMoldyBits();
BOOL IsBlockMoldy(SHORT i);
BOOL IsBlockPurgable(SHORT i);
BOOL IsBlockMultiUser(SHORT i);

BOOL IsHandleFlushed(LONG i);


void PrintUnFreedMemoryReport();
SHORT SetBlockName(char * /* name */ , SHORT /* Hdl */ );
SHORT SetDebugInfo(char * /* file */ , LONG /* line */ , SHORT /* Hdl */ );



#line 179 "memmanag.h"


}


// _MEMMANAG_H
#line 26 "system.h"
 
#line 1 "resmanag.h"
/* ========================================================================
   Copyright (c) 1990,1996	Synergistic Software
   All Rights Reserved
   Author: G. Powell
   ======================================================================== */



/* ------------------------------------------------------------------------
   Sub Includes
   ------------------------------------------------------------------------ */
#line 1 "typedefs.h"
/* =======================================================================
   Copyright (c) 1990,1995   Synergistic Software
   All Rights Reserved.
   =======================================================================
   Filename: TYPEDEFS.H   -Header file for all core types
   Author: Everyone
   ======================================================================== */
// _TYPEDEFS_H#line 163 "typedefs.h"

#line 12 "resmanag.h"
 
#line 1 "memmanag.h"
/* ========================================================================
   Copyright (c) 1990,1996	Synergistic Software
   All Rights Reserved
   Author: G. Powell
   ======================================================================== */
// _MEMMANAG_H#line 185 "memmanag.h"
#line 13 "resmanag.h"
 

/* ------------------------------------------------------------------------
   Defines and Compile Flags
   ------------------------------------------------------------------------ */

/* ------------------------------------------------------------------------
   Enums
   ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------
   Typedefs
   ------------------------------------------------------------------------ */
typedef SHORT  (*PFRESLOAD)		(CSTRPTR szResName, BOOL fSetPal, BOOL fLockRes, BOOL fRotated);
typedef SHORT  (*PFRESDISPOSE)	(SHORT sResHandle, SHORT sMemHandle);
typedef SHORT  (*PFRESSETPURGE)	(SHORT sResHandle, SHORT sMemHandle);
typedef SHORT  (*PFRESCLRPURGE)	(SHORT sResHandle, SHORT sMemHandle);
typedef ULONG  (*PFRESHASH)		(CSTRPTR szResName);

/* RESTYPE structure */
typedef struct _RESTYPE
{
	char			achExtention[4];	// three letter extention to register 
	PFRESLOAD		pfLoadProc;			// Load function 
	PFRESDISPOSE	pfDisposeProc;		// Dispose function 
	PFRESSETPURGE	pfSetPurgeProc;		// Set Purge function 
	PFRESCLRPURGE	pfClrPurgeProc;		// Clear Purge function 
	PFRESHASH		pfHashProc;			// Hash the szResName. 
} RESTYPE, PRESTYPE;

/* ------------------------------------------------------------------------
   Macros   
   ------------------------------------------------------------------------ */






#line 57 "resmanag.h"

/* ------------------------------------------------------------------------
   Global Variables
   ------------------------------------------------------------------------ */

extern "C" {


extern ULONG				*cbResOffset;			/* resmanag.c */ 
extern SHORT				*iResBlock;		   		/* resmanag.c */ 
extern UBYTE				*iResFile;				/* resmanag.c */ 
//extern USHORT				iNextResSlotAvail;		/* resmanag.c */
#line 72 "resmanag.h"
extern UBYTE				iNextFileNameAvail;		/* resmanag.c */ 
extern BOOL					fNewRes;				/* resmanag.c */ 
extern int					file;

extern UBYTE				*iResExtIndex;		/* index into ResExtentions */ 
extern RESTYPE				ResExtentions[];

extern LONG					iMaxResSlots;
extern LONG					iMaxResSlotsUsed;


}


/* ------------------------------------------------------------------------
   Prototypes
   ------------------------------------------------------------------------ */

extern "C" {


/* resmanag.c */
SHORT OpenResFile_ (CSTRPTR szFileName);
SHORT _GetResource_ (CSTRPTR szResName, BOOL fSetPal, BOOL fLockRes, BOOL fRotated);
SHORT Query_iResBlock (SHORT i);
SHORT PutPCX (SHORT iS, USHORT x, USHORT y, USHORT width, USHORT height, CSTRPTR szFileName);
SHORT PutScreen (SHORT iS, USHORT x, USHORT y, USHORT width, USHORT height, CSTRPTR szFileName);
SHORT RegisterResExtention ( CSTRPTR sExtention, 
							   PFRESLOAD LoadProc,
							   PFRESDISPOSE DisposeProc, 
							   PFRESSETPURGE SetPurgeProc, 
							   PFRESCLRPURGE ClrPurgeProc,
							   PFRESHASH HashProc );
SHORT DisposRes (SHORT iResBlk, SHORT iMemBlk);
SHORT ReleaseRes (SHORT iResBlk);
SHORT SetPurgeRes (SHORT iResBlk, SHORT iMemBlk);
SHORT ClrPurgeRes (SHORT iResBlk, SHORT iMemBlk);
//GEH USHORT HashCRC(CSTRPTR szResName);
ULONG HashCRC(CSTRPTR szResName);
ULONG HashID(CSTRPTR szFileName);
USHORT CheckSum(SHORT i);

// Call before initializing the memory manager. Or inside the memory
// manager init fn.
BOOL InitResourceManager(USHORT NumResHandles);
void FreeResourceManager();


}

// _RESMAMANG_H
#line 27 "system.h"

#line 1 "regions.h"
/* ========================================================================
   Copyright (c) 1990,1996	Synergistic Software
   All Rights Reserved
   Author: G. Powell
   ======================================================================== */



/* ------------------------------------------------------------------------
   Sub Includes
   ------------------------------------------------------------------------ */
#line 1 "typedefs.h"
/* =======================================================================
   Copyright (c) 1990,1995   Synergistic Software
   All Rights Reserved.
   =======================================================================
   Filename: TYPEDEFS.H   -Header file for all core types
   Author: Everyone
   ======================================================================== */
// _TYPEDEFS_H#line 163 "typedefs.h"

#line 12 "regions.h"
 

/* ------------------------------------------------------------------------
   Defines and Compile Flags
   ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------
   Enums
   ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------
   Typedefs
   ------------------------------------------------------------------------ */
typedef enum {
	REGION_EVENT_NOT_HANDLED,
	REGION_HANDLED_EVENT
} REGION_EVENT_TYPE;

// Structure to return the previous key state in add_key & del_key.
typedef struct _KeyStruct {
	LONG	val;
	LONG	val2;
	PFVLL	func;
} KEYSTRUCT, *PTR_KEYSTRUCT;

typedef enum {
		CHANGE_ALL_REGIONS = 6,
		CHANGE_TOP_STACK = -12
	} CHANGE_REGION_MODE;

/* ------------------------------------------------------------------------
   Macros   
   ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------
   Prototypes
   ------------------------------------------------------------------------ */

extern "C" {


/* regions.c */
void add_key(LONG /* key */ ,
				  PFVLL /* func */ , 
				  LONG /* val */ , 
				  LONG /* val2 */ );

void replace_key_vals(LONG /* key */ , 
                 PFVLL /* pNewFunc */ ,
                 LONG /* NewVal */ ,
                 LONG /* NewVal2 */ ,
                 PTR_KEYSTRUCT /* pOldKeyStruct */ );
void del_key(LONG /* key */ , 
             PTR_KEYSTRUCT /* pKeyStruct */ );

LONG add_region(LONG x,LONG y,LONG w,LONG h,LONG key,PFVLL func,LONG val, LONG val2,LONG id, int idToolTip);
void del_region(PFVLL func,LONG key);
void del_all_regions(void);
REGION_EVENT_TYPE check_regions();
void paint_tooltips(void);
void init_regions(void);
void push_regions(void);
void pop_regions(void);
void activate_region(LONG id, BOOL state_on);
void OutlineAllRegions(void);
BOOL change_tooltip(PFVLL func, LONG key, LONG x, LONG y, 
					LONG newTooltip,
					CHANGE_REGION_MODE crMode);
BOOL change_function(PFVLL Oldfunc, 
                     LONG Oldkey, 
                     LONG x, LONG y, 
                     PFVLL NewFunc,
					 LONG NewKey,
					 LONG NewVal,
					 LONG NewVal2,
					 CHANGE_REGION_MODE crMode);

BOOL del_region_xy(PFVLL Oldfunc,
				   LONG x, 
				   LONG y, 
				   LONG w, 
				   LONG h, 
				   CHANGE_REGION_MODE crMode);

}

// _REGIONS_H
#line 28 "system.h"



//---- random override for logging
#line 1 "random.h"
/* ========================================================================
   Copyright (c) 1990,1996	Synergistic Software
   All Rights Reserved
   ========================================================================
   Filename: random.hxx  -
   Author:   David L Jackson

   ========================================================================

	This file contains the random procedures used by Birthright. 
	In general DOS and WIN95 just use the normal rand() function. 
	In multiplayer we do just alittle bit more by logging each random.

   ======================================================================== */



#line 36 "random.h"

#line 32 "system.h"
 



/* ------------------------------------------------------------------------
	Misc Defines
   ------------------------------------------------------------------------ */
/* Scale defines */
















/* ------------------------------------------------------------------------
	General Defines
   ------------------------------------------------------------------------ */



/* mark file as unavailable for future referance */


// Macro for testing bad memory pointers.













/* menu defines */



/* menu flags */


















/* ------------------------------------------------------------------------
	Font Defines
   ------------------------------------------------------------------------ */
















/* ------------------------------------------------------------------------
	Defines for resource manager functions
   ------------------------------------------------------------------------ */
/* file I/O flag defines */



/* header type defines */















/* ------------------------------------------------------------------------
	Defines for graphic functions
   ------------------------------------------------------------------------ */
/* non-standard mode defines */


/* draw routine function constants */







/* defines for Print */




/************************************************************
	Defines for type of installation selected by user, CD-ROM drive letter
************************************************************/




/* ------------------------------------------------------------------------
	Structure defines
   ------------------------------------------------------------------------ */
typedef struct colorspec
{
	UBYTE		bRed;
	UBYTE		bGreen;
	UBYTE		bBlue;
} COLORSPEC, *PALETTE;

/* BITM header structure */
typedef struct bitmhdr
{
	SHORT		w;				/* raster width & height in pixels */ 
	USHORT	h;
	SHORT		scale;		/* current scale discovered */ 
	SHORT		x_ctr_pt;	/* center point discovered */ 
	SHORT		type;			/* set to TYPEBITM */ 
} BITMHDR, *BITMPTR, ARECT, *RECTPTR;


/* Flic Chunk Header */
typedef struct
{
	LONG		size;			/* Size of chunk including header. */ 
	USHORT	type;			/* Value from ChunkTypes above. */ 
} CHUNKHEAD, *CHUNKHEADPTR;

/* Flic Frame Header */
typedef struct
{
	LONG		size;				/* Size of frame including header. */ 
	USHORT	type;				/* Always FRAME_TYPE */ 
	SHORT		chunks;			/* Number of chunks in frame. */ 
	UBYTE		reserved[8];	/* Always 0. */ 
} FRAMEHEAD, *FRAMEHEADPTR;

/* menu button types */
typedef enum {
	BUTTON_REGION = 0,
	BUTTON_SHADEBEVEL,
	BUTTON_COLORBEVEL,
	BUTTON_ENTRY,
	BUTTON_LISTBOX,
	BUTTON_BITMAP
} BUTTON_TYPE;

/* menu buttons */
typedef struct _BUTTON {
	LONG			Id;				// button id 
	BUTTON_TYPE		btType;			// button type 
	LONG			Flags;			// button control flags 
	LONG			Color;			// color of button 
	int				iLabel;			// text label for button 
	LONG			LabelColor;		// color of label text 
	CSTRPTR			pArt;			// name of art for this button 
	CSTRPTR			pHilight;		// name of art for hilight state 
	LONG			X;				// x,y,w,y of button region 
	LONG			Y;
	LONG			W;
	LONG			H;
	LONG			Key;			// hot key short cut 
	PFVLL			pfFunction;		// function if region activated 
	LONG			Arg;			// user arg passed to function 
	int				idToolTip;		// Tooltip for the region. 
} BUTTON;

typedef struct _MENU {
	BUTTON	*Buttons;
	LONG	MenuButtonCount;
} MENU, *PMENU;

/* ------------------------------------------------------------------------
   Macros
   ------------------------------------------------------------------------ */














// adjusts a value for screen resolution
//GEH #define X_RES_ADJ(x)	((x) * window_width / MAX_VIEW_WIDTH)
//GEH #define Y_RES_ADJ(y)	((y) * window_height / MAX_VIEW_HEIGHT)
// I fixed the screen to always be MAX_VIEW_WIDTH/HEIGHT
















/* ------------------------------------------------------------------------
   Prototypes
   ------------------------------------------------------------------------ */

extern "C" {


#line 290 "system.h"

/* assert.c */
// over-ride the assert
#line 296 "system.h"
void _assert(BOOL fTest,char *FileName, SHORT LineNum);




/* system.c */
void SaveVideoSet (void);
void RestoreVideoSet (void);
void set_margin_size (LONG l,LONG r,LONG t,LONG b);
void get_margin_size (LONG *l,LONG *r,LONG *t,LONG *b);
void set_screen_size (LONG vw,LONG vh);
void set_view_size (LONG vx,LONG vy,LONG vw,LONG vh);
void plot (LONG x,LONG y,LONG c);
LONG get_pixel (LONG x,LONG y);
void line (LONG x0, LONG y0, LONG x1, LONG y1,LONG color);
ULONG detect_scale (SHORT t, SHORT h, SHORT w);
LONG gplot_char(LONG c, LONG x, LONG y, LONG color);
LONG gtext_width(char *text);
LONG gtext_height(char *text);
SHORT gprint_text(LONG x,LONG y,char *text,LONG color);
void print_text_centered(LONG x,LONG y,char * text,LONG color);
SHORT print_textf(LONG x, LONG y, LONG color, const char *format, ...);
void init_gfont(SHORT type_and_size);
void ClearRemapTable(void);
void SetRemapTable(USHORT);
void DrawBitmap (SHORT x, SHORT y, SHORT iBitm, SHORT xb, SHORT yb, SHORT w, SHORT h);
SHORT SaveBitmap (SHORT x, SHORT y, SHORT w, SHORT h);
void ZoomBitmap(SHORT x, SHORT y, SHORT iBitm, SHORT xb, SHORT yb, 
					 SHORT w, SHORT h, SHORT hDest, POINT start,
					 POINT bck, SHORT bckw, SHORT bckh);
void ZoomOutBitmap(SHORT x, SHORT y, SHORT iBitm, SHORT xb, SHORT yb, 
						 SHORT w, SHORT h, SHORT hDest, POINT start,
						 POINT bck, SHORT bckw, SHORT bckh);
void ScaleBitmap (SHORT, SHORT, SHORT, SHORT, SHORT, SHORT, SHORT, SHORT);
SHORT _OpenBitm (SHORT w, USHORT h, BOOL fLocked);
BOOL Exists( char *filename);
void dec_view_size(LONG arg1, LONG arg2);
void inc_view_size(LONG arg1, LONG arg2);
void inc_lens (LONG, LONG);
void dec_lens (LONG, LONG);


/* menu.c */
void InitMenuSys(PMENU UserMenus, LONG Count);
void ReleaseMenu(LONG Index);
void ShowSubMenu(LONG, LONG index);
void QuitSystem(LONG, LONG);
void ShowMenu(LONG Index);
void HideSubMenu(LONG, LONG index);
void HideMenu(LONG Index);
void RunMenus(void);
void IncrementVal( LONG unused, LONG pVal );
void DecrementVal( LONG unused, LONG pVal );
void ToggleVal(LONG unused,  LONG pVal );
LONG SetButtonValue ( LONG MenuIndex, LONG ButtonId, LONG Val);
LONG GetButtonValue ( LONG MenuIndex, LONG ButtonId);
LONG SetButtonProc ( LONG MenuIndex, LONG ButtonId, PFVLL pFunc, LONG Val, LONG Key );
LONG ChangeButtonProc ( LONG MenuIndex, LONG ButtonId, PFVLL pFunc, LONG Val, LONG Key );
LONG SetButtonLabel ( LONG MenuIndex, LONG ButtonId, int iLabel, LONG Color );
LONG SetButtonLabelColor ( LONG MenuIndex, LONG ButtonId, LONG Color );
LONG SetButtonPosition ( LONG MenuIndex, LONG ButtonId, LONG X, LONG Y );
LONG GetButtonPosition ( LONG MenuIndex, LONG ButtonId, LONG *X, LONG *Y );
LONG SetButtonSize ( LONG MenuIndex, LONG ButtonId, LONG W, LONG H );
LONG GetButtonSize ( LONG MenuIndex, LONG ButtonId, LONG *W, LONG *H );
LONG GetButtonFlags ( LONG MenuIndex, LONG ButtonId );
LONG SetButtonFlag ( LONG MenuIndex, LONG ButtonId, LONG Flag );
LONG SetButtonType ( LONG MenuIndex, LONG ButtonId, LONG Type );
LONG ClearButtonFlag ( LONG MenuIndex, LONG ButtonId, LONG Flag );
LONG GetButtonLabel(LONG MenuIndex, LONG ButtonID, CSTRPTR *pLabel);
LONG GetButtonArt(LONG MenuIndex, LONG ButtonId, CSTRPTR *pArt);
LONG SetButtonArt ( LONG MenuIndex, LONG ButtonId, CSTRPTR pArtPath);
LONG SetButtonHilightArt ( LONG MenuIndex, LONG ButtonId, CSTRPTR pArtPath);
LONG SetButtonHilight ( LONG MenuIndex, LONG ButtonId, BOOL Hilight );
LONG SetUpdate(LONG MenuIndex, LONG ButtonId);
LONG CleanUpdate(LONG MenuIndex, LONG ButtonId);
LONG SetButtonToolTip(LONG MenuIndex, LONG ButtonId, LONG NewToolTip);
LONG ChangeButtonToolTip(LONG MenuIndex, LONG ButtonId, LONG NewToolTip);

/* redbook.c */
int PlayRedBook (ULONG start, ULONG length);
int StopRedBook (void);
int PlayTrack (SHORT track);
unsigned long FindTrackStart (unsigned char track);
int CheckCDBusy (void);
int PlayCDMusic (unsigned short tune);
void LoadMusicFromCD(short);
/* game.cpp */
void GAMEToggleMainMenu(LONG fState, LONG);
char* GetSourcePath(void);
BOOL CheckCDError(void);

/* fopen.c */
FILE *FileOpen( CSTRPTR pszFile, CSTRPTR pszAccess );
SHORT DiskOpen( CSTRPTR pszFile );
LONG FileAccess(CSTRPTR);
/* vdpmi.c */
void * D32DosMemAlloc ( ULONG size );

/* ------------------------------------------------------------------------
   Global Variables
   ------------------------------------------------------------------------ */
// for critical errors due to CD removed
extern BOOL fGraphInitialized;	// main.cpp 
extern BOOL fIsFadedOut;

extern char CDDrive[4];
extern SHORT InstallationType;   /*main.cpp*/ 
extern char InstallPath[256];
extern ULONG *			apBlocks;				/* memmanag.c */ 
extern COLORSPEC		CurPal[256];
extern BOOL				fLowMemory;				/* memmanag.c */ 
extern BOOL				fMinMemory;				/* memmanag.c */ 
extern BOOL				fSmallMap;				/* memmanag.c */ 
extern BOOL				fRestrictAni;			/* memmanag.c */ 
extern BOOL				fLowResAni;				/* memmanag.c */ 
extern BOOL 			fMedResAni;				/* memmanag.c */ 
extern BOOL 			fLowResTextures;		/* memmanag.c */ 
extern BOOL 			fMedResTextures;		/* memmanag.c */ 
extern LONG  			screen_buffer_width;	/* system.c */ 
extern LONG  			screen_buffer_height;
extern LONG				graphics_mode;
extern PTR				screen;
extern LONG				lens_factor;
extern int				fMusic;					/* redbook.c */ 
extern SHORT			UserCDVolume;			/* redbook.c */ 
extern SHORT	ucWhichTrack;			// redbook.c 
extern POINT         zoomStart;           //menu.c 

/*	======================================================================= */



}

// _SYSTEM_H
#line 11 ".\winsys\ddraw.cpp"
 
#line 1 "engine.h"
/* RM250 */
/* ========================================================================
   Copyright (c) 1990,1996	Synergistic Software
   All Rights Reserved
   ======================================================================== */



/* ------------------------------------------------------------------------
   Sub Includes
   ------------------------------------------------------------------------ */
//map.h!
#line 1 "map.h"
/* ========================================================================
   Copyright (c) 1990,1996	Synergistic Software
   All Rights Reserved
   ======================================================================== */




/* ------------------------------------------------------------------------
   Sub Includes
   ------------------------------------------------------------------------ */
#line 1 "typedefs.h"
/* =======================================================================
   Copyright (c) 1990,1995   Synergistic Software
   All Rights Reserved.
   =======================================================================
   Filename: TYPEDEFS.H   -Header file for all core types
   Author: Everyone
   ======================================================================== */
// _TYPEDEFS_H#line 163 "typedefs.h"

#line 12 "map.h"
 
#line 1 "thingtyp.h"
/* ========================================================================
   Copyright (c) 1990,1995   Synergistic Software
   All Rights Reserved.
   =======================================================================
   Filename: THINGTYP.H    -Enumerations of the objects in the game.
   Author: Gary Powell
   ======================================================================== */



/* ------------------------------------------------------------------------
   Includes
   ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------
   Notes
   ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------
   Defines and Compile Flags
   ------------------------------------------------------------------------ */


//enum table for objects in Birthright
// Note: The numbers assigned to the enumeration are the same as the indices
//       as the values in mythings[objectindex].type.

typedef enum {
	NOLOW			 		=	-1,
	NO_THING         		=    0,	// (nothing) 
//	PLAYERSTART1     		=    1,	// Player 1 start
//	PLAYERSTART2     		=    2,	// Player 2 start
//	PLAYERSTART3     		=    3,	// Player 3 start
//	PLAYERSTART4     		=    4,	// Player 4 start
//	DEATHMATCH       		=   11,	// Deathmatch start positions.
//	TELEPORT         		=   14,	// teleport to the SECTOR containing this thing
	FIRST_GAME_THING 		=   15,	// first game thing 
	GARGOYLE_1				=	15,	// Gargoyle 
	T_GARGOYLE_1			=	16,	// Troop Gargoyle 
	OTYUGH_1				=	17,	// Otyugh 
	T_OTYUGH_1				=	18,	// Troop Otyugh 
		
	ARCHER           		=   20,	// Archer 
	LIGHT_CAVALRY    		=   21,	// Light Cavalry 
	ELITE_INFANTRY   		=   22,	// Elite Infantry 
	INFANTRY         		=   23,	// Infantry 
	IRREGULAR        		=   24,	// Irregular 
	KNIGHT           		=   25,	// Knight/Heavy Cavalry 
	T_LORD_MALE_1    		=   26,	// Troop Lord Male 1 
	OFFICER          		=   27,	// Officer 
	PIKEMAN          		=   28,	// Pikeman 
	T_WYVERN_1         		=   29,	// Troop Wyvern	1 
	T_ANKHEG          		=   30,	// Troop Ankheg 
	T_OGRE           		=   31,	// Troop Ogre 
	T_HELL_HOUND     		=   32,	// Troop Hell Hound 
	T_HARPY          		=   33,	// Troop Harpy 
	T_SKELETON       		=   34,	// Troop Skeleton 
	T_GIANT_SPIDER   		=   35,	// Troop Giant Spider 
	T_SPECTRE        		=   36,	// Troop Spectre 
	T_WRAITH         		=   37, // Troop Wraith 
	DWARF_ARCHER     		=   38,	// Dwarf Archer 
	DWARF_INFANTRY   		=   39,	// Dwarf Infantry 
	T_DWARF_OFFICER_1    	=   40,	// Troop Dwarf Officer 1 
	T_DWARF_OFFICER_2		=	41, // Troop Dwarf Officer 2 
	ELF_ARCHER       		=   42,	// Elf Archer 
 	ELF_OFFICER_2    		=   43,	// Elf Officer 2 
	ELF_INFANTRY     		=   44,	// Elf Infantry 
	ELF_OFFICER_1      		=   45,	// Elf Officer 1 
	T_DWARF_OFFICER_3		=   46,	// Troop Dwarf Officer 3 
	GOBLIN_ARCHER    		=   47,	// Goblin Archer 
	GOBLIN_CAVALRY   		=   48,	// Goblin Cavalry 
	GOBLIN_INFANTRY  		=   49,	// Goblin Infantry 
	T_GOBLIN_ZOMBIE	 		=   50,	// Troop Goblin Zombie 
	T_GOBLIN_OFFICER 		=   51,	// Troop Goblin Officer 
	T_GOBLIN_QUEEN   		=   52,	// Troop Goblin Queen 
	T_ZOMBIE         		=   53,	// Troop Zombie 
	T_CEILING_SPIDER 		=   54,	// Troop Ceiling Spider 
	MERC_INFANTRY    		=   55,	// Mercenary Infantry 
	T_ELF_LADY_LORD  		=   56,	// Troop Elf Lady Lord 
	MERC_OFFICER     		=   57,	// Mercenary Officer 
	MERC_PIKEMAN     		=   58,	// Mercenary Pikeman 
	T_DOG            		=   59, // Troop Dog 
	WIZARD_MALE_4			=	60,	// Wizard Male 4 
	T_WIZARD_MALE_4			=	61,	// Troop Wizard Male 4 
	T_LORD_MALE_2    		=   62, // Troop Lord Male 2 
	WIZARD_MALE_3			=   63,	// Wizard Male 3  
	T_LORD_MALE_3    		=   64,	// Troop Lord Male 3 
	CHIEF            		=   65,	// Chief 
	LORD_MALE_4       		=   66,	// Lord Male 4 
	LORD_MALE_5       		=   67,	// Lord Male 5 
	GUARD            		=   68,	// Guard 
	LIEUTENANT       		=   69,	// Lieutenant 
	GUILDER_MALE_1         	=   70,	// Guilder Male 1 
	GUILDER_MALE_2          =   71,	// Guilder Male 2 
	T_LORD_MALE_4    		=   72,	// Troop Lord Male 4 
	T_LORD_MALE_5         	=   73,	// Troop Lord Male 5 
	LORD_MALE_6         	=   74,	// Lord Male 6 
	PRIEST_MALE_1   		=   75,	// Priest Male 1 
	PRIEST_MALE_2   		=   76,	// Priest Male 2 
	PRIEST_FEMALE_1   		=   77,	// Priest Female 1 
	T_LORD_MALE_6    		=   78,	// Troop Lord Male 6 
	ELF_LADY_LORD  			=   79,	// Elf Lady Lord 
	T_LORD_MALE_7    		=   80,	// Troop Lord Male 7 
	ELF_LORD_1     			=   81,	// Elf Lord 1 
	T_LORD_FEMALE_1  		=   82,	// Troop Lord Female 1 
	ROGUE            		=   83,	// Rogue 
	ROYAL_GUARD      		=   84,	// Royal Guard 
	T_GUILDER_FEMALE 		=   85,	// Troop Guilder Female 
	LORD_MALE_7      		=	86,	// Lord Male 7 
	GUILDER_FEMALE    		=   87,	// Guilder Female 
	DWARF_LORD_3    		=   88,	// Dwarf Lord 3 
	DWARF_LORD_2    		=   89,	// Dwarf LOrd 2 
	GOBLIN_LORD_1    		=   90,	// Goblin Lord 1 
	WARRIOR          		=   91,	// Warrior 
	GOBLIN_QUEEN            =   92,	// Goblin Queen 
	WIZARD_FEMALE_1  		=   93,	// Wizard Female 1 
	WIZARD_FEMALE_2  		=   94,	// Wizard Female 2 
	WIZARD_MALE_1    		=   95,	// Wizard Male 1 
	WIZARD_MALE_2    		=   96,	// Wizard Male 2 
	
	LORD_FEMALE_1    		=   98,	// Lord Female 1 
	LORD_FEMALE_2    		=   99,	// Lord Female 2 
	LORD_FEMALE_3    		=  100,	// Lord Female 3 
	LORD_MALE_1      		=  101,	// Lord Male 1 
	LORD_MALE_2      		=  102,	// Lord Male 2 
	LORD_MALE_3      		=  103,	// Lord Male 3 
	T_LORD_FEMALE_2  		=  104,	// Troop Lord Female 2 
	T_LORD_FEMALE_3  		=  105,	// Troop Lord Female 3 
	T_WIZARD_FEMALE_1		=  106,	// Troop Wizard Female 1 
	T_WIZARD_FEMALE_2		=  107,	// Troop Wizard Female 2 
	T_WIZARD_MALE_1  		=  108,	// Troop Wizard Male 1 
	T_WIZARD_MALE_2  		=  109,	// Troop Wizard Male 2 
	
	T_WIZARD_MALE_3  		=  111,	// Troop Wizard Male 3 
	T_GUILDER_MALE_1 		=  112,	// Troop Guilder Male 1 
	T_GUILDER_MALE_2 		=  113,	// Troop Guilder Male 2 
	T_PRIEST_MALE_1  		=  114,	// Troop Priest Male 1 
	T_PRIEST_MALE_2  		=  115,	// Troop Priest Male 2 
	DWARF_LORD_1     		=  116,	// Dwarf Lord 1 
	DWARF_GUARD      		=  117,	// Dwarf Guard 
	T_PRIEST_FEMALE_1		=  118,	// Troop Priest Female 1 
	ELF_GUARD        		=  119,	// Elf Guard 
	ELF_LORD_2       		=  120,	// Elf Lord 2 
	GNOLL_1					=  121, // Gnoll 1 
	GNOLL_IRREGULAR			=  122, // Gnoll Irregular 
	T_WYVERN_2				=  123, // Troop Wyvern 2 
	GOBLIN_GUARD     		=  124,	// Goblin Guard 
	GOBLIN_ZOMBIE			=  125, // Goblin Zombie 
	ANKHEG           		=  126,	// Ankheg 
	WYVERN_2				=  127, // Wyvern 2 
	WRAITH             	 	=  128,	// Wraith 
	DOG              		=  129,	// Dog 
	GORGON           		=  130,	// Gorgon 
	HARPY            		=  131,	// Harpy 
	HELL_HOUND       		=  132,	// Hell Hound 
	OGRE             		=  133,	// Ogre 
	MANSLAYER        		=  134,	// Rhuobhe Manslayer 
	SKELETON         		=  135,	// Skeleton 
	SPECTRE          		=  136,	// Spectre 
	SPIDER_KING      		=  137,	// Spider King 
	GIANT_SPIDER     		=  138,	// Giant Spider 
	WYVERN_1           		=  139,	// Wyvern 1 
	ZOMBIE			 		=  140,	// Zombie 
	CEILING_SPIDER   		=  141,	// Giant Spider on ceiling  
	T_MANSLAYER      		=  142,	// Troop Manslayer 
	T_GORGON		 		=  143,	// Troop Gorgon 
	T_SPIDER_KING	 		=  144,	// Troop Spider King 
	ASSASSIN 				=  145, // Assassin 
	T_ASSASSIN				=  146, // Troop Assassin 
	T_INFANTRY_X	 		=  147,	// Infantry Intro 
	ROYAL_GUARD_X	 		=  148,	// Royal Guard Intro 
	LORD_THRONE		 		=  149,	// Lord Throne 
	LAST_GAME_AVATAR 		=  149,	//  
	
	BARREL_1         		=  150,	// Barrel 1 
	BOWL_1           		=  151,	// Bowl 1 
	BUCKET_1         		=  152,	// Bucket1 
	CHANDELIER_1     		=  153,	// Chandelier 1 
	CANDLE_1         		=  154,	// Candle 1 
	COLUMN_1         		=  155,	// Column 1 
	COLUMN_2         		=  156,	// Column 2 
	CUP_1            		=  157,	// Cup 1 
	FIRE_1           		=  158,	// Fire 1 
	FLAGON_1         		=  159,	// Flagon 1 
	HELMET_1         		=  160,	// Helmet 1 
	KNIFE_1          		=  161,	// Knife 1 
	PLATE_1          		=  162,	// Plate 1 
	POTTED_PLANT_1   		=  163,	// Potted Plant 1 
	POTION_OF_FIRE_RESISTANCE		= 	164,
	SCROLL_OF_ARMOR_ENHANCEMENT_1	=	165,	
	SPEAR_1          		=  166,	// Spear 1 
	STATUE_1         		=  167,	// Statue 1 
	STATUE_2         		=  168,	// Statue 2 
	STOOL_1          		=  169,	// Stool 1 
	SWORD_1          		=  170,	// Sword 1 
	TABLE_1          		=  171,	// Table 1 
	TOME_OF_THE_PRINCE		=  172, // Tome of the Prince 
	WALL_TORCH_1     		=  173,	// Wall Torch 1 
	VASE_1           		=  174,	// Vase 1 
	FOUNTAIN_1		 		=  175,	// Fountain 1 
	BUSH_1			 		=  176,	// Bush 1 
	TREE_1			 		=  177,	// Tree 1 
	TREE_2			 		=  178,	// Tree 2 
	WALL_TORCH_2     		=  179,	// Wall Torch 2 
	
	DUNGEON_COLUMN	 		= 180,
	CAVE_COLUMN_1	 		= 181,
	BIZARRE_COLUMN_1 		= 182,
	MARBLE_COLUMN	 		= 183,
	STALACTITE_1	 		= 184,
	STALACTITE_2	 		= 185,
	STALACTITE_3	 		= 186,
	BIZARRE_STALACTITE_1 	= 187,
	STALAGMITE_1			= 188,
	STALAGMITE_2			= 189,
	CAVE_ROCK_1				= 190,
	CAVE_ROCK_2				= 191,
	CAVE_ROCK_3				= 192,
	BIZARRE_ROCK			= 193,
	DUNGEON_RUBBLE			= 194,
	CAVE_RUBBLE				= 195,
	STATUE_3				= 196,
	TORCH_2					= 197,
	HANGING_CHAINS_1 		= 198,
	KEY_SILVER				= 199,
	KEY_TINY				= 200,
	KEY_RED					= 201,
	KEY_BLUE				= 202,
	KEY_JEWELED				= 203,
	KEY_WHITE				= 204,
	KEY_SKELETON			= 205,
	SMASHED_BARREL_1 		= 206,
	EMPTY_CHEST				= 207,
	TREASURE_CHEST			= 208,
	CANDELABRA_1			= 209,
	CANDELABRA_2			= 210,
	POTION_OF_EXTRA_HEALING	= 211, 
	KEY_OF_OPENING			= 212, 
	POTION_OF_HEALING		= 213, 
	POTION_OF_FLYING		= 214, 
	BROKEN_VASE_1			= 215,
	VASE_2					= 216,
	BROKEN_VASE_2			= 217,
	VASE_3					= 218,
	BROKEN_VASE_3			= 219,
	TABLE_2					= 220,
	TABLE_3					= 221,
	STOOL_2					= 222,
	STOOL_3					= 223,
	POTTED_PLANT_2			= 224,
	POTTED_PLANT_3			= 225,
	STATUE_4				= 226,
	TORCH_3					= 227,
	GOLD_COINS_1			= 228,
	GOLD_COINS_2			= 229,
	BIZARRE_COLUMN_2 		= 230,
	CAVE_COLUMN_2			= 231,
	BIZARRE_STALACTITE_2 	= 232,
	TREE_3					= 233,
	TREE_4					= 234,
	TREE_5					= 235,
	TREE_6					= 236,
	TREE_7					= 237,
	TREE_8					= 238,
	TREE_9					= 239,
	TREE_10					= 240,
	TREE_11					= 241,
	TREE_12					= 242,
	TREE_13					= 243,
	TREE_14					= 244,
	STMP_1					= 245,
	STMP_2					= 246,
	THORN_1					= 247,
	BUSH_2					= 248,
	BUSH_3					= 249,
	BUSH_4					= 250,
	BUSH_5					= 251,
	BUSH_6					= 252,
	BUSH_7					= 253,
	FOREST_COLUMN_1			= 254,
	FOREST_COLUMN_2			= 255,
	EVIL_COLUMN_1			= 256,
	TWIG_1					= 257,
	EVIL_COLUMN_2			= 258,
	EVIL_CHANDELIER			= 259,
	LEAF_1					= 260,	
	LEAF_2					= 261,	
	LEAF_3					= 262,	
	GOLD_COINS_3			= 263,
	GOLD_COINS_4			= 264,
	GOLD_COINS_5			= 265,
	ROCK_5					= 266,
	ROCK_6					= 267,
	ROCK_7					= 268,
	ROCK_8					= 269,
	BARREL_3				= 270,
	STATUE_6				= 271,
	FIRE_2					= 272,
	FIRE_3					= 273,
	FIRE_4					= 274,
	FIRE_5					= 275,
	T0RCH_5					= 276,
	STATUE_5				= 277,
	VASE_7					= 278,
	VASE_8					= 279,
	
	AMULET_OF_FEATHER_FALL  			= 280,						
	AMULET_OF_SPEED         			= 281,						
	AMULET_OF_STRIDING_AND_SPRINGING   	= 282,						
	AMULET_VERSUS_UNDEAD 				= 283,						
	AMULET_OF_WATER_WALKING             = 284,						
	AMULET_OF_INSPIRATION               = 285,						
	BALM_OF_HEALING   					= 286,						
	TOME_OF_MYSTIC_MAGICS				= 287,						
	BOOK_OF_EXALTED_DEEDS   			= 288,						
	BOOK_OF_VILE_DARKNESS   			= 289,						
	TOME_OF_SORCERORS_LORE				= 290,						
	CHIME_OF_OPENING	 				= 291,						
	CLOAK_OF_PROTECTION_1   			= 292,						
	CLOAK_OF_PROTECTION_2   			= 293,						
	CLOAK_OF_PROTECTION_3   			= 294,						
	TOME_OF_THE_HIGH_WIZARDS			= 295,						
	TOME_OF_THE_MAGE_LORDS				= 296,		
	GAUNTLETS_OF_DEXTERITY   			= 297,						
	GAUNTLETS_OF_OGRE_POWER   			= 298,						
	GEM_OF_ATTRACTION   				= 299,						
	GEM_BLUE   							= 300,						
	GEM_GREEN   						= 301,						
	GEM_OF_PASSAGE   					= 302,						
							
	GEM_OF_SHIFTING   					= 304,						
							
	IOUN_STONE_PALE_BLUE   				= 306,						
	IOUN_STONE_SCARLET_AND_BLUE   		= 307,						
	IOUN_STONE_INCANDESCENT_BLUE   		= 308,						
	IOUN_STONE_DEEP_RED   				= 309,						
	IOUN_STONE_PINK   					= 310,						
	IOUN_STONE_PINK_AND_GREEN   		= 311,						
							
	IOUN_STONE_PEARLY_WHITE   			= 313,						
	SPELL_SCROLL_1						= 314,
	SPELL_SCROLL_2						= 315,
	SPELL_SCROLL_3						= 316,
	IOUN_STONE_DUSTY_ROSE   			= 317,						
	KEY_BLACK   						= 318,						
	KEY_BONE   							= 319,						
	KEY_STONE   						= 320,						
	LIBRIUM_OF_GAINFUL_CONJURATION   	= 321,						
	LIBRIUM_OF_INEFFABLE_DAMNATION   	= 322,						
	LIBRIUM_OF_SILVER_MAGIC   			= 323,						
							
	NECKLACE_OF_MISSILES   				= 325,						
							
	OIL_OF_SHARPNESS_1  				= 327,						
	OIL_OF_SHARPNESS_2  				= 328,						
	OIL_OF_SHARPNESS_3  				= 329,						
	OIL_OF_SHARPNESS_4  				= 330,						
	OIL_OF_SHARPNESS_5  				= 331,						
							
							
	POTION_OF_HILL_GIANT_STRENGTH   	= 334,						
	POTION_OF_STONE_GIANT_STRENGTH   	= 335,
	POTION_OF_FROST_GIANT_STRENGTH   	= 336,
	POTION_OF_FIRE_GIANT_STRENGTH    	= 337,
	POTION_OF_CLOUD_GIANT_STRENGTH   	= 338,
	POTION_OF_STORM_GIANT_STRENGTH   	= 339,
	POTION_OF_TITAN_STRENGTH   			= 340,
	
	POTION_OF_DIMINUTION   				= 342,
	
	POTION_OF_INVULNERABILITY   		= 344,
	POTION_OF_LEVITATION   				= 345,
	RING_OF_FEATHER_FALLING   			= 346,
	RING_OF_FIRE_FALLING   				= 347,
	
	RING_OF_JUMPING   					= 349,
	RING_OF_PROTECTION_1   				= 350,
	RING_OF_PROTECTION_2   				= 351,
	RING_OF_PROTECTION_3   				= 352,
	RING_OF_PROTECTION_4   				= 353,
	RING_OF_REGENERATION   				= 354,
	RING_OF_RESISTANCE_1   				= 355,
	RING_OF_RESISTANCE_2   				= 356,
	RING_OF_RESISTANCE_3   				= 357,
	RING_OF_WIZARDRY					= 358,
	RING_OF_NIGHTVISION   				= 359,
	DIERDRIENS_RING   					= 360,
	FAELES_RING   						= 361,
	ROD_OF_RESURRECTION   				= 362,
	SCROLL_OF_ARMOR_ENHANCEMENT_2   	= 363,
	SCROLL_OF_ARMOR_ENHANCEMENT_3   	= 364,
	SCROLL_OF_ARMOR_ENHANCEMENT_4   	= 365,
	SCROLL_OF_ARMOR_ENHANCEMENT_5   	= 366,
	
	STAFF_OF_CURING   					= 368,
	
	GAVELONS_STAFF_OF_PROSPERITY   		= 370,
	
	VIAL_OF_HOLY_WATER	 				= 372,
	WAND_OF_ENEMY_DETECTION 	 		= 373,
	
	WAND_OF_FIRE 	 					= 375,
	
	WAND_OF_FROST 	 					= 377,
	WAND_OF_ILLUMINATION 	 			= 378,
	WAND_OF_LIGHTNING	 				= 379,
	WAND_OF_MAGIC_DETECTION	 			= 380,
	WAND_OF_PARALYZATION	 			= 381,
	WAND_OF_SECRET_DETECTION	 		= 382,
	BANNER_OF_ROELE	 					= 383,
	BARAZADS_TOOLS	 					= 384,
	
	BRENNAS_FAVOR	 					= 386,
	CHALICE_OF_THE_DEAD	 				= 387,
	CROWN_OF_COMMAND	 				= 388,
	STATE_CROWN_OF_ANUIRE	 			= 389,
	DANICAS_CRYSTAL_OF_SCRYING	 		= 390,
	EMPERORS_CROWN	 					= 391,
	FARIDS_COFFER_OF_THE_REALM	 		= 392,
	HAMMER_OF_THUNDER	 				= 393,
	
	ROBES_OF_THE_MASES	 				= 395,
	REGALIA_OF_EMPIRE	 				= 396,
	SIELSHEGH_GEM_LARGE	 				= 397,
	SIELSHEGH_GEM_MEDIUM	 			= 398,
	SWORD_OF_ROELE	 					= 399,
	SCEPTRE_OF_CUIRAECEN	 			= 400,
   	CORGANDALS_STAFF					= 401,
	NAPPOLANS_TOME_OF_WAR	 			= 402,
	TORC_OF_SPLENDOR	 				= 403,
	VAUBENELS_BOOK_OF_FORTIFICATION		= 404,
	CANDLE_OF_INVOCATION	 			= 405,
	
	PRINCE_ROP							= 406,
	GOBLIN_KING_ROP						= 407,
	PARCHMENT_3							= 408,
	
// OFFENSIVE WIZARD SPELLS

    FIRST_PROJECTILE_EFFECT				= 409,
	FIREBALL_1							= 409,
	LORES_FIREBALL_1					= 410,
	PLASMA_BALL_1						= 411,
	LORES_PLASMA_BALL_1					= 412,
	PLASMA_STREAK_1                     = 413,
	PLASMA_BALL_2                       = 414,
	LORES_PLASMA_STREAK_1				= 415,
	LORES_PLASMA_BALL_2					= 416,
	LIGHTNING_1							= 417,
	LORES_LIGHTNING_1					= 418,
	VAPORIZE_1							= 419,
	LORES_VAPORIZE_1					= 420,
	CRUMBLE_1							= 421,
	LORES_CRUMBLE_1						= 422,
	CHAIN_LIGHTNING_2					= 423,
    LAST_PROJECTILE_EFFECT				= 423,

// Some other random items

	POTION_OF_POISON_CURE				= 424,
	ROCK_9								= 425,
	ROCK_10								= 426,
	BUSH_8								= 427,
	BUSH_9								= 428,
	BUSH_10								= 429,
	BUSH_11								= 430,
	BUSH_12								= 431,
	TREE_15								= 432,
	TREE_16								= 433,
	TREE_17								= 434,
	TREE_18								= 435,
	TREE_19								= 436,
	TREE_20								= 437,
	CORPSE_1							= 438,
	HAY_PILE_1	  						= 439,
	GARGOYLE_STATUE						= 440,
	REFUSE_PILE							= 441,
	GORGONS_BANNER						= 442,

// REALM SPELLS
	
	REALM_ALCHEMY_1						= 450,
	REALM_DEATH_PLAGUE_1				= 451,
	REALM_DEMAGOGUE_1					= 452,
	REALM_DISPEL_REALM_MAGIC_1			= 453,
	REALM_LEGION_OF_DEAD_1				= 454,
	REALM_MASS_DESTRUCTION_1			= 455,
	REALM_RAZE_1						= 456,
	REALM_SCRY_1						= 457,
	REALM_STRONGHOLD_1					= 458,
	REALM_SUBVERSION_1					= 459,
	REALM_SUMMONING_1					= 460,
	REALM_TRANSPORT_1					= 461,
	REALM_WARDING_1						= 462,
	
// PRIESTLY REALM SPELLS
	
	REALM_BLESS_LAND_1                  = 463,
	REALM_BLESS_ARMY_1                  = 464,
	REALM_BLIGHT_1                      = 465,
	REALM_DISPEL_REALM_MAGIC_PR_1       = 466,
	REALM_HONEST_DEALING_1              = 467,
	REALM_INVESTITURE_1                 = 468,
	
// PRIEST SPELLS														  
    
	CURE_LIGHT_1						= 469,
	DETECT_EVIL_1						= 470,
	DETECT_MAGIC_PR_1					= 471,
	LIGHT_PR_1							= 472,
	SHILLELAGH_1						= 473,
	TURN_UNDEAD_1						= 474,
	BARKSKIN_1							= 475,
	FIND_TRAPS_1						= 476,
	FIND_TREASURE_1						= 477,
	RESIST_FIRE_1						= 478,
	SPIRITUAL_HAMMER_1					= 479,
	MAGICAL_VESTAMENT_1					= 480,
	WATER_WALK_1						= 481,
	CURE_SERIOUS_1						= 482,
	PROT_FROM_EVIL_1					= 483,
	CURE_CRITICAL_1						= 484,
	FLAME_STRIKE_1						= 485,
	TRUE_SEEING_1						= 486,
	HEAL_1								= 487,
	FIRE_STORM_1						= 488,
	HOLY_WORD_1							= 489,
	RESURRECTION_1						= 490,
										
// MORE WIZARD SPELLS									
																		
	DETECT_MAGIC_1						= 497,
	FEATHER_FALL_1						= 498,
	JUMP_1								= 499,
	LIGHT_1								= 500,
	MAGIC_MISSILE_1						= 501,
	REDUCE_1							= 502,
	SHOCKING_GRASP_1					= 503,
	BLINDNESS_1							= 504,
	CONTINUAL_LIGHT_1					= 505,
	KNOCK_1								= 506,
	LEVITATE_1							= 507,
	LOCATE_OBJECT_1						= 508,
	POISON_ARROW_1						= 509,
	STRENGTH_1							= 510,
//	FIREBALL_1							= 511,  //already above
	FLY_1								= 512,
	STONE_UNDEAD_1						= 513,
	INFRAVISION_1						= 514,
	LIGHTNING_BOLT_1					= 515,
	CONFUSION_1							= 516,
	ICE_STORM_1							= 517,
	MINOR_GLOBE_INVULN_1				= 518,
	STONESKIN_1							= 519,
	CONE_OF_COLD_1						= 520,
	DISINTIGRATE_1						= 521,
	TELEPORT_1							= 522,
	CHAIN_LIGHTNING_1					= 523,
	DEATH_1								= 524,
	GLOBE_INVULN_1						= 525,
	FLESH_TO_STONE_1					= 526,
	IMPROVED_FIREBAL_1					= 527,
	POWER_STUN_1						= 528,
	POWER_BLIND_1						= 529,
	SPELL_IMMUNITY_1					= 530,
	METEOR_SWARM_1						= 531,
	POWER_KILL_1						= 532,
	TIME_STOP_1							= 533,

	
// MORE CHARACTERS							  
											  
	MERC_ARCHER							= 551,
	MERC_CAVALRY						= 552,
	ELF_CAVALRY							= 553,
	LEVY								= 554,
	SCOUT								= 555,
	MERC_IRREGULAR						= 556,
											  
											  
// HINTS											  
	
	HINT_1	 							= 561,
	HINT_2								= 562,
	HINT_3								= 563,
	HINT_4								= 564,
	HINT_5								= 565,

// FIENDS

	FIRST_FIEND							= 566,
	MOLTH_KAMBAR						= 566,
	KAST_EKCTRAL						= 567,
	BAUBB_THE_TOYMAKER					= 568,
	ENDAERAL_CATHBIRN					= 569,
	SPAWN_OF_THE_CHIMAERA				= 570,
	NHOUN_THE_ELF						= 571,
	TIESKAR_GRAECHER					= 572,
	
	LAST_FIEND							= 572,
	
	LESSER_SPECTRE						= 573,
	LESSER_WRAITH						= 574,

// Blood Abilities

    BLOOD_ALERTNESS_1					= 601,
	BLOOD_ALTER_APPEARANCE_1			= 602,
	BLOOD_ANIMAL_AFFINITY_1				= 603,
	BLOOD_BATTLEWISE_1					= 604,
	BLOOD_BLOOD_HISTORY_1				= 605,
	BLOOD_BLOODMARK_1					= 606,
	BLOOD_CHARACTER_READING_1			= 607,
	BLOOD_COURAGE_1						= 608,
	BLOOD_DETECT_LIE_1					= 609,
	BLOOD_DETECT_ILLUSION_1				= 610,
	BLOOD_DIRECTION_SENSE_1				= 611,
	BLOOD_DIVINE_AURA_1					= 612,
	BLOOD_DIVINE_WRATH_1				= 613,
	BLOOD_ELEMENTAL_CONTROL_1			= 614,
	BLOOD_ENHANCED_SENSE_1				= 615,
	BLOOD_FEAR_1						= 616,
	BLOOD_HEALING_1						= 617,
	BLOOD_HEIGHTENED_ABILITY_1			= 618,
	BLOOD_IRON_WILL_1					= 619,
	BLOOD_PERSUASION_1					= 620,
	BLOOD_POISON_SENSE_1				= 621,
	BLOOD_PROTECTION_FROM_EVIL_1		= 622,
	BLOOD_REGENERATION_1				= 623,
	BLOOD_RESISTANCE_1					= 624,
	BLOOD_SHADOW_FORM_1					= 625,
	BLOOD_TOUCH_OF_DECAY_1				= 626,
	BLOOD_TRAVEL_1						= 627,

// lores art for battle 8Meg version
	LORES_A_BOW							= 628,	
	LORES_A_CAV							= 629,	
	LORES_A_EIN							= 630,	
	LORES_A_INF							= 631,	
	LORES_A_IRR							= 632,	
	LORES_A_KNT							= 633,	
	LORES_A_OFF							= 634,	
	LORES_A_PIK							= 635,	
	LORES_M_INF							= 636,	
	LORES_M_OFF							= 637,	
	LORES_M_PIK							= 638,	
	LORES_D_INF							= 639,	
	LORES_D_BOW							= 640,	
	LORES_D_OFF							= 641,	
	LORES_E_BOW							= 642,	
	LORES_E_INF							= 643,	
	LORES_E_OFF							= 644,	
	LORES_G_BOW							= 645,	
	LORES_G_CAV							= 646,	
	LORES_G_INF							= 647,	
	LORES_G_OFF							= 648,	
	LORES_C_SKL							= 649,	
	LORES_C_SPD							= 650,	
	LORES_N_IRR							= 651,	

LAST_GAME_THING  						= 651		// keep this up-to-date!!! 
											
} THINGTYPE;								
											
											
// JHC HACK for doors.c						





// DKT more hackage 961023



											
// _THINGTYPE_H						
#line 13 "map.h"
 
#line 1 "C:\WATCOM\H\limits.h"
/*
 *  limits.h	Machine and OS limits
 *
 *  Copyright by WATCOM International Corp. 1988-1996.  All rights reserved.
 */


/*
 *  ANSI required limits
 */
/*  number of bits in a byte	    */
#line 16 "C:\WATCOM\H\limits.h"
 /*  minimum value of a char	    */
 /*  maximum value of a char	    */

/*  maximum length of multibyte char	*/
/*  minimum value of a signed char	*/
/*  maximum value of a signed char	*/
/*  maximum value of an unsigned char	*/

/*  minimum value of a short int	*/
/*  maximum value of a short int	*/
/*  maximum value of an unsigned short	*/
/*	maximum value of a long int	*/
/* minimum value of a long int	*/
/* maximum value of a unsigned long    */

 /*	minimum value of an int 	*/
 /*	maximum value of an int 	*/
 /*	maximum value of an unsigned int*/
#line 39 "C:\WATCOM\H\limits.h"

/*	The maximum number of bytes	    */
				    /*	supported for the name of a time    */
				    /*	zone (not of the TZ variable).	    */




#line 14 "map.h"


/* ------------------------------------------------------------------------
   Defines and Compile Flags
   ------------------------------------------------------------------------ */








typedef struct _MAP_INFO {
	SHORT	origin_x;
	SHORT	origin_y;
	SHORT	clip_x;
	SHORT	clip_y;
	SHORT	center_x;
	SHORT	center_y;
	SHORT 	world_center_x;
	SHORT 	world_center_y;
	LONG	zoom_factor;
	LONG	draw_map;
	LONG	full_screen;
	LONG	show_grid;
	LONG	draw_cheater_lines;
	LONG	region_type;  				//full-screen, normal, none. 
} MAP_INFO, *PTR_MAP_INFO;

typedef struct 
{
	LONG Treasure;
	LONG Enemies;
	LONG SecretDoors;
	LONG Traps;
	LONG Evil;
	LONG InvisibleCreatures;
	LONG Magic;
	LONG QuestObject;

} MapHighlightData;
	
	
   
//reserved bits 3-7 (0x0004-0x0040) for map shapes/colors




//these are for attrs



		  
//so are these
//bit 5 set
//bit 6 set
//bits 5,6 set
//bit 7 set
//bits 7,5 set
//bits 7,6 set
//bits 7,6,5 set



//so are these
//bit 5 set			//transparent
//bit 6 set			//gettable
//bits 5,6 set		//bumpable
//bit 7 set			//flora
//bits 7,5 set		//nut'n honey
//bits 7,6 set
//bits 7,6,5 set











//map drawing colors








//these probably need to be changed!























//any value that's not in (-256,256)







/* ------------------------------------------------------------------------
   Prototypes
   ------------------------------------------------------------------------ */



extern "C" 
{


extern LONG GetMarginReductionCount(void);


//gotta love arbitrary numbers...




void MapHandleZoom(LONG);

void SetMapHighlightTreasure(LONG,LONG);
void SetMapHighlightEnemies(LONG,LONG);
void SetMapHighlightSecretDoors(LONG,LONG);
void SetMapHighlightTraps(LONG,LONG);
void SetMapHighlightEvil(LONG,LONG);
void SetMapHighlightInvisibleCreatures(LONG,LONG);
void SetMapHighlightMagic(LONG,LONG);
void SetMapHighlightQuestObject(LONG,LONG);


BOOL SetMapCameraDraw(LONG);
BOOL SetMapPlayerDraw(LONG); 
BOOL SetMapGridDraw(LONG);
BOOL SetMapShowAll(LONG,LONG);
BOOL SetMapDraw(LONG,LONG);
BOOL SetMapFullScreen(LONG,LONG);

PFV SetMapGameDraw(PFV pfGameFunc);
void DrawMap (LONG,LONG,LONG,LONG);
void ZoomMap(LONG,LONG);
void DrawMapStyledObject(POINT* a,LONG angle,ULONG color,LONG shape,LONG radius,BOOL scaled);
void DrawMapAvatar(LONG,ULONG,BOOL);
void DrawMapThing(LONG,LONG);

void DrawMapPlayer(void);
void DrawMapCamera(void);
void DrawMapQuestObject(void);


void MapTeleport(LONG code);  

BOOL IsAvatarDead(THINGTYPE);

void ZoomMapAbsolute(LONG,LONG);

BOOL MapIsActive(void);
LONG MapZoomFactor(void);
LONG MapCenterX(void);
LONG MapCenterY(void);
void SetMapCenter(LONG,LONG);


}


#line 13 "engine.h"


#line 1 "typedefs.h"
/* =======================================================================
   Copyright (c) 1990,1995   Synergistic Software
   All Rights Reserved.
   =======================================================================
   Filename: TYPEDEFS.H   -Header file for all core types
   Author: Everyone
   ======================================================================== */
// _TYPEDEFS_H#line 163 "typedefs.h"

#line 15 "engine.h"
 
#line 1 "C:\WATCOM\H\limits.h"
/*
 *  limits.h	Machine and OS limits
 *
 *  Copyright by WATCOM International Corp. 1988-1996.  All rights reserved.
 */
#line 47 "C:\WATCOM\H\limits.h"
#line 16 "engine.h"

#line 1 "things.h"
/* ========================================================================
   Copyright (c) 1990,1995   Synergistic Software
   All Rights Reserved
   ========================================================================
   Filename: THINGS.H
   Author: Alan Clark
   ======================================================================== */



/* maximum number of mythings in a given wad */











//TTYPE ATTRIBUTE BITS




//see MAP.H for bits (3-7)	0x0004
//see MAP.H for bits (3-7)	0x0008
//see MAP.H for bits (3-7)	0x0010
//see MAP.H for bits (3-7)	0x0020
//see MAP.H for bits (3-7)	0x0040

// Like a potted plant.
// Like a tree you can go thru the branches.










/* animation sequence defines */
typedef enum {
	ANIMATION0SEQ = 0,
	ANIMATION1SEQ,
	ANIMATION2SEQ,
	ANIMATION3SEQ,
	ANIMATION4SEQ,
	ANIMATION5SEQ,
	ANIMATION6SEQ,
	ANIMATION7SEQ,
	ANIMATION8SEQ,
	ANIMATION9SEQ,
	ANIMATION10SEQ,
	ANIMATION11SEQ,
	ANIMATION12SEQ,
	
	// Enter new sequences above this.
	MAX_ANIMATIONSEQ
} ANIM_SEQUENCE_ENUM;



/* ------------------------------------------------------------------------
   Typedefs and Structures
   ------------------------------------------------------------------------ */
typedef struct{
	LONG			x;
	LONG			y;
	SHORT			z;
	LONG			dist;					// 24.8 value 
//	LONG			xDrawn;
//	LONG			yDrawn;
	unsigned int	OriginalType: 10;
	unsigned int	valid		: 1;
	unsigned int	fDrawn		: 1;
	unsigned int	iSequence	: 6;
	unsigned int	fMapSpotted : 1;	// do we draw this on the map? 
	unsigned int	AIbits		: 5;
	unsigned int	inVisible	: 1;
	unsigned int    Frozen   	: 1;
	unsigned int	SkipFrame	: 1;
	unsigned int	unused		: 5;
	SHORT			type;
	SHORT			ssect;				// ssector it is in 
	SHORT			sect;				// sector it is in 
	SHORT			next_thing;
	SHORT			iBitm;
	SHORT			iAnim;
	SHORT			heiScaled;
	SHORT			widScaled;
	UBYTE			angle;			// Byteans 0 -> 255. 
	UBYTE			scale_adjust;
	UBYTE			bControl;
	UBYTE			ColorRemap;		// index into the shade table. 
} MYTHING;
	
/* Animation Header */
typedef struct
{
	ULONG	offData;			/* offset into Data of current sequence */ 
#line 110 "things.h"
	SHORT	width;		      	/* width in pixels */ 
	USHORT	height;		   		/* height in pixels */ 
//	USHORT	scale;		   		/* current scale discovered */
//	USHORT	speed;		   		/* in milliseconds */
//	SHORT	iData[NUMSEQUENCES];/* Array of flic sequences. */
	SHORT	hiData;				/* Handle to an I_DATABLK resource. */ 
	SHORT	iBuff;		   		/* handle to delta accumulation buffer */ 
	SHORT	sequence;	      	/* current sequence */ 
	SBYTE	rotation;  	      	/* current rotation */ 
	SBYTE	type;		      	/* set to TYPE_FLIC or TYPE_PCX */ 
	UBYTE	frame;		   		/* current frame in sequence */ 
	UBYTE	totalFrames;		/* total frames for this sequence */ 

} ANIMHDR, *ANIMPTR;

typedef struct _I_DATA_BLK 
{
#line 130 "things.h"
	SHORT	iData[ (13 * 5) ];
} I_DATA_BLK;

typedef struct{
	char name[7];			// Dos file name of the art. 
	SHORT  LowResIndex;		// the index in the TTYPE array to a lower resolution thing. 
	USHORT attrib;
}TTYPE;

typedef struct
{
	// LONG	t;
	SHORT	t;										// [d6-26-96 JPC] 
	// SHORT	sector;								// [d6-26-96 JPC]
	SHORT	light;								// [d6-26-96 JPC] 
	LONG	sx;				
	LONG	dx,dy,dye;		
	LONG	clip;			
	LONG	src_inc;		
} THING_SPAN;


/* ------------------------------------------------------------------------
   Prototypes
   ------------------------------------------------------------------------ */

extern "C" {


extern LONG		MaxThingSpans;

extern THING_SPAN	*thing_spans;
extern LONG			tot_thing_spans;
extern TTYPE		ttypes[];
extern PTR        	TTypePtr;
extern LONG       	G_TTypeSize;
extern LONG       	G_NumberOfTTypes;


//GEH try to get this out of stuff!
extern MYTHING *	mythings;


/* things.c */
void MarkOldAnimPurgable(SHORT iAnim, ULONG seq);
SHORT load_FLC_sequence (ULONG iAnim, ULONG type, ULONG seq, ULONG Rotation);
ERRCODE decode_frame(ANIMPTR pAnim, FLICHEADPTR pHead);
void decode_byte_run (PTR pData, ANIMPTR pAnim);
void decode_literal (PTR pData, ANIMPTR pAnim);
void decode_delta_flc (PTR pData, ANIMPTR pAnim);
void ChangeThingType(LONG ThingType, LONG NewType);
void load_obj_graphic (LONG i, 
					   ULONG type, 
					   ULONG AnimationSeq, 
					   SBYTE rot,
					   UBYTE bFlcControl,
					   UBYTE bPCXControl);
LONG create_thing (ULONG type, LONG x,LONG y,LONG z);
void init_things (LONG * PlayerStart);
void purge_thing (LONG /* ThingIndex */  );
void purge_all_things (void);
void set_thing (LONG index,LONG x,LONG y,LONG z,LONG a);
void move_thing (LONG t,LONG dx,LONG dy);
void move_thing_to (LONG t,LONG nx,LONG ny);
void LoopSequenceContinuously (LONG t, ULONG sequence);
void LoopSequenceOnce (LONG t, ULONG sequence);
void PlaySequenceOnce (LONG t, ULONG sequence);
BOOL TestSequenceDone (LONG t);
LONG SequenceFrameNumber (LONG t);
void remove_thing (LONG t);
void add_thing (LONG t,LONG ss);
void clear_thing_spans (void);
SHORT AllocateAnim(SHORT Type, LONG ttype);
SHORT OpenAnim (SHORT iAnim, SHORT iSeq, CSTRPTR szFileName, SHORT Type);
void RemoveAnim (SHORT iAnim);
SHORT SetAnimSequence (SHORT iAnim, SHORT iSeq);
SHORT NextAnimFrame (SHORT iAnim, USHORT sequence, USHORT rotation, UBYTE * pCtrl, SHORT frame);
void RegisterTTypes (PTR _TTypePtr, LONG _G_TTypeSize, LONG /* NumberOfElements */ );
BOOL IsBumpable(LONG /* ThingIndex */ );
BOOL HangsFromCeiling(LONG /* ThingIndex */  );
BOOL IsFlyingThing(LONG /* ThingIndex */  );
BOOL IsHalfWidthBumpable(LONG /* ThingIndex */ );
BOOL CanStandOn(LONG /* ThingIndex */ );
BOOL ThingIsHeatSource (LONG thingIndex);
BOOL ThingIsCold (LONG thingIndex);
BOOL ThingIsMagic (LONG thingIndex);
BOOL ThingIsEvil (LONG thingIndex);
BOOL ThingIsPickupable (LONG thingIndex);
USHORT get_center_point(SHORT iAnim);
LONG get_scale(SHORT iAnim);
void change_scale_adjust(LONG t, LONG newScale);
void ChangeThingZ (LONG iSector);
void SetFrame(LONG t /* ThingIndex */ , ULONG iSeq, SHORT iFrame);
void sort_things_from_camera(LONG);
void SetDontDrawCloser(LONG /* ThingIndex */ );
void ClearDontDrawCloser();

void SetQuestThing(LONG /* ThingType */ );
LONG GetQuestThing();
void InitMagicThings(SHORT * /* pMagicObjects */ ,
					 LONG /* NumberOfObjects */ ,
					 LONG /* MagicThingIndex */ ,
					 LONG /* QuestThingIndex */  );

LONG QuestItemMythingsIndex(void);
SHORT DisposeIDataBlk (SHORT iResBlk, SHORT iMemBlk);
SHORT LoadIData (
	CSTRPTR szFileName,
	BOOL  fSetPal,  
	BOOL  fLockRes, 
	BOOL  fRotated);


}




/* ------------------------------------------------------------------------ */


#line 17 "engine.h"
 
#line 1 "doors.h"

/* ========================================================================
   Copyright (c) 1996  Synergistic Software
   All Rights Reserved
   ========================================================================
   Filename: DOORS.H
   Author: John Conley
   ======================================================================== */





extern "C" {


// There are 3 switch textures in the game; when user activates one,
// change the texture to the other one.

extern LONG gSwitchTexture[ 3 ][2];

void init_doors (void);
void stop_door (LONG s);
void handle_doors (LONG arg);
void open_door (LONG seg, LONG spcl);
void HandleLifts (LONG arg);
void HandleFloors (LONG arg);
void HandleCeilings (LONG arg);
void DoorActivate (LONG iLinedef, LONG tag, LONG special);
void LiftActivate (LONG iLinedef, LONG tag, LONG special);
BOOL FloorIsActive (LONG iSector);
void FloorActivate (LONG iLinedef, LONG tag, LONG special);
BOOL CeilingIsActive (LONG iSector);
void CeilingActivate (LONG iLinedef, LONG tag, LONG special);

BOOL LinedefIsSwingingDoor(LONG Ldidx);



}




#line 18 "engine.h"
 
#line 1 "sectors.h"
/* ========================================================================
   Copyright (c) 1996   Synergistic Software
   All Rights Reserved
   ========================================================================
   Filename: SECTORS.H
   ======================================================================== */




extern "C" {


void point_to_sector_info( LONG x, LONG y, LONG *sec, LONG *f, LONG *c, LONG *s, LONG *t);
void ssector_to_sector_info( LONG x, LONG y, ULONG PointSsector, LONG *sector, LONG *floor, LONG *ceiling, LONG *special, LONG *tag );
void sector_info( LONG sector, LONG *floor, LONG *ceiling, LONG *special, LONG *tag );
LONG raise_sector_floor(LONG s,LONG inc);
LONG raise_sector_ceiling(LONG s,LONG inc);
ULONG point_to_sector(LONG x,LONG y);
long point_to_sector_special(long x, long y);
LONG point_to_floor_height(LONG x,LONG y);
LONG point_to_ceiling_height(LONG x,LONG y);
ULONG find_ssector(LONG x,LONG y);
void point_to_ssector(LONG n);
LONG tag_to_sector(LONG tag);
LONG TagToNextSector (LONG iStart, LONG tag);
LONG tag_to_line(LONG tag, LONG notline);
void activate_seg(LONG arg);
// [d11-14-96 JPC] Removed: BOOL GetSectorDamage (LONG iSector, LONG *damageNumber);
// [d11-29-96 JPC] Removed: BOOL GetCrusherDamage (LONG iSector, LONG *damageNumber, LONG avatarHeight, LONG avatarZ);
BOOL IsSplashSector (LONG iSector);
BOOL IsLavaSector (LONG iSector);


}




#line 19 "engine.h"
 

/* ------------------------------------------------------------------------
   Defines and Compile Flags
   ------------------------------------------------------------------------ */



//#define VIEW_WIDTH 	MAX_VIEW_WIDTH
//#define VIEW_HEIGHT 	MAX_VIEW_HEIGHT

#line 36 "engine.h"


/* 24.8 fixed point adjust value for the PLAYER structure and it's routines */




/* types for player starts */






/* types for mouse_found_type */






/* animation control defines */










/* ingore this argument value */


// #define CAMERA_FIXEDPT	0
// #define CAMERA_INT_VAL(x)	(x)
// #define CAMERA_FLOAT_VAL(x)	(x)




/* check line special types */
// JPC Changed the following from 0 and 1 to 1 and 2 because we AND the
// values with the sSpecial parameter.  sSpecial & CHECKLINE_PLAYER
// came out 0, even when sSpecial was CHECKLINE_PLAYER.
// Note that if we add new values, they need to be a power of 2.
// was 0
// was 1


/* ------------------------------------------------------------------------
	Key defines
   ------------------------------------------------------------------------ */
/* scan codes for key handler */

	
	
	
	
	
	
	
	
	
	
	
	
	// '-'
	// '='
	
	
	
	
	
	
	
	
	
	
	
	
	// '['
	// ']'
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	/* numeric keypad 7, or home */
	/* numeric keypad 8, or up arrow */
	/* numeric keypad 9, or pgup */
	/* "-" by numeric keypad */
	/* numeric keypad 4, or left arrow */
	/* numeric keypad 5 */
	/* numeric keypad 6, or right arrow */
	/* "+" by numeric keypad */
	/* numeric keypad 1, or end */
	/* numeric keypad 2, or down arrow */
	/* numeric keypad 3, or pgdn */
	
	
#line 268 "engine.h"

// movement key masks


















/* ------------------------------------------------------------------------
   Enums
   ------------------------------------------------------------------------ */
/* the types of things we can click on */
// Also these things can be "bumped"
typedef enum
{
	iNOTHING = 0,
	iOBJECT,	// Click on 
	iFLOOR,		// Click on 
	iWALL,		// Click on (Hit face on) 
#line 302 "engine.h"
	iSLIDE_ON_WALL,	// Hit on side 
	iCEILING,	// Hit your head 
	iHOLE,		// Gaping hole in front of you. 
	iSHALLOW_WATER,
	iDEEP_WATER,
	iLAVA,
	iACID,
	iEDGE_OF_WORLD,
	iMONSTER_BOX,
	iEXITLEVEL	// Wad-to-wad teleport 
} WadThingType;

// predefined angle resolutions
//  1/256 resolution
//  2/256
//  4/256
//  8/256
// 16/256
// 32/256

/* ------------------------------------------------------------------------
   Typedefs
   ------------------------------------------------------------------------ */
typedef struct{
	LONG	dx, dy;
	LONG	a;
	LONG	vx, vy;
} TELEPORT_DATA;

typedef struct {
	LONG		x;	// Target coordinates 
	LONG		y;
	LONG		z;
	LONG		a;
	LONG		p;
} CAMERA_LINEAR_TARGET;

typedef struct {
	LONG		x;     		// face to pt. 
	LONG		y;    		// face to pt. 
	LONG		z;	   		// New Z 
	LONG		p;	   		// New Pitch 
	LONG		a;			// destination angle in Polar coords. (a, distance) 
	LONG		h;			// New Height 
	LONG		radius;		// New radius 
	LONG		distance;	// New min distance to pt. 
	LONG		max_distance;	// New max distance to pt. 
} CAMERA_ROTATIONAL_TARGET;

typedef struct{
	LONG		x,y;		// xy 
	LONG		z;			// height above floor 
	LONG		a,p;		// angle, pitch 
	LONG		TargetRequested; // A flag 
	LONG		TargetFactor;
	LONG		Rate[4];	 //Rate[0]: distance rate    Rate[1]: height rate 
							 //Rate[2]: angle rate       Rate[3]: pitch rate
	union	{
		CAMERA_LINEAR_TARGET  		LTarget;
		CAMERA_ROTATIONAL_TARGET	RTarget;
	};
	
	CAMERA_ROTATIONAL_TARGET	Current;
	
	LONG		vx;			// Velocity values. 
	LONG		vy;
	LONG		vz;
	LONG		va;
} CAMERA;

typedef struct{
	LONG		x,y;		// xy 
	LONG		z;			// height above floor 
	LONG		a,p;		// angle, pitch 
	LONG		attributes; // unused so far 
	LONG		width;		// width of buffer 
	LONG		height;		// height of buffer 
	SHORT		buffer;		// handle to buffer 
} CAMERA_DESCRIPTOR;



typedef struct{
	LONG			x,y;		// using 24.8 fixed point for xy 
	LONG			z;			// height above floor 
	LONG			a,p;		// angle, pitch (NO ROLL) 
	LONG			w,h;		// width, height 
	BOOL			Flying;		// Whether you are flying or not. 
	BOOL			Crouching;	// Whether you are crouching or not. 
	LONG			ThingIndex;	// index in the mythings array. 
	LONG        ceiling, floor;
	UBYTE			WalkThruWall;	 //Whether control key is held down. 
	WadThingType	bump;		// Last Wad thing bumped. (reset every render.) 
	LONG			BumpIndex;	// if an object bumped, its thing index is here. 
	LONG			currentSector;				// [d11-13-96 JPC] for sound effects 
	LONG			fallHeight;					// [d11-22-96 JPC] 
} PLAYER;

typedef POINT 		FIXED_POINT;       	// For 24.8 fixed point math points. 
typedef POINT_3D	FIXED_POINT_3D;		// x & y are 28.8 and z is LONG 
typedef VECTOR		FIXED_VECTOR;   	// a pair of 24.8 delta values. 
typedef VECTOR_3D	FIXED_VECTOR_3D;	// x & y are 24.8 and z is a LONG. 

/* ------------------------------------------------------------------------
   Macros
   ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------
   Prototypes
   ------------------------------------------------------------------------ */

extern "C" {


/* 2dmouse.c */
void mouse_move(void);
void handle_2dmouse(void);
PFVLLL SetMouseClicked (WadThingType Type, PFVLLL pfClickFunc );

/* blockm.c */
POINT GetBlockCornerFromXY(LONG x,LONG y);
SHORT* get_blockm (long px1,long py1);

/* bump.c */
// Note the POINT is in 28.4 FixedPoint values.
LONG CheckBump (PLAYER *Player, FIXED_VECTOR_3D *pPoint, LONG /* Rate */ );
// Note the POINT is in 28.4 FixedPoint values.
WadThingType CheckMove (PLAYER *pPlayer, FIXED_VECTOR_3D *pPoint, SHORT sSpecial, LONG *BumpAngle, LONG *BumpDistance);
WadThingType CheckLongMove (PLAYER *pPlayer, LONG a, LONG distance, LONG sSpecial, LONG z, LONG *BumpDistance);
WadThingType CheckMoveSimple (
	PLAYER *pPlayer,
	FIXED_VECTOR_3D *pPoint, 	// This is the delta of the motion, not the absolute location. 
	SHORT sSpecial,
	LONG *BumpDistance);// distance to line squared; 

/* camera.c */
void InitializeCamera(CAMERA *, LONG /* X */ ,
								LONG /* Y */ ,
								LONG /* Z */ ,
								LONG /* A */ ,
								LONG /* P */ );
void SetCameraPosition(CAMERA *,const LONG x,const LONG y,const LONG z, const LONG a, const LONG p);




void SetCameraCurrentPosition(CAMERA *,const LONG x,const LONG y,const LONG z, const LONG angle, const LONG p, const LONG radius);
void SetCameraMotionVars( CAMERA *pCamera, const LONG	TargetFactor, const LONG	LinearRate);


void SetCameraTarget( CAMERA *, const LONG Targetx, const LONG Targety, const LONG Targetz, const LONG Targeta, const LONG Targetp, const BOOL swoop);
void SetCameraRotateTarget(CAMERA *,
						   const LONG Targetx,
						   const LONG Targety,
						   const LONG NewZ,
						   const LONG NewPitch,
						   const LONG DeltaAngle,
						   const LONG MinRadius,
						   const LONG NewDistance,
						   const BOOL swoop);
void MoveCamera(CAMERA *, const LONG KeyState);
void SwoopCamera(CAMERA *pCamera);
void MoveCameraEvenly(CAMERA *pCamera);
void RotateSwoopCamera(CAMERA *pCamera);
void RotateCameraEvenly(CAMERA *pCamera);
void push_camera(void);
void pull_camera(void);

//WRC Fixed Camera functions (mirrors etc...)  these are bad icky things.
//do not use them.
//SHORT NewVideoBuffer(LONG VWidth, LONG VHeight);
//void RedirectVideo(SHORT buffer);
//void RestoreVideo(void);
//void CloseVideoBuffer(SHORT buffer);

void RotateCameraAroundPoint(CAMERA * pCamera, LONG KeyState);
void SetCameraRotatePointTarget( CAMERA *pCamera, const LONG , const LONG , const LONG, const LONG , const LONG , const BOOL );
void SetCameraRotatePointRates( CAMERA *pCamera, const LONG , const LONG , const LONG , const LONG, const LONG, const LONG );

/* clip.c */
LONG lines_intersect(LONG x1,LONG y1,LONG x2,LONG y2,LONG x3,LONG y3,LONG x4,LONG y4);

/* convert.c */
LONG seg_to_height(LONG s,LONG side);

/* cue.c */
void SetArtPath ( CSTRPTR pArtPath );
void CreateShadeTable ( UBYTE  *ptrPalette, LONG  percIntensity, LONG  percTranslucent, LONG  percRed, LONG  percGreen, LONG  percBlue );
void init_shade_table(CHAR *Name);
void color_rect (LONG x,LONG y,LONG w,LONG h,LONG s);
void color_box (LONG x,LONG y,LONG w,LONG h,LONG s);
void color_edged_rect (LONG x,LONG y,LONG w,LONG h,LONG s);
void shade_rect (LONG x,LONG y,LONG w,LONG h,LONG s);
void shade_edged_rect (LONG x,LONG y,LONG w,LONG h,LONG s);
void zoom_color_edged_rect (LONG x, LONG y, LONG w, LONG h, LONG s, SHORT hDest);
void zoomout_color_edged_rect (LONG x, LONG y, LONG w, LONG h, LONG s, SHORT hDest);
void zoom_shade_edged_rect (LONG x, LONG y, LONG w, LONG h, LONG s, SHORT hDest);
void zoomout_shade_edged_rect (LONG x, LONG y, LONG w, LONG h, LONG s, SHORT hDest);

/* extent.c */

/* level.c */
void SetWadPath ( CSTRPTR pWadPath );
void load_level(char *name, LONG PlayerStart);
void load_new_wad(char *name, LONG PlayerStart);

/* player.c */
void TeleportPlayer (ULONG );
void PlayerArrival (LONG * );
void InitPlayer (LONG , LONG , LONG );


/* point.c */
void set_lens (LONG lens);
void set_view(void);
LONG aprox_dist(LONG x1, LONG y1, LONG x2, LONG y2);
LONG dist(LONG x1, LONG y1, LONG x2, LONG y2);
LONG AngleFromPoint ( LONG X1, LONG Y1, LONG X2, LONG Y2, LONG Resolution );
LONG AngleFromPoint2 ( LONG X1, LONG Y1, LONG X2, LONG Y2, LONG Resolution );
LONG RelativeAngle( LONG Angle1, LONG Angle2 );
void RotateAnglePoint (POINT *p, POINT *origin, ULONG a);
void xlate(POINT *p);
void xlatePoint(POINT *p,POINT a);
//rot8_angle coord-system is on the Std. Cartesian Coord System.
//Nova engine is based on the (0=north,64=east)

void rot8 (POINT *p);
void rot8dbl (POINT *p);
void rot8_angle (POINT *p,ULONG a);
void rot8_r_angle(POINT *p,ULONG OldAngle, ULONG DeltaAngle,LONG radius);

/* reject.c */
BOOL reject(LONG MySector, LONG HisSector);

/* render.c */
void render_view(LONG fskipmap);

/* sectors.c */
// Now in sectors.h

/* spans.c */
void init_spans (void);

/* task.c */
void init_tasks(void);
void add_task(LONG freq,PFVL func,LONG var);
void remove_task(PFVL func);
void run_tasks(void);

/* textures.c */

/* mouse.c */
void SysHideCursor (void);
void SysShowCursor (void);

/* ------------------------------------------------------------------------
   Global Variables
   ------------------------------------------------------------------------ */
extern SHORT		origin_x;
extern SHORT		origin_y;
extern SHORT		clip_x;
extern SHORT		clip_y;

extern LONG			objClicked;
extern WadThingType	typeClicked;
extern LONG			butClicked;

extern LONG			render_width; 		// width and height of rendered data 
extern LONG			render_height;
extern LONG			render_perspect;
extern LONG			render_center_x, render_center_y;
extern LONG			window_width;
extern LONG			window_height;

extern LONG	PlayerLoresSpeed;
extern LONG	PlayerHiresSpeed ;



	extern SHORT 	sDrawMode;

extern CAMERA		camera;
extern PLAYER		player;
//extern MAP_INFO		gMapInfo;  //use access functions...

extern BOOL	fFreeze; 					// whether to allow player movement 
extern LONG	fExitLevel;					// an exit tag line has been crossed 


extern CSTRPTR 	sky_filenames[];
extern SHORT	hSky_filenames;

extern BOOL  fPause;
extern BOOL  fRender;
extern BOOL  gfInCombat;

extern ULONG	tot_nodes;


}

// _ENGINE_H
#line 12 ".\winsys\ddraw.cpp"
 

#line 1 ".\winsys\ddrawpro.h"
/* ========================================================================
   Copyright (c) 1990,1996	Synergistic Software
   All Rights Reserved
   ======================================================================== */



/* ------------------------------------------------------------------------
   Sub Includes
   ------------------------------------------------------------------------ */
#line 1 "system.h"
/* =======================================================================
   Copyright (c) 1990,1995   Synergistic Software
   All Rights Reserved.
   =======================================================================
   Filename: SYSTEM.H   -Header file for all source files
   Author: Chris Phillips & Wes Cumberland
   ========================================================================
   Contains the following internal functions: 
   Contains the following general functions:
   ======================================================================== */
// _SYSTEM_H#line 431 "system.h"
#line 11 ".\winsys\ddrawpro.h"
 

#line 1 "C:\DXSDK\SDK\INC\DDraw.h"
/*==========================================================================;
 *
 *  Copyright (C) 1994-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddraw.h
 *  Content:    DirectDraw include file
 *
 ***************************************************************************/





#line 1 "C:\WATCOM\H\NT\objbase.h"
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       objbase.h
//
//  Contents:   Component object model defintions.
//
//----------------------------------------------------------------------------

#line 1 "C:\WATCOM\H\NT\rpc.h"
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    rpc.h

Abstract:

    Master include file for RPC applications.

--*/


#line 1 "C:\WATCOM\H\NT\windows.h"
/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) 1985-1995, Microsoft Corporation

Module Name:


    windows.h

Abstract:

    Master include file for Windows applications.

--*/

/* _WINDOWS_ */#line 216 "C:\WATCOM\H\NT\windows.h"
#line 16 "C:\WATCOM\H\NT\rpc.h"

// RPC_NO_WINDOWS_H

// __RPC_H__#line 121 "C:\WATCOM\H\NT\rpc.h"

#line 12 "C:\WATCOM\H\NT\objbase.h"

#line 1 "C:\WATCOM\H\NT\rpcndr.h"
/*++

Copyright (c) 1992-1995 Microsoft Corporation

Module Name:

    rpcndr.h

Abstract:

    Definitions for stub data structures and prototypes of helper functions.

Environment:

    DOS, Win 3.X, and Win/NT.

--*/

/* __RPCNDR_H__ */#line 2263 "C:\WATCOM\H\NT\rpcndr.h"
#line 13 "C:\WATCOM\H\NT\objbase.h"


// __OBJBASE_H__#line 582 "C:\WATCOM\H\NT\objbase.h"
#line 14 "C:\DXSDK\SDK\INC\DDraw.h"

#line 19 "C:\DXSDK\SDK\INC\DDraw.h"





extern "C" {


/*
 * GUIDS used by DirectDraw objects
 */

 extern "C" const GUID   CLSID_DirectDraw ;
 extern "C" const GUID   CLSID_DirectDrawClipper ;
 extern "C" const GUID   IID_IDirectDraw ;
 extern "C" const GUID   IID_IDirectDraw2 ;
 extern "C" const GUID   IID_IDirectDrawSurface ;
 extern "C" const GUID   IID_IDirectDrawSurface2 ;

 extern "C" const GUID   IID_IDirectDrawPalette ;
 extern "C" const GUID   IID_IDirectDrawClipper ;
                 


/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDirectDraw                         *LPDIRECTDRAW;
typedef struct IDirectDraw2                        *LPDIRECTDRAW2;
typedef struct IDirectDrawSurface                  *LPDIRECTDRAWSURFACE;
typedef struct IDirectDrawSurface2                 *LPDIRECTDRAWSURFACE2;

typedef struct IDirectDrawPalette                  *LPDIRECTDRAWPALETTE;
typedef struct IDirectDrawClipper                  *LPDIRECTDRAWCLIPPER;

typedef struct _DDFXROP                    *LPDDFXROP;
typedef struct _DDSURFACEDESC              *LPDDSURFACEDESC;

/*
 * API's
 */

//#if defined( _WIN32 ) && !defined( _NO_ENUM )
    typedef BOOL (    __stdcall  * LPDDENUMCALLBACKA)(GUID    *, LPSTR, LPSTR, LPVOID);
    typedef BOOL (    __stdcall  * LPDDENUMCALLBACKW)(GUID    *, LPWSTR, LPWSTR, LPVOID);
    extern HRESULT  __stdcall  DirectDrawEnumerateW( LPDDENUMCALLBACKW lpCallback, LPVOID lpContext );
    extern HRESULT  __stdcall  DirectDrawEnumerateA( LPDDENUMCALLBACKA lpCallback, LPVOID lpContext );
    #line 80 "C:\DXSDK\SDK\INC\DDraw.h"
        typedef LPDDENUMCALLBACKA       LPDDENUMCALLBACK;
        
    
    extern HRESULT  __stdcall  DirectDrawCreate( GUID    *lpGUID, LPDIRECTDRAW    *lplpDD, IUnknown    *pUnkOuter );
    extern HRESULT  __stdcall  DirectDrawCreateClipper( DWORD dwFlags, LPDIRECTDRAWCLIPPER    *lplpDDClipper, IUnknown    *pUnkOuter );
    #line 89 "C:\DXSDK\SDK\INC\DDraw.h"









#line 101 "C:\DXSDK\SDK\INC\DDraw.h"

//#ifndef WINNT
typedef HRESULT (    __stdcall  * LPDDENUMMODESCALLBACK)(LPDDSURFACEDESC, LPVOID);
typedef HRESULT (    __stdcall  * LPDDENUMSURFACESCALLBACK)(LPDIRECTDRAWSURFACE, LPDDSURFACEDESC, LPVOID);
//#endif
/*
 * DDCOLORKEY
 */
typedef struct _DDCOLORKEY
{
    DWORD       dwColorSpaceLowValue;   // low boundary of color space that is to  
                                        // be treated as Color Key, inclusive
    DWORD       dwColorSpaceHighValue;  // high boundary of color space that is  
                                        // to be treated as Color Key, inclusive
} DDCOLORKEY;

typedef DDCOLORKEY   * LPDDCOLORKEY;

/*
 * DDBLTFX
 * Used to pass override information to the DIRECTDRAWSURFACE callback Blt.
 */
typedef struct _DDBLTFX
{
    DWORD       dwSize;                         // size of structure 
    DWORD       dwDDFX;                         // FX operations 
    DWORD       dwROP;                          // Win32 raster operations 
    DWORD       dwDDROP;                        // Raster operations new for DirectDraw 
    DWORD       dwRotationAngle;                // Rotation angle for blt 
    DWORD       dwZBufferOpCode;                // ZBuffer compares 
    DWORD       dwZBufferLow;                   // Low limit of Z buffer 
    DWORD       dwZBufferHigh;                  // High limit of Z buffer 
    DWORD       dwZBufferBaseDest;              // Destination base value 
    DWORD       dwZDestConstBitDepth;           // Bit depth used to specify Z constant for destination 
    union
    {
        DWORD   dwZDestConst;                   // Constant to use as Z buffer for dest 
        LPDIRECTDRAWSURFACE lpDDSZBufferDest;   // Surface to use as Z buffer for dest 
    };
    DWORD       dwZSrcConstBitDepth;            // Bit depth used to specify Z constant for source 
    union
    {
        DWORD   dwZSrcConst;                    // Constant to use as Z buffer for src 
        LPDIRECTDRAWSURFACE lpDDSZBufferSrc;    // Surface to use as Z buffer for src 
    };
    DWORD       dwAlphaEdgeBlendBitDepth;       // Bit depth used to specify constant for alpha edge blend 
    DWORD       dwAlphaEdgeBlend;               // Alpha for edge blending 
    DWORD       dwReserved;
    DWORD       dwAlphaDestConstBitDepth;       // Bit depth used to specify alpha constant for destination 
    union
    {
        DWORD   dwAlphaDestConst;               // Constant to use as Alpha Channel 
        LPDIRECTDRAWSURFACE lpDDSAlphaDest;     // Surface to use as Alpha Channel 
    };
    DWORD       dwAlphaSrcConstBitDepth;        // Bit depth used to specify alpha constant for source 
    union
    {
        DWORD   dwAlphaSrcConst;                // Constant to use as Alpha Channel 
        LPDIRECTDRAWSURFACE lpDDSAlphaSrc;      // Surface to use as Alpha Channel 
    };
    union
    {
        DWORD   dwFillColor;                    // color in RGB or Palettized 
        DWORD   dwFillDepth;                    // depth value for z-buffer 
        LPDIRECTDRAWSURFACE lpDDSPattern;       // Surface to use as pattern 
    };
    DDCOLORKEY  ddckDestColorkey;               // DestColorkey override 
    DDCOLORKEY  ddckSrcColorkey;                // SrcColorkey override 
} DDBLTFX;

typedef DDBLTFX   * LPDDBLTFX;


/*
 * DDSCAPS
 */
typedef struct _DDSCAPS
{
    DWORD       dwCaps;         // capabilities of surface wanted 
} DDSCAPS;

typedef DDSCAPS   * LPDDSCAPS; 

/*
 * DDCAPS
 */
// space required to store ROP array

typedef struct _DDCAPS
{
    DWORD       dwSize;                 // size of the DDDRIVERCAPS structure 
    DWORD       dwCaps;                 // driver specific capabilities 
    DWORD       dwCaps2;                // more driver specific capabilites 
    DWORD       dwCKeyCaps;             // color key capabilities of the surface 
    DWORD       dwFXCaps;               // driver specific stretching and effects capabilites 
    DWORD       dwFXAlphaCaps;          // alpha driver specific capabilities 
    DWORD       dwPalCaps;              // palette capabilities 
    DWORD       dwSVCaps;               // stereo vision capabilities 
    DWORD       dwAlphaBltConstBitDepths;       // DDBD_2,4,8 
    DWORD       dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8 
    DWORD       dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8 
    DWORD       dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8 
    DWORD       dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8 
    DWORD       dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8 
    DWORD       dwZBufferBitDepths;             // DDBD_8,16,24,32 
    DWORD       dwVidMemTotal;          // total amount of video memory 
    DWORD       dwVidMemFree;           // amount of free video memory 
    DWORD       dwMaxVisibleOverlays;   // maximum number of visible overlays 
    DWORD       dwCurrVisibleOverlays;  // current number of visible overlays 
    DWORD       dwNumFourCCCodes;       // number of four cc codes 
    DWORD       dwAlignBoundarySrc;     // source rectangle alignment 
    DWORD       dwAlignSizeSrc;         // source rectangle byte size 
    DWORD       dwAlignBoundaryDest;    // dest rectangle alignment 
    DWORD       dwAlignSizeDest;        // dest rectangle byte size 
    DWORD       dwAlignStrideAlign;     // stride alignment 
    DWORD       dwRops[ (256/32) ];   // ROPS supported 
    DDSCAPS     ddsCaps;                // DDSCAPS structure has all the general capabilities 
    DWORD       dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3 
    DWORD       dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3 
    DWORD       dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3 
    DWORD       dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3 
    DWORD       dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3 
    DWORD       dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3 
    DWORD       dwReserved1;            // reserved 
    DWORD       dwReserved2;            // reserved 
    DWORD       dwReserved3;            // reserved 
    DWORD       dwSVBCaps;              // driver specific capabilities for System->Vmem blts 
    DWORD       dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts 
    DWORD       dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts 
    DWORD       dwSVBRops[ (256/32) ];// ROPS supported for System->Vmem blts 
    DWORD       dwVSBCaps;              // driver specific capabilities for Vmem->System blts 
    DWORD       dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts 
    DWORD       dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts 
    DWORD       dwVSBRops[ (256/32) ];// ROPS supported for Vmem->System blts 
    DWORD       dwSSBCaps;              // driver specific capabilities for System->System blts 
    DWORD       dwSSBCKeyCaps;          // driver color key capabilities for System->System blts 
    DWORD       dwSSBFXCaps;            // driver FX capabilities for System->System blts 
    DWORD       dwSSBRops[ (256/32) ];// ROPS supported for System->System blts 
    DWORD       dwReserved4;            // reserved 
    DWORD       dwReserved5;            // reserved 
    DWORD       dwReserved6;            // reserved 
} DDCAPS;

typedef DDCAPS   * LPDDCAPS;



/*
 * DDPIXELFORMAT
 */
typedef struct _DDPIXELFORMAT
{
    DWORD       dwSize;                 // size of structure 
    DWORD       dwFlags;                // pixel format flags 
    DWORD       dwFourCC;               // (FOURCC code) 
    union
    {
        DWORD   dwRGBBitCount;          // how many bits per pixel (BD_4,8,16,24,32) 
        DWORD   dwYUVBitCount;          // how many bits per pixel (BD_4,8,16,24,32) 
        DWORD   dwZBufferBitDepth;      // how many bits for z buffers (BD_8,16,24,32) 
        DWORD   dwAlphaBitDepth;        // how many bits for alpha channels (BD_1,2,4,8) 
    };
    union
    {
        DWORD   dwRBitMask;             // mask for red bit 
        DWORD   dwYBitMask;             // mask for Y bits 
    };
    union
    {
        DWORD   dwGBitMask;             // mask for green bits 
        DWORD   dwUBitMask;             // mask for U bits 
    };
    union
    {
        DWORD   dwBBitMask;             // mask for blue bits 
        DWORD   dwVBitMask;             // mask for V bits 
    };
    union
    {
        DWORD   dwRGBAlphaBitMask;      // mask for alpha channel 
        DWORD   dwYUVAlphaBitMask;      // mask for alpha channel 
    };
} DDPIXELFORMAT;

typedef DDPIXELFORMAT   * LPDDPIXELFORMAT;

/*
 * DDOVERLAYFX
 */
typedef struct _DDOVERLAYFX
{
    DWORD       dwSize;                         // size of structure 
    DWORD       dwAlphaEdgeBlendBitDepth;       // Bit depth used to specify constant for alpha edge blend 
    DWORD       dwAlphaEdgeBlend;               // Constant to use as alpha for edge blend 
    DWORD       dwReserved;
    DWORD       dwAlphaDestConstBitDepth;       // Bit depth used to specify alpha constant for destination 
    union
    {
        DWORD   dwAlphaDestConst;               // Constant to use as alpha channel for dest 
        LPDIRECTDRAWSURFACE lpDDSAlphaDest;     // Surface to use as alpha channel for dest 
    };
    DWORD       dwAlphaSrcConstBitDepth;        // Bit depth used to specify alpha constant for source 
    union
    {
        DWORD   dwAlphaSrcConst;                // Constant to use as alpha channel for src 
        LPDIRECTDRAWSURFACE lpDDSAlphaSrc;      // Surface to use as alpha channel for src 
    };
    DDCOLORKEY  dckDestColorkey;                // DestColorkey override 
    DDCOLORKEY  dckSrcColorkey;                 // DestColorkey override 
    DWORD       dwDDFX;                         // Overlay FX 
    DWORD       dwFlags;                        // flags 
} DDOVERLAYFX;

typedef DDOVERLAYFX    *LPDDOVERLAYFX;

/*
 * DDBLTBATCH: BltBatch entry structure
 */
typedef struct _DDBLTBATCH
{
    LPRECT              lprDest;
    LPDIRECTDRAWSURFACE lpDDSSrc;
    LPRECT              lprSrc;
    DWORD               dwFlags;
    LPDDBLTFX           lpDDBltFx;
} DDBLTBATCH;

typedef DDBLTBATCH    * LPDDBLTBATCH;

/*
 * callbacks
 */
typedef DWORD   (    __stdcall  *LPCLIPPERCALLBACK)(LPDIRECTDRAWCLIPPER lpDDClipper, HWND hWnd, DWORD code, LPVOID lpContext );
#line 337 "C:\DXSDK\SDK\INC\DDraw.h"


/*
 * INTERACES FOLLOW:
 *      IDirectDraw
 *      IDirectDrawClipper
 *      IDirectDrawPalette
 *      IDirectDrawSurface
 */

/*
 * IDirectDraw 
 */



 typedef struct IDirectDraw { struct IDirectDrawVtbl * lpVtbl; } IDirectDraw; typedef struct IDirectDrawVtbl IDirectDrawVtbl; struct IDirectDrawVtbl 
{
    /*** IUnknown methods ***/
     HRESULT (__stdcall * QueryInterface)  ( IDirectDraw * This,   const IID &  riid, LPVOID    * ppvObj)   ;
     ULONG (__stdcall * AddRef)  ( IDirectDraw * This )    ;
     ULONG (__stdcall * Release)  ( IDirectDraw * This )   ;
    /*** IDirectDraw methods ***/
     HRESULT (__stdcall * Compact) ( IDirectDraw * This )   ;
     HRESULT (__stdcall * CreateClipper) ( IDirectDraw * This,  DWORD, LPDIRECTDRAWCLIPPER   *, IUnknown    * )   ;
     HRESULT (__stdcall * CreatePalette) ( IDirectDraw * This,  DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE   *, IUnknown    * )   ;
     HRESULT (__stdcall * CreateSurface) ( IDirectDraw * This,   LPDDSURFACEDESC, LPDIRECTDRAWSURFACE    *, IUnknown    *)   ;
     HRESULT (__stdcall * DuplicateSurface) (  IDirectDraw * This,  LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE    * )   ;
     HRESULT (__stdcall * EnumDisplayModes) (  IDirectDraw * This,  DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK )   ;
     HRESULT (__stdcall * EnumSurfaces) ( IDirectDraw * This,  DWORD, LPDDSURFACEDESC, LPVOID,LPDDENUMSURFACESCALLBACK )   ;
     HRESULT (__stdcall * FlipToGDISurface) ( IDirectDraw * This )   ;
     HRESULT (__stdcall * GetCaps) (  IDirectDraw * This,  LPDDCAPS, LPDDCAPS)   ;
     HRESULT (__stdcall * GetDisplayMode) (  IDirectDraw * This,  LPDDSURFACEDESC)   ;
     HRESULT (__stdcall * GetFourCCCodes) ( IDirectDraw * This,   LPDWORD, LPDWORD )   ;
     HRESULT (__stdcall * GetGDISurface) ( IDirectDraw * This,  LPDIRECTDRAWSURFACE    *)   ;
     HRESULT (__stdcall * GetMonitorFrequency) ( IDirectDraw * This,  LPDWORD)   ;
     HRESULT (__stdcall * GetScanLine) ( IDirectDraw * This,  LPDWORD)   ;
     HRESULT (__stdcall * GetVerticalBlankStatus) ( IDirectDraw * This,  LPBOOL )   ;
     HRESULT (__stdcall * Initialize) ( IDirectDraw * This,  GUID    *)   ;
     HRESULT (__stdcall * RestoreDisplayMode) ( IDirectDraw * This )   ;
     HRESULT (__stdcall * SetCooperativeLevel) ( IDirectDraw * This,  HWND, DWORD)   ;
     HRESULT (__stdcall * SetDisplayMode) ( IDirectDraw * This,  DWORD, DWORD,DWORD)   ;
     HRESULT (__stdcall * WaitForVerticalBlank) ( IDirectDraw * This,  DWORD, HANDLE )   ;
};
































 typedef struct IDirectDraw2 { struct IDirectDraw2Vtbl * lpVtbl; } IDirectDraw2; typedef struct IDirectDraw2Vtbl IDirectDraw2Vtbl; struct IDirectDraw2Vtbl 
{
    /*** IUnknown methods ***/
     HRESULT (__stdcall * QueryInterface)  ( IDirectDraw2 * This,   const IID &  riid, LPVOID    * ppvObj)   ;
     ULONG (__stdcall * AddRef)  ( IDirectDraw2 * This )    ;
     ULONG (__stdcall * Release)  ( IDirectDraw2 * This )   ;
    /*** IDirectDraw methods ***/
     HRESULT (__stdcall * Compact) ( IDirectDraw2 * This )   ;
     HRESULT (__stdcall * CreateClipper) ( IDirectDraw2 * This,  DWORD, LPDIRECTDRAWCLIPPER   *, IUnknown    * )   ;
     HRESULT (__stdcall * CreatePalette) ( IDirectDraw2 * This,  DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE   *, IUnknown    * )   ;
     HRESULT (__stdcall * CreateSurface) ( IDirectDraw2 * This,   LPDDSURFACEDESC, LPDIRECTDRAWSURFACE    *, IUnknown    *)   ;
     HRESULT (__stdcall * DuplicateSurface) (  IDirectDraw2 * This,  LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE    * )   ;
     HRESULT (__stdcall * EnumDisplayModes) (  IDirectDraw2 * This,  DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK )   ;
     HRESULT (__stdcall * EnumSurfaces) ( IDirectDraw2 * This,  DWORD, LPDDSURFACEDESC, LPVOID,LPDDENUMSURFACESCALLBACK )   ;
     HRESULT (__stdcall * FlipToGDISurface) ( IDirectDraw2 * This )   ;
     HRESULT (__stdcall * GetCaps) (  IDirectDraw2 * This,  LPDDCAPS, LPDDCAPS)   ;
     HRESULT (__stdcall * GetDisplayMode) (  IDirectDraw2 * This,  LPDDSURFACEDESC)   ;
     HRESULT (__stdcall * GetFourCCCodes) ( IDirectDraw2 * This,   LPDWORD, LPDWORD )   ;
     HRESULT (__stdcall * GetGDISurface) ( IDirectDraw2 * This,  LPDIRECTDRAWSURFACE    *)   ;
     HRESULT (__stdcall * GetMonitorFrequency) ( IDirectDraw2 * This,  LPDWORD)   ;
     HRESULT (__stdcall * GetScanLine) ( IDirectDraw2 * This,  LPDWORD)   ;
     HRESULT (__stdcall * GetVerticalBlankStatus) ( IDirectDraw2 * This,  LPBOOL )   ;
     HRESULT (__stdcall * Initialize) ( IDirectDraw2 * This,  GUID    *)   ;
     HRESULT (__stdcall * RestoreDisplayMode) ( IDirectDraw2 * This )   ;
     HRESULT (__stdcall * SetCooperativeLevel) ( IDirectDraw2 * This,  HWND, DWORD)   ;
     HRESULT (__stdcall * SetDisplayMode) ( IDirectDraw2 * This,  DWORD, DWORD,DWORD, DWORD, DWORD)   ;
     HRESULT (__stdcall * WaitForVerticalBlank) ( IDirectDraw2 * This,  DWORD, HANDLE )   ;
    /*** Added in the v2 interface ***/
     HRESULT (__stdcall * GetAvailableVidMem) ( IDirectDraw2 * This,  LPDDSCAPS, LPDWORD, LPDWORD)   ;
};





























/*
 * IDirectDrawPalette
 */



 typedef struct IDirectDrawPalette { struct IDirectDrawPaletteVtbl * lpVtbl; } IDirectDrawPalette; typedef struct IDirectDrawPaletteVtbl IDirectDrawPaletteVtbl; struct IDirectDrawPaletteVtbl 
{
    /*** IUnknown methods ***/
     HRESULT (__stdcall * QueryInterface)  ( IDirectDrawPalette * This,   const IID &  riid, LPVOID    * ppvObj)   ;
     ULONG (__stdcall * AddRef)  ( IDirectDrawPalette * This )    ;
     ULONG (__stdcall * Release)  ( IDirectDrawPalette * This )   ;
    /*** IDirectDrawPalette methods ***/
     HRESULT (__stdcall * GetCaps) ( IDirectDrawPalette * This,  LPDWORD)   ;
     HRESULT (__stdcall * GetEntries) ( IDirectDrawPalette * This,  DWORD,DWORD,DWORD,LPPALETTEENTRY)   ;
     HRESULT (__stdcall * Initialize) ( IDirectDrawPalette * This,  LPDIRECTDRAW, DWORD, LPPALETTEENTRY)   ;
     HRESULT (__stdcall * SetEntries) ( IDirectDrawPalette * This,  DWORD,DWORD,DWORD,LPPALETTEENTRY)   ;
};













/*
 * IDirectDrawClipper
 */



 typedef struct IDirectDrawClipper { struct IDirectDrawClipperVtbl * lpVtbl; } IDirectDrawClipper; typedef struct IDirectDrawClipperVtbl IDirectDrawClipperVtbl; struct IDirectDrawClipperVtbl 
{
    /*** IUnknown methods ***/
     HRESULT (__stdcall * QueryInterface)  ( IDirectDrawClipper * This,   const IID &  riid, LPVOID    * ppvObj)   ;
     ULONG (__stdcall * AddRef)  ( IDirectDrawClipper * This )    ;
     ULONG (__stdcall * Release)  ( IDirectDrawClipper * This )   ;
    /*** IDirectDrawClipper methods ***/
     HRESULT (__stdcall * GetClipList) ( IDirectDrawClipper * This,  LPRECT, LPRGNDATA, LPDWORD)   ;
     HRESULT (__stdcall * GetHWnd) ( IDirectDrawClipper * This,  HWND    *)   ;
     HRESULT (__stdcall * Initialize) ( IDirectDrawClipper * This,  LPDIRECTDRAW, DWORD)   ;
     HRESULT (__stdcall * IsClipListChanged) ( IDirectDrawClipper * This,  BOOL    *)   ;
     HRESULT (__stdcall * SetClipList) ( IDirectDrawClipper * This,  LPRGNDATA,DWORD)   ;
     HRESULT (__stdcall * SetHWnd) ( IDirectDrawClipper * This,  DWORD, HWND )   ;
};















/*
 * IDirectDrawSurface and related interfaces
 */



 typedef struct IDirectDrawSurface { struct IDirectDrawSurfaceVtbl * lpVtbl; } IDirectDrawSurface; typedef struct IDirectDrawSurfaceVtbl IDirectDrawSurfaceVtbl; struct IDirectDrawSurfaceVtbl 
{
    /*** IUnknown methods ***/
     HRESULT (__stdcall * QueryInterface)  ( IDirectDrawSurface * This,   const IID &  riid, LPVOID    * ppvObj)   ;
     ULONG (__stdcall * AddRef)  ( IDirectDrawSurface * This )    ;
     ULONG (__stdcall * Release)  ( IDirectDrawSurface * This )   ;
    /*** IDirectDrawSurface methods ***/
     HRESULT (__stdcall * AddAttachedSurface) ( IDirectDrawSurface * This,  LPDIRECTDRAWSURFACE)   ;
     HRESULT (__stdcall * AddOverlayDirtyRect) ( IDirectDrawSurface * This,  LPRECT)   ;
     HRESULT (__stdcall * Blt) ( IDirectDrawSurface * This,  LPRECT,LPDIRECTDRAWSURFACE, LPRECT,DWORD, LPDDBLTFX)   ;
     HRESULT (__stdcall * BltBatch) ( IDirectDrawSurface * This,  LPDDBLTBATCH, DWORD, DWORD )   ;
     HRESULT (__stdcall * BltFast) ( IDirectDrawSurface * This,  DWORD,DWORD,LPDIRECTDRAWSURFACE, LPRECT,DWORD)   ;
     HRESULT (__stdcall * DeleteAttachedSurface) ( IDirectDrawSurface * This,  DWORD,LPDIRECTDRAWSURFACE)   ;
     HRESULT (__stdcall * EnumAttachedSurfaces) ( IDirectDrawSurface * This,  LPVOID,LPDDENUMSURFACESCALLBACK)   ;
     HRESULT (__stdcall * EnumOverlayZOrders) ( IDirectDrawSurface * This,  DWORD,LPVOID,LPDDENUMSURFACESCALLBACK)   ;
     HRESULT (__stdcall * Flip) ( IDirectDrawSurface * This,  LPDIRECTDRAWSURFACE, DWORD)   ;
     HRESULT (__stdcall * GetAttachedSurface) ( IDirectDrawSurface * This,  LPDDSCAPS, LPDIRECTDRAWSURFACE    *)   ;
     HRESULT (__stdcall * GetBltStatus) ( IDirectDrawSurface * This,  DWORD)   ;
     HRESULT (__stdcall * GetCaps) ( IDirectDrawSurface * This,  LPDDSCAPS)   ;
     HRESULT (__stdcall * GetClipper) ( IDirectDrawSurface * This,  LPDIRECTDRAWCLIPPER   *)   ;
     HRESULT (__stdcall * GetColorKey) ( IDirectDrawSurface * This,  DWORD, LPDDCOLORKEY)   ;
     HRESULT (__stdcall * GetDC) ( IDirectDrawSurface * This,  HDC    *)   ;
     HRESULT (__stdcall * GetFlipStatus) ( IDirectDrawSurface * This,  DWORD)   ;
     HRESULT (__stdcall * GetOverlayPosition) ( IDirectDrawSurface * This,  LPLONG, LPLONG )   ;
     HRESULT (__stdcall * GetPalette) ( IDirectDrawSurface * This,  LPDIRECTDRAWPALETTE   *)   ;
     HRESULT (__stdcall * GetPixelFormat) ( IDirectDrawSurface * This,  LPDDPIXELFORMAT)   ;
     HRESULT (__stdcall * GetSurfaceDesc) ( IDirectDrawSurface * This,  LPDDSURFACEDESC)   ;
     HRESULT (__stdcall * Initialize) ( IDirectDrawSurface * This,  LPDIRECTDRAW, LPDDSURFACEDESC)   ;
     HRESULT (__stdcall * IsLost) ( IDirectDrawSurface * This )   ;
     HRESULT (__stdcall * Lock) ( IDirectDrawSurface * This,  LPRECT,LPDDSURFACEDESC,DWORD,HANDLE)   ;
     HRESULT (__stdcall * ReleaseDC) ( IDirectDrawSurface * This,  HDC)   ;
     HRESULT (__stdcall * Restore) ( IDirectDrawSurface * This )   ;
     HRESULT (__stdcall * SetClipper) ( IDirectDrawSurface * This,  LPDIRECTDRAWCLIPPER)   ;
     HRESULT (__stdcall * SetColorKey) ( IDirectDrawSurface * This,  DWORD, LPDDCOLORKEY)   ;
     HRESULT (__stdcall * SetOverlayPosition) ( IDirectDrawSurface * This,  LONG, LONG )   ;
     HRESULT (__stdcall * SetPalette) ( IDirectDrawSurface * This,  LPDIRECTDRAWPALETTE)   ;
     HRESULT (__stdcall * Unlock) ( IDirectDrawSurface * This,  LPVOID)   ;
     HRESULT (__stdcall * UpdateOverlay) ( IDirectDrawSurface * This,  LPRECT, LPDIRECTDRAWSURFACE,LPRECT,DWORD, LPDDOVERLAYFX)   ;
     HRESULT (__stdcall * UpdateOverlayDisplay) ( IDirectDrawSurface * This,  DWORD)   ;
     HRESULT (__stdcall * UpdateOverlayZOrder) ( IDirectDrawSurface * This,  DWORD, LPDIRECTDRAWSURFACE)   ;
};








































/*
 * IDirectDrawSurface2 and related interfaces
 */


 typedef struct IDirectDrawSurface2 { struct IDirectDrawSurface2Vtbl * lpVtbl; } IDirectDrawSurface2; typedef struct IDirectDrawSurface2Vtbl IDirectDrawSurface2Vtbl; struct IDirectDrawSurface2Vtbl 
{
    /*** IUnknown methods ***/
     HRESULT (__stdcall * QueryInterface)  ( IDirectDrawSurface2 * This,   const IID &  riid, LPVOID    * ppvObj)   ;
     ULONG (__stdcall * AddRef)  ( IDirectDrawSurface2 * This )    ;
     ULONG (__stdcall * Release)  ( IDirectDrawSurface2 * This )   ;
    /*** IDirectDrawSurface methods ***/
     HRESULT (__stdcall * AddAttachedSurface) ( IDirectDrawSurface2 * This,  LPDIRECTDRAWSURFACE2)   ;
     HRESULT (__stdcall * AddOverlayDirtyRect) ( IDirectDrawSurface2 * This,  LPRECT)   ;
     HRESULT (__stdcall * Blt) ( IDirectDrawSurface2 * This,  LPRECT,LPDIRECTDRAWSURFACE2, LPRECT,DWORD, LPDDBLTFX)   ;
     HRESULT (__stdcall * BltBatch) ( IDirectDrawSurface2 * This,  LPDDBLTBATCH, DWORD, DWORD )   ;
     HRESULT (__stdcall * BltFast) ( IDirectDrawSurface2 * This,  DWORD,DWORD,LPDIRECTDRAWSURFACE2, LPRECT,DWORD)   ;
     HRESULT (__stdcall * DeleteAttachedSurface) ( IDirectDrawSurface2 * This,  DWORD,LPDIRECTDRAWSURFACE2)   ;
     HRESULT (__stdcall * EnumAttachedSurfaces) ( IDirectDrawSurface2 * This,  LPVOID,LPDDENUMSURFACESCALLBACK)   ;
     HRESULT (__stdcall * EnumOverlayZOrders) ( IDirectDrawSurface2 * This,  DWORD,LPVOID,LPDDENUMSURFACESCALLBACK)   ;
     HRESULT (__stdcall * Flip) ( IDirectDrawSurface2 * This,  LPDIRECTDRAWSURFACE2, DWORD)   ;
     HRESULT (__stdcall * GetAttachedSurface) ( IDirectDrawSurface2 * This,  LPDDSCAPS, LPDIRECTDRAWSURFACE2    *)   ;
     HRESULT (__stdcall * GetBltStatus) ( IDirectDrawSurface2 * This,  DWORD)   ;
     HRESULT (__stdcall * GetCaps) ( IDirectDrawSurface2 * This,  LPDDSCAPS)   ;
     HRESULT (__stdcall * GetClipper) ( IDirectDrawSurface2 * This,  LPDIRECTDRAWCLIPPER   *)   ;
     HRESULT (__stdcall * GetColorKey) ( IDirectDrawSurface2 * This,  DWORD, LPDDCOLORKEY)   ;
     HRESULT (__stdcall * GetDC) ( IDirectDrawSurface2 * This,  HDC    *)   ;
     HRESULT (__stdcall * GetFlipStatus) ( IDirectDrawSurface2 * This,  DWORD)   ;
     HRESULT (__stdcall * GetOverlayPosition) ( IDirectDrawSurface2 * This,  LPLONG, LPLONG )   ;
     HRESULT (__stdcall * GetPalette) ( IDirectDrawSurface2 * This,  LPDIRECTDRAWPALETTE   *)   ;
     HRESULT (__stdcall * GetPixelFormat) ( IDirectDrawSurface2 * This,  LPDDPIXELFORMAT)   ;
     HRESULT (__stdcall * GetSurfaceDesc) ( IDirectDrawSurface2 * This,  LPDDSURFACEDESC)   ;
     HRESULT (__stdcall * Initialize) ( IDirectDrawSurface2 * This,  LPDIRECTDRAW, LPDDSURFACEDESC)   ;
     HRESULT (__stdcall * IsLost) ( IDirectDrawSurface2 * This )   ;
     HRESULT (__stdcall * Lock) ( IDirectDrawSurface2 * This,  LPRECT,LPDDSURFACEDESC,DWORD,HANDLE)   ;
     HRESULT (__stdcall * ReleaseDC) ( IDirectDrawSurface2 * This,  HDC)   ;
     HRESULT (__stdcall * Restore) ( IDirectDrawSurface2 * This )   ;
     HRESULT (__stdcall * SetClipper) ( IDirectDrawSurface2 * This,  LPDIRECTDRAWCLIPPER)   ;
     HRESULT (__stdcall * SetColorKey) ( IDirectDrawSurface2 * This,  DWORD, LPDDCOLORKEY)   ;
     HRESULT (__stdcall * SetOverlayPosition) ( IDirectDrawSurface2 * This,  LONG, LONG )   ;
     HRESULT (__stdcall * SetPalette) ( IDirectDrawSurface2 * This,  LPDIRECTDRAWPALETTE)   ;
     HRESULT (__stdcall * Unlock) ( IDirectDrawSurface2 * This,  LPVOID)   ;
     HRESULT (__stdcall * UpdateOverlay) ( IDirectDrawSurface2 * This,  LPRECT, LPDIRECTDRAWSURFACE2,LPRECT,DWORD, LPDDOVERLAYFX)   ;
     HRESULT (__stdcall * UpdateOverlayDisplay) ( IDirectDrawSurface2 * This,  DWORD)   ;
     HRESULT (__stdcall * UpdateOverlayZOrder) ( IDirectDrawSurface2 * This,  DWORD, LPDIRECTDRAWSURFACE2)   ;
    /*** Added in the v2 interface ***/
     HRESULT (__stdcall * GetDDInterface) ( IDirectDrawSurface2 * This,  LPVOID    *)   ;
     HRESULT (__stdcall * PageLock) ( IDirectDrawSurface2 * This,  DWORD)   ;
     HRESULT (__stdcall * PageUnlock) ( IDirectDrawSurface2 * This,  DWORD)   ;
};















































/*
 * DDSURFACEDESC
 */
typedef struct _DDSURFACEDESC
{
    DWORD               dwSize;                 // size of the DDSURFACEDESC structure 
    DWORD               dwFlags;                // determines what fields are valid 
    DWORD               dwHeight;               // height of surface to be created 
    DWORD               dwWidth;                // width of input surface 
    LONG                lPitch;                 // distance to start of next line (return value only) 
    DWORD               dwBackBufferCount;      // number of back buffers requested 
    union
    {
        DWORD           dwMipMapCount;          // number of mip-map levels requested 
        DWORD           dwZBufferBitDepth;      // depth of Z buffer requested 
        DWORD           dwRefreshRate;          // refresh rate (used when display mode is described) 
    };
    DWORD               dwAlphaBitDepth;        // depth of alpha buffer requested 
    DWORD               dwReserved;             // reserved 
    LPVOID              lpSurface;              // pointer to the associated surface memory 
    DDCOLORKEY          ddckCKDestOverlay;      // color key for destination overlay use 
    DDCOLORKEY          ddckCKDestBlt;          // color key for destination blt use 
    DDCOLORKEY          ddckCKSrcOverlay;       // color key for source overlay use 
    DDCOLORKEY          ddckCKSrcBlt;           // color key for source blt use 
    DDPIXELFORMAT       ddpfPixelFormat;        // pixel format description of the surface 
    DDSCAPS             ddsCaps;                // direct draw surface capabilities 
} DDSURFACEDESC;

/*
 * ddsCaps field is valid.
 */
// default

/*
 * dwHeight field is valid.
 */


/*
 * dwWidth field is valid.
 */


/*
 * lPitch is valid.
 */


/*
 * dwBackBufferCount is valid.
 */


/*
 * dwZBufferBitDepth is valid.
 */


/*
 * dwAlphaBitDepth is valid.
 */




/*
 * ddpfPixelFormat is valid.
 */


/*
 * ddckCKDestOverlay is valid.
 */


/*
 * ddckCKDestBlt is valid.
 */


/*
 * ddckCKSrcOverlay is valid.
 */


/*
 * ddckCKSrcBlt is valid.
 */


/*
 * dwMipMapCount is valid.
 */


 /*
  * dwRefreshRate is valid
  */



/*
 * All input fields are valid. 
 */



/*============================================================================
 *
 * Direct Draw Capability Flags
 *
 * These flags are used to describe the capabilities of a given Surface.
 * All flags are bit flags. 
 *
 *==========================================================================*/

/****************************************************************************
 *
 * DIRECTDRAWSURFACE CAPABILITY FLAGS
 *
 ****************************************************************************/
/*
 * This bit currently has no meaning.
 */


/*
 * Indicates that this surface contains alpha information.  The pixel
 * format must be interrogated to determine whether this surface
 * contains only alpha information or alpha information interlaced
 * with pixel color data (e.g. RGBA or YUVA).
 */


/*
 * Indicates that this surface is a backbuffer.  It is generally
 * set by CreateSurface when the DDSCAPS_FLIP capability bit is set.
 * It indicates that this surface is THE back buffer of a surface
 * flipping structure.  DirectDraw supports N surfaces in a
 * surface flipping structure.  Only the surface that immediately
 * precedeces the DDSCAPS_FRONTBUFFER has this capability bit set.
 * The other surfaces are identified as back buffers by the presence
 * of the DDSCAPS_FLIP capability, their attachment order, and the
 * absence of the DDSCAPS_FRONTBUFFER and DDSCAPS_BACKBUFFER
 * capabilities.  The bit is sent to CreateSurface when a standalone
 * back buffer is being created.  This surface could be attached to
 * a front buffer and/or back buffers to form a flipping surface
 * structure after the CreateSurface call.  See AddAttachments for
 * a detailed description of the behaviors in this case.
 */


/*
 * Indicates a complex surface structure is being described.  A
 * complex surface structure results in the creation of more than
 * one surface.  The additional surfaces are attached to the root
 * surface.  The complex structure can only be destroyed by
 * destroying the root.
 */


/*
 * Indicates that this surface is a part of a surface flipping structure.
 * When it is passed to CreateSurface the DDSCAPS_FRONTBUFFER and
 * DDSCAP_BACKBUFFER bits are not set.  They are set by CreateSurface
 * on the resulting creations.  The dwBackBufferCount field in the
 * DDSURFACEDESC structure must be set to at least 1 in order for
 * the CreateSurface call to succeed.  The DDSCAPS_COMPLEX capability
 * must always be set with creating multiple surfaces through CreateSurface.
 */


/*
 * Indicates that this surface is THE front buffer of a surface flipping
 * structure.  It is generally set by CreateSurface when the DDSCAPS_FLIP
 * capability bit is set.
 * If this capability is sent to CreateSurface then a standalonw front buffer
 * is created.  This surface will not have the DDSCAPS_FLIP capability.
 * It can be attached to other back buffers to form a flipping structure.
 * See AddAttachments for a detailed description of the behaviors in this
 * case.
 */


/*
 * Indicates that this surface is any offscreen surface that is not an overlay,
 * texture, zbuffer, front buffer, back buffer, or alpha surface.  It is used
 * to identify plain vanilla surfaces.
 */


/*
 * Indicates that this surface is an overlay.  It may or may not be directly visible
 * depending on whether or not it is currently being overlayed onto the primary 
 * surface.  DDSCAPS_VISIBLE can be used to determine whether or not it is being 
 * overlayed at the moment. 
 */


/*
 * Indicates that unique DirectDrawPalette objects can be created and
 * attached to this surface.
 */


/*
 * Indicates that this surface is the primary surface.  The primary
 * surface represents what the user is seeing at the moment.
 */


/*
 * Indicates that this surface is the primary surface for the left eye.
 * The primary surface for the left eye represents what the user is seeing
 * at the moment with the users left eye.  When this surface is created the
 * DDSCAPS_PRIMARYSURFACE represents what the user is seeing with the users
 * right eye.
 */


/*
 * Indicates that this surface memory was allocated in system memory
 */


/*
 * Indicates that this surface can be used as a 3D texture.  It does not
 * indicate whether or not the surface is being used for that purpose.
 */


/*
 * Indicates that a surface may be a destination for 3D rendering.  This
 * bit must be set in order to query for a Direct3D Device Interface 
 * from this surface.
 */


/*
 * Indicates that this surface exists in video memory.
 */


/*
 * Indicates that changes made to this surface are immediately visible.  
 * It is always set for the primary surface and is set for overlays while
 * they are being overlayed and texture maps while they are being textured.
 */


/*
 * Indicates that only writes are permitted to the surface.  Read accesses 
 * from the surface may or may not generate a protection fault, but the 
 * results of a read from this surface will not be meaningful.  READ ONLY.
 */


/*
 * Indicates that this surface is a z buffer. A z buffer does not contain
 * displayable information.  Instead it contains bit depth information that is
 * used to determine which pixels are visible and which are obscured. 
 */


/*
 * Indicates surface will have a DC associated long term
 */


/*
 * Indicates surface should be able to receive live video
 */


/*
 * Indicates surface should be able to have a stream decompressed
 * to it by the hardware.
 */


/*
 * Surface is a 320x200 or 320x240 ModeX surface
 */


/*
 * Indicates surface is one level of a mip-map. This surface will
 * be attached to other DDSCAPS_MIPMAP surfaces to form the mip-map.
 * This can be done explicitly, by creating a number of surfaces and
 * attaching them with AddAttachedSurface or by implicitly by CreateSurface.
 * If this bit is set then DDSCAPS_TEXTURE must also be set.
 */




/*
 * Indicates that memory for the surface is not allocated until the surface
 * is loaded (via the Direct3D texture Load() function).
 */




 /****************************************************************************
 *
 * DIRECTDRAW DRIVER CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Display hardware has 3D acceleration.
 */


/*
 * Indicates that DirectDraw will support only dest rectangles that are aligned
 * on DIRECTDRAWCAPS.dwAlignBoundaryDest boundaries of the surface, respectively.
 * READ ONLY.
 */


/*
 * Indicates that DirectDraw will support only source rectangles  whose sizes in 
 * BYTEs are DIRECTDRAWCAPS.dwAlignSizeDest multiples, respectively.  READ ONLY.
 */

/*
 * Indicates that DirectDraw will support only source rectangles that are aligned
 * on DIRECTDRAWCAPS.dwAlignBoundarySrc boundaries of the surface, respectively.
 * READ ONLY.
 */


/*
 * Indicates that DirectDraw will support only source rectangles  whose sizes in 
 * BYTEs are DIRECTDRAWCAPS.dwAlignSizeSrc multiples, respectively.  READ ONLY.
 */


/*
 * Indicates that DirectDraw will create video memory surfaces that have a stride 
 * alignment equal to DIRECTDRAWCAPS.dwAlignStride.  READ ONLY.
 */


/*
 * Display hardware is capable of blt operations.
 */


/*
 * Display hardware is capable of asynchronous blt operations.
 */


/*
 * Display hardware is capable of color space conversions during the blt operation.
 */


/*
 * Display hardware is capable of stretching during blt operations.
 */


/*
 * Display hardware is shared with GDI.
 */


/*
 * Display hardware can overlay.
 */


/*
 * Set if display hardware supports overlays but can not clip them.
 */


/*
 * Indicates that overlay hardware is capable of color space conversions during
 * the overlay operation.
 */


/*
 * Indicates that stretching can be done by the overlay hardware.
 */


/*
 * Indicates that unique DirectDrawPalettes can be created for DirectDrawSurfaces
 * other than the primary surface.
 */


/*
 * Indicates that palette changes can be syncd with the veritcal refresh.
 */


/*
 * Display hardware can return the current scan line.
 */


/*
 * Display hardware has stereo vision capabilities.  DDSCAPS_PRIMARYSURFACELEFT 
 * can be created.
 */


/*
 * Display hardware is capable of generating a vertical blank interrupt.
 */


/*
 * Supports the use of z buffers with blt operations.
 */


/*
 * Supports Z Ordering of overlays.
 */


/*
 * Supports color key
 */


/*
 * Supports alpha surfaces
 */


/*
 * colorkey is hardware assisted(DDCAPS_COLORKEY will also be set)
 */


/*
 * no hardware support at all
 */


/*
 * Display hardware is capable of color fill with bltter
 */


/*
 * Display hardware is bank switched, and potentially very slow at
 * random access to VRAM.
 */


/*
 * Display hardware is capable of depth filling Z-buffers with bltter
 */


/*
 * Display hardware is capable of clipping while bltting.
 */


/*
 * Display hardware is capable of clipping while stretch bltting.
 */


/*
 * Display hardware is capable of bltting to or from system memory
 */



 /****************************************************************************
 *
 * MORE DIRECTDRAW DRIVER CAPABILITY FLAGS (dwCaps2)
 *
 ****************************************************************************/

/*
 * Display hardware is certified
 */


/*
 * Driver cannot interleave 2D operations (lock and blt) to surfaces with
 * Direct3D rendering operations between calls to BeginScene() and EndScene()
 */


/****************************************************************************
 *
 * DIRECTDRAW FX ALPHA CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Supports alpha blending around the edge of a source color keyed surface.
 * For Blt.
 */


/*
 * Supports alpha information in the pixel format.  The bit depth of alpha 
 * information in the pixel format can be 1,2,4, or 8.  The alpha value becomes
 * more opaque as the alpha value increases.  (0 is transparent.)
 * For Blt.
 */


/*
 * Supports alpha information in the pixel format.  The bit depth of alpha 
 * information in the pixel format can be 1,2,4, or 8.  The alpha value 
 * becomes more transparent as the alpha value increases.  (0 is opaque.) 
 * This flag can only be set if DDCAPS_ALPHA is set.
 * For Blt.
 */


/*
 * Supports alpha only surfaces.  The bit depth of an alpha only surface can be
 * 1,2,4, or 8.  The alpha value becomes more opaque as the alpha value increases.
 * (0 is transparent.)
 * For Blt.
 */


/*
 * The depth of the alpha channel data can range can be 1,2,4, or 8.  
 * The NEG suffix indicates that this alpha channel becomes more transparent
 * as the alpha value increases. (0 is opaque.)  This flag can only be set if
 * DDCAPS_ALPHA is set.
 * For Blt.
 */


/*
 * Supports alpha blending around the edge of a source color keyed surface.
 * For Overlays.
 */


/*
 * Supports alpha information in the pixel format.  The bit depth of alpha 
 * information in the pixel format can be 1,2,4, or 8.  The alpha value becomes
 * more opaque as the alpha value increases.  (0 is transparent.)
 * For Overlays.
 */


/*
 * Supports alpha information in the pixel format.  The bit depth of alpha 
 * information in the pixel format can be 1,2,4, or 8.  The alpha value 
 * becomes more transparent as the alpha value increases.  (0 is opaque.) 
 * This flag can only be set if DDCAPS_ALPHA is set.
 * For Overlays.
 */


/*
 * Supports alpha only surfaces.  The bit depth of an alpha only surface can be
 * 1,2,4, or 8.  The alpha value becomes more opaque as the alpha value increases.
 * (0 is transparent.)
 * For Overlays.
 */


/*
 * The depth of the alpha channel data can range can be 1,2,4, or 8.  
 * The NEG suffix indicates that this alpha channel becomes more transparent
 * as the alpha value increases. (0 is opaque.)  This flag can only be set if
 * DDCAPS_ALPHA is set.
 * For Overlays.
 */


/****************************************************************************
 *
 * DIRECTDRAW FX CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Uses arithmetic operations to stretch and shrink surfaces during blt
 * rather than pixel doubling techniques.  Along the Y axis.
 */


/*
 * Uses arithmetic operations to stretch during blt
 * rather than pixel doubling techniques.  Along the Y axis. Only
 * works for x1, x2, etc.
 */


/*
 * Supports mirroring left to right in blt.
 */


/*
 * Supports mirroring top to bottom in blt.
 */


/*
 * Supports arbitrary rotation for blts.
 */


/*
 * Supports 90 degree rotations for blts.
 */


/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * x axis (horizontal direction) for blts.
 */


/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the x axis (horizontal direction) for blts.
 */


/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * y axis (horizontal direction) for blts.  
 */


/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the y axis (vertical direction) for blts.  
 */


/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * x axis (horizontal direction) for blts.
 */


/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the x axis (horizontal direction) for blts.
 */


/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * y axis (horizontal direction) for blts.  
 */


/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the y axis (vertical direction) for blts.  
 */


/*
 * Uses arithmetic operations to stretch and shrink surfaces during 
 * overlay rather than pixel doubling techniques.  Along the Y axis 
 * for overlays.
 */


/*
 * Uses arithmetic operations to stretch surfaces during 
 * overlay rather than pixel doubling techniques.  Along the Y axis 
 * for overlays. Only works for x1, x2, etc.
 */


/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * x axis (horizontal direction) for overlays.
 */


/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the x axis (horizontal direction) for overlays.
 */


/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * y axis (horizontal direction) for overlays.  
 */


/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the y axis (vertical direction) for overlays.  
 */


/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * x axis (horizontal direction) for overlays.
 */


/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the x axis (horizontal direction) for overlays.
 */


/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * y axis (horizontal direction) for overlays.  
 */


/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the y axis (vertical direction) for overlays.  
 */


/*
 * DirectDraw supports mirroring of overlays across the vertical axis
 */


/*
 * DirectDraw supports mirroring of overlays across the horizontal axis
 */


/****************************************************************************
 *
 * DIRECTDRAW STEREO VIEW CAPABILITIES
 *
 ****************************************************************************/

/*
 * The stereo view is accomplished via enigma encoding.
 */


/*
 * The stereo view is accomplished via high frequency flickering.
 */


/*
 * The stereo view is accomplished via red and blue filters applied
 * to the left and right eyes.  All images must adapt their colorspaces
 * for this process.
 */


/*
 * The stereo view is accomplished with split screen technology.
 */


/****************************************************************************
 *
 * DIRECTDRAWPALETTE CAPABILITIES
 *
 ****************************************************************************/

/*
 * Index is 4 bits.  There are sixteen color entries in the palette table.
 */


/*
 * Index is onto a 8 bit color index.  This field is only valid with the
 * DDPCAPS_1BIT, DDPCAPS_2BIT or DDPCAPS_4BIT capability and the target
 * surface is in 8bpp. Each color entry is one byte long and is an index
 * into destination surface's 8bpp palette.
 */


/*
 * Index is 8 bits.  There are 256 color entries in the palette table.
 */


/*
 * Indicates that this DIRECTDRAWPALETTE should use the palette color array
 * passed into the lpDDColorArray parameter to initialize the DIRECTDRAWPALETTE
 * object.
 */


/*
 * This palette is the one attached to the primary surface.  Changing this
 * table has immediate effect on the display unless DDPSETPAL_VSYNC is specified
 * and supported.
 */


/*
 * This palette is the one attached to the primary surface left.  Changing
 * this table has immediate effect on the display for the left eye unless
 * DDPSETPAL_VSYNC is specified and supported.
 */


/*
 * This palette can have all 256 entries defined
 */


/*
 * This palette can have modifications to it synced with the monitors
 * refresh rate.
 */


/*
 * Index is 1 bit.  There are two color entries in the palette table.
 */


/*
 * Index is 2 bit.  There are four color entries in the palette table.
 */



/****************************************************************************
 *
 * DIRECTDRAWPALETTE SETENTRY CONSTANTS
 *
 ****************************************************************************/


/****************************************************************************
 *
 * DIRECTDRAWPALETTE GETENTRY CONSTANTS
 *
 ****************************************************************************/

/* 0 is the only legal value */

/****************************************************************************
 *
 * DIRECTDRAWSURFACE SETPALETTE CONSTANTS
 *
 ****************************************************************************/


/****************************************************************************
 *
 * DIRECTDRAW BITDEPTH CONSTANTS
 *
 * NOTE:  These are only used to indicate supported bit depths.   These
 * are flags only, they are not to be used as an actual bit depth.   The
 * absolute numbers 1, 2, 4, 8, 16, 24 and 32 are used to indicate actual
 * bit depths in a surface or for changing the display mode.
 *
 ****************************************************************************/

/*
 * 1 bit per pixel.
 */


/*
 * 2 bits per pixel.
 */


/*
 * 4 bits per pixel.
 */


/*
 * 8 bits per pixel.
 */


/*
 * 16 bits per pixel.
 */


/*
 * 24 bits per pixel.
 */


/*
 * 32 bits per pixel.
 */


/****************************************************************************
 *
 * DIRECTDRAWSURFACE SET/GET COLOR KEY FLAGS
 *
 ****************************************************************************/

/*
 * Set if the structure contains a color space.  Not set if the structure
 * contains a single color key.
 */


/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a destination color key for blt operations.
 */


/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a destination color key for overlay operations.
 */


/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a source color key for blt operations.
 */


/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a source color key for overlay operations.
 */



/****************************************************************************
 *
 * DIRECTDRAW COLOR KEY CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Supports transparent blting using a color key to identify the replaceable 
 * bits of the destination surface for RGB colors.
 */


/*
 * Supports transparent blting using a color space to identify the replaceable
 * bits of the destination surface for RGB colors.
 */


/*
 * Supports transparent blting using a color space to identify the replaceable
 * bits of the destination surface for YUV colors.
 */


/*
 * Supports transparent blting using a color key to identify the replaceable 
 * bits of the destination surface for YUV colors.
 */


/*
 * Supports overlaying using colorkeying of the replaceable bits of the surface
 * being overlayed for RGB colors.
 */


/*
 * Supports a color space as the color key for the destination for RGB colors.
 */


/*
 * Supports a color space as the color key for the destination for YUV colors.
 */


/*
 * Supports only one active destination color key value for visible overlay
 * surfaces.
 */


/*
 * Supports overlaying using colorkeying of the replaceable bits of the 
 * surface being overlayed for YUV colors.
 */


/*
 * Supports transparent blting using the color key for the source with
 * this surface for RGB colors.
 */


/*
 * Supports transparent blting using a color space for the source with
 * this surface for RGB colors.
 */


/*
 * Supports transparent blting using a color space for the source with
 * this surface for YUV colors.
 */


/*
 * Supports transparent blting using the color key for the source with
 * this surface for YUV colors.
 */


/*
 * Supports overlays using the color key for the source with this
 * overlay surface for RGB colors.
 */


/*
 * Supports overlays using a color space as the source color key for
 * the overlay surface for RGB colors.
 */


/*
 * Supports overlays using a color space as the source color key for
 * the overlay surface for YUV colors.
 */


/*
 * Supports only one active source color key value for visible
 * overlay surfaces.
 */


/*
 * Supports overlays using the color key for the source with this
 * overlay surface for YUV colors.
 */


/*
 * there are no bandwidth trade-offs for using colorkey with an overlay
 */



/****************************************************************************
 *
 * DIRECTDRAW PIXELFORMAT FLAGS
 *
 ****************************************************************************/

/*
 * The surface has alpha channel information in the pixel format.
 */


/*
 * The pixel format contains alpha only information
 */


/*
 * The FourCC code is valid.
 */


/*
 * The surface is 4-bit color indexed.
 */


/*
 * The surface is indexed into a palette which stores indices
 * into the destination surface's 8-bit palette.
 */


/*
 * The surface is 8-bit color indexed.
 */


/*
 * The RGB data in the pixel format structure is valid.
 */


/*
 * The surface will accept pixel data in the format specified
 * and compress it during the write.
 */


/*
 * The surface will accept RGB data and translate it during
 * the write to YUV data.  The format of the data to be written
 * will be contained in the pixel format structure.  The DDPF_RGB
 * flag will be set. 
 */


/*
 * pixel format is YUV - YUV data in pixel format struct is valid
 */


/*
 * pixel format is a z buffer only surface
 */


/*
 * The surface is 1-bit color indexed.
 */


/*
 * The surface is 2-bit color indexed.
 */


/*===========================================================================
 *
 *
 * DIRECTDRAW CALLBACK FLAGS
 *
 *
 *==========================================================================*/

/****************************************************************************
 *
 * DIRECTDRAW ENUMSURFACES FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate all of the surfaces that meet the search criterion.
 */


/*
 * A search hit is a surface that matches the surface description.
 */


/*
 * A search hit is a surface that does not match the surface description.
 */


/*
 * Enumerate the first surface that can be created which meets the search criterion.
 */


/*
 * Enumerate the surfaces that already exist that meet the search criterion.
 */



/****************************************************************************
 *
 * DIRECTDRAW ENUMDISPLAYMODES FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate Modes with different refresh rates.  EnumDisplayModes guarantees
 * that a particular mode will be enumerated only once.  This flag specifies whether
 * the refresh rate is taken into account when determining if a mode is unique.
 */



/****************************************************************************
 *
 * DIRECTDRAW SETCOOPERATIVELEVEL FLAGS
 *
 ****************************************************************************/

/*
 * Exclusive mode owner will be responsible for the entire primary surface.
 * GDI can be ignored. used with DD
 */


/*
 * allow CTRL_ALT_DEL to work while in fullscreen exclusive mode 
 */


/*
 * prevents DDRAW from modifying the application window.
 * prevents DDRAW from minimize/restore the application window on activation.
 */


/*
 * app wants to work as a regular Windows application
 */


/*
 * app wants exclusive access
 */



/*
 * app can deal with non-windows display modes
 */



/****************************************************************************
 *
 * DIRECTDRAW BLT FLAGS
 *
 ****************************************************************************/

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the destination surface as the alpha channel for this blt.
 */


/*
 * Use the dwConstAlphaDest field in the DDBLTFX structure as the alpha channel
 * for the destination surface for this blt.
 */


/*
 * The NEG suffix indicates that the destination surface becomes more
 * transparent as the alpha value increases. (0 is opaque)
 */


/*
 * Use the lpDDSAlphaDest field in the DDBLTFX structure as the alpha
 * channel for the destination for this blt.
 */


/*
 * Use the dwAlphaEdgeBlend field in the DDBLTFX structure as the alpha channel
 * for the edges of the image that border the color key colors.
 */


/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the source surface as the alpha channel for this blt.
 */


/*
 * Use the dwConstAlphaSrc field in the DDBLTFX structure as the alpha channel
 * for the source for this blt.
 */


/*
 * The NEG suffix indicates that the source surface becomes more transparent
 * as the alpha value increases. (0 is opaque)
 */


/*
 * Use the lpDDSAlphaSrc field in the DDBLTFX structure as the alpha channel
 * for the source for this blt. 
 */


/*
 * Do this blt asynchronously through the FIFO in the order received.  If
 * there is no room in the hardware FIFO fail the call.
 */


/*
 * Uses the dwFillColor field in the DDBLTFX structure as the RGB color
 * to fill the destination rectangle on the destination surface with.
 */


/*
 * Uses the dwDDFX field in the DDBLTFX structure to specify the effects
 * to use for the blt.
 */


/*
 * Uses the dwDDROPS field in the DDBLTFX structure to specify the ROPS
 * that are not part of the Win32 API.
 */


/*
 * Use the color key associated with the destination surface.
 */


/*
 * Use the dckDestColorkey field in the DDBLTFX structure as the color key
 * for the destination surface.
 */


/*
 * Use the color key associated with the source surface.
 */


/*
 * Use the dckSrcColorkey field in the DDBLTFX structure as the color key
 * for the source surface.
 */


/*
 * Use the dwROP field in the DDBLTFX structure for the raster operation
 * for this blt.  These ROPs are the same as the ones defined in the Win32 API.
 */


/*
 * Use the dwRotationAngle field in the DDBLTFX structure as the angle
 * (specified in 1/100th of a degree) to rotate the surface.
 */


/*
 * Z-buffered blt using the z-buffers attached to the source and destination
 * surfaces and the dwZBufferOpCode field in the DDBLTFX structure as the
 * z-buffer opcode.
 */


/*
 * Z-buffered blt using the dwConstDest Zfield and the dwZBufferOpCode field
 * in the DDBLTFX structure as the z-buffer and z-buffer opcode respectively
 * for the destination.
 */


/*
 * Z-buffered blt using the lpDDSDestZBuffer field and the dwZBufferOpCode
 * field in the DDBLTFX structure as the z-buffer and z-buffer opcode
 * respectively for the destination.
 */


/*
 * Z-buffered blt using the dwConstSrcZ field and the dwZBufferOpCode field
 * in the DDBLTFX structure as the z-buffer and z-buffer opcode respectively
 * for the source.
 */


/*
 * Z-buffered blt using the lpDDSSrcZBuffer field and the dwZBufferOpCode
 * field in the DDBLTFX structure as the z-buffer and z-buffer opcode
 * respectively for the source.
 */


/*
 * wait until the device is ready to handle the blt
 * this will cause blt to not return DDERR_WASSTILLDRAWING
 */


/*
 * Uses the dwFillDepth field in the DDBLTFX structure as the depth value
 * to fill the destination rectangle on the destination Z-buffer surface
 * with.
 */



/****************************************************************************
 *
 * BLTFAST FLAGS
 *
 ****************************************************************************/






/****************************************************************************
 *
 * FLIP FLAGS
 *
 ****************************************************************************/




/****************************************************************************
 *
 * DIRECTDRAW SURFACE OVERLAY FLAGS
 *
 ****************************************************************************/

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the destination surface as the alpha channel for the
 * destination overlay.
 */


/*
 * Use the dwConstAlphaDest field in the DDOVERLAYFX structure as the
 * destination alpha channel for this overlay.
 */


/*
 * The NEG suffix indicates that the destination surface becomes more
 * transparent as the alpha value increases. 
 */


/*
 * Use the lpDDSAlphaDest field in the DDOVERLAYFX structure as the alpha
 * channel destination for this overlay.
 */


/*
 * Use the dwAlphaEdgeBlend field in the DDOVERLAYFX structure as the alpha
 * channel for the edges of the image that border the color key colors.
 */


/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the source surface as the source alpha channel for this overlay.
 */


/*
 * Use the dwConstAlphaSrc field in the DDOVERLAYFX structure as the source
 * alpha channel for this overlay.
 */


/*
 * The NEG suffix indicates that the source surface becomes more transparent
 * as the alpha value increases.
 */


/*
 * Use the lpDDSAlphaSrc field in the DDOVERLAYFX structure as the alpha channel
 * source for this overlay.
 */


/*
 * Turn this overlay off.
 */


/*
 * Use the color key associated with the destination surface.
 */


/*
 * Use the dckDestColorkey field in the DDOVERLAYFX structure as the color key
 * for the destination surface
 */


/*
 * Use the color key associated with the source surface.
 */


/*
 * Use the dckSrcColorkey field in the DDOVERLAYFX structure as the color key
 * for the source surface.
 */


/*
 * Turn this overlay on.
 */


/*
 * Add a dirty rect to an emulated overlayed surface.
 */


/*
 * Redraw all dirty rects on an emulated overlayed surface.
 */


/*
 * Redraw the entire surface on an emulated overlayed surface.
 */



/*
 * Use the overlay FX flags to define special overlay FX
 */



/****************************************************************************
 *
 * DIRECTDRAWSURFACE LOCK FLAGS
 *
 ****************************************************************************/

/*
 * The default.  Set to indicate that Lock should return a valid memory pointer
 * to the top of the specified rectangle.  If no rectangle is specified then a
 * pointer to the top of the surface is returned.
 */
// default

/*
 * Set to indicate that Lock should wait until it can obtain a valid memory
 * pointer before returning.  If this bit is set, Lock will never return 
 * DDERR_WASSTILLDRAWING.
 */


/*
 * Set if an event handle is being passed to Lock.  Lock will trigger the event
 * when it can return the surface memory pointer requested.
 */


/*
 * Indicates that the surface being locked will only be read from.
 */


/*
 * Indicates that the surface being locked will only be written to
 */



/****************************************************************************
 *
 * DIRECTDRAWSURFACE PAGELOCK FLAGS
 *
 ****************************************************************************/

/*
 * No flags defined at present
 */


/****************************************************************************
 *
 * DIRECTDRAWSURFACE PAGEUNLOCK FLAGS
 *
 ****************************************************************************/

/*
 * No flags defined at present
 */


/****************************************************************************
 *
 * DIRECTDRAWSURFACE BLT FX FLAGS
 *
 ****************************************************************************/

/*
 * If stretching, use arithmetic stretching along the Y axis for this blt.
 */


/*
 * Do this blt mirroring the surface left to right.  Spin the
 * surface around its y-axis.
 */


/*
 * Do this blt mirroring the surface up and down.  Spin the surface
 * around its x-axis.
 */


/*
 * Schedule this blt to avoid tearing.
 */


/*
 * Do this blt rotating the surface one hundred and eighty degrees.
 */


/*
 * Do this blt rotating the surface two hundred and seventy degrees.
 */


/*
 * Do this blt rotating the surface ninety degrees.
 */


/*
 * Do this z blt using dwZBufferLow and dwZBufferHigh as  range values
 * specified to limit the bits copied from the source surface.
 */


/*
 * Do this z blt adding the dwZBufferBaseDest to each of the sources z values
 * before comparing it with the desting z values.
 */


/****************************************************************************
 *
 * DIRECTDRAWSURFACE OVERLAY FX FLAGS
 *
 ****************************************************************************/

/*
 * If stretching, use arithmetic stretching along the Y axis for this overlay.
 */


/*
 * Mirror the overlay across the vertical axis
 */


/*
 * Mirror the overlay across the horizontal axis
 */


/****************************************************************************
 *
 * DIRECTDRAW WAITFORVERTICALBLANK FLAGS
 *
 ****************************************************************************/

/*
 * return when the vertical blank interval begins
 */


/*
 * set up an event to trigger when the vertical blank begins
 */


/*
 * return when the vertical blank interval ends and display begins
 */


/****************************************************************************
 *
 * DIRECTDRAW GETFLIPSTATUS FLAGS
 *
 ****************************************************************************/

/*
 * is it OK to flip now?
 */


/*
 * is the last flip finished?
 */


/****************************************************************************
 *
 * DIRECTDRAW GETBLTSTATUS FLAGS
 *
 ****************************************************************************/

/*
 * is it OK to blt now?
 */


/*
 * is the blt to the surface finished?
 */



/****************************************************************************
 *
 * DIRECTDRAW ENUMOVERLAYZORDER FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate overlays back to front.
 */


/*
 * Enumerate overlays front to back
 */


/****************************************************************************
 *
 * DIRECTDRAW UPDATEOVERLAYZORDER FLAGS
 *
 ****************************************************************************/

/*
 * Send overlay to front
 */


/*
 * Send overlay to back
 */


/*
 * Move Overlay forward
 */


/*
 * Move Overlay backward
 */


/*
 * Move Overlay in front of relative surface
 */


/*
 * Move Overlay in back of relative surface
 */


/*===========================================================================
 *
 *
 * DIRECTDRAW RETURN CODES
 *
 * The return values from DirectDraw Commands and Surface that return an HRESULT
 * are codes from DirectDraw concerning the results of the action
 * requested by DirectDraw.
 *
 *==========================================================================*/

/*
 * Status is OK
 *
 * Issued by: DirectDraw Commands and all callbacks
 */


/****************************************************************************
 *
 * DIRECTDRAW ENUMCALLBACK RETURN VALUES
 *
 * EnumCallback returns are used to control the flow of the DIRECTDRAW and
 * DIRECTDRAWSURFACE object enumerations.   They can only be returned by
 * enumeration callback routines.
 *
 ****************************************************************************/

/*
 * stop the enumeration
 */


/*
 * continue the enumeration
 */


/****************************************************************************
 *
 * DIRECTDRAW ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/

/*
 * This object is already initialized
 */


/*
 * This surface can not be attached to the requested surface.
 */


/*
 * This surface can not be detached from the requested surface.
 */


/*
 * Support is currently not available.
 */


/*
 * An exception was encountered while performing the requested operation
 */


/*
 * Generic failure.
 */


/*
 * Height of rectangle provided is not a multiple of reqd alignment
 */


/*
 * Unable to match primary surface creation request with existing 
 * primary surface.
 */


/*
 * One or more of the caps bits passed to the callback are incorrect.
 */


/*
 * DirectDraw does not support provided Cliplist.
 */


/*
 * DirectDraw does not support the requested mode
 */


/*
 * DirectDraw received a pointer that was an invalid DIRECTDRAW object.
 */


/*
 * One or more of the parameters passed to the callback function are
 * incorrect.
 */


/*
 * pixel format was invalid as specified
 */


/*
 * Rectangle provided was invalid.
 */


/*
 * Operation could not be carried out because one or more surfaces are locked
 */


/*
 * There is no 3D present.
 */


/*
 * Operation could not be carried out because there is no alpha accleration
 * hardware present or available.
 */



/*
 * no clip list available
 */


/*
 * Operation could not be carried out because there is no color conversion
 * hardware present or available.
 */


/*
 * Create function called without DirectDraw object method SetCooperativeLevel
 * being called.
 */


/*
 * Surface doesn't currently have a color key
 */


/*
 * Operation could not be carried out because there is no hardware support
 * of the dest color key.
 */


/*
 * No DirectDraw support possible with current display driver
 */


/*
 * Operation requires the application to have exclusive mode but the
 * application does not have exclusive mode.
 */


/*
 * Flipping visible surfaces is not supported.
 */


/*
 * There is no GDI present.
 */


/*
 * Operation could not be carried out because there is no hardware present
 * or available.
 */


/*
 * Requested item was not found
 */


/*
 * Operation could not be carried out because there is no overlay hardware
 * present or available.
 */


/*
 * Operation could not be carried out because there is no appropriate raster
 * op hardware present or available.
 */


/*
 * Operation could not be carried out because there is no rotation hardware
 * present or available.
 */


/*
 * Operation could not be carried out because there is no hardware support
 * for stretching
 */


/*
 * DirectDrawSurface is not in 4 bit color palette and the requested operation
 * requires 4 bit color palette.
 */


/*
 * DirectDrawSurface is not in 4 bit color index palette and the requested
 * operation requires 4 bit color index palette.
 */


/*
 * DirectDraw Surface is not in 8 bit color mode and the requested operation
 * requires 8 bit color.
 */


/*
 * Operation could not be carried out because there is no texture mapping
 * hardware present or available.
 */


/*
 * Operation could not be carried out because there is no hardware support
 * for vertical blank synchronized operations.
 */


/*
 * Operation could not be carried out because there is no hardware support
 * for zbuffer blting.
 */


/*
 * Overlay surfaces could not be z layered based on their BltOrder because
 * the hardware does not support z layering of overlays.
 */


/*
 * The hardware needed for the requested operation has already been
 * allocated.
 */


/*
 * DirectDraw does not have enough memory to perform the operation.
 */


/*
 * DirectDraw does not have enough memory to perform the operation.
 */


/*
 * hardware does not support clipped overlays
 */


/*
 * Can only have ony color key active at one time for overlays
 */


/*
 * Access to this palette is being refused because the palette is already
 * locked by another thread.
 */


/*
 * No src color key specified for this operation.
 */


/*
 * This surface is already attached to the surface it is being attached to.
 */


/*
 * This surface is already a dependency of the surface it is being made a
 * dependency of.
 */


/*
 * Access to this surface is being refused because the surface is already
 * locked by another thread.
 */


/*
 * Access to this surface is being refused because no driver exists
 * which can supply a pointer to the surface.
 * This is most likely to happen when attempting to lock the primary
 * surface when no DCI provider is present.
 */


/*
 * Access to Surface refused because Surface is obscured.
 */


/*
 * Access to this surface is being refused because the surface is gone.
 * The DIRECTDRAWSURFACE object representing this surface should 
 * have Restore called on it.
 */


/*
 * The requested surface is not attached.
 */


/*
 * Height requested by DirectDraw is too large.
 */


/*
 * Size requested by DirectDraw is too large --  The individual height and
 * width are OK.
 */


/*
 * Width requested by DirectDraw is too large.
 */


/*
 * Action not supported.
 */


/*
 * FOURCC format requested is unsupported by DirectDraw
 */


/*
 * Bitmask in the pixel format requested is unsupported by DirectDraw
 */


/*
 * vertical blank is in progress
 */


/*
 * Informs DirectDraw that the previous Blt which is transfering information
 * to or from this Surface is incomplete.
 */


/*
 * Rectangle provided was not horizontally aligned on reqd. boundary
 */


/*
 * The GUID passed to DirectDrawCreate is not a valid DirectDraw driver
 * identifier.
 */


/*
 * A DirectDraw object representing this driver has already been created
 * for this process.
 */


/*
 * A hardware only DirectDraw object creation was attempted but the driver
 * did not support any hardware.
 */


/*
 * this process already has created a primary surface
 */


/*
 * software emulation not available.
 */


/*
 * region passed to Clipper::GetClipList is too small.
 */


/*
 * an attempt was made to set a clip list for a clipper objec that
 * is already monitoring an hwnd.
 */


/*
 * No clipper object attached to surface object
 */


/*
 * Clipper notification requires an HWND or
 * no HWND has previously been set as the CooperativeLevel HWND.
 */


/*
 * HWND used by DirectDraw CooperativeLevel has been subclassed,
 * this prevents DirectDraw from restoring state.
 */


/*
 * The CooperativeLevel HWND has already been set.
 * It can not be reset while the process has surfaces or palettes created.
 */


/*
 * No palette object attached to this surface.
 */


/*
 * No hardware support for 16 or 256 color palettes.
 */


/*
 * If a clipper object is attached to the source surface passed into a
 * BltFast call.
 */


/*
 * No blter.
 */


/*
 * No DirectDraw ROP hardware.
 */


/*
 * returned when GetOverlayPosition is called on a hidden overlay
 */


/*
 * returned when GetOverlayPosition is called on a overlay that UpdateOverlay
 * has never been called on to establish a destionation.
 */


/*
 * returned when the position of the overlay on the destionation is no longer
 * legal for that destionation.
 */


/*
 * returned when an overlay member is called for a non-overlay surface
 */

 
/*
 * An attempt was made to set the cooperative level when it was already
 * set to exclusive.
 */


/*
 * An attempt has been made to flip a surface that is not flippable.
 */


/*
 * Can't duplicate primary & 3D surfaces, or surfaces that are implicitly
 * created.
 */


/*
 * Surface was not locked.  An attempt to unlock a surface that was not
 * locked at all, or by this process, has been attempted.
 */


/*
 * Windows can not create any more DCs
 */


/*
 * No DC was ever created for this surface.
 */


/*
 * This surface can not be restored because it was created in a different
 * mode.
 */


/*
 * This surface can not be restored because it is an implicitly created
 * surface.
 */


/*
 * The surface being used is not a palette-based surface
 */



/*
 * The display is currently in an unsupported mode
 */


/*
 * Operation could not be carried out because there is no mip-map
 * texture mapping hardware present or available.
 */


/*
 * The requested action could not be performed because the surface was of
 * the wrong type.
 */




/*
 * A DC has already been returned for this surface. Only one DC can be 
 * retrieved per surface.
 */


/*
 * The attempt to page lock a surface failed.
 */


/*
 * The attempt to page unlock a surface failed.
 */


/*
 * An attempt was made to page unlock a surface with no outstanding page locks.
 */


/*
 * An attempt was made to invoke an interface member of a DirectDraw object
 * created by CoCreateInstance() before it was initialized.
 */


/* Alpha bit depth constants */



};



#line 13 ".\winsys\ddrawpro.h"

/* ------------------------------------------------------------------------
   Defines and Compile Flags
   ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------
   Enums
   ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------
   Typedefs
   ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------
   Macros   
   ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------
   Prototypes
   ------------------------------------------------------------------------ */

extern "C" {


void    DDCleanup               ( void );
void    DDDrawBuffer            ( PCHAR pchBuf );
void    DDEraseScreen           ( void );
HRESULT DDFlipScreen            ( LPDIRECTDRAWSURFACE lpDDSFlip );
HRESULT DDFlipSurface           ( void );
HDC	  DDGetDC					  ( BOOL fBack );
DWORD	  DDGetSurfaceWidth		  ( void );
BOOL    DDInitialize            ( HWND hwndMain, BOOL fGDI );
HRESULT DDLockSurface           ( PCHAR *ppchBuf, long *pViewWidth );
BOOL	  DDRealizePalette		  ( void );
void	  DDReleaseDC				  ( HDC hdc );
BOOL    DDRestoreSurfaces       ( void );
HRESULT DDSetDisplayMode        ( BOOL fHigh );
HRESULT DDUnlockSurface         ( PCHAR pchBuf );


}

// _DDRAWPRO_H
#line 14 ".\winsys\ddraw.cpp"


extern "C" {
extern HDC		gdcScreen;
}

extern "C" HRESULT  __stdcall  DDAttachedCallback( LPDIRECTDRAWSURFACE lpDDSurface, 
                                       LPDDSURFACEDESC lpDDSurfaceDesc, 
														LPVOID lpContext );

extern "C"
{
typedef struct pal
{
  WORD Version;
  WORD NumberOfEntries;
  PALETTEENTRY aEntries[256];
} pal;
extern pal LogicalPalette;
}



 // -- local direct draw items
LPDIRECTDRAW            lpDD                    =  0 ;   // DirectDraw object 
LPDIRECTDRAWSURFACE     lpDDSPrimary    =  0 ;   // DirectDraw primary surface 
LPDIRECTDRAWSURFACE     lpDDSBack1              =  0 ;   // DirectDraw back surface 
LPDIRECTDRAWSURFACE     lpDDSBack2              =  0 ;   // DirectDraw GDI surface 
LPDIRECTDRAWPALETTE     lpDDPPalette    =  0 ;   // DirectDraw palette 

static BOOL    fUsingGDI       =  0 ;
static HWND    hwndAppDD       =  0 ;
static DWORD   dwFillColor     = 0;
static HRESULT ddrvalG         = 0;
static USHORT  usNum           = 0;
static HDC		hdcSurface		 =  0 ;



extern "C" HRESULT  __stdcall  DDAttachedCallback( 
	LPDIRECTDRAWSURFACE lpDDSurface, 
    LPDDSURFACEDESC /* lpDDSurfaceDesc */ , 
    LPVOID /* lpContext */ )
{
   if (  0  == lpDDSBack1 )
	   lpDDSBack1 = lpDDSurface;
   else
      lpDDSBack2 = lpDDSurface;

   return (  1  );
} // DDAttachedCallback 




//--------------------------------------------------------------------------
//
//  void DDCleanup
//
//  Description:
//              Clean up all DirectDraw items.
//
//  Arguments:
//              none
//
//  Return none
//
//--------------------------------------------------------------------------
extern "C" {
void DDCleanup( void )
{
         // -- make sure GDI surface is in front
   if ( lpDD !=  0  )
   {
            (lpDD)->lpVtbl->RestoreDisplayMode(lpDD) ;
            (lpDD)->lpVtbl->SetCooperativeLevel(lpDD, hwndAppDD, 0x00000008l) ;
            (lpDD)->lpVtbl->FlipToGDISurface(lpDD) ;
   }

         // -- release all DD buffers with the front buffer
   if( lpDDSPrimary !=  0  )
		 (lpDDSPrimary)->lpVtbl->Release(lpDDSPrimary) ;
       
   if( lpDDSBack2 !=  0  )
       (lpDDSBack2)->lpVtbl->Release(lpDDSBack2) ;
       
      
        // -- release the palette
   if( lpDDPPalette !=  0  )
       (lpDDPPalette)->lpVtbl->Release(lpDDPPalette) ;

        // -- release DirectDraw itself        
   if( lpDD !=  0  )
       (lpDD)->lpVtbl->Release(lpDD) ;

    // -- mark the cleanup effort
   lpDDSPrimary =  0 ;
   lpDDSBack1 =  0 ;
   lpDDSBack2 =  0 ;

   lpDDPPalette =  0 ;

   lpDD =  0 ;

//   SetWindowPos( hwndAppDD, HWND_NOTOPMOST, 0, 0, 
//                                           MAX_VIEW_WIDTH+GetSystemMetrics(SM_CXFRAME) * 2, 
//                                           MAX_VIEW_HEIGHT+GetSystemMetrics(SM_CYCAPTION) + GetSystemMetrics(SM_CYMENU) + (GetSystemMetrics(SM_CYFRAME) * 2), 
//                                           0 );

} // DDCleanup 
}




//--------------------------------------------------------------------------
//
//  void DDDrawBuffer
//
//  Description:
//              Draw the buffer to the DirectDraw surface and display.
//
//  Arguments:
//              pchBuf          - buffer to display
//
//  Return none
//
//--------------------------------------------------------------------------
extern "C" void DDDrawBuffer ( PCHAR pchBuf )
{
	int i;
   HRESULT ddrval;
   DDSURFACEDESC ddsd;
   RECT src;

   ddsd.dwSize = sizeof(DDSURFACEDESC);
                                         
    // -- we have an error here
   if (  0  == lpDDSBack1 )
           return;

   DDEraseScreen();

   if ( fUsingGDI &&  
                   (lpDDSBack2 !=  0 ) )
   {
		
      ddrval =  (lpDDSBack2)->lpVtbl->GetSurfaceDesc(lpDDSBack2,&ddsd) ;
		                               
      src.left = 0;
      src.top = 0;
      src.right = ddsd.dwWidth;
      src.bottom = ddsd.dwHeight;

       // -- Blt the GDI from the back to the middle buffer
      ddrval =  
                                       (lpDDSBack1)->lpVtbl->BltFast(lpDDSBack1,0,0,lpDDSBack2,&src,0x00000000 | 0x00000010) ;
   }

	 // -- Do the buffer part
   ddrval = DDLockSurface( (PCHAR *)&ddsd.lpSurface, &ddsd.lPitch );

	if ( ddrval ==  0  )
   {
		PCHAR lpS = (PCHAR) ddsd.lpSurface;
      PCHAR lpB = pchBuf;

        // -- copy buffer to back surface
      for ( i = 0; i <  480 ; i++ )
      {
		 	memcpy( lpS, lpB,  640  );
         lpS += ddsd.lPitch;
         lpB +=  640 ;
      }
	   DDUnlockSurface( (PCHAR) ddsd.lpSurface );
   }

} // DDDrawBuffer 




//--------------------------------------------------------------------------
//
//  void DDEraseScreen
//
//  Description:
//              Erase the DirectDraw screen in preparation for drawing.
//
//  Arguments:
//              none
//
//  Return none
//
//--------------------------------------------------------------------------
extern "C" void DDEraseScreen ( void )
{
    DDBLTFX     ddbltfx;
    HRESULT     ddrval;

        if (  0  == lpDDSBack1 )
                return;
        
    // Erase the background
    ddbltfx.dwSize = sizeof( ddbltfx );
    ddbltfx.dwFillColor = dwFillColor;

    while (  1  )
    {
      ddrval =  
                               (lpDDSBack1)->lpVtbl->Blt(lpDDSBack1,0,0,0,0x00000400l | 0x01000000l,&ddbltfx) ;

      if( ddrval ==  0  )
      {
			break;
      }
		if( ddrval ==  ((HRESULT) (((unsigned long)(1)<<31) | ((unsigned long)(0x876)<<16) | ((unsigned long)(450))) )  )
      {
			if( !DDRestoreSurfaces() )
				return;
      }
      if( ddrval !=  ((HRESULT) (((unsigned long)(1)<<31) | ((unsigned long)(0x876)<<16) | ((unsigned long)(540))) )  )
      {
			return;
      }
    } // while TRUE 

} // DDEraseScreen 




//--------------------------------------------------------------------------
//
//  void DDFlipScreen
//
//  Description:
//              Flip the DirectDraw screen.
//
//  Arguments:
//              none
//
//  Return none
//
//--------------------------------------------------------------------------
extern "C" HRESULT DDFlipScreen( LPDIRECTDRAWSURFACE lpDDSFlip )
{
   HRESULT     ddrval;

   if (  0  == lpDDSPrimary )
		return (  0x80004005L  );

    // Flip the surfaces
   while (  1  )
   {
		ddrval =  (lpDDSPrimary)->lpVtbl->Flip(lpDDSPrimary,lpDDSFlip,0x00000001l) ;

      if ( ddrval ==  0  )
      {
			break;
      }
      if ( ddrval ==  ((HRESULT) (((unsigned long)(1)<<31) | ((unsigned long)(0x876)<<16) | ((unsigned long)(450))) )  )
      {
			if( !DDRestoreSurfaces() )
         {
				break;
         }
      }
	   if ( ddrval !=  ((HRESULT) (((unsigned long)(1)<<31) | ((unsigned long)(0x876)<<16) | ((unsigned long)(540))) )  )
      {
		   break;
      }
	} // while TRUE 

	return ( ddrval );

} // DDFlipScreen 




//--------------------------------------------------------------------------
//
//  void DDFlipSurface
//
//  Description:
//              Flip the DirectDraw screen.
//
//  Arguments:
//              none
//
//  Return none
//
//--------------------------------------------------------------------------
extern "C" HRESULT DDFlipSurface( void )
{
	LPDIRECTDRAWSURFACE lpDDSFlip =  0 ;

   if ( fUsingGDI )
		lpDDSFlip = lpDDSBack1;

   return ( DDFlipScreen( lpDDSFlip ) );

} // DDFlipSurface 




//--------------------------------------------------------------------------
//
//  BOOL DDGetDC
//
//  Description:
//		Return an HDC for the surface.
//
//  Arguments:
//		fBack		- if TRUE, get the back buffer, else the front
//
//  Return an HDC for the surface
//
//--------------------------------------------------------------------------
extern "C" HDC DDGetDC( BOOL fBack )
{
	if ( fBack )
		ddrvalG =  (lpDDSBack1)->lpVtbl->GetDC(lpDDSBack1,&hdcSurface) ;
	else
		ddrvalG =  (lpDDSPrimary)->lpVtbl->GetDC(lpDDSPrimary,&hdcSurface) ;

	if ( ddrvalG ==  0  )
		return ( hdcSurface );
	else
		return (  0  );
} // DDGetHdc 




//--------------------------------------------------------------------------
//
//  BOOL DDGetSurfaceWidth
//
//  Description:
//		Return the surface width of the primary surface.
//
//  Arguments:
//		none
//
//  Return surface width
//
//--------------------------------------------------------------------------
extern "C" DWORD DDGetSurfaceWidth( void )
{
	DDSURFACEDESC dds;

	 (lpDDSPrimary)->lpVtbl->GetSurfaceDesc(lpDDSPrimary,&dds) ;

	return ( dds.dwWidth );
} // DDgetSurfaceWidth 




//--------------------------------------------------------------------------
//
//  BOOL DDInitialize
//
//  Description:
//              Initialize DirectDraw.
//
//  Arguments:
//              hwndMain        - handle of game window
//              fGDI            - do we need GDI also
//
//  Return TRUE if DirectDraw was initialized, else FALSE
//
//--------------------------------------------------------------------------
extern "C" BOOL DDInitialize ( HWND hwndMain, BOOL fGDI )
{
	BOOL fOK =  1 ;

    DDSURFACEDESC   ddsd;
    DDSCAPS         ddscaps;
	int rval;
        
         // -- Save the requested state information
        fUsingGDI = fGDI;
        hwndAppDD = hwndMain;

//      SetWindowPos( hwndMain, HWND_NOTOPMOST, 0, 0, GetSystemMetrics(SM_CXFULLSCREEN), 
//                                                              GetSystemMetrics(SM_CYFULLSCREEN), SWP_NOREDRAW  );

		// see if we are in 256 color mode
		rval = GetDeviceCaps(gdcScreen,  24 );
		if(rval == -1 || rval == 32767)
			return  0 ;

         // --
         // -- Create the Direct Draw object
         // --
        usNum = 0;
		printf("before DirectDrawCreate( NULL, &lpDD, NULL )");
        ddrvalG = DirectDrawCreate(  0 , &lpDD,  0  );
		printf("after DirectDrawCreate( NULL, &lpDD, NULL )");

    if( ddrvalG !=  0  )
        {
                fOK =  0 ;
        DDCleanup();
                goto DDInitializeExit;
        }


         // --
         // -- Set the cooperative level
         // --
        usNum = 2;
        if ( fGDI )
        ddrvalG =  
//                                                              DDSCL_NORMAL );
                                                                (lpDD)->lpVtbl->SetCooperativeLevel(lpDD, hwndMain, 0x00000010l | 0x00000001l) ;
        else
		{
			printf("before IDirectDraw_SetCooperativeLevel");
	        ddrvalG =  
                                                                (lpDD)->lpVtbl->SetCooperativeLevel(lpDD, hwndMain, 0x00000010l | 0x00000001l) ;
			printf("after IDirectDraw_SetCooperativeLevel");
		}
    if( ddrvalG !=  0  )
        {
                fOK =  0 ;
        DDCleanup();
                goto DDInitializeExit;
        }


         // --
         // -- Set the mode to 640 by 480 by 8
         // --
        usNum = 3;
//      if ( !fGDI )
//      {
			printf("before DDSetDisplayMode");
                ddrvalG = DDSetDisplayMode(  1  ); 
			printf("after DDSetDisplayMode");
//      }
//      else
//      {
//              ddrvalG = IDirectDraw_SetDisplayMode( lpDD, 800, 600, 8 );
//      }
        if( ddrvalG !=  0  )
        {
                fOK =  0 ;
        DDCleanup();
                goto DDInitializeExit;
        }


         // --
     // -- Create the front and back surfaces
         // --
    memset( &ddsd, 0, sizeof( ddsd ) );
    ddsd.dwSize = sizeof( ddsd );
    ddsd.dwFlags =  0x00000001l  |  0x00000020l ;
    ddsd.ddsCaps.dwCaps =  0x00000200l  |
                           0x00000010l  |
                           0x00000008l ;
    ddsd.dwBackBufferCount = fGDI ? 2 : 1;

        usNum = 4;
	printf("before IDirectDraw_CreateSurface");
    ddrvalG =  (lpDD)->lpVtbl->CreateSurface(lpDD, &ddsd, &lpDDSPrimary, 0) ;
	printf("after IDirectDraw_CreateSurface");
    if( ddrvalG !=  0  )
        {
                fOK =  0 ;
        DDCleanup();
                goto DDInitializeExit;
        }


         // --
     // -- Get a pointer to the back buffer(s)
         // --
        usNum = 5;
        if ( !fGDI )
        {
                ddscaps.dwCaps =  0x00000004l ;
                ddrvalG =  
                                                                                                        (lpDDSPrimary)->lpVtbl->GetAttachedSurface(lpDDSPrimary,&ddscaps,&lpDDSBack1) ;
        if( ddrvalG !=  0  )
                {
                        fOK =  0 ;
                DDCleanup();
                        goto DDInitializeExit;
                }
        }
        else 
        {
                ddrvalG =  
                                                                                                                                (lpDDSPrimary)->lpVtbl->EnumAttachedSurfaces(lpDDSPrimary,0,DDAttachedCallback) ;

//              usNum = 6;
//          ddsd.dwFlags = DDSD_CAPS | DDSD_BACKBUFFERCOUNT;
//              ddsd.ddsCaps.dwCaps = DDSCAPS_FLIP;
//          ddsd.dwBackBufferCount = 1;
//          ddrvalG = IDirectDraw_CreateSurface( lpDD, &ddsd, &lpDDSBack2, NULL );
            if( ddrvalG !=  0  )
                {
                        fOK =  0 ;
                DDCleanup();
                        goto DDInitializeExit;
                }

//              usNum = 7;
//              ddrvalG = IDirectDrawSurface_AddAttachedSurface( lpDDSPrimary, lpDDSBack2 );
//          if( ddrvalG != DD_OK )
//              {
//                      fOK = FALSE;
//              DDCleanup();
//                      goto DDInitializeExit;
//              }
        }


         // --
         // -- Deal with Blting the GDI
         // --
        if ( fGDI )
        {
                DDSURFACEDESC ddsdesc;
                RECT src;

            ddsdesc.dwSize = sizeof( ddsdesc );
                usNum = 10;
                ddrvalG =  (lpDDSPrimary)->lpVtbl->GetSurfaceDesc(lpDDSPrimary,&ddsdesc) ;
                                        
                src.left = 0;
                src.top = 0;
                src.right = ddsdesc.dwWidth;
                src.bottom = ddsdesc.dwHeight;

                 // -- Blt the GDI from the front to the middle buffer
                usNum = 7;
                ddrvalG =  
                                                                                        (lpDDSBack1)->lpVtbl->BltFast(lpDDSBack1,0,0,lpDDSPrimary,&src,0x00000000 | 0x00000010) ;

                 // -- Flip to make the GDI copy the backmost buffer
                DDFlipScreen(  0  );
        }

         // -- Get everything setup for sure
        usNum = 11;
    if( !DDRestoreSurfaces() )
        {
                fOK =  0 ;
                DDCleanup();
                goto DDInitializeExit;
        }


         // --
         // -- Cleanup and leave
         // --
DDInitializeExit:

        return ( fOK );
} // DDInitialize 




//--------------------------------------------------------------------------
//
//  HRESULT DDLockSurface
//
//  Description:
//              Attempt to lock the DirectDraw surface memory.
//
//  Arguments:
//              ppchBuf         - pointer to address of screen buffer
//              pViewWidth      - return the pitch of the surface memory
//
//  Return HRESULT from DirectDraw
//
//--------------------------------------------------------------------------
extern "C" HRESULT DDLockSurface( PCHAR *ppchBuf, long *pViewWidth )
{
   DDSURFACEDESC ddsdesc;
   HRESULT ddrval =  0 ;

    // -- pre-initialize stuff
   ddsdesc.dwSize = sizeof(DDSURFACEDESC);
   (*ppchBuf) =  0 ;

   if (  0  == lpDDSBack1 )
		return (  ((HRESULT) (((unsigned long)(1)<<31) | ((unsigned long)(0x876)<<16) | ((unsigned long)(450))) )  ); 


    // -- lock the surface drawing area
	while (  1  )
   {
      ddrval =  
					                  (lpDDSBack1)->lpVtbl->Lock(lpDDSBack1,0,&ddsdesc,0x00000000L | 0x00000001L,0) ;

      if( ddrval ==  0  )
      {
			break;
      }
      if( ddrval ==  ((HRESULT) (((unsigned long)(1)<<31) | ((unsigned long)(0x876)<<16) | ((unsigned long)(450))) )  )
      {
         if( !DDRestoreSurfaces() )
				break;
      }
      if ( ddrval !=  ((HRESULT) (((unsigned long)(1)<<31) | ((unsigned long)(0x876)<<16) | ((unsigned long)(540))) )  )
      {
			break;
      }

		if ( GetAsyncKeyState(  0x73  ) & 0x8000 )
			break;
	} // while TRUE 

   if (  0  == ddrval )
   {
		(*ppchBuf) = (PCHAR) ddsdesc.lpSurface;
      (*pViewWidth) = ddsdesc.lPitch;
   }

	return ( ddrval );
} // DDLockSurface 




//--------------------------------------------------------------------------
//
//  BOOL DDRealizePalette
//
//  Description:
//              Deal with the new palette,
//
//  Arguments:
//              none
//
//  Return none
//
//--------------------------------------------------------------------------
extern "C" BOOL DDRealizePalette( void )
{
	HRESULT ddrval;

   if( lpDDPPalette !=  0  )
	{
		 // -- we must make sure the reference count gets decremented
		 // --  before we release the palette 
		 (lpDDSPrimary)->lpVtbl->SetPalette(lpDDSPrimary,0) ;

       (lpDDPPalette)->lpVtbl->Release(lpDDPPalette) ;
		lpDDPPalette =  0 ;
	}


    // -- Create and set the palette 
   ddrval =  
                            (lpDD)->lpVtbl->CreatePalette(lpDD, 0x00000004l | 0x00000040l, &LogicalPalette.aEntries[0], &lpDDPPalette, 0) ;

   if ( ddrval !=  0  )
       return (  0  );

    // -- Set the palette
	 (lpDDSPrimary)->lpVtbl->SetPalette(lpDDSPrimary,lpDDPPalette) ;

	return (  1  );
} // DDRealizePalette 




//--------------------------------------------------------------------------
//
//  BOOL DDReleaseDC
//
//  Description:
//		Release the HDC for the surface.
//
//  Arguments:
//		none
//
//  Returns: none
//
//--------------------------------------------------------------------------
extern "C" void DDReleaseDC( HDC hdc )
{
	 (lpDDSBack1)->lpVtbl->ReleaseDC(lpDDSBack1,hdc) ;
} // DDReleaseDC 




//--------------------------------------------------------------------------
//
//  BOOL DDRestoreSurfaces
//
//  Description:
//              Attempt to restore the DirectDraw surfaces.
//
//  Arguments:
//              none
//
//  Return TRUE if surfaces could be restored, else FALSE
//
//--------------------------------------------------------------------------
extern "C" BOOL DDRestoreSurfaces( void )
{
        HRESULT     ddrval;

    ddrval =  (lpDDSPrimary)->lpVtbl->Restore(lpDDSPrimary) ;
    if ( ddrval !=  0  )
        return (  0  );

	 return ( DDRealizePalette() );

    // set colorfill colors and color keys according to bitmap contents

        // -- CLR_INVALID will make palette 0's entry the transparent one
//    dwFillColor = DDColorMatch( lpScreen, CLR_INVALID );
//    
//    return ( TRUE );
} // DDRestoreSurfaces 




//--------------------------------------------------------------------------
//
//  HRESULT DDSetDisplayMode
//
//  Description:
//              Set the display mode.
//
//  Arguments:
//              fHigh   - if true, set high-res, else low-res
//
//  Return HRESULT from DirectDraw
//
//--------------------------------------------------------------------------
extern "C" HRESULT DDSetDisplayMode( BOOL fHigh )
{
	if ( fHigh )
		return (  (lpDD)->lpVtbl->SetDisplayMode(lpDD, 640, 480, 8)  );
	else
		return (  (lpDD)->lpVtbl->SetDisplayMode(lpDD, 320, 200, 8)  );
} // DDSetDisplayMode 




//--------------------------------------------------------------------------
//
//  HRESULT DDUlockSurface
//
//  Description:
//              Attempt to unlock the DirectDraw surface memory.
//
//  Arguments:
//              pchBuf          - address of screen buffer
//
//  Return HRESULT from DirectDraw
//
//--------------------------------------------------------------------------
extern "C" HRESULT DDUnlockSurface( PCHAR pchBuf )
{
	HRESULT ddrVal =  0 ;

	while (  1  )
	{
		 // -- unlock the drawing surface
		ddrVal =  (lpDDSBack1)->lpVtbl->Unlock(lpDDSBack1,pchBuf) ;

		if ( ddrVal ==  0  )
		{
			break;
		}

		if ( ddrVal ==  ((HRESULT) (((unsigned long)(1)<<31) | ((unsigned long)(0x876)<<16) | ((unsigned long)(450))) )  )
	   {
	      if( !DDRestoreSurfaces() )
			{
				break;
			}
	   }

		if( ddrVal !=  ((HRESULT) (((unsigned long)(1)<<31) | ((unsigned long)(0x876)<<16) | ((unsigned long)(540))) )  )
      {
			break;
      }
	} // while TRUE 

	return ( ddrVal );
} // DDUnlockSurface 

// DDraw.cpp
