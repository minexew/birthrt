/* ========================================================================
   Copyright (c) 1990,1996	Synergistic Software
   All Rights Reserved
   ========================================================================
   Filename: MAPAI.CPP
   Author:   Alan Clark & David Jackson

   ========================================================================
   Contains the following general functions:

		void DoNPCAdmin (void)
		BOOL DoNPCAction (void)

   ======================================================================== */

/* ------------------------------------------------------------------------
   Includes
   ------------------------------------------------------------------------ */
#ifdef _WINDOWS
#include <windows.h>
#endif

#include <stdio.h>
#include <string.h>
#include <stdarg.h>

#include "system.h"

#include "actnmenu.hxx"
#include "charsel.hxx"
#include "gamemap.hxx"
#include "gmenuenm.h"
#include "mapai.hxx"
#include "multimap.hxx"
#include "multiui.hxx"
#include "realm.hxx"
#include "report.hxx"
#include "sound.hxx"
#include "strmgr.h"
#include "strenum.h"
#include "playstat.hxx"
#include "regents.hxx"
#include "request.h"

#ifdef _WINDOWS
#include "winsys\mulplay.hxx"
#include "winsys\mono_c.h"
#endif



/* ------------------------------------------------------------------------
   Notes
   ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------
   Defines and Compile Flags
   ------------------------------------------------------------------------ */
#define	TEST_1		0
#define	TEST_2		0
#define	TEST_3		0
#define	TEST_4		0
#define	TEST_5		0
#define	TEST_6		0
#define	TEST_7		0
#define	TEST_8		0
#define	TEST_9		0
#define	TEST_10		0
#define	TEST_11		0
#define	TEST_12		0
#define	TEST_13		0
#define	TEST_14		0
#define	TEST_15		0
#define	TEST_16		0
#define	TEST_17		0
#define	TEST_18		0
#define	TEST_19		0
#define	TEST_20		0
#define	TEST_21		0
#define	TEST_22		0
#define	TEST_23		0
#define	TEST_24		0
#define	TEST_25		0
#define	TEST_26		0
#define	TEST_27		0
#define	TEST_28		0
#define	TEST_29		0
#define	TEST_30		0
#define	TEST_31		0
#define	TEST_32		0
#define	TEST_33		0
#define	TEST_34		0
#define	TEST_35		0
#define	TEST_36		0



#define D20TOPERCENT(a)		((mundane_descriptions)?(105-((a)*5)):(a))
#define PERCENTCHAR			((mundane_descriptions)?'%':0)

#define MUSTERINFO		0

#define MDBROWN			136

#define VIA_ROAD			1
#define ANY_WAY			2


#define NOAUTOMP           1

#define PERCENTCHAR			((mundane_descriptions)?'%':0)

#undef PURPLE_GRAD
#define PURPLE_GRAD				9

#undef RED_GRAD
#define RED_GRAD					3


/* ------------------------------------------------------------------------
   Macros
   ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------
   Prototypes
   ------------------------------------------------------------------------ */
void WarDeclared(REALM::REALM_TYPE who, REALM::REALM_TYPE onWhom, BOOL fSend);	// from actnmenu.cpp
static void RollNPCAction (LONG, LONG );
void IncNum (LONG lpNum, LONG);
void DecNum (LONG lpNum, LONG);
BOOL FindHolding (REALM::REALM_TYPE provrealm, REALM::REALM_TYPE placerealm, PROVINCE prov, LONG icon, LONG fMax);
BOOL CheckUnit2ndMoveBlocked(LONG iMovingUnit, PROVINCE iCurProv, PROVINCE iNewProv);
void DrawRoads_ (PROVINCE prov, LONG border);
void DisplayProcess (LONG mode, LONG color, LONG index1, LONG index2);
void UpdateUnitAndPlaceCount (void);
BOOL CheckNotWarded (LONG iMovingUnit, PROVINCE iNewProv, PROVINCE iOldProv);
void PaintOthersDiplomacy (LONG MenuCombo, LONG menuResponse);

#ifdef _WINDOWS
void DoMultiplayerDataIntegrityCheck (void);
#endif

extern "C" {
extern void SysForceCursor (void);
}

#ifdef _LOGCOMMENT
extern "C" void RandomLogComment ( char * szString );
extern "C" void RandomLogPrefix ( char * szString );
#endif



/* ------------------------------------------------------------------------
   Global Variables
   ------------------------------------------------------------------------ */
// debug strings, don't translate

#if defined (_LOGCOMMENT)
DEFINE_VECTOR_DATA(CSTRPTR,szAIMode) = {
	"ENTRENCH",
	"ECON_FTR","ECON_THF","ECON_PRST","ECON_WIZ",
	"BUILD_FTR","BUILD_THF","BUILD_PRST","BUILD_WIZ",
	"CTRL_FTR","CTRL_THF","CTRL_PRST","CTRL_WIZ",
	"DEFEND","RAID","WAR_MIN_FTR","WAR_MED_FTR","WAR_MAX_FTR","WAR_WIZ",
	"IRR_ANY","IRR_FTR","IRR_THF","IRR_PRST","IRR_WIZ",
	"ELF_ENTRENCH","BUILD_ELF","DEFEND_ELF","RAID_ELF","WAR_ELF",
	"DWARF_ENTRENCH","BUILD_DWARF","DEFEND_DWARF","RAID_DWARF","WAR_DWARF",
	"GOBBO_ENTRENCH","BUILD_GOBBO","DEFEND_GOBBO","RAID_GOBBO","WAR_GOBBO",
	"BUILD_SPIDER","RAID_SPIDER","WAR_SPIDER",
	"BUILD_GORGON","RAID_GORGON","WAR_GORGON","DEFEND_GORGON",
	"SCREW_BACK_BIGGER","SCREW_BACK_SMALLER",
	"INVEST" };
DEFINE_VECTOR_CLASS(CSTRPTR, szAIMode);
#endif


LONG		global_action_turn = 1;
LONG		prev_action_turn = 1;

DEFINE_VECTOR_DATA_S(UBYTE,RealmOrder,LAND_REALM_COUNT);
DEFINE_VECTOR_CLASS(UBYTE,RealmOrder);

DEFINE_MATRIX_DATA_S(UBYTE,fAllowed,3,ACTION_COUNT) = {  /*
 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 8 8
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 */
{1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
{1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1},
{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
};
DEFINE_MATRIX_CLASS_S(UBYTE, fAllowed, 3, ACTION_COUNT);

static PROVINCE				UnitProvince = NO_PROVINCE;
LONG				iCurrentRealmIndex;
static REALM::REALM_TYPE	TargetRealm = REALM::NO_COUNTRY;
PROVINCE				TargetProvince = NO_PROVINCE;
static PROVINCE	StartProvince = NO_PROVINCE;
USHORT			TargetPlace = 0;
USHORT 	StartPlace = 0;
USHORT			TargetUnit = 0;
static REALM::REALM_TYPE		TestTargetRealm = REALM::NO_COUNTRY;
static REALM::REALM_TYPE		TriggeredTargetRealm = REALM::NO_COUNTRY;
static USHORT	cGroups;
static LONG		strTargetProvince;
static LONG		timeCount=0;
static LONG		old_dist = 99999999;
static BOOL		fDoneOthersAction;
DEFINE_VECTOR_DATA_S(UBYTE,fProv,PROVINCE_COUNT);
DEFINE_VECTOR_CLASS(UBYTE, fProv);
//extern DECL_VECTOR_CLASS(CSTRPTR,szHoldType);
extern DECL_VECTOR_CLASS(GAME_STRING,gsHoldType);
LONG				BattleSync;

extern LONG			fControlMode;
extern int			reqSound;
extern DECL_VECTOR_CLASS(SHORT,province_tax);
extern SHORT	    fRoundOver;
extern SHORT		cProvHolds;
extern SHORT		cProvinces;
extern SHORT		cCastles;
extern SHORT		cOccupiedProv;
extern LONG			domain_power;
extern LONG			realm_tax;
extern LONG			realm_reg;
extern LONG			domain_maint;
extern LONG			troop_moves;
extern LONG			payroll;
extern LONG			payregency;
extern LONG			new_treasury;
extern LONG			prov_tax, prov_trade, prov_reg;
extern REALM::REALM_TYPE		CurrentRealm;
extern BOOL			fPlayerNeverDeclaredWar;
extern DIPLOMACY_DATA 	dData;
extern volatile BOOL	fAnyKeyChanged;
extern BOOL			fTutorialSelected;
extern BOOL			mundane_descriptions;
extern LONG			fOtherDipMP;
extern BOOL			fSyncPending;
extern int			iTTimeLimit;
extern LONG			WaitingCount;
extern LONG			WaitingWho;
extern LONG			WaitingWhen;
extern LONG			WaitingBar216ths;

/* ========================================================================
   Function    - 
   Description - do AI for all NPC realms
   Returns     -
   ======================================================================== */
void DoNPCAdmin (void)
{
	LONG	i, j, k, l, rlm, hr, fr, iUnit, roll, surplus;

	#ifdef _WINDOWS
	if ( IsMultiPlayer() )
		DoMultiplayerDataIntegrityCheck();
	#endif

	hr = HomeRealm;
	fr = fFinalRoll;
	for (i=REALM::FIRST_REALM; i<LAND_REALM_COUNT; ++i)		// clear the realm order list
		RealmOrder[i]=REALM::REALM_OUT_OF_RANGE;
	RealmOrder[0] = REALM::NO_COUNTRY;

	for (rlm=REALM::FIRST_REALM; rlm<LAND_REALM_COUNT; ++rlm)
	{
		run_timers();  		// cdb 11/27	// ABC: don't put in inner loops

	#ifdef _WINDOWS
       AMultiPlayer.LookForMessages();   //---- Update not specific messages
	#endif

	 	if (realm[rlm].mfExists())				// don't do destroyed realms
		{
	#ifdef _WINDOWS
			//---- Set next random Seed
			AMultiPlayer.NextSeed(__FILE__,__LINE__);
	#endif

			// don't do player realms in advanced or expert mode
			if (!realm[rlm].mfIsPlayerCtrl() || fControlMode == 0)
			{

				#if 0 //def _LOGCOMMENT // #1
				{
					char temp[100];
					sprintf ( temp, "DoNPCAdmin %d - %s  starting regency:%04d  treasury:%06d",
							1,
							realm[rlm].mfGetName(),
							realm[rlm].mfGetRegency(),
							realm[rlm].mfGetTreasury());
					RandomLogComment ( temp );
				}
				#endif

				HomeRealm = (REALM::REALM_TYPE)rlm;
				fFinalRoll = 999;
				cOccupiedProv = 0;
				cCastles = 0;
				cProvHolds = 0;
				realm_tax = 0;
				trade_routes = 0;
				domain_power = 0;
				cProvinces = 0;

				// give NPCs a little boost
				if ( !realm[rlm].mfIsPlayerCtrl() )
				{
					i = ( (game_difficulty == DIF_EASY)?5:((game_difficulty == DIF_MEDIUM)?10:15) ) * date;
					realm[rlm].mfAddTreasury(i);

					if (random(5)==0)						// 20% chance of 50GB boost
						realm[rlm].mfAddTreasury(500);
				}

				// get income and expenses for provinces
				for (i=1; i<PROVINCE_COUNT; ++i)
				{
					if (province[i].Realm == rlm) ++cProvHolds;

					province_tax[cProvinces] = -1;
					ProvinceInfo(i, CASTLE1_ICON);
					if (prov_castle>0) ++cCastles;
					if (prov_law>0)	 ++cProvHolds;
					if (prov_temple>0) ++cProvHolds;
					if (prov_guild>0)	 ++cProvHolds;
					if (province[i].OccupRealm==rlm) ++cOccupiedProv;

					if (province[i].Realm == rlm)
					{
						l = (province[i].Contested) ? 0 : LoyaltyAdj[province[i].TaxLevel];
						l -= (province[i].OccupRealm != 0);
						j = (province[i].OccupRealm==rlm) ? prov_units : prov_law;
						if (j >= province[i].CivLevel)		// all law available
						{
							if (l<0) ++l; if (l<0) ++l;
						}
						else if ((j*2)>=province[i].CivLevel)	// half of all law
						{
							if (l<0) ++l;
						}
						else											// less than half of law
						{
							l = NoLawLoyaltyAdj[province[i].TaxLevel] - (province[i].OccupRealm!=0);
						}

						#if 0 //def _LOGCOMMENT	// #2
						{
							char temp[100];
							sprintf ( temp, "DoNPCAdmin %d - %s:%s  prov_tax:%04d  prov_trade:%04d  prov_reg:%04d",
								2,
								realm[rlm].mfGetName(),
								province[i].name,
								prov_tax,
								prov_trade,
								prov_reg);
							RandomLogComment ( temp );
						}
						#endif
					}

					realm_tax += prov_tax;
					trade_routes += prov_trade;
					domain_power += prov_reg;
				}

				// calc payroll
				payroll = payregency = 0;
				if (rlm != REALM::MONSTERS				// monsters don't have payroll
					&& rlm != REALM::SPIDERFELL		// awnsheigh don't have payroll
					&& rlm != REALM::RHUOBHE			// 
					&& rlm != REALM::MARKAZOR			// 
					&& rlm != REALM::MURKILAD			// 
					&& rlm != REALM::GORGONSCROWN)	// 
				{
					for (i=1; i<MAX_UNITS; ++i)
					{
						// scan through units for leaders
						if (units[i].Realm == rlm && units[i].Joined == 0)
						{
							iUnit = i;
							while (iUnit != -1)		// list followers
							{
//								if (units[iUnit].Paid)
									payroll += UnitMaintCost[units[iUnit].Icon];
//								if (units[iUnit].Use_Regency)
//									payregency += UnitMaintCost[units[iUnit].Icon] * 5;
								iUnit = units[iUnit].NextUnit;
							}
						}
					}
				}

				if (cProvHolds > 100)
					domain_maint = (cProvHolds/3) + cCastles + cOccupiedProv + CourtCost[realm[rlm].mfGetCourt()];
				else
					domain_maint = MaintCost[cProvHolds] + cCastles + cOccupiedProv + CourtCost[realm[rlm].mfGetCourt()];

				//printf("  Maint - total:%d  MaintCost:%d  Castles:%d  OccProv:%d  Court:%d\n",domain_maint,MaintCost[cProvHolds],cCastles,cOccupiedProv,CourtCost[realm[rlm].mfGetCourt()]);
				realm_reg = MIN(domain_power,regents[realm[rlm].mfGetRegent()].mfGetBL_strength()) + realm[rlm].mfGetRegency() - payregency;
				//printf("  Regency - total:%d  oldRegency:%d  addRegency:%d  payregency:%d\n",realm_reg,realm[rlm].mfGetRegency(),MIN(domain_power,regents[realm[rlm].mfGetRegent()].BL_strength),payregency);

				//new_treasury = realm[rlm].mfGetTreasury() + ((realm_tax + law_holding_claims
				//		+ trade_routes - payroll - domain_maint)*10);
				realm[rlm].mfSetIncome(realm_tax + trade_routes - payroll - domain_maint);
				surplus =  realm[rlm].mfGetTreasury();
				new_treasury = realm[rlm].mfGetTreasury() + (realm[rlm].mfGetIncome() * 10);
				//printf("  Treas - total:%d  oldTreasury:%d  +realmTax:%d  +trade:%d  -payroll:%d  -maint:%d\n",new_treasury,realm[rlm].mfGetTreasury(),realm_tax*10,trade_routes*10,payroll*10,domain_maint*10);

				#if 0 //def _LOGCOMMENT	// #3
				{
					char temp[100];
					sprintf ( temp, "DoNPCAdmin %d - %s  realm_tax:%04d  trade:%04d  payroll:%04d  maint:%04d",
						3,
						realm[rlm].mfGetName(),
						realm_tax,
						trade_routes,
						payroll,
						domain_maint);
					RandomLogComment ( temp );
				}
				#endif

				if (new_treasury < 0)
				{
					if (((-new_treasury)*5) >= realm_reg)
					{
						// convert all regency to GB
						new_treasury += realm_reg / 5;
						realm_reg -= (realm_reg / 5) * 5;

						// disband troops troops to get to zero
						for (i=1; i<MAX_UNITS; ++i)
						{
							// scan through units for leaders
							if (units[i].Realm == rlm && UnitMaintCost[units[i].Icon])
							{
								new_treasury += UnitMaintCost[units[i].Icon];
								DeleteUnit(i,FALSE);
								if (new_treasury >= 0)
									break;
							}
						}
						if (new_treasury < 0) new_treasury = 0;
						printf("NPC ADMIN - %s is FLAT BROKE.\n",realm[rlm].mfGetName());
					}

					else		// buy treasury to a balanced level
					{
						realm_reg += new_treasury*5;
						new_treasury = realm_reg/10;		// make treasury positive by half of remaining regency
						realm_reg -= new_treasury*5;
					}
				}

				// monsters and five peaks don't collect regency
				if (rlm == REALM::MONSTERS || rlm == REALM::FIVEPEAKS) realm_reg = 0;

				realm[rlm].mfSetRegency(realm_reg);
				realm[rlm].mfSetTreasury(new_treasury);
				realm[rlm].mfSetSurplusIncome( (surplus > 0) ? surplus : 0);

				//printf("NPC ADMIN - %s regency:%d  treasury:%d\n",realm[rlm].name,realm[rlm].regency,realm[rlm].treasury);

				#if 0 //def _LOGCOMMENT	// #4
				{
					char temp[100];
					sprintf ( temp, "DoNPCAdmin %d - %s  regency:%04d  treasury:%06d",
							4,
							realm[rlm].mfGetName(),
							realm[rlm].mfGetRegency(),
							realm[rlm].mfGetTreasury());
					RandomLogComment ( temp );
				}
				#endif
			}

			// roll for this turn's order
			while (RealmOrder[(roll=random(LAND_REALM_COUNT))] != REALM::REALM_OUT_OF_RANGE) {}
			RealmOrder[roll] = rlm;

			#if 0 //def _LOGCOMMENT	// #5
			{
				char temp[100];
				sprintf ( temp, "DoNPCAdmin %d - %s is realm #%ld in the realm order\n",
					5,
					realm[rlm].mfGetName(),
					roll);
				RandomLogComment ( temp );
			}
			#endif
		}

	}	// for all realms

	#if 0 //def _LOGCOMMENT	// #6
	{
		char temp[100];
		sprintf ( temp, "DoNPCAdmin %d - Order for new turn:  ", 6);
		RandomLogComment ( temp );
		for (i=0; i<LAND_REALM_COUNT; ++i)
		{
			j = RealmOrder[i];
			if (j >= 0 && j < LAND_REALM_COUNT)
				sprintf ( temp, "             #%ld - %s",i,realm[RealmOrder[i]].mfGetName() );
			else
				sprintf ( temp, "             #%ld - %s",i,"unused" );
			RandomLogComment ( temp );
		}
	}
	#endif

	#ifdef _WINDOWS
	if ( IsMultiPlayer() )
		DoMultiplayerDataIntegrityCheck();
	#endif

	iCurrentRealmIndex = 0;		// start new turn

	HomeRealm = (REALM::REALM_TYPE)hr;
	fFinalRoll = fr;

}

/* ========================================================================
   Function    - 
   Description - 
   Returns     - 
   ======================================================================== */
LONG SpendNPCRegency (LONG realm_, LONG rp)
{
	LONG const oldregency = realm[realm_].mfGetRegency();
	LONG rv;

	rv = MIN(rp, oldregency);
	if (rv < 0)
	{
		rv = 0;
	}
	else
	{
		// see how much is actually successfully spent here
		LONG const newregency = realm[realm_].mfAddRegency(-rv);
		rv = oldregency - newregency;
	}

	//SetGameData(MP_REALM, MPRLM_REGENCY, realm_, realm[realm_].regency, TRUE);

	#if 0 //def _LOGCOMMENT	// #7
	{
		char temp[100];
		sprintf ( temp, "   SpendNPCRegency - %d %s spent:%d now:%d", 
			7,
			realm[realm_].mfGetName(),
			rp,
			realm[realm_].mfGetRegency());
		RandomLogComment ( temp );
	}
	#endif

	return rv;
}

/* ========================================================================
   Function    - 
   Description - 
   Returns     -
   ======================================================================== */
static LONG	RegencePoint;
static LONG	opp_modRegency;
static LONG	StartSuccess;

void DoneNPCAction (LONG, LONG)
{
	fDoneOthersAction = FALSE;

	if (RegencePoint > realm[HomeRealm].mfGetRegency())
		realm[HomeRealm].mfSetRegency(0);
	else
		realm[HomeRealm].mfAddRegency(-RegencePoint);

	//SetGameData(MP_REALM, MPRLM_REGENCY, HomeRealm, realm[HomeRealm].mfGetRegency(), TRUE);

	#if 0 //def _LOGCOMMENT	// #8
	{
		char temp[100];
		sprintf ( temp, "   DoneNPCAction - %d %s   Reg spent:%d   Reg now:%d", 
			8,
			realm[HomeRealm].mfGetName(),
			RegencePoint,
			realm[HomeRealm].mfGetRegency());
		RandomLogComment ( temp );
	}
	#endif

	del_region(RollNPCAction, 0);
	del_region(DoneNPCAction, 0);

	//SetButtonProc (D_MOREINFO, 0, PaintMoreInfo, 0, 0);
	//SetButtonProc (D_MOREINFO, 4, HideSubMenu, D_MOREINFO, 0);
	HideRequest(D_MOREINFO);

	RunMenus();
}

/* ========================================================================
   Function    - 
   Description - 
   Returns     -
   ======================================================================== */
static void RollNPCAction (LONG, LONG)
{
	if (RegencePoint+response[curResponse].modRegency > realm[HomeRealm].mfGetRegency())
	{
		AddSndObj((BIRTHRT_SND)SND_UI_NOT_ENOUGH_REGENCY,0,VOLUME_NINETY);
		return;
	}
	fDoneOthersAction = FALSE;
}

/* ========================================================================
   Function    - PaintNPCAction
   Description - 
   Returns     -
   ======================================================================== */
void PaintNPCAction (LONG MenuCombo, LONG)
{
	SHORT	i, j, m=-1;
	LONG	X,Y;
	LONG	W,H;
	LONG	MenuId, ButtonId;
	LONG	result = 0;
	LONG	startY;
	UBYTE	success;
	char FormatString[80];
	char actionBuffer[80];

	SPLIT_LONG(MenuCombo, MenuId, ButtonId);

	del_region(RollNPCAction, 0);
	del_region(DoneNPCAction, 0);
	del_region(IncNum,0);
	del_region(DecNum,0);
//	DeleteActnMenuRegions();
//	iThisRoll = -1;

	fAllowRollButton = TRUE;
	fAllowDoneButton = FALSE;

	// get position of text area
	if( GetButtonPosition( MenuId, 0, &X, &Y ) == fERROR)
		return;

	// get size of menu
	if( GetButtonSize( MenuId, 0, &W, &H ) == fERROR)
		return;

	startY = Y;

	init_gfont(FONT_SANS_8PT);

	// ---------------------------------
	// print body of menu here
	// ---------------------------------

	Y += 20;
	X += 20;
	switch ( response[curResponse].lWhichAction )
	{
		case ACTION_CONTEST_LAW:
			m = 0;
			break; 
		case ACTION_CONTEST_GLD:
			m = 1;
			break;
		case ACTION_CONTEST_TMP:
			m = 2;
			break;
		case ACTION_CONTEST_SRC:
			m = 3;
			break;
		default:
	 		break;
	}

	if (m >= 0 && (places[TargetPlace].Level == 0
			   		|| places[TargetPlace].Contested == TRUE) )
	{
		strcpy(FormatString, STRMGR_GetStr(STR_MAPAI_DESTROYING_HOLDING_FMT));
		print_textf(X+5,Y, DKBROWN, FormatString, realm[CurrentRealm].mfGetName(), STRMGR_GetStr(gsHoldType[m]), province[TargetProvince].name);
	}
	else
	{
		strcpy(FormatString,STRMGR_GetStr(STR_ACTNMENU_WHICH_ACTION_FMT));
		strcpy(actionBuffer, szAIAction[response[curResponse].lWhichAction].mfGetStr());
		print_textf(X+5,Y, DKBROWN, FormatString, realm[CurrentRealm].mfGetName(), actionBuffer, province[TargetProvince].name);
	}

	Y += 30;
	print_textf(X+5, Y, DKBROWN, STRMGR_GetStr(STR_ACTNMENU_F02_SUCCESS));
	print_textf(X+71, Y+6, DKBROWN, "^F02^c%d%c", D20TOPERCENT(response[curResponse].lSuccess+response[curResponse].modRegency),PERCENTCHAR);

	print_textf(X+110, Y, DKBROWN,   STRMGR_GetStr(STR_MAPAI_MODIFY_SUCCESS));
	print_textf(X+110, Y+8, DKBROWN, STRMGR_GetStr(STR_MAPAI_USING_REGENCY));
	SetupMod(X+200, Y, &response[curResponse].modRegency, 0, 20*((response[curResponse].lSuccess+response[curResponse].modRegency)<20), 1);

	//---- Only play the sounds once

	if (response[curResponse].lResult == 1)	// success
	{
		AddSndObj((BIRTHRT_SND)SND_UI_SUCCEEDED,0,VOLUME_NINETY);
		response[curResponse].lResult = 3;
	}
	if (response[curResponse].lResult == 2)	// failure
	{
 		AddSndObj((BIRTHRT_SND)SND_UI_DID_NOT_SUCCEED,0,VOLUME_NINETY);
		response[curResponse].lResult = 4;
	}

	//---- Now we can print the data 
	if ( response[curResponse].lResult == 3 )
	{
		fAllowRollButton = FALSE;
		fAllowDoneButton = TRUE;
		print_textf(X+130, Y + 20, RED, STRMGR_GetStr(STR_MAPAI_ACTION_SUCCEEDED));
	}

	if ( response[curResponse].lResult == 4 )
	{
		fAllowRollButton = FALSE;
		fAllowDoneButton = TRUE;
		print_textf(X+130, Y + 20, RED, STRMGR_GetStr(STR_MAPAI_ACTION_FAILED));
	}

	Y = startY+H-80;
	print_textf(X+5, Y, DKBROWN, STRMGR_GetStr(STR_MAPAI_TOTAL_COST_FMT), RegencePoint+response[curResponse].modRegency);

	Y = startY+H-65;
	print_textf(X+5, Y, DKBROWN,STRMGR_GetStr(STR_MAPAI_SPEND_REGENCY_HELP));

	// draw buttons
	init_gfont(FONT_TITL_10PT);
	Y = startY+H-32;

	if(fAllowRollButton)
		add_region(X+138, Y, 68, 28, 0, RollNPCAction, 0, 0, 0, -1);

	SHORT iButton = GetResourceStd ("UI\\REGBTN2A.PCX", FALSE);

	DrawBitmap (X+138-15, (SHORT)Y, iButton, 0, 0, 999, 999);
	print_textf(X+138+34-15, Y+14, (fAllowRollButton)?WHITE:GREY, "^F02^c%s", STRMGR_GetStr(STR_ROLL1));

	if(fAllowDoneButton)
		add_region(X+218, Y, 68, 28, 0, DoneNPCAction, 0, 0, 0, -1);

	DrawBitmap (X+218, (SHORT)Y, iButton, 0, 0, 999, 999);
	print_textf(X+218+34, Y+14, (fAllowDoneButton)?WHITE:GREY, "^F02^c%s", STRMGR_GetStr(STR_DONE1));

	if (iButton!=fERROR)
		SetPurge(iButton);
}


/* ========================================================================
   Function    - 
   Description - 
   Returns     - 
   ======================================================================== */
BOOL RollNPCSuccess (LONG action, BOOL * fSync, BOOL * fSend )
{
	LONG	success, additionalRP, addCur, addTar, tot_addCur, tot_addTar;
	LONG	rv = FALSE;

	*fSync = FALSE;
	*fSend = FALSE;

	success = StartSuccess = 16 - SpendNPCRegency(CurrentRealm, 15);

	//printf("CurrentRealm:%s action:%s TargetProv:%s TargetPlace:%d success:%d\n",
	//realm[CurrentRealm].name, szAIAction[action],
	//province[TargetProvince].name, TargetPlace, success);

	// find the realm of the target
	if (TargetPlace)
	{
 		TargetRealm = (REALM::REALM_TYPE)places[TargetPlace].Realm;	// get the realm from the holding..
	}
	else if (TargetProvince)
	{
		TargetRealm = (REALM::REALM_TYPE)province[TargetProvince].Realm;	// ..or province
	}
	else
		return TRUE;	// neither TargetPlace or TargetProvince is set

	// we don't oppose ourselves
	if (TargetRealm == CurrentRealm)
		return TRUE;

	// --------------------------------------------------------
	// Player is the target of the action, allow opposition
	// --------------------------------------------------------
	if (TargetRealm == HomeRealm)
	{
		*fSend = TRUE;
		*fSync = TRUE;

		push_regions();
		response[curResponse].lWhichAction = action;
		response[curResponse].lSuccess = success;
		response[curResponse].modRegency	= 0;
		modRegency = 0;
		RegencePoint = 0;
		opp_modRegency = 0;
		response[curResponse].lResult = 0;

		// do the dialog box
		SetButtonProc (D_MOREINFO, 0, PaintNPCAction, 0, 0);
		SetButtonProc (D_MOREINFO, 4, NULL, 0, 0);
		ShowRequest(D_MOREINFO, curResponse);

DoItAgain:
		response[curResponse].modRegency = modRegency = 0;
		SysForceCursor();
		fDoneOthersAction = TRUE;
		while (fDoneOthersAction)
			MenuLoop();

		RegencePoint += response[curResponse].modRegency;
		response[curResponse].lSuccess = success = StartSuccess - opp_modRegency + RegencePoint;
		//printf("RollNPCSuccess - start suc:%d  our RP:%d  Opp RP:%d  success:%d\n",StartSuccess,RegencePoint,opp_modRegency,success);

		if (response[curResponse].modRegency)
		{
			additionalRP = 0;
			switch (action)
			{
				case ACTION_AGITATE_FOE:
				case ACTION_AGITATE_OWN:
				case ACTION_RULE_LAW:
				case ACTION_RULE_GLD:
				case ACTION_RULE_TMP:
				case ACTION_RULE_SRC:
					if (random(100)<30 && success>10)
						additionalRP = SpendNPCRegency(CurrentRealm, random(10));
					break;

				case ACTION_CONTEST_LAW:
				case ACTION_CONTEST_GLD:
				case ACTION_CONTEST_TMP:
				case ACTION_CONTEST_SRC:
				case ACTION_CREATE_LAW:
				case ACTION_CREATE_GLD:
				case ACTION_CREATE_TMP:
				case ACTION_CREATE_SRC:
				case ACTION_LEYLINE:
				case ACTION_RULE_PROV:
				case ACTION_TRADEROUTE:
					if (random(100)<60 && success>10)
						additionalRP = SpendNPCRegency(CurrentRealm, random(success-1));
					break;

				case ACTION_INVESTITURE:
					if (success>5
						&&(	  (game_difficulty==DIF_EASY && random(100) < 65)
							||(game_difficulty==DIF_MEDIUM && random(100) < 75)
						    ||(game_difficulty==DIF_HARD && random(100) < 85)))
						additionalRP = SpendNPCRegency(CurrentRealm, success-1);
					break;
				
				case ACTION_ESPIONAGE_ASSASSIN:
					success = UnitMusterCost[units[TargetUnit].Icon]+1;
			}

			if (additionalRP)
			{
				//AddSndObj((BIRTHRT_SND)SND_UI_SUCCESS_MODIFIED_BY_OPPONENT,0,VOLUME_NINETY);
				AddSndObj((BIRTHRT_SND)(32362),0,VOLUME_NINETY);
				opp_modRegency += additionalRP;
				response[curResponse].lSuccess = success = StartSuccess - opp_modRegency + RegencePoint;
				response[curResponse].lResult = 0;
				goto DoItAgain;
			}
		}

		response[curResponse].modRegency = modRegency = 0;

		if (random(20) >= success)
		{
			rv = TRUE;
			response[curResponse].lResult = 1;
		}
		else
			response[curResponse].lResult = 2;

		SysForceCursor();
		fDoneOthersAction = TRUE;
		while (fDoneOthersAction)
			MenuLoop();

		#ifdef _WINDOWS
		if (IsMultiPlayer())
		{
			// can't xmit data until all have reached this point, put up wait box
			StartSync( iMPS_SYNC8 );
			CheckSync( iMPS_SYNC8, TRUE, TRUE );
		}
		#endif

		SetGameData(MP_REALM, MPRLM_REGENCY, HomeRealm, realm[HomeRealm].mfGetRegency(), TRUE);
		SetGameData(MP_REALM, MPRLM_REGENCY, CurrentRealm, realm[CurrentRealm].mfGetRegency(), TRUE);

		pop_regions();
		clear_key_status(0);
	}

	//------------------------------------------------
	// Some player is the target of the action
	// but on another, remote, machine.
	//------------------------------------------------
	#ifdef _WINDOWS
	else if (IsMultiPlayer() && realm[TargetRealm].mfIsPlayerCtrl())
	{
		// can't go on until all have reached this point, put up wait box
		//fSyncPending = TRUE;
		//ShowSyncWaitWindow( iMPS_SYNC8, 0 );
		//while (fSyncPending)
		//{
		//	MenuLoop();
		//	#ifdef _DEBUG
		//	LogFlush();
		//	#endif
		//}
		//AMultiPlayer.ResetSync( iMPS_SYNC8 );
		StartSync( iMPS_SYNC8 );
		CheckSync( iMPS_SYNC8, TRUE, TRUE );

		*fSync = TRUE;
		return FALSE;
	}
	#endif

	//------------------------------------------------
	// spend some more of both players regency here
	//------------------------------------------------
	else
	{
		tot_addCur = tot_addTar = 0;
		addCur = addTar = 1;
		success = StartSuccess;
		do
		{
			addTar = 0;
			if (addCur && random(100)<85 && success<14)
				addTar = SpendNPCRegency(TargetRealm, random(20-success));
			tot_addTar += addTar;
			success = StartSuccess - tot_addCur + tot_addTar;

			addCur = 0;
			if (addTar && random(100)<75 && success>7)
				addCur = SpendNPCRegency(CurrentRealm, random(success-1));
			tot_addCur += addCur;
			success = StartSuccess - tot_addCur + tot_addTar;
		}
		while (addCur || addTar);

		if (random(20) >= success)
			rv = TRUE;

		//printf("CurrentRealm:%s action:%s TargetRealm:%s TargetProv:%s TargetPlace:%d\n",
		//	realm[CurrentRealm].name, szAIAction[action],
		//	realm[TargetRealm].name, province[TargetProvince].name, TargetPlace);
		//printf("RollNPCSuccess - start suc:%d  TarRP:%d  CurRP:%d  success:%d\n",StartSuccess,tot_addTar,tot_addCur,success);
	}

	return rv;
}

/* ========================================================================
   Function    - IsBorder
   Description - 
   Returns     - returns TRUE if prov borders realm
   ======================================================================== */
#define ADJACENT			1
#define MY_ADJ_ALLYS		2

BOOL IsBorder (PROVINCE prov, REALM::REALM_TYPE realm, SHORT action, LONG purpose)
{
	LONG	i, j, testprov_border, testprov_borderrealm;

	for (i=0; i<7; ++i)
	{
		testprov_border = province[prov].Border[i].Province;
		testprov_borderrealm = province[testprov_border].Realm;

		if ( realm != REALM::ANY_REALM
			&&	(testprov_borderrealm == realm
					|| (AREALLIED(testprov_borderrealm,realm) && purpose==MY_ADJ_ALLYS) )
			&& (action == ACTION_DIPLMCY_DMD_PROV
					|| TerrainCost[province[prov].Border[i].MoveCost] < 100 )
			)
		{
			return TRUE;
		}

		if ( realm == REALM::ANY_REALM
				&& action == ACTION_MOVE_BORDER_OWN
				&& testprov_borderrealm != CurrentRealm
				&& !AREALLIED(testprov_borderrealm, CurrentRealm) )
			return TRUE;

		if (realm == REALM::ANY_REALM && testprov_borderrealm != CurrentRealm)
			return TRUE;
	}
	return FALSE;
}

/* ========================================================================
   Function    - UnitsHere
   Description - set count of groups (cGroups) and strTargetProvince
   Returns     - number of units of realm in prov
   ======================================================================== */
LONG UnitsHere (PROVINCE prov, REALM::REALM_TYPE realm)
{
	LONG	i, iUnit;
	LONG	cUnits = 0;

	cGroups = 0;
	strTargetProvince = 0;

	for (i=1; i<MAX_UNITS; ++i)
	{
		// scan through units for leaders
		if ( units[i].Joined==0 
			&& (units[i].Realm==realm || realm == REALM::ANY_REALM)
			&& UnitFinalProvince(i)==prov)
		{
			++cGroups;
			++cUnits;
			iUnit = i;

			if (units[iUnit].Icon <= C_WYV_UNIT_ICON)
			{
				strTargetProvince += UnitMusterCost[units[iUnit].Icon];
			}

			while (iUnit != -1)		// list followers
			{
				++cUnits;

				// GWP MORE HACKING HERE TOO, see note above.
				if (units[iUnit].Icon <= C_WYV_UNIT_ICON)
				{
					strTargetProvince += UnitMusterCost[units[iUnit].Icon];
				}
				iUnit = units[iUnit].NextUnit;
			}
		}
	}

	return cUnits;
}

/* ========================================================================
   Function    - UnitsHereNotUs
   Description - 
   Returns     - 
   ======================================================================== */
BOOL UnitsHereNotUs (PROVINCE prov)
{
	LONG	i, iUnit;
	LONG	cUnits = 0;

	for (i=1; i<MAX_UNITS; ++i)
	{
		// scan through units for leaders
		if ( units[i].Joined==0 
				&& !AREALLIED(units[i].Realm, CurrentRealm)
				&& UnitFinalProvince(i)==prov )
			return TRUE;
	}

	return FALSE;
}

/* ========================================================================
   Function    - 
   Description - 
   Returns     -
   ======================================================================== */
void Clear_fProv (void)
{
	LONG i;
	for (i=0; i<PROVINCE_COUNT; ++i)
		fProv[i] = FALSE;
}

/* ========================================================================
   Function    - 
   Description - 
   Returns     -
   ======================================================================== */
LONG ProvDist (LONG cur_prov, LONG dest_prov, LONG cProvDist, BOOL fTerrainDontCare)
{
	LONG	i, dx, dy, dist;
	LONG	test_prov;
	LONG	best_prov = 0;
	LONG	best_border = 0;
	LONG	min_dist = 99999999;

//printf("?");

	if (cProvDist==0)
		Clear_fProv();

	fProv[cur_prov] = TRUE;

	for (i=0; i<7; ++i)
	{
		test_prov = province[cur_prov].Border[i].Province;
		dx = province[dest_prov].x - province[test_prov].x;
		dy = province[dest_prov].y - province[test_prov].y;
		dist = (dx * dx) + (dy * dy);
		if (!fProv[test_prov] && dist < min_dist && (fTerrainDontCare || TerrainCost[province[cur_prov].Border[i].MoveCost] < 100))
		{
			min_dist = dist;
			best_prov = test_prov;
			best_border = i;
		}
	}

	// found a good province
	if (best_prov && best_prov != dest_prov)
		cProvDist = ProvDist(best_prov, dest_prov, cProvDist+1, fTerrainDontCare);

	return cProvDist;
}

/* ========================================================================
   Function    - 
   Description - 
   Returns     -
   ======================================================================== */
BOOL FindProvWithSrcTmp( PROVINCE prov, BOOL flag, LONG rqLevel)
{
	// if flag is true, find province with source, otherwise, find one with temple
	LONG t, c;

	CheckAndFixPlaces(prov);
	t = c = province[prov].FirstPlace;
	while (c != 0 && t>=0 && t<MAX_PLACES)
	{
		if (((flag && places[t].Icon == SOURCE1_ICON&& places[t].Level >= rqLevel)
		   ||(!flag && places[t].Icon == TEMPLE1_ICON && places[t].Level >= rqLevel)) 
		  && places[t].Realm == CurrentRealm)
			break;
		c = places[t].NextPlace;
		t = province[prov].FirstPlace + c;
	}
	if (c!=0)
	 	return TRUE;
	else 
		return FALSE;
}
/* ========================================================================
   Function    - 
   Description -  sub function to support FindProv for NPC Diplomacy
   Returns     -
   ======================================================================== */
LONG FindProvForDIP (PROVINCE prov, BOOL realm_flag, LONG base)
{
   LONG c, j;
   LONG t = 0;

   if ((realm_flag && province[prov].Realm != CurrentRealm)||(!realm_flag&&province[prov].Realm == CurrentRealm))
   {
		t = base;
		// there is a forein unit (if realm_flag == TRUE)
		// or there is a our unit (if realm_flag == FALSE)
	   for (c = 1; c < MAX_UNITS; ++c)
		{
	   	if ( ((!realm_flag && units[c].Realm == CurrentRealm)
					|| (realm_flag && units[c].Realm != CurrentRealm))
				&& UnitFinalProvince(c) == prov && units[c].Joined == 0)
	   	{
	   		t -= 20;
	   		break;
	   	}
		}

	  	// find a foreign castle or our castle if realm_flag == FALSE
		CheckAndFixPlaces(prov);
	  	j = c = province[prov].FirstPlace;
	  	while (c!=0)
	  	{
	  		if (((realm_flag && places[j].Realm != CurrentRealm)||(!realm_flag && places[j].Realm == CurrentRealm))
				 && places[j].Icon == CASTLE1_ICON)
	  		{
	  			t -= 10;
	  			break;
	  		}
	  		c = places[j].NextPlace;
	  		j = province[prov].FirstPlace+c;
	  	}

   	if ( province[prov].Terrain==FOREST
			|| province[prov].Terrain == SWAMP
			|| province[prov].Terrain == MOUNTN
			|| province[prov].Terrain == HILLS )
		{
   		if (realm_flag)
				t += 20;
			else
				t -= 20;
		}
   }

   return t;

}

/* ========================================================================
   Function    - 
   Description -  sub function to support FindProv for NPC Diplomacy
   Returns     -
   ======================================================================== */
BOOL OfferProvince()
{
   LONG i,t;
   LONG maxReaction=0;
   LONG pr=0;
   LONG base=100;
   for(i=1; i<PROVINCE_COUNT; ++i)
   {
   		t = FindProvForDIP((PROVINCE)i, FALSE, base);
		if(t==0)
			continue;
		t += random(10);
   		if(t > maxReaction)
   		{
   			maxReaction = t;
   			pr = i;
   		}
	}
	if (pr)			// if a province was selected
	{
		StartProvince = (PROVINCE)pr;
		return TRUE;
	}
	return FALSE;

}
/* ========================================================================
   Function    - 
   Description - 
   Returns     -
   ======================================================================== */
BOOL FindProv (SHORT action)
{
	LONG	i, t, c, s;
	LONG	maxReaction=0;
	LONG	j = 999;
	LONG	f = FALSE;
	LONG	pr = 0;

	for (i=1; i<PROVINCE_COUNT; ++i)
	{
		switch (action)
		{
			case ACTION_AGITATE_FOE:
				if( timeCount == 0 )
					f = (FindHolding(TargetRealm, CurrentRealm, (PROVINCE)i, 0, TRUE) 
									&& province[i].Loyalty == 1);
				else
					f = (FindHolding(TargetRealm, CurrentRealm, (PROVINCE)i, 0, TRUE)
									&& province[i].Loyalty == 2); 
				break;
			case ACTION_AGITATE_OWN:
				if( timeCount == 0 )
					f = (province[i].Realm == CurrentRealm && province[i].Loyalty == 0);
				else 
					f = (province[i].Realm == CurrentRealm && province[i].Loyalty == 1);
				
				break;

			//-----------------------------------------------
			// unit is chosen first. see UnitProvince
			//-----------------------------------------------
			case ACTION_MOVE_BORDER_FOE:
				if ((province[i].Realm == TargetRealm || TargetRealm == REALM::ANY_REALM)
						&& IsBorder((PROVINCE)i,CurrentRealm, action, MY_ADJ_ALLYS)
						&& i != UnitProvince )
					if ((c = UnitsHere((PROVINCE)i,CurrentRealm)) < j)	// find min units
					{
						j = c;
						pr = i;
					}
				break;

			case ACTION_MOVE_BORDER_OWN:
			case ACTION_MOVE_RETREAT:
				if ((province[i].Realm == CurrentRealm || AREALLIED(province[i].Realm,CurrentRealm))
						&& IsBorder((PROVINCE)i,TargetRealm, action, ADJACENT)
						&& i != UnitProvince )
					if ((c = UnitsHere((PROVINCE)i,CurrentRealm)) < j)	// find min units
					{
						j = c;
						pr = i;
					}
				break;

			case ACTION_MOVE_FILL_FOE:
			case ACTION_MOVE_FILL_OWN:
			case ACTION_MOVE_UNOCCUP_FOE:
			case ACTION_MOVE_UNOCCUP_OWN:
				if ( (province[i].Realm == TargetRealm || TargetRealm == REALM::ANY_REALM)
						&& i != UnitProvince )
					f = (UnitsHere((PROVINCE)i,CurrentRealm) == 0);		// find empty provs
				break;

			case ACTION_MOVE_REINFORCE_FOE:
			case ACTION_MOVE_REINFORCE_OWN:
				if ( (province[i].Realm == TargetRealm || TargetRealm == REALM::ANY_REALM)
						&& i != UnitProvince )
					if ((c = UnitsHere((PROVINCE)i,CurrentRealm)) < j)	// find min units
						if (c > 0)										// but not zero
						{
							j = c;
							pr = i;
						}
				break;

			//-----------------------------------------------
			// province is chosen first
			//-----------------------------------------------
			case ACTION_MOVE_ATTACK_FOE:
				if (province[i].Realm == TargetRealm || TargetRealm == REALM::ANY_REALM)
					f = UnitsHereNotUs((PROVINCE)i);		// find provs with enemy
				break;
			case ACTION_MOVE_ATTACK_OWN:
				if (province[i].Realm == CurrentRealm)
					f = UnitsHereNotUs((PROVINCE)i);		// find provs with enemy
				break;

	 		case ACTION_FORTIFY:
				f = (province[i].Realm == CurrentRealm
						&& !FindHolding(CurrentRealm, CurrentRealm, (PROVINCE)i, CASTLE1_ICON, FALSE)
					 	&& province[i].Realm == CurrentRealm
						&& IsBorder((PROVINCE)i, REALM::ANY_REALM, action, ADJACENT)
						&& !random(3));
				break;

			case ACTION_MUSTER_INF:
			case ACTION_MUSTER_EIN:
			case ACTION_MUSTER_BOW:
			case ACTION_MUSTER_IRR:
			case ACTION_MUSTER_PIK:
			case ACTION_MUSTER_LVY:
			case ACTION_MUSTER_SCT:
			case ACTION_MUSTER_KNT:
			case ACTION_MUSTER_CAV:
			case ACTION_MUSTER_MINF:
			case ACTION_MUSTER_MBOW:
			case ACTION_MUSTER_MIRR:
			case ACTION_MUSTER_MPIK:
			case ACTION_MUSTER_MCAV:
			case ACTION_MUSTER_EINF:
			case ACTION_MUSTER_EBOW:
			case ACTION_MUSTER_ECAV:
			case ACTION_MUSTER_DINF:
			case ACTION_MUSTER_DBOW:
			case ACTION_MUSTER_GINF:
			case ACTION_MUSTER_GBOW:
			case ACTION_MUSTER_GCAV:
			case ACTION_MUSTER_NINF:
			case ACTION_MUSTER_NIRR:
			case ACTION_MUSTER_CSKL:
				t = action - ACTION_MUSTER_INF + 1;
#if MUSTERINFO
if (province[i].LevyMustered >= province[i].CivLevel)
	printf("MUSTER FAILED - CivLevel limit in %s\n",province[i].name);
#endif
				if (province[i].Realm == CurrentRealm
					&& province[i].LevyMustered < province[i].CivLevel
					&& (c = UnitsHere((PROVINCE)i,CurrentRealm)) < j		// find min units
					&& province[i].CivLevel >= LevelUnitReqt[t]
//					&& (	(province[i].HumanPop	&& t>=A_INF_UNIT_ICON && t<=A_CAV_UNIT_ICON)
//						||	(province[i].ElfPop		&& t>=E_INF_UNIT_ICON && t<=E_CAV_UNIT_ICON)
//						||	(province[i].DwarfPop	&& t>=D_INF_UNIT_ICON && t<=D_BOW_UNIT_ICON)
//						||	(province[i].GoblinPop	&& t>=G_INF_UNIT_ICON && t<=G_CAV_UNIT_ICON)
//						||	(t>=M_INF_UNIT_ICON && t<=M_CAV_UNIT_ICON) )
					)
				{
					j = c;
					pr = i;
				}
				break;

			case ACTION_RSPELL_BLESSLAND:
				f = (province[i].Realm == CurrentRealm
						&& !province[i].Blessed
						&& !province[i].Dispel
						&& random(3)==0 
						&& FindProvWithSrcTmp((PROVINCE)i, 0, 1));

				break;
			case ACTION_RSPELL_BLIGHT:
				f = ((province[i].Realm == TargetRealm || TargetRealm == REALM::ANY_REALM) 
					 	&& !province[i].Blighted 
						&& !province[i].Dispel
						&& random(2)==0 
						&& FindProvWithSrcTmp((PROVINCE)i, 0, 3));

			case ACTION_RSPELL_DEMAGOGUE:
				f = ((province[i].Realm == TargetRealm || TargetRealm == REALM::ANY_REALM) 
					    && province[i].Loyalty 
						&& !province[i].Dispel
						&& random(2)==0 
						&& FindProvWithSrcTmp((PROVINCE)i, 1, 3));
						
				break;
			case ACTION_RSPELL_WARDING:
				f = (!province[i].Warded 
						&& (province[i].Realm == TargetRealm || TargetRealm == REALM::ANY_REALM)
						&& !province[i].Dispel
						&& random(4)==0 
						&& FindProvWithSrcTmp((PROVINCE)i, 1, 5));
					
				break;

			case ACTION_RSPELL_RAZE:
				f = (!province[i].Warded
						&& !province[i].Dispel
						&& FindProvWithSrcTmp((PROVINCE)i, 1, 5)
						&& FindHolding(REALM::ANY_REALM,TargetRealm,(PROVINCE)i,CASTLE1_ICON, TRUE));
		
				break;
			case ACTION_RSPELL_STRONGHOLD:
				if (!province[i].Dispel
						&& random(2) == 0
						&& FindProvWithSrcTmp((PROVINCE)i, 1, 7))
				{
					CheckAndFixPlaces((PROVINCE)i);
					t = c = province[i].FirstPlace;
					while (c != 0 && t>=0 && t<MAX_PLACES)
					{
						if (places[t].Icon == WIZTOWER_ICON && places[t].Realm == CurrentRealm)
							break;				 // if there is a wiztower, go to others
						c = places[t].NextPlace;
						t = province[i].FirstPlace + c;
					}
					if ( !c )
						f = TRUE;
				}
				break;
			
			case ACTION_RSPELL_SUMMONING:
			case ACTION_RSPELL_LEGIONOFTHEDEAD:
				f = (!province[i].Dispel
						&& random(2)==0
						&& FindProvWithSrcTmp((PROVINCE)i, 1, 3));
					
				break;

			case ACTION_RSPELL_BLESSARMY:
				f = (!province[i].Dispel
						&& random(2)==0 
						&& FindProvWithSrcTmp((PROVINCE)i, 0, 3));
				break;
					
			case ACTION_RSPELL_DEATHPLAGUE:
				f = (!province[i].Dispel
						&& random(2)==0 
						&& province[i].CivLevel
						&& (province[i].Realm == TargetRealm || TargetRealm == REALM::ANY_REALM)
						&& FindProvWithSrcTmp((PROVINCE)i, 1, 5));
					
				break;
		

			case ACTION_RULE_PROV:
				if (province[i].Realm == CurrentRealm
					&& (c = province[i].CivLevel) < j
					&&  c < 10)	// find min civ level
				{
					j = c;
					pr = i;
				}
				break;

		}

		if (f)		// if current province is selected
		{
			TargetProvince = (PROVINCE)i;
//printf("TPrv:%s ",province[TargetProvince].name);
			return TRUE;
		}
	}

	if (pr)			// if a province was selected
	{
		TargetProvince = (PROVINCE)pr;
//printf("TPrv:%s ",province[TargetProvince].name);
		return TRUE;
	}

	#if 0 //def _LOGCOMMENT	// #9
	{
		char temp[100];
		sprintf ( temp, "   FindProvince %d - Failed", 9 );
		RandomLogComment ( temp );
	}
	#endif

	return FALSE;
}

/* ========================================================================
   Function    - 
   Description - 
   Returns     -
   ======================================================================== */
BOOL FindUnit (REALM::REALM_TYPE realm_, LONG action)
{
	LONG	i, c, iUnit;
	LONG	j = 0;
	LONG	cUnits = 0;
	LONG	f = FALSE;
	LONG	u = 0;
	LONG	strTarget;
	LONG	min_dist = 99999999;
	PROVINCE	UnitProv;
	PROVINCE	up;

	for (i=1; i<MAX_UNITS; ++i)
	{
		// scan through units for leaders
		if (units[i].Realm == realm_ && units[i].Joined == 0)
		{
			UnitProv = UnitFinalProvince(i);

			switch (action)
			{
				case ACTION_MOVE_BORDER_FOE:
				case ACTION_MOVE_BORDER_OWN:
					UnitsHere(UnitProv, CurrentRealm);	// set cGroups
					if (!IsBorder(UnitProv, TargetRealm, 0, ADJACENT)
						//&& UnitProv != TargetProvince		// dont test vs TargetProvince
						&& cGroups > j)			// find max groups
						{
							j = c;
							u = i;
							up = UnitProv;
						}
					break;

				case ACTION_MOVE_FILL_FOE:
				case ACTION_MOVE_FILL_OWN:
				case ACTION_MOVE_REINFORCE_FOE:
				case ACTION_MOVE_REINFORCE_OWN:
				case ACTION_MOVE_UNOCCUP_FOE:
				case ACTION_MOVE_UNOCCUP_OWN:
					UnitsHere(UnitProv, CurrentRealm);	// set cGroups
					//if (UnitProv != TargetProvince && cGroups > j)		// dont test vs TargetProvince
					if (cGroups > j)			// find max groups
					{
						j = c;
						u = i;
						up = UnitProv;
					}
					break;

			case ACTION_MOVE_RETREAT:
					f = (province[UnitProv].Realm != CurrentRealm);
					up = UnitProv;
					break;

			case ACTION_MOVE_ATTACK_FOE:
			case ACTION_MOVE_ATTACK_OWN:
					strTarget = strTargetProvince;
					UnitsHere(UnitProv, CurrentRealm);
					if (strTargetProvince > strTarget				// big enough
						&& (c=ProvDist(UnitProv,TargetProvince,0,FALSE)) < min_dist )	// closest
					{
						min_dist = c;
						u = i;
						up = UnitProv;
					}
					break;
				 
	 		case ACTION_RSPELL_BLESSARMY:
					if (UnitProv == TargetProvince)
					{
						for (iUnit = i; iUnit > 0 && !u; iUnit = units[iUnit].NextUnit)
						  	u = (units[iUnit].Blessed == FALSE && random(2)==0)?iUnit:0;
						up = UnitProv;
					}
					break;

			case ACTION_RSPELL_MASSDESTRUCTION:
					if (FindProvWithSrcTmp(UnitProv, 1, 5))
					{
						for (iUnit = i; iUnit > 0 && !u; iUnit = units[iUnit].NextUnit)
						{
						  	u = (units[iUnit].Icon != GORGON_UNIT_ICON 
								 	&& units[iUnit].Icon != RHUOBHE_UNIT_ICON 
									&& random(4)==0
									&& iUnit != regents[realm[realm_].mfGetRegent()].mfGetunit()) 
									?iUnit:0;
							if (u)
								up = TargetProvince = UnitProv;
						}
					}
					break;

			case ACTION_ESPIONAGE_ASSASSIN:
					for (iUnit = i; iUnit > 0 && !u; iUnit = units[iUnit].NextUnit)
					{
					  	u = (random(6)==0
								&& units[iUnit].Icon < FIRST_CHARACTER_TYPE)?iUnit:0;
						if(u)
							up = TargetProvince = UnitProv;
					}
				 	break;
			}
		}

		if (f)		// if current unit is selected
		{
			TargetUnit = i;
			UnitProvince = up;
			//printf("TUnt:%d ",TargetUnit);
			return TRUE;
		}
	}

	if (u)			// if a unit was selected
	{
		TargetUnit = u;
		UnitProvince = up;
	//printf("TUnt:%d ",TargetUnit);
		return TRUE;
	}

	#if 0 //def _LOGCOMMENT	// #10
	{
		char temp[100];
		sprintf ( temp, "   FindUnit %d - Failed", 10 );
		RandomLogComment ( temp );
	}
	#endif

	return FALSE;
}

/* ========================================================================
   Function    - 
   Description - 
   Returns     -
   ======================================================================== */
BOOL FindNotHolding (REALM::REALM_TYPE realm_, LONG icon, BOOL fDontCare)
{
	LONG	i, j, k, c;

	for (i=1; i<PROVINCE_COUNT; ++i)
	{
		if (province[i].Realm == realm_ || fDontCare)
		{
			CheckAndFixPlaces((PROVINCE)i);
			j = k = province[i].FirstPlace; c=0;
			while (k != 0 && c++<PROVINCE_COUNT && j>=0 && j<MAX_PLACES)
			{
				if (places[j].Realm == realm_ && places[j].Icon == icon)
					break;
				k = places[j].NextPlace;
				j = province[i].FirstPlace + k;
			}
			if (k == 0)		// province without holding of type icon
			{
				TargetProvince = (PROVINCE)i;

				#if 0 //def _LOGCOMMENT	// #11
				{
					char temp[100];
					sprintf ( temp, "   FindNotHolding %d - succeeded; found province(k)=%d, limiter(c)=%d, j=%d, province(i)=%d",
						11,
						k,c,j,i );
					RandomLogComment ( temp );
				}
				#endif

				return TRUE;
			}
		}
	}

	#if 0 //def _LOGCOMMENT	// #12
	{
		char temp[100];
		sprintf ( temp, "   FindNotHolding %d - failed; found province(k)=%d, limiter(c)=%d, j=%d, province(i)=%d",
			12,
			k,c,j,i );
		RandomLogComment ( temp );
	}
	#endif

	return FALSE;
}

/* ========================================================================
   Function    - 
   Description - 
   Returns     -
   ======================================================================== */
BOOL FindHolding (REALM::REALM_TYPE provrealm, REALM::REALM_TYPE placerealm, PROVINCE prov, LONG icon, LONG fMax)
{
	LONG	i, j, k, c, tr, cnt;
	LONG	p = 0;
	LONG	h = 0;
	LONG	max = 0;
	LONG	min = 999;

	for (i=1; i<PROVINCE_COUNT; ++i)
	{
		if (prov == ANY_PROVINCE || i == prov)
		{
			if (province[i].Realm == provrealm || provrealm == REALM::ANY_REALM)
			{
				CheckAndFixPlaces((PROVINCE)i);
				j = k = province[i].FirstPlace; cnt = 0;
				while (k != 0 && cnt++<PROVINCE_COUNT && j>=0 && j<MAX_PLACES)
				{
					if (	((placerealm != REALM::ANY_REALM && places[j].Realm == placerealm) ||
							 (placerealm == REALM::ANY_REALM && provrealm != REALM::ANY_REALM && places[j].Realm != provrealm))
						&& (!icon || places[j].Icon == icon) )
					{
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// add variation
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!
						c = places[j].Level;

						if (icon == GUILD1_ICON)
						{
							c = province[i].CivLevel;
							tr = (places[j].iRoute1!=0)+(places[j].iRoute2!=0)+(places[j].iRoute3!=0);
							if (tr >= ((c+2)/3) )		// can't make more trade routes
								c = 0;
						}

						if (fMax && c > max)		// find max
						{
							max = c;
							p = i;
							h = j;
						}
						else if (fMax && icon == CASTLE1_ICON && c == 0)
							continue;	// don't do anything if the level of the castle is zero

						if (!fMax && c < min)		// find min
						{
							min = c;
							p = i;
							h = j;
						}
					}
					k = places[j].NextPlace;
					j = province[i].FirstPlace + k;
				}
			}
		}
	}

	if (h>0 && p>0 && p<PROVINCE_COUNT)
	{
		TargetProvince = (PROVINCE)p;
		TargetPlace = h;
		return TRUE;
	}

	#if 0 //def _LOGCOMMENT	// #13
	{
		char temp[100];
		sprintf ( temp, "   FindHolding %d - Failed",13 );
		RandomLogComment ( temp );
	}
	#endif

	return FALSE;
}

/* ========================================================================
   Function    - 
   Description - 
   Returns     -
   ======================================================================== */
BOOL CheckHoldLevels (PROVINCE prov, LONG icon)
{
	LONG	j, k, lvl, maxlvls, c;

	if (icon == SOURCE1_ICON)
		maxlvls = province[prov].MagLevel;
	else
		maxlvls = province[prov].CivLevel;
	lvl = 0;

	CheckAndFixPlaces(prov);
	j = k = province[prov].FirstPlace; c = 0;
	while (k != 0 && c++<PROVINCE_COUNT && j>=0 && j<MAX_PLACES)
	{
		if (places[j].Icon == icon)
			lvl += places[j].Level;
		k = places[j].NextPlace;
		j = province[prov].FirstPlace + k;
	}

	#if 0 //def _LOGCOMMENT	// #14
	if (lvl >= maxlvls);
	{
		char temp[100];
		sprintf ( temp, "   	CheckHoldLevels %d - Failed", 14 );
		RandomLogComment ( temp );
	}
	#endif

	return (lvl < maxlvls);
}

/* ========================================================================
   Function    - 
   Description - 
   Returns     -
   ======================================================================== */
BOOL FindDiffTerrain (LONG via)
{
	LONG	i, d, p = 0;
	LONG	terrain = province[StartProvince].Terrain;
	REALM::REALM_TYPE	realm_ = (REALM::REALM_TYPE)province[StartProvince].Realm;
	LONG	min = 999999;

	if (via == ANY_WAY)
	{
		for (i=1; i<PROVINCE_COUNT; ++i)
		{
			if (province[i].Realm == realm_ && province[i].Terrain != terrain)
			{
				d = ProvDist(StartProvince, i, 0, FALSE);
				if (d < min)
				{
					min = d;
					p = i;
				}
			}
		}

		if (p)
		{
			TargetProvince = (PROVINCE)p;
			return TRUE;
		}

		#if 0 //def _LOGCOMMENT	// #15
		{
			char temp[100];
			sprintf ( temp, "   FindDiffTerrain %d - Failed1", 15 );
			RandomLogComment ( temp );
		}
		#endif

		return FALSE;
	}


	// VIA_ROAD
	if (RecursiveRoadFollower(StartProvince) == FALSE)
	{

		#if 0 //def _LOGCOMMENT	// #16
		{
			char temp[100];
			sprintf ( temp, "   FindDiffTerrain %d - Failed2", 16 );
			RandomLogComment ( temp );
		}
		#endif

		return FALSE;
	}

	for (i=1; i<PROVINCE_COUNT; ++i)
	{
		if (iSelectedHolding[i][3]==TRUE
//			&& province[i].Realm == realm_
			&& province[i].Terrain != terrain)			// check for existing road
		{
			TargetProvince = (PROVINCE)i;
			return TRUE;
		}
	}

	#if 0 //def _LOGCOMMENT	// #17
	{
		char temp[100];
		sprintf ( temp, "   FindDiffTerrain %d - Failed3", 17 );
		RandomLogComment ( temp );
	}
	#endif

	return FALSE;
}

/* ========================================================================
   Function    - 
   Description - 
   Returns     -
   ======================================================================== */
BOOL CanAfford (LONG costGBNow, LONG costRegNow, LONG costGBPerTurn, REALM::REALM_TYPE realm_)
{
	BOOL	rv;

	if (realm_ == REALM::MONSTERS || realm_ == REALM::FIVEPEAKS)
		costRegNow = 0;

	// if more than 500 GB then don't worry about maintenance
	if (realm[realm_].mfGetTreasury() > 5000)
	{
		rv = (costGBNow <= (realm[realm_].mfGetTreasury()/10)
					&& costRegNow <= realm[realm_].mfGetRegency());

		#if 0 //def _LOGCOMMENT	// #18
		if (!rv)
		{
			char temp[100];
			sprintf ( temp, "   CanAfford %d - Failed1", 18 );
			RandomLogComment ( temp );
		}
		#endif

		return rv;
	}

	rv = (costGBNow <= (realm[realm_].mfGetTreasury()/10)
					&& costRegNow <= realm[realm_].mfGetRegency()
					&& costGBPerTurn <= (realm[realm_].mfGetSurplusIncome()/10));

	#if 0 //def _LOGCOMMENT	// #19
	if (!rv)
	{
		char temp[100];
		sprintf ( temp, "   CanAfford %d - Failed2", 19 );
		RandomLogComment ( temp );
	}
	#endif

	return rv;
}

/* ========================================================================
   Function    - 
   Description - 
   Returns     -
   ======================================================================== */
static void PayForIt (REALM::REALM_TYPE ThisRealm, LONG payGB, LONG payRegency, LONG AllocateSurplus)
{
	if (realm[ThisRealm].mfGetTreasury() < (payGB*10))
		realm[ThisRealm].mfSetTreasury(0);
	else
		realm[ThisRealm].mfAddTreasury(-(payGB*10));

	if (realm[ThisRealm].mfGetRegency() < payRegency)
		realm[ThisRealm].mfSetRegency(0);
	else
		realm[ThisRealm].mfAddRegency( -payRegency);

	//SetGameData(MP_REALM, MPRLM_REGENCY, ThisRealm, realm[ThisRealm].regency, TRUE);

	#if 0 //def _LOGCOMMENT	// #20
	{
		char temp[100];
		sprintf ( temp, "   PayForIt %d - %s  GB spent:%d  GB now (x10):%d   Reg spent:%d  Reg now:%d", 
					20,
					realm[ThisRealm].mfGetName(),
					payGB,
					realm[ThisRealm].mfGetTreasury(),
					payRegency,
					realm[ThisRealm].mfGetRegency());
		RandomLogComment ( temp );
	}
	#endif

	if (realm[ThisRealm].mfGetSurplusIncome() < (AllocateSurplus*10))
		realm[ThisRealm].mfSetSurplusIncome(0);
	else
		realm[ThisRealm].mfAddSurplusIncome(-(AllocateSurplus*10));
}

/* ========================================================================
   Function    - 
   Description - 
   Returns     -
   ======================================================================== */
BOOL BorderPermitted (REALM::REALM_TYPE source_realm, REALM::REALM_TYPE dest_realm, PROVINCE dest_prov)
{
	return ( dest_realm==source_realm
				|| dest_realm==REALM::MONSTERS
				|| dest_realm==REALM::ANUIRE
				|| source_realm==REALM::MONSTERS
				|| ISATWAR(source_realm, dest_realm)
				|| AREALLIED(source_realm, dest_realm)
				|| province[dest_prov].OccupRealm == source_realm );
}

/* ================================== */
BOOL npc_move_ (PROVINCE cur_prov)
{
	LONG	i, dx, dy, dist, cnt, l;
	REALM::REALM_TYPE test_realm;
	PROVINCE	test_prov;
	PROVINCE	best_prov = NO_PROVINCE;
	LONG	best_border = 0;
	LONG	border_cost = 0;
	LONG	min_dist = 99999999;
	BOOL	fTerrainPassable;
	BOOL	fBorderPermitted;
	BOOL	fSend = (CurrentRealm == HomeRealm);
	BOOL	rv;

	if (cur_prov == TargetProvince)			// already there
		return TRUE;

	fProv[cur_prov] = TRUE;

	// scan through borders of current province to find the best way to go
	for (i=0; i<7; ++i)
	{
		test_prov = (PROVINCE) province[cur_prov].Border[i].Province;
		test_realm = (REALM::REALM_TYPE)province[test_prov].Realm;
		dx = province[TargetProvince].x - province[test_prov].x;
		dy = province[TargetProvince].y - province[test_prov].y;
		dist = (dx * dx) + (dy * dy);

		border_cost = TerrainCost[province[cur_prov].Border[i].MoveCost];
		fTerrainPassable = (border_cost < 100);
		fBorderPermitted = BorderPermitted(CurrentRealm,test_realm,test_prov);

		//dist = dist * (border_cost + 2);		//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		dist = dist * (border_cost + 1);		//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

		//printf("%d:%d%d%d%d%d ",i,(dist<min_dist),(!fProv[test_prov]),fTerrainPassable,
		//	fBorderPermitted,(!CheckUnit2ndMoveBlocked(TargetUnit, cur_prov, test_prov)) );

		if (	dist < min_dist
				&& !fProv[test_prov]			// don't backtrack
				&& fTerrainPassable
				&& fBorderPermitted
				&& !CheckUnit2ndMoveBlocked(TargetUnit, cur_prov, test_prov)
				&& CheckNotWarded(TargetUnit, test_prov, cur_prov)
			)
		{
			min_dist = dist;
			best_prov = test_prov;
			best_border = i;
		}
	}

	// if player-controlled and we are walking away from destination then stop
	if (fSend && min_dist > old_dist)
	{
		reqSound = SND_UI_IMPASSABLE;
		return (units[TargetUnit].DestProvince != 0);
	}

	if (best_prov != NO_PROVINCE)		// found a good province
	{
		// check for afford
		cnt = 1;
		l = TargetUnit;
		while (units[l].NextUnit > 0)
		{
			++cnt;
			l = units[l].NextUnit;
		}

		border_cost = TerrainCost[province[cur_prov].Border[best_border].MoveCost];
		if (playerstats[realm[CurrentRealm].mfGetRegent()] != fERROR)
		{
			PTR_PLAYER_STATS pPS = (PTR_PLAYER_STATS)BLKPTR(playerstats[realm[CurrentRealm].mfGetRegent()]);
			border_cost += pPS->StatsMod.mfGetMod(STATSMOD::MOVECOST_MOD);
			if (border_cost < 0) border_cost = 0;
		}

		if ((border_cost * cnt) > realm[CurrentRealm].mfGetTreasury())
		{
			if (fSend) reqSound = SND_UI_NOT_ENOUGH_GOLD;

			#ifdef _LOGCOMMENT	// #21
			{
				char temp[100];
				sprintf ( temp, "   npc_move %d - Failed, could not afford  border:%d cnt:%d treas:%d", 
					21,
					border_cost, 
					cnt, 
					realm[CurrentRealm].mfGetTreasury());
				RandomLogComment ( temp );
			}
			#endif

			return FALSE;
		}

		if (units[TargetUnit].DestProvince==0)
			//units[TargetUnit].DestProvince = best_prov;
			SetGameData(MP_UNITS, MPUNITS_DESTPROVINCE, TargetUnit, best_prov, FALSE);
		else if (units[TargetUnit].DestPath1==0)
			//units[TargetUnit].DestPath1 = best_border+1;
			SetGameData(MP_UNITS, MPUNITS_DESTPATH1, TargetUnit, best_border+1, FALSE);
		else if (units[TargetUnit].DestPath2==0)
			//units[TargetUnit].DestPath2 = best_border+1;
			SetGameData(MP_UNITS, MPUNITS_DESTPATH2, TargetUnit, best_border+1, FALSE);
		else
			//units[TargetUnit].DestPath3 = best_border+1;
			SetGameData(MP_UNITS, MPUNITS_DESTPATH3, TargetUnit, best_border+1, FALSE);

		// pay for it
		realm[CurrentRealm].mfAddTreasury( -(TerrainCost[province[cur_prov].Border[best_border].MoveCost] * cnt));
		if (fSend)
			SetGameData(MP_REALM, MPRLM_TREASURY, CurrentRealm, realm[CurrentRealm].mfGetTreasury(), TRUE);

		if (best_prov == TargetProvince)		// we're there !!
			return TRUE;

		old_dist = min_dist;
		rv = npc_move_(best_prov);		// do next step

		if (fSend)							// if player-controlled
			return (units[TargetUnit].DestProvince != 0);  // true if any move

		//#ifdef _LOGCOMMENT
		//if (rv == FALSE)
		//{
		//	char temp[100];
		//	sprintf ( temp, "   npc_move - Failed, next step returned FALSE" );
		//	RandomLogComment ( temp );
		//}
		//#endif

		return rv;
	}

	#ifdef _LOGCOMMENT	// #22
	{
		char temp[100];
		sprintf ( temp, "   npc_move %d - Failed, no acceptable border", 22 );
		RandomLogComment ( temp );
	}
	#endif

	return FALSE;
}


/* ======================================================================== */
BOOL npc_move (PROVINCE cur_prov)
{
	LONG	i, dx, dy;
	BOOL	fSend = (CurrentRealm == HomeRealm);
	BOOL	retVal;

	if (cur_prov == NO_PROVINCE)
		cur_prov = (PROVINCE) UnitFinalProvince(TargetUnit);

	#ifdef _LOGCOMMENT // #23
	{
		char temp[120];
		if (fSend)
			sprintf ( temp, "npc_move %d - Player %s Move - TargetUnit:%d cur_prov:%s TargetProvince:%s",
				23,
				realm[CurrentRealm].mfGetName(), 
				TargetUnit, 
				province[cur_prov].name, 
				province[TargetProvince].name);
		else
			sprintf ( temp, "   npc_move %d - TargetUnit:%d cur_prov:%s TargetProvince:%s",
				TargetUnit, 
				province[cur_prov].name, 
				province[TargetProvince].name);
		RandomLogComment ( temp );
	}
	#endif


	// check for able to actually enter final province
	if ( !BorderPermitted(CurrentRealm, (REALM::REALM_TYPE)province[TargetProvince].Realm, TargetProvince) )
	{
		if ( CurrentRealm == HomeRealm )
			reqSound = SND_UI_YOU_CANNOT_CROSS_THAT_BORDER1;
		return FALSE;
	}

	if ( !CheckNotWarded(TargetUnit, TargetProvince, TargetProvince) )
	{
		if ( CurrentRealm == HomeRealm )
			reqSound = SND_UI_IMPASSABLE;
		return FALSE;
	}

	//units[TargetUnit].DestProvince = 0;
	SetGameData(MP_UNITS, MPUNITS_DESTPROVINCE, TargetUnit, 0, FALSE);
	//units[TargetUnit].DestPath1 = 0;
	SetGameData(MP_UNITS, MPUNITS_DESTPATH1, TargetUnit, 0, FALSE);
	//units[TargetUnit].DestPath2 = 0;
	SetGameData(MP_UNITS, MPUNITS_DESTPATH2, TargetUnit, 0, FALSE);
	//units[TargetUnit].DestPath3 = 0;
	SetGameData(MP_UNITS, MPUNITS_DESTPATH3, TargetUnit, 0, FALSE);
	//units[TargetUnit].MovePart = 0;
	SetGameData(MP_UNITS, MPUNITS_MOVEPART, TargetUnit, 0, FALSE);

	// calculate the current distance to the target province
	dx = province[TargetProvince].x - province[cur_prov].x;
	dy = province[TargetProvince].y - province[cur_prov].y;
	old_dist = (dx * dx) + (dy * dy);

	old_dist = old_dist * 4;	// equivalent to forest

	// call the actual lower level move, save the result
	retVal = npc_move_(cur_prov);

	// broadcast the new unit data
	#ifdef _WINDOWS
	if (fSend && IsMultiPlayer())
		AMultiPlayer.UnitMessage(TargetUnit, (UBYTE *)&units[TargetUnit]);
	#endif

	return retVal;
}

/* ========================================================================
   Function    - RecursiveRoadBuilder
   Description - build a road from cur_prov to TargetProvince
   Returns     - TRUE if successful
   ======================================================================== */
BOOL RecursiveRoadBuilder (PROVINCE cur_prov)
{
	LONG	i, dx, dy, dist;
	PROVINCE	test_prov;
	PROVINCE	best_prov = NO_PROVINCE;
	LONG	best_border = 0;
	LONG	min_dist = 99999999;

	for (i=0; i<7; ++i)
	{
		test_prov = (PROVINCE) province[cur_prov].Border[i].Province;
		dx = province[TargetProvince].x - province[test_prov].x;
		dy = province[TargetProvince].y - province[test_prov].y;
		dist = (dx * dx) + (dy * dy);
		if (dist < min_dist && TerrainCost[province[cur_prov].Border[i].MoveCost] < 100)
		{
			min_dist = dist;
			best_prov = test_prov;
			best_border = i;
		}
	}

	if (best_prov)		// found a good province
	{
		if (best_prov != TargetProvince)
			if (RecursiveRoadBuilder(best_prov) == FALSE)
				return FALSE;

		//!!!!!!!!!!!!!!!!!!!
		// check for afford
		// pay for it
		//!!!!!!!!!!!!!!!!!!!

		// build a road segment if not already built
		if (province[cur_prov].Border[best_border].MoveCost != PLAINS_ROAD
			&& province[cur_prov].Border[best_border].MoveCost != RIVER_ROAD)
		{
//printf("");
			SpendNPCRegency(CurrentRealm, 5);
			// set border one direction
			province[cur_prov].Border[best_border].MoveCost = PLAINS_ROAD;
			//SetGameData(MP_PROVINCE, MPPROV_BORDER0+best_border, cur_prov, PLAINS_ROAD, TRUE);
			DrawRoads_(cur_prov, best_border);

			// set border other direction
			for (i=0; i<7; ++i)
				if (province[best_prov].Border[i].Province == cur_prov)
				{
					province[best_prov].Border[i].MoveCost = PLAINS_ROAD;
					//SetGameData(MP_PROVINCE, MPPROV_BORDER0+i, best_prov, PLAINS_ROAD, TRUE);
					DrawRoads_(best_prov, i);
				}

			// draw the road the same way it's done in GAMEMAP.CPP
			//if (province[cur_prov].x < province[best_prov].x
			//	|| (province[cur_prov].x==province[best_prov].x
			//		&& province[cur_prov].y < province[best_prov].y))
			//	MapLine(province[cur_prov].x,province[cur_prov].y,province[best_prov].x,province[best_prov].y,MDBROWN,MDBROWN,TRUE);
			//else
			//	MapLine(province[best_prov].x,province[best_prov].y,province[cur_prov].x,province[cur_prov].y,MDBROWN,MDBROWN,TRUE);
		}
		return TRUE;
	}

	return FALSE;
}

/* ========================================================================
   Function    - 
   Description - 
   Returns     -
   ======================================================================== */
BOOL npc_traderoute (LONG place)
{
	if (places[place].Icon != GUILD1_ICON)
	{
		#if defined(_DEBUG)
		fatal_error("Error %s[%d] Wrong place to put a trade route.\n.", __FILE__, __LINE__);
		#else
		return FALSE;
		#endif
	}
	
	if (places[place].iRoute1==0)
	{
		places[place].iRoute1 = TargetProvince;
		//printf("NPC Trade Route - holding:%d iRoute1 from %s to %s\n",place,province[StartProvince].name,province[TargetProvince].name);
		return TRUE;
	}
	else if (places[place].iRoute2==0)
	{
		places[place].iRoute2 = TargetProvince;
		//printf("NPC Trade Route - holding:%d iRoute2 from %s to %s\n",place,province[StartProvince].name,province[TargetProvince].name);
		return TRUE;
	}
	else if (places[place].iRoute3==0)
	{
		places[place].iRoute3 = TargetProvince;
		//printf("NPC Trade Route - holding:%d iRoute3 from %s to %s\n",place,province[StartProvince].name,province[TargetProvince].name);
		return TRUE;
	}

	#ifdef _LOGCOMMENT	// #24
	{
		char temp[100];
		sprintf ( temp, "   npc_traderoute %d - Failed", 24 );
		RandomLogComment ( temp );
	}
	#endif

	return FALSE;
}

/* ========================================================================
   Function    - 
   Description - fSend - broadcast or not 
   Returns     -
   ======================================================================== */
void SetHelped (REALM::REALM_TYPE Target, REALM::REALM_TYPE Active, BOOL fSend )
{
	LONG	k;

	if (Target != Active)
	{
		if (RealmStatus[Target][Active] & 0x80)
		{
			RealmStatus[Target][Active] &= 0x7F;			// clear SCREWED flag
			SetGameData(MP_REALMSTATUS, Target, Active, RealmStatus[Target][Active], fSend);
		}
		else
		{
			k = RealmReaction[Target][Active] + (random(5)+1);	// 1% to 5% increase
			RealmReaction[Target][Active] = (k<150)?k:150;
			SetGameData(MP_REALMREACTION, Target, Active, RealmReaction[Target][Active], fSend);
			if (Target<LAND_REALM_COUNT)
			{
				k = RealmReaction[Active][Target] + (random(5)+1);	// 1% to 5% increase
				RealmReaction[Active][Target] = (k<150)?k:150;
				SetGameData(MP_REALMREACTION, Active, Target, RealmReaction[Active][Target], fSend);
			}
		}
	}
}

/* ========================================================================
   Function    - 
   Description - fSend - broadcast or not 
   Returns     -
   ======================================================================== */
void SetScrewed (REALM::REALM_TYPE Target, REALM::REALM_TYPE Active, BOOL fSend )
{
	LONG	k;

	if (Target != REALM::ANY_REALM && Target != Active)
	{
#if 0
		k = RealmReaction[Target][Active] - (random(5)+1);	// 1% to 5% reduction
		RealmReaction[Target][Active] = (k>0)?k:0;
		SetGameData(MP_REALMREACTION, Target, Active, RealmReaction[Target][Active], fSend);
		if (AREALLIED(Target,Active))		// if allied, trash alliance
		{
			RealmStatus[Target][Active]--;
			if (RealmStatus[Target][Active]<STATUS_NEUTRAL)
				RealmStatus[Target][Active]=STATUS_NEUTRAL;
			SetGameData(MP_REALMSTATUS, Target, Active, RealmStatus[Target][Active], fSend);

			if (Target<LAND_REALM_COUNT)
			{
				RealmStatus[Active][Target]--;
				if (RealmStatus[Active][Target]<STATUS_NEUTRAL)
					RealmStatus[Active][Target]=STATUS_NEUTRAL;
				SetGameData(MP_REALMSTATUS, Active, Target, RealmStatus[Active][Target], fSend);
			}
		}
		else										// if not, then set screwed
#endif
		{
			RealmStatus[Target][Active] |= 0x80;				// set SCREWED flag
			SetGameData(MP_REALMSTATUS, Target, Active, RealmStatus[Target][Active], fSend);
			if (Target<LAND_REALM_COUNT)
			{
				RealmStatus[Active][Target] &= 0x7F;			// clear recip. SCREWED flag
				SetGameData(MP_REALMSTATUS, Active, Target, RealmStatus[Active][Target], fSend);
			}
		}
	}
}

/* ======================================================================== */
BOOL TestInvaded (REALM::REALM_TYPE testRealm)
{
	LONG i, unit_test_prov;

	if (AREALLIED(CurrentRealm, testRealm))
		return FALSE;

	for (i=1; i<MAX_UNITS; ++i)							// test INVADED
	{
		if (units[i].Joined == 0 &&			// Only look at the leaders of stacks.
		    units[i].Realm == testRealm)
		{
			if (province[UnitFinalProvince(i)].Realm == CurrentRealm)
			{
				printf("TEST INVADED - %s has invaded %s in prov %s\n",realm[testRealm].mfGetName(),realm[CurrentRealm].mfGetName(),province[UnitFinalProvince(i)].name);
				TestTargetRealm = testRealm;
				return TRUE;
			}
		}
	}

	return FALSE;
}

/* ======================================================================== */
BOOL TestRebellion (void)
{
	LONG	i;
	for (i=1; i<PROVINCE_COUNT; ++i)
		if (province[i].Realm == CurrentRealm && province[i].Loyalty == 0)
		{
			TestTargetRealm = CurrentRealm;
			TargetProvince = (PROVINCE)i;
			return TRUE;
		}
	return FALSE;
}

/* ======================================================================== */
BOOL TestOccupied (void)
{
	LONG	i;
	for (i=1; i<PROVINCE_COUNT; ++i)
		if (province[i].Realm != CurrentRealm && province[i].OccupRealm == CurrentRealm)
		{
			TestTargetRealm = (REALM::REALM_TYPE)province[i].Realm;
			TargetProvince = (PROVINCE)i;
			return TRUE;
		}
	return FALSE;
}

/* ======================================================================== */
BOOL TestAdjacent (REALM::REALM_TYPE ActiveRealm, REALM::REALM_TYPE testRealm)
{
	LONG	i, j;

	for (i=1; i<PROVINCE_COUNT; ++i)
		//if ((province[i].Realm == ActiveRealm || AREALLIED(province[i].Realm,ActiveRealm))
		if ( province[i].Realm == ActiveRealm
				&& IsBorder((PROVINCE)i, testRealm, 0, ADJACENT) )
			return TRUE;
	return FALSE;
}

/* ======================================================================== */
BOOL TestBroke (void)
{
	if (realm[CurrentRealm].mfGetTreasury() < 5)
	{
		TestTargetRealm = CurrentRealm;
		return TRUE;
	}
	return FALSE;
}

/* ======================================================================== */
BOOL TestHated (REALM::REALM_TYPE testRealm)
{
	return (RealmReaction[CurrentRealm][testRealm] <= 25);
}

/* ======================================================================== */
BOOL TestAlly (REALM::REALM_TYPE testRealm)
{
	return (AREALLIED(CurrentRealm,testRealm));
}

/* ======================================================================== */
BOOL TestHatedAtwar (REALM::REALM_TYPE testRealm)
{
	LONG	i;
	for (i=1; i<LAND_REALM_COUNT; ++i)
		if (ISATWAR(testRealm,i))
			return TRUE;
	return FALSE;
}

/* ======================================================================== */
BOOL TestAllyAtwar (REALM::REALM_TYPE testRealm)
{
	LONG	i;
//////////////////////////////////
//	static LONG	counter = 0;
//////////////////////////////////

	for (i=1; i<LAND_REALM_COUNT; ++i)
		if (ISATWAR(testRealm,i))
		{
			TestTargetRealm = (REALM::REALM_TYPE)i;

//////////////////////////////////
//			if (CurrentRealm != REALM::GORGONSCROWN)
//			{
//				++counter;
//			}
//////////////////////////////////

			return TRUE;
		}
	return FALSE;
}

/* ======================================================================== */
BOOL TestScrewed (REALM::REALM_TYPE testRealm)		// agitate, assassinate, contest, create holding, offensive magic
{
	return (RealmStatus[CurrentRealm][testRealm] & 0x80);
}

/* ======================================================================== */
BOOL TestBuildup (REALM::REALM_TYPE testRealm)		// > 5 units in any border prov
{
	LONG	i;

	for (i=1; i<PROVINCE_COUNT; ++i)
		if (province[i].Realm == testRealm
				&& IsBorder((PROVINCE)i, CurrentRealm, 0, ADJACENT)
				&& UnitsHere((PROVINCE)i, testRealm)>5 )
		{
			TargetProvince = (PROVINCE)i;
			return TRUE;
		}
	return FALSE;
}

/* ======================================================================== */
BOOL TestNoUnits (REALM::REALM_TYPE testRealm)
{
	LONG	i;

	for (i=1; i<PROVINCE_COUNT; ++i)
		if (province[i].Realm == testRealm
				&& IsBorder((PROVINCE)i, CurrentRealm, 0, ADJACENT)
				&& !UnitsHere((PROVINCE)i, testRealm) )
		{
			TargetProvince = (PROVINCE)i;
			return TRUE;
		}
	return FALSE;
}

/* ======================================================================== */
BOOL TestEconBigger (REALM::REALM_TYPE testRealm)			// > ours
{
	return (realm[testRealm].mfGetIncome() > realm[CurrentRealm].mfGetIncome());
}

/* ======================================================================== */
BOOL TestEconSmaller (REALM::REALM_TYPE testRealm)			// < ours
{
	return (realm[testRealm].mfGetIncome() < realm[CurrentRealm].mfGetIncome());
}

/* ======================================================================== */
BOOL TestEconMuchSmaller (REALM::REALM_TYPE testRealm)		// < 70% of ours
{
	return (realm[testRealm].mfGetIncome() < ((realm[CurrentRealm].mfGetIncome()*7)/10) );
}

// ========================================================================
REALM::REALM_TYPE TestTriggers (USHORT Triggers)
{
	REALM::REALM_TYPE		i;
	BOOL		f = TRUE;
	BOOL		t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15,t16;

	// check for triggers
	for (i=REALM::FIRST_REALM; i<LAND_REALM_COUNT; i = (REALM::REALM_TYPE)(i + 1))
	{
		TestTargetRealm = REALM::NO_COUNTRY;

	#if 01
		t1=t2=t3=t4=t5=t6=t7=t8=t9=t10=t11=t12=t13=t14=t15=t16=FALSE;
		if ((Triggers & TEST_INVADED)			&& !TestInvaded(i)		) goto NOT_TRGD; else t1=1;
		if ((Triggers & TEST_SCREWED)			&& !TestScrewed(i)		) goto NOT_TRGD; else t2=1;
		if ((Triggers & TEST_ADJACENT)		&& !TestAdjacent(CurrentRealm,i) ) goto NOT_TRGD; else t4=1;
		if ((Triggers & TEST_BUILDUP)			&& !TestBuildup(i)		) goto NOT_TRGD; else t3=1;
		if ((Triggers & TEST_HATED)			&& !TestHated(i)			) goto NOT_TRGD; else t5=1;
		if ((Triggers & TEST_ALLY)				&& !TestAlly(i)			) goto NOT_TRGD; else t6=1;
		if ((Triggers & TEST_NOT_ALLY)		&& TestAlly(i)			) goto NOT_TRGD; else t7=1;
		if ((Triggers & TEST_HATED_ATWAR)	&& !TestHatedAtwar(i)	) goto NOT_TRGD; else t8=1;
		if ((Triggers & TEST_ALLY_ATWAR)		&& !TestAllyAtwar(i)		) goto NOT_TRGD; else t9=1;
		if ((Triggers & TEST_NOUNITS)			&& !TestNoUnits(i)		) goto NOT_TRGD; else t10=1;
		if ((Triggers & TEST_ECONBIGGER)		&& !TestEconBigger(i)	) goto NOT_TRGD; else t11=1;
		if ((Triggers & TEST_ECONSMALLER)	&& !TestEconSmaller(i)	) goto NOT_TRGD; else t12=1;
		if ((Triggers & TEST_ECONMUCHSMALLR)&& !TestEconMuchSmaller(i)	) goto NOT_TRGD; else t13=1;
		if ((Triggers & TEST_BROKE)			&& !TestBroke()			) goto NOT_TRGD; else t14=1;
		if ((Triggers & TEST_REBELLION)		&& !TestRebellion()		) goto NOT_TRGD; else t15=1;
		if ((Triggers & TEST_OCCUPIED)		&& !TestOccupied()		) goto NOT_TRGD; else t16=1;

	#else
		if ((Triggers & TEST_INVADED)			&& !TestInvaded(i)		) continue;
		if ((Triggers & TEST_SCREWED)			&& !TestScrewed(i)		) continue;
		if ((Triggers & TEST_ADJACENT)		&& !TestAdjacent(CurrentRealm,i) ) continue;
		if ((Triggers & TEST_BUILDUP)			&& !TestBuildup(i)		) continue;
		if ((Triggers & TEST_HATED)			&& !TestHated(i)			) continue;
		if ((Triggers & TEST_ALLY)				&& !TestAlly(i)			) continue;
		if ((Triggers & TEST_NOT_ALLY)		&& TestAlly(i)			) continue;
		if ((Triggers & TEST_HATED_ATWAR)	&& !TestHatedAtwar(i)	) continue;
		if ((Triggers & TEST_ALLY_ATWAR)		&& !TestAllyAtwar(i)		) continue;
		if ((Triggers & TEST_NOUNITS)			&& !TestNoUnits(i)		) continue;
		if ((Triggers & TEST_ECONBIGGER)		&& !TestEconBigger(i)	) continue;
		if ((Triggers & TEST_ECONSMALLER)	&& !TestEconSmaller(i)	) continue;
		if ((Triggers & TEST_ECONMUCHSMALLR)&& !TestEconMuchSmaller(i)	) continue;
		if ((Triggers & TEST_BROKE)			&& !TestBroke()			) continue;
		if ((Triggers & TEST_REBELLION)		&& !TestRebellion()		) continue;
		if ((Triggers & TEST_OCCUPIED)		&& !TestOccupied()		) continue;
	#endif

	#ifdef _LOGCOMMENT	// #25
      {
			char temp[100];
			char temp1[50];
			int temp2 = 0;
			
			if (Triggers & TEST_INVADED)		temp2+= sprintf(&temp1[temp2], "INV" );
			if (Triggers & TEST_SCREWED)		temp2+= sprintf(&temp1[temp2], "SCR" );
			if (Triggers & TEST_ADJACENT)		temp2+= sprintf(&temp1[temp2], "ADJ" );
			if (Triggers & TEST_BUILDUP)		temp2+= sprintf(&temp1[temp2], "BLD" );
			if (Triggers & TEST_HATED)			temp2+= sprintf(&temp1[temp2], "HAT" );
			if (Triggers & TEST_ALLY)			temp2+= sprintf(&temp1[temp2], "ALY" );
			if (Triggers & TEST_NOT_ALLY)		temp2+= sprintf(&temp1[temp2], "NAL" );
			if (Triggers & TEST_HATED_ATWAR)	temp2+= sprintf(&temp1[temp2], "HWR" );
			if (Triggers & TEST_ALLY_ATWAR)	temp2+= sprintf(&temp1[temp2], "AWR" );
			if (Triggers & TEST_NOUNITS)		temp2+= sprintf(&temp1[temp2], "NUN" );
			if (Triggers & TEST_ECONBIGGER)	temp2+= sprintf(&temp1[temp2], "BIG" );
			if (Triggers & TEST_ECONSMALLER)	temp2+= sprintf(&temp1[temp2], "SML" );
			if (Triggers &TEST_ECONMUCHSMALLR)temp2+=sprintf(&temp1[temp2], "EMS" );
			if (Triggers & TEST_BROKE)			temp2+= sprintf(&temp1[temp2], "BRK" );
			if (Triggers & TEST_REBELLION)	temp2+= sprintf(&temp1[temp2], "REB" );
			if (Triggers & TEST_OCCUPIED)		temp2+= sprintf(&temp1[temp2], "OCC" );
			
			if (TestTargetRealm)
				sprintf ( temp, "TRIGGERED  %d TR:%s TTR:%s (%d)", 
					25,
					temp1, realm[TestTargetRealm].mfGetName(), TestTargetRealm );
			else
				sprintf ( temp, "TRIGGERED  %d TR:%s I:%s (%d)", 
					25,
					temp1, realm[i].mfGetName(), i );
			
			RandomLogComment ( temp );
		}
	#endif


		if (TestTargetRealm)		// return the third party that's now the target
			return TestTargetRealm;

		return (REALM::REALM_TYPE)i;					// return the triggering realm


NOT_TRGD:

	#if 0
	#ifdef _LOGCOMMENT	// #26
      {
			char temp[100];
			char temp1[50];
			int temp2 = 0;
			
			if (Triggers & TEST_INVADED)		temp2+= sprintf(&temp1[temp2], (t1)?"INV":"inv" );
			if (Triggers & TEST_SCREWED)		temp2+= sprintf(&temp1[temp2], (t2)?"SCR":"scr" );
			if (Triggers & TEST_ADJACENT)		temp2+= sprintf(&temp1[temp2], (t4)?"ADJ":"adj" );
			if (Triggers & TEST_BUILDUP)		temp2+= sprintf(&temp1[temp2], (t3)?"BLD":"bld" );
			if (Triggers & TEST_HATED)			temp2+= sprintf(&temp1[temp2], (t5)?"HAT":"hat" );
			if (Triggers & TEST_ALLY)			temp2+= sprintf(&temp1[temp2], (t6)?"ALY":"aly" );
			if (Triggers & TEST_NOT_ALLY)		temp2+= sprintf(&temp1[temp2], (t7)?"NAL":"nal" );
			if (Triggers & TEST_HATED_ATWAR)	temp2+= sprintf(&temp1[temp2], (t8)?"HWR":"hwr" );
			if (Triggers & TEST_ALLY_ATWAR)	temp2+= sprintf(&temp1[temp2], (t9)?"AWR":"awr" );
			if (Triggers & TEST_NOUNITS)		temp2+= sprintf(&temp1[temp2], (t10)?"NUN":"nun" );
			if (Triggers & TEST_ECONBIGGER)	temp2+= sprintf(&temp1[temp2], (t11)?"BIG":"big" );
			if (Triggers & TEST_ECONSMALLER)	temp2+= sprintf(&temp1[temp2], (t12)?"SML":"sml" );
			if (Triggers &TEST_ECONMUCHSMALLR)temp2+=sprintf(&temp1[temp2], (t13)?"EMS":"ems" );
			if (Triggers & TEST_BROKE)			temp2+= sprintf(&temp1[temp2], (t14)?"BRK":"brk" );
			if (Triggers & TEST_REBELLION)	temp2+= sprintf(&temp1[temp2], (t15)?"REB":"reb" );
			if (Triggers & TEST_OCCUPIED)		temp2+= sprintf(&temp1[temp2], (t16)?"OCC":"occ" );
			
			if (TestTargetRealm)
				sprintf ( temp, "NOT TRGD   %d TR:%s TTR:%s (%d)", 
					26,
					temp1, realm[TestTargetRealm].mfGetName(), TestTargetRealm );
			else
				sprintf ( temp, "NOT TRGD   %d TR:%s I:%s (%d)", 
					26,
					temp1, realm[i].mfGetName(), i );
			//RandomLogComment ( temp );
		}
	#endif
	#endif

		i = i;
	}
	return REALM::NO_COUNTRY;						// return NO TRIGGER set
}

/* ========================================================================
   Function    - FindRealm
   Description - Used only by diplomacy. Set TargetRealm 
   Returns     - TRUE if TargetRealm is valid
   ======================================================================== */
BOOL FindRealm ()
{
 	LONG maxReaction=0;
	LONG tmp;
	REALM::REALM_TYPE realm_= REALM::NO_COUNTRY;
	LONG i;

	//#ifdef _LOGCOMMENT	// #27
	char temp[100];
	//#endif

	for (i=REALM::FIRST_REALM; i<REALM::REALM_COUNT; ++i)
	{
		if(RealmStatus[i][CurrentRealm] != STATUS_VASSAL
		   		&&(i >= 35 || (i<35 && RealmStatus[CurrentRealm][i]!=STATUS_VASSAL)) 
		   		&& i!=CurrentRealm)
		{

			tmp = RealmReaction[i][CurrentRealm];

		//#ifdef _LOGCOMMENT // #28
	  	//	sprintf(temp, "FindRealm - RealmReaction[%s][%s] = %d", realm[i].mfGetName(),realm[CurrentRealm].mfGetName(),tmp);
		//	RandomLogComment(temp);
		//#endif

			tmp += TestAdjacent(CurrentRealm, (REALM::REALM_TYPE) i) ? 15 : 0;

		//#ifdef _LOGCOMMENT // #29
	  	//	sprintf(temp, "FindRealm - TestAdjacent(%s,%s) = %d", realm[CurrentRealm].mfGetName(),realm[i].mfGetName(),TestAdjacent(CurrentRealm,i));
		//	RandomLogComment(temp);
		//#endif

			tmp -= (RealmStatus[i][CurrentRealm] == STATUS_PERMISSIVE_ALLIANCE)?25:0;

		//#ifdef _LOGCOMMENT // #30
  		//	sprintf(temp, "FindRealm - RealmStatus[%s][%s]==STATUS_PERMISSIVE_ALLIANCE  %d", realm[i].mfGetName(),realm[CurrentRealm].mfGetName(),(RealmStatus[i][CurrentRealm] == STATUS_PERMISSIVE_ALLIANCE)?25:0);
		//	RandomLogComment(temp);
		//#endif

			tmp -= (RealmStatus[i][CurrentRealm] == STATUS_FULL_ALLIANCE)?45:0;

		//#ifdef _LOGCOMMENT	// #31
	  	//	sprintf(temp, "FindRealm - RealmReaction[%s][%s]==STATUS_FULL_ALLIANCE  %d", realm[i].mfGetName(),realm[CurrentRealm].mfGetName(),(RealmStatus[i][CurrentRealm] == STATUS_FULL_ALLIANCE)?45:0);
		//	RandomLogComment(temp);
		//#endif

			tmp += random(20);

		//#ifdef _LOGCOMMENT	// #32
	  	//	sprintf(temp, "FindRealm - +random(20) = %d", tmp);
		//	RandomLogComment(temp);
		//#endif

		   if (tmp > maxReaction)
			{
				maxReaction = tmp;
				realm_ = (REALM::REALM_TYPE)i;
			}
		}
	}

	if (realm_ == REALM::NO_COUNTRY)
	{
		TargetRealm = REALM::NO_COUNTRY;

		#ifdef _LOGCOMMENT	// #33
	  		sprintf(temp, "FindRealm %d - Failed", 33);
			RandomLogComment(temp);
		#endif

		return FALSE;
	}
	else
	{
		TargetRealm = realm_;
		return TRUE;
	}

}

/* ========================================================================
   Function    - FindFoe
   Description - set TargetRealm 
   Returns     - TRUE if TargetRealm is valid
   ======================================================================== */
BOOL FindFoe (REALM::REALM_TYPE realm_, LONG action )
{
	LONG	i;

	for (i=1; i<LAND_REALM_COUNT; ++i)		// test for invasion
   {
		if (TestInvaded((REALM::REALM_TYPE)i))						// stop the war, we've been invaded
		{
			TargetRealm = (REALM::REALM_TYPE)i;
			TriggeredTargetRealm = (REALM::REALM_TYPE)i;

			//---- declare war on whoever invaded us
			if (	( action == ACTION_DECLAREWAR_UNOCCUP
				 	|| action == ACTION_DECLAREWAR_WEAK
				 	|| action == ACTION_DECLAREWAR_DIFTERRAIN
				 	|| action == ACTION_DECLAREWAR_BACKSTAB)
				&& !ISATWAR(realm_,i) )
			{
				return FALSE;		// in ACTION_DECLAREWAR... FALSE means go ahead and declare war
			}

			return TRUE;			//... everywhere else we want to kick the invader
		}
   }

	for (i=1; i<LAND_REALM_COUNT; ++i)		// test for at war
   {
		if (ISATWAR(realm_,i))
		{
			TargetRealm = (REALM::REALM_TYPE)i;
			return TRUE;
		}
   }

	if ( action == ACTION_MOVE_BORDER_OWN )
	{
		TargetRealm = REALM::ANY_REALM;
		return TRUE;
	}

	return FALSE;
}


/* ======================================================================== */
#if 01
CSTRPTR szTriggerTest (USHORT tests)
{
	switch (tests)
	{
		case (TEST_ALLY+TEST_ALLY_ATWAR)									: return "ALYWAR";
		case (TEST_ALLY+TEST_ALLY_ATWAR+TEST_ADJACENT)				: return "ALYWARADJ";
		case (TEST_BUILDUP+TEST_ADJACENT)								: return "BLDADJ";
		case (TEST_BUILDUP+TEST_ADJACENT+TEST_ECONBIGGER)			: return "BLDADJBIG";
		case (TEST_BROKE)														: return "BRK";
		case (TEST_BROKE+TEST_ADJACENT+TEST_ECONSMALLER)			: return "BRKADJSML";
		case (TEST_HATED+TEST_HATED_ATWAR+TEST_ADJACENT)			: return "HATWARADJ";
		case (TEST_INVADED)													: return "INV";
		case (TEST_INVADED+TEST_ECONBIGGER)								: return "INVBIG";
		case (TEST_INVADED+TEST_ECONSMALLER)							: return "INVSML";
		case (TEST_NOT_ALLY+TEST_NOUNITS+TEST_ADJACENT)				: return "NUNADJ";
		case (TEST_NOT_ALLY+TEST_NOUNITS+TEST_ADJACENT+TEST_HATED)	: return "NUNADJHAT";
		case (TEST_NOT_ALLY+TEST_NOUNITS+TEST_ADJACENT+TEST_ECONSMALLER)	: return "NUNADJSML";
		case (TEST_OCCUPIED)													: return "OCC";
		case (TEST_SCREWED+TEST_ADJACENT)								: return "SCRADJ";
		case (TEST_SCREWED+TEST_ADJACENT+TEST_ECONBIGGER)			: return "SCRADJBIG";
		case (TEST_SCREWED+TEST_ADJACENT+TEST_ECONSMALLER)			: return "SCRADJSML";
		case (TEST_SCREWED+TEST_ECONBIGGER)								: return "SCRBIG";
		case (TEST_SCREWED)													: return "SCR";
	}
	return "none";
}
#endif

/* ========================================================================
   Function    - 
   Description - 
   Returns     -
   ======================================================================== */
LONG HoldingValue (LONG iHold)
{
	if (iHold < 1 || iHold >= MAX_PLACES || places[iHold].Realm == 0)
		return 0;

	if (places[iHold].Icon == GUILD1_ICON)
		return (places[iHold].Level * 5);		// 5 gb per level for guild
	else
		return (places[iHold].Level * 3);		// 3 gb per level for others
}

/* ========================================================================
   Function    - 
   Description - 
   Returns     -
   ======================================================================== */
LONG OfferHolding (void)
{
	LONG	i,  c;
	LONG	p = 0;
	LONG	min = 999;
	LONG	regent_;
	LONG	not_icon = GUILD1_ICON;

	TargetPlace = 0;
	regent_ = realm[CurrentRealm].mfGetRegent();

	// regent is wizard, give out guild, temple, or law
	if (regents[regent_].mfGetClass1() == WIZARD || regents[regent_].mfGetClass2() == WIZARD)
		not_icon = SOURCE1_ICON;
	else if (regents[regent_].mfGetClass1() == PRIEST|| regents[regent_].mfGetClass2() == PRIEST)
		not_icon = TEMPLE1_ICON;
	else if (regents[regent_].mfGetClass1() == BARD || regents[regent_].mfGetClass2() == BARD)
		not_icon = SOURCE1_ICON;

	for (i=1; i<MAX_PLACES; ++i)
	{
		if ( places[i].Realm == CurrentRealm
			&& places[i].Icon != not_icon
			&& (places[i].Icon == SOURCE1_ICON || places[i].Icon == TEMPLE1_ICON || places[i].Icon == GUILD1_ICON) )
		{
			c = places[i].Level;

			if ( c < min)		// find min
			{
				min = c;
				p = i;
			}
		}
	}

	if (p)
	{
		TargetPlace = p;
		return HoldingValue(p);
	}

	return 0;
}

/* ========================================================================
   Function    - 
   Description - 
   Returns     -
   ======================================================================== */
LONG DemandHolding (REALM::REALM_TYPE realm_, SHORT oldDemand)
{
	LONG i, j, m, tmp, place, maxReaction;
	LONG regent_ = realm[CurrentRealm].mfGetRegent();
	LONG notProv = 0;

	if (TargetPlace)
		notProv = HoldingToProv(TargetPlace);
	maxReaction = 0;
	StartPlace = 0;
	place = 0;

	for (i = 1; i<PROVINCE_COUNT; ++i)
	{
		if (province[i].Realm != CurrentRealm)
			continue;

		CheckAndFixPlaces((PROVINCE)i);
		j = m = province[i].FirstPlace;

		while (j != 0)
		{
			tmp = 0;
			if ( m != oldDemand && i != notProv
				&& (places[m].Icon == LAW1_ICON || places[m].Icon == SOURCE1_ICON || places[m].Icon == TEMPLE1_ICON || places[m].Icon == GUILD1_ICON) )
			{
				if (places[m].Realm == realm_)
				{
					tmp += 20;
					if (places[m].Icon == LAW1_ICON)
						tmp += 20;
					tmp += random(5);
				}
	 			if (tmp > maxReaction)
				{
					maxReaction = tmp;
					place = m;
				}

				else if (tmp == maxReaction && random(3) == 0 && tmp != 0)
				{
				 	maxReaction = tmp;
					place = m;
				}
			}

			j = places[m].NextPlace;
			m = province[i].FirstPlace + j;
		}
	}


	// found no place within our realm
	if (!place)
	{
		for (i = 1; i<MAX_PLACES; ++i)
		{
			if ( ( (realm_ && places[i].Realm == realm_) || (realm_ == REALM::NO_COUNTRY && places[i].Realm != CurrentRealm) )
				 	&& places[i].Level != 0
					&& i != oldDemand
					&& (places[i].Icon == SOURCE1_ICON || places[i].Icon == TEMPLE1_ICON || places[i].Icon == GUILD1_ICON)
					&& notProv != HoldingToProv(i)
				)
			{
				tmp = RealmReaction[places[i].Realm][CurrentRealm];

				if ( (places[i].Icon == TEMPLE1_ICON
							&& (regents[regent_].mfGetClass1()==PRIEST || regents[regent_].mfGetClass2()==PRIEST) )
		   		|| (places[i].Icon == SOURCE1_ICON
							&& (regents[regent_].mfGetClass1()==WIZARD || regents[regent_].mfGetClass2()==WIZARD
								|| regents[regent_].mfGetClass1()==BARD || regents[regent_].mfGetClass2()==BARD) ) )
					tmp += 20;

				tmp += random(15);

				if (realm_ == REALM::NO_COUNTRY)
					tmp += places[i].Level * 4;

				else 	  // if action is diplomacy, asking for the non_zero place with lowest level
					tmp += (10-places[i].Level) * 3;

				if (tmp > maxReaction)
				{
					maxReaction = tmp;
					place = i;
				}
				else if (tmp == maxReaction && random(3) == 0)
				{
				 	maxReaction = tmp;
					place = i;
				}
			}
		}
	}


	if (place)
	{
		StartPlace = place;
		return HoldingValue(place);
	}

	StartPlace = 0;
	return 0;
}

/* ========================================================================
   Function    - 
   Description - 
   Returns     -
   ======================================================================== */
BOOL DoNPCAction (void)
{
	LONG				f, i, j, k, type, icon, min, roll, action, m, done;
	REALM::REALM_TYPE	rlm;
	LONG				cAttemptedRolls, dist, gold, offgold, trib, value;
	LONG				maxReaction = 0;
	LONG				tmp, place, CurrentRegent;
	LONG				minDist = 99;
	AI_ACTION_PTR	p;

	BOOL				fSync;
	BOOL 				fSend;
	LONG				holding;
	PROVINCE			tmpProvince;
	LONG				reaction;
	static BOOL		fActionsOver = 0;  //---- action round over

	//static BOOL		fPrintDebugData = TRUE;

	// ========================================================================
	// 
	// ========================================================================

	//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	#if 0
	#define BOX_X	220
	#define BOX_Y	150
	#define BOX_W	200
	#define BOX_H	100
	if (fPrintDebugData)
	{
		char temp[200];
		sprintf(temp, "START OF TURN LOG START OF TURN LOG START OF TURN LOG START OF TURN LOG ");
		RandomLogComment ( temp );
		sprintf(temp, "START OF TURN LOG     fActionsOver  %ld", fActionsOver             );
		RandomLogComment ( temp );
		sprintf(temp, "START OF TURN LOG     IsMultiPlayer()  %ld", IsMultiPlayer()       );
		RandomLogComment ( temp );
		sprintf(temp, "START OF TURN LOG     iCurrentRealmIndex  %ld", iCurrentRealmIndex );
		RandomLogComment ( temp );
		sprintf(temp, "START OF TURN LOG     action_turn  %ld", action_turn               );
		RandomLogComment ( temp );
		sprintf(temp, "START OF TURN LOG     prev_action_turn  %ld", prev_action_turn     );
		RandomLogComment ( temp );
		sprintf(temp, "START OF TURN LOG     CurrentRealm  %ld", CurrentRealm             );
		RandomLogComment ( temp );
		sprintf(temp, "START OF TURN LOG     HomeRealm  %ld", HomeRealm                   );
		RandomLogComment ( temp );
		sprintf(temp, "START OF TURN LOG START OF TURN LOG START OF TURN LOG START OF TURN LOG ");
		RandomLogComment ( temp );
		fPrintDebugData = FALSE;
	}
	#endif
	//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	if (!fActionsOver)
	{
		#ifdef _WINDOWS
		if (IsMultiPlayer())			// wait until all are done
		{
			// Player's turn. Wait until new action
			if (iCurrentRealmIndex == 0)
			{
				if (action_turn == prev_action_turn		// return until player takes his turn
					&& action_turn < 4 )
				{
					if (CurrentRealm != HomeRealm)
					{
						reqSound = SND_UI_YOUR_TURN1;
						fRedrawAll = TRUE;
						WaitingBar216ths = 0;
						WaitingWhen = get_time();
					}
					CurrentRealm = HomeRealm;

					return FALSE;
				}

				WaitingBar216ths = 0;
				WaitingWhen = 0;

				if (CurrentRealm == HomeRealm)
				{
					StartSync( iMPS_SYNC3 );
					fRedrawAll = TRUE;
				}
				CurrentRealm = REALM::NO_COUNTRY;

				if ( GetAsyncKeyState( VK_F10 ) & 0x8000 )		// Break out
					AMultiPlayer.Finalize();

				WaitingCount = CheckSync( iMPS_SYNC3, FALSE, FALSE );
				if ( WaitingCount)
				{
					fRedrawAll = TRUE;
					return FALSE;
				}

				// all players are done and synced
				fRedrawAll = TRUE;
				UpdateUnitAndPlaceCount();

			}
		}
		else
		#endif

		// Player's turn. Wait until new action
		if (CurrentRealm == HomeRealm &&
			action_turn == prev_action_turn &&
			action_turn < 4 )
		{
			return FALSE;
		}

	}


	//-----------------------------------------
	// make the AI select an action for an NPC
	//-----------------------------------------
	prev_action_turn = action_turn;

GetNextRealm:				// if realm is invalid it loops here until a valid realm is found
	++iCurrentRealmIndex;

	// check for end of action condition
	if (iCurrentRealmIndex >= LAND_REALM_COUNT)
	{

		//---- Sync before troop movement
		#ifdef _WINDOWS
		if (!fActionsOver)
		{
			//if ( IsMultiPlayer() )
			//	DoMultiplayerDataIntegrityCheck();
			StartSync( iMPS_SYNC4 );
			CheckSync( iMPS_SYNC4, TRUE, TRUE );
			BattleSync = 0;			// clear sync counter for battles
		}
		#endif

		fActionsOver = 1; 		// The action turn is over so stop doing things

		// wait for all units to reach destinations
		#ifdef _WINDOWS
		if ( IsMultiPlayer() )
		{
			for (i=1; i<MAX_UNITS; ++i)
			{
				if ( units[i].Joined == FALSE
					&& units[i].Realm
					&& units[i].province
					&& units[i].iIconBitm != fERROR
					&& realm[units[i].Realm].mfExists()
					&& units[i].DestProvince != NO_PROVINCE )
				{
					iCurrentRealmIndex = LAND_REALM_COUNT - 1;		// make it loop again
					fRedrawAll = TRUE;
					return FALSE;
				}
			}

			//---- Sync before battle
			StartSync( iMPS_SYNC1 );
			CheckSync( iMPS_SYNC1, TRUE, TRUE );
		}
		#endif

		// wait for all battles to be fought
		for (i=1; i<MAX_UNITS; ++i)
		{
			if (units[i].Joined == FALSE
				&& units[i].Realm
				&& units[i].province
				&& units[i].iIconBitm != fERROR
				&& realm[units[i].Realm].mfExists())
			{
				tmp = CheckUnitArrival(i, FALSE);	// force stationary units to battle
		
				if (tmp & fSCENEBATTLE)		// go to Scene level battle
				{
					iCurrentRealmIndex = LAND_REALM_COUNT - 1;		// make it loop again
					ClearRemapTable();
					#ifdef _WINDOWS
					// -- The action isn't really restarted, we just restart the
					// -- action as a way to get a sync 4 to occur to sync up the 
					// -- multi player code
					fActionsOver = FALSE;						// force a sync 4
					#endif
					
					return TRUE;
				}

				if ( (tmp & fAUTOBATTLE)		// units retreated, loop to movement check
					|| units[i].DestProvince != NO_PROVINCE)
				{
					iCurrentRealmIndex = LAND_REALM_COUNT - 1;		// make it loop again
					fRedrawAll = TRUE;
					
					#ifdef _WINDOWS
					if (tmp & fNPCBATTLE)
					{
						StartSync( iMPS_SYNC4 );					// force sync 4
						CheckSync( iMPS_SYNC4, TRUE, TRUE );
					}
					#endif
					
					return FALSE;
				}
			}

		}

		//---- Battle/troop movement is now over 
		fActionsOver = 0;

		#ifdef _WINDOWS
		StartSync( iMPS_SYNC2 );	//---- Sync after battles/troop movement 
		CheckSync( iMPS_SYNC2, TRUE, TRUE );
		//fPrintDebugData = TRUE;		//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		#endif

		iCurrentRealmIndex = 0;		// reset
		++global_action_turn;

		if ( global_action_turn >= 4 )
		{
			global_action_turn = 1;
			fRoundOver = TRUE;
			fUpdateDataArea = TRUE;			// prime the pump
			CurrentRealm = REALM::REALM_OUT_OF_RANGE;
			prev_action_turn = 1;
			return FALSE;
		}

		if (IsMultiPlayer())			// wait until all are done
		{
			CurrentRealm = REALM::NO_COUNTRY;
			fRedrawAll = TRUE;
			return FALSE;
		}
	}

	//-----------------------------------------
	// get next realm from the realm order list
	//-----------------------------------------
	rlm = (REALM::REALM_TYPE)RealmOrder[iCurrentRealmIndex];
	CurrentRealm = rlm;

	// handle known invalid conditions
	if (rlm >= LAND_REALM_COUNT || rlm < 1 || !realm[rlm].mfExists())
		goto GetNextRealm;

	#ifdef _WINDOWS
	// don't do player realms in multiplayer
	if ( IsMultiPlayer() && realm[rlm].mfIsPlayerCtrl())
		goto GetNextRealm;
	#endif

	#ifdef _LOGCOMMENT	// #34
	{
		char temp[100];
		sprintf ( temp, "--------    %d #%d: start of %s turn (GB:%d R:%d)    --------",
			34,
			iCurrentRealmIndex,
			realm[rlm].mfGetName(),
			realm[rlm].mfGetTreasury(),
			realm[rlm].mfGetRegency());
		RandomLogComment ( temp );
	}
	#endif

	//----- Seed the number generator 
	#ifdef _WINDOWS
	AMultiPlayer.NextSeed(__FILE__,__LINE__);
	#endif


	if (rlm == HomeRealm)			// give the player his turn
	{
		//printf("PC ACTION\n");
		reqSound = SND_UI_YOUR_TURN1;
		fRedrawAll = TRUE;
		return FALSE;
	}

	if (realm[rlm].mfIsPlayerCtrl())		// don't do player realms
	{
		//printf("PC ACTION\n");
		fRedrawAll = TRUE;
		return FALSE;
	}

	npc_ai[rlm].CurrentAction = ACTION_PASS;

	//-------------------------------------------
	// mode change condition
	//-------------------------------------------
	if (npc_ai[rlm].CurrentMode >= MODE_COUNT || random(100)<npc_ai[rlm].Fickleness)
	{
NewMode:
		//npc_ai[rlm].CurrentMode = npc_ai[rlm].Modes[random(10)];

		for (j=i=0; i<10; ++i)
			j += (LONG)npc_ai[rlm].Chance[i];
		k = random(j);

		//printf("MODE CHANGE - Realm:%s chance_tot:%d choice:%d\n",realm[rlm].name,j,k);
		for (i=0; i<10; ++i)
		{
			k -= npc_ai[rlm].Chance[i];
			if (k < 0)
			{
				npc_ai[rlm].CurrentMode = npc_ai[rlm].Modes[i];

       	#ifdef _LOGCOMMENT	// #35
				char temp[100];
				sprintf ( temp, "DoNPCAction %d - ModeChange: %s changing to %s", 
					35,
					realm[rlm].mfGetName(), 
					szAIMode[npc_ai[rlm].CurrentMode]);
				RandomLogComment ( temp );
			#endif

				break;
			}
		}
		//printf("NPC ACTION - %s has changed modes to %s (%d)\n",realm[rlm].mfGetName(),szAIMode[npc_ai[rlm].CurrentMode],npc_ai[rlm].CurrentMode);
	}

	//-------------------------------------------
	// trigger conditions
	//-------------------------------------------
	TriggeredTargetRealm = REALM::NO_COUNTRY;
	for (i=0; i<8 && !TriggeredTargetRealm; ++i)
	{
		TriggeredTargetRealm = TestTriggers(npc_ai[rlm].Triggers[i].Tests);
		if (TriggeredTargetRealm)
		{
			//printf("TRIGGER - %s trigger %d (%s) set off by %s, mode now %s\n",
			//realm[rlm].mfGetName(),i,szTriggerTest(npc_ai[rlm].Triggers[i].Tests),
			//realm[TriggeredTargetRealm].mfGetName(),szAIMode[npc_ai[rlm].Triggers[i].Action]);

			npc_ai[rlm].CurrentMode = npc_ai[rlm].Triggers[i].Action;

	     	#ifdef _LOGCOMMENT	// #36
			{
				char temp[100];
				sprintf ( temp, "DoNPCAction %d - %s  triggered action:%s  target realm:%s",
					36,
					realm[rlm].mfGetName(),
					szAIMode[npc_ai[rlm].CurrentMode],
					realm[TriggeredTargetRealm].mfGetName());
				RandomLogComment ( temp );
			}
			#endif

		}
	}

	//-------------------------------------------
	// roll an action
	//-------------------------------------------
	cAttemptedRolls = 0;

ReRoll:

	fSend = FALSE;                          //---- Reset flags
	fSync = FALSE;

	++cAttemptedRolls;
	if (cAttemptedRolls>25)					// only try 25 times then change modes
		goto NewMode;

Another:
	run_timers();  // cdb 11/27	// ABC don't put in inner loops

#ifdef _WINDOWS
	AMultiPlayer.LookForMessages();   //---- Update non specific messages
#endif

	p = Modes[npc_ai[rlm].CurrentMode];

	roll = random(100);
	for (k=0; roll > p[k].Chance; ++k) {}
	action = p[k].Action;

	// Because this thing is so confusing let us write out what we are
	// doing. This way we can figure out why this thing is out of sync
	// during a multiplayer game. 

	#ifdef _LOGCOMMENT	// #37
		char temp[100];
		if (TriggeredTargetRealm && TriggeredTargetRealm!=rlm
				&& TriggeredTargetRealm < LAND_REALM_COUNT)
			sprintf ( temp, "DoNPCAction %d - %s  doing action:%s (maybe on %s)", 
				37,
				realm[rlm].mfGetName(), 
				szAIAction[action].mfGetStr(), 
				realm[TriggeredTargetRealm].mfGetName());
		else
			sprintf ( temp, "DoNPCAction %d - %s  doing action:%s", 
				37,
				realm[rlm].mfGetName(), 
				szAIAction[action].mfGetStr());
		RandomLogComment ( temp );
	#endif

	//-------------------------------------------
	// do an action
	//-------------------------------------------
	if (!fTutorialSelected || date > 7)		// in tutorial, no actions until turn 7
	{
		if (!fAllowed[fControlMode][action])
			goto ReRoll_;				// can't do the action so try another

		switch (action)
		{
		case ACTION_NONE:
			goto ReRoll_;				// can't do the action so try another

		case ACTION_AGITATE_FOE:
			if (rlm == REALM::MONSTERS) goto ReRoll_;
			if(!CanAfford (1, 1, 0, rlm)) goto ReRoll_;
			if (TriggeredTargetRealm && TriggeredTargetRealm!=rlm
					&& TriggeredTargetRealm < LAND_REALM_COUNT)
				TargetRealm = TriggeredTargetRealm;
			else if (!FindFoe(rlm,action)) 
				goto ReRoll_;
			// have a foe in TargetRealm
			// if there isn't a province whose loyalty is poor, 
			// find one whose loyalty is average.
			// timeCount == 0, the first run, timeCount == 1, the second run
			for( timeCount = 0; timeCount < 2; ++timeCount )					  
				if (FindProv(action)) break;
			if(timeCount == 2) goto ReRoll_;
			TargetPlace=0;

			npc_ai[rlm].CurrentAction = action;
			if (!RollNPCSuccess(action, &fSync, &fSend )) break;

			province[TargetProvince].Loyalty--;
			SetScrewed(TargetRealm, CurrentRealm, fSend );
 			if(TargetRealm == HomeRealm)
				AddReport(SUBJ_AGITATE, 1, TargetProvince, province[TargetProvince].Loyalty);
			SetGameData(MP_PROVINCE, MPPROV_LOYALTY, TargetProvince, province[TargetProvince].Loyalty, fSend );
			if(!CanAfford (1, 1, 0, rlm)) break;
			PayForIt(rlm,1, 1, 0);
			break;

		case ACTION_AGITATE_OWN:
			if (rlm == REALM::MONSTERS) goto ReRoll_;
			if(!CanAfford (1, 1, 0, rlm)) goto ReRoll_;
			for ( timeCount = 0; timeCount < 2; ++timeCount )
				if (FindProv(action)) break;
			if(timeCount == 2) goto ReRoll_;
			npc_ai[rlm].CurrentAction = action;
			//if(!RollNPCSuccess(action)) break;
			++province[TargetProvince].Loyalty;
			SetGameData(MP_PROVINCE, MPPROV_LOYALTY, TargetProvince, province[TargetProvince].Loyalty, FALSE );
			PayForIt(rlm, 1, 1, 0);
			break;

		case ACTION_BUILDROAD:
			if (rlm == REALM::MONSTERS) goto ReRoll_;
			//printf("BUILD ROAD - start");
			if (!FindHolding(rlm,rlm,ANY_PROVINCE,GUILD1_ICON, TRUE)) goto ReRoll_; // if no guilds don't bother
			//printf(" found:%s  end",province[TargetProvince].name);
			StartProvince = TargetProvince;
			if (!FindDiffTerrain(ANY_WAY)) goto ReRoll_;	// must be to diff terrain
			//printf(" found:%s ",province[TargetProvince].name);
			if (!RecursiveRoadBuilder(StartProvince)) goto ReRoll_;
			npc_ai[rlm].CurrentAction = action;
			goto Another_;				// action was free so do another

		case ACTION_CONTEST_LAW:
		case ACTION_CONTEST_GLD:
		case ACTION_CONTEST_TMP:
		case ACTION_CONTEST_SRC:
			switch(action)
			{
			case ACTION_CONTEST_LAW:
				j = 0;
				break;
			case ACTION_CONTEST_GLD:
				j = 1;
				break;
			case ACTION_CONTEST_TMP:
				j = 2;
				break;
			case ACTION_CONTEST_SRC:
				j = 3;
				break;
			}

			if (rlm == REALM::MONSTERS) goto ReRoll_;
			if (TriggeredTargetRealm)
			{
				if (FindHolding(rlm, TriggeredTargetRealm, ANY_PROVINCE, InfoReqType[j], TRUE))
					goto FOUND_ONE;
				if (FindHolding(REALM::ANY_REALM, TriggeredTargetRealm, ANY_PROVINCE, InfoReqType[j], TRUE)
						&& FindHolding(REALM::ANY_REALM, rlm, TargetProvince, ANY_PROVINCE, TRUE) )
							goto FOUND_ONE;
			}
			if (FindHolding(rlm, REALM::ANY_REALM, ANY_PROVINCE, InfoReqType[j], TRUE))
			{
				TargetRealm = (REALM::REALM_TYPE) places[TargetPlace].Realm;
				goto FOUND_ONE;
			}					
			goto ReRoll_;				// can't do the action so try another

FOUND_ONE:
			npc_ai[rlm].CurrentAction = action;
			if (!RollNPCSuccess(action,&fSync,&fSend)) break;
	 		if (places[TargetPlace].Level == 0
				   || places[TargetPlace].Contested == TRUE)
				DeleteHolding(TargetProvince, TargetPlace, fSend);
			else
				//places[TargetPlace].Contested = TRUE;
				SetGameData(MP_PLACES, MPPLACE_CONTESTED, TargetPlace, TRUE, fSend );
			break;

		case ACTION_CREATE_LAW:
			icon = LAW1_ICON; type = 0;
			goto CreateHldng;
		case ACTION_CREATE_GLD:
			icon = GUILD1_ICON; type = 1;
			goto CreateHldng;
		case ACTION_CREATE_TMP:
			icon = TEMPLE1_ICON; type = 2;
			goto CreateHldng;
		case ACTION_CREATE_SRC:
			icon = SOURCE1_ICON; type = 3;
CreateHldng:
			if (rlm == REALM::MONSTERS) goto ReRoll_;
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//			if (TriggeredTargetRealm)
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			if (cntHolds > (MAX_PLACES-60)) goto ReRoll_;
			if (!FindNotHolding(rlm, icon, FALSE)) goto ReRoll_;
			TargetPlace=0;
			npc_ai[rlm].CurrentAction = action;
			if (!RollNPCSuccess(action,&fSync, &fSend)) break;
			//--- We can't goto ReRoll after RollNPCSuccess
			//if (!CreateHolding(type, 0, 0, TargetProvince, rlm, fSend ) ) goto ReRoll_;
			CreateHolding(type, 0, 0, TargetProvince, rlm, fSend);
			break;

		case ACTION_DECLAREWAR_UNOCCUP:
		case ACTION_DECLAREWAR_WEAK:
		case ACTION_DECLAREWAR_DIFTERRAIN:
		case ACTION_DECLAREWAR_BACKSTAB:
			if (rlm == REALM::MONSTERS) goto ReRoll_;
			if (action_turn > 2			// don't declare war after 2nd action
				||	(fPlayerNeverDeclaredWar
					&&	(	(game_difficulty == DIF_EASY && date < 4)
						||	(game_difficulty == DIF_MEDIUM && date < 3)
						||	(game_difficulty == DIF_HARD && date < 2)
				)	)	)
				goto ReRoll_;

			if (FindFoe(rlm,action)) goto ReRoll_;	// if already at war don't do again

			// triggered action
			if (TriggeredTargetRealm && TriggeredTargetRealm!=rlm
					&& TriggeredTargetRealm < LAND_REALM_COUNT)
			{
				npc_ai[rlm].CurrentAction = action;

				WarDeclared(rlm, TriggeredTargetRealm, FALSE);

#if 0
				RealmStatus[rlm][TriggeredTargetRealm] = (TestAdjacent(rlm,TriggeredTargetRealm))?STATUS_AT_WAR_ADJ:STATUS_AT_WAR;

				k = RealmReaction[rlm][TriggeredTargetRealm] - (Tribute[TriggeredTargetRealm][rlm] * 5);
				RealmReaction[rlm][TriggeredTargetRealm] = (k>0)?k:0;
				k = RealmReaction[TriggeredTargetRealm][rlm] - (5 + random(10) + (Tribute[rlm][TriggeredTargetRealm] * 5));
				RealmReaction[TriggeredTargetRealm][rlm] = (k>0)?k:0;

				Tribute[rlm][TriggeredTargetRealm] = 0; Tribute[TriggeredTargetRealm][rlm] = 0;
#endif
				npc_ai[rlm].OldAtWar = TargetRealm;
				//printf("TRG DECLARE WAR - %s on %s\n",realm[rlm].mfGetName(),realm[TriggeredTargetRealm].name);
				break;
			}

			// check for previous at war status
			if (npc_ai[rlm].OldAtWar && realm[npc_ai[rlm].OldAtWar].mfExists())
			{
				min = 39;
				TargetRealm = (REALM::REALM_TYPE) npc_ai[rlm].OldAtWar;		// attack them again
			}

			// search for someone to attack
			else
			{
				min = 9999;
				TargetRealm = REALM::NO_COUNTRY;
				for (i=1; i<LAND_REALM_COUNT; ++i)	// find minimum reaction
				{
					// not self, imp. city of anuire, or full (or better) allies
					if (i==rlm || i==REALM::ANUIRE || AREFULLALLIES(rlm,i))
						continue;

					for (f=0,j=1; j<PROVINCE_COUNT && !f; ++j)	// find adj realm
						if (province[j].Realm==rlm || (rlm==REALM::GORGONSCROWN && AREALLIED(rlm,province[j].Realm)))
							for (k=0; k<7 && !f; ++k)
								if (province[province[j].Border[k].Province].Realm==i)
								{
									roll = RealmReaction[rlm][i]+random(40)-20	// 20%
											- (ISATWAR(i,rlm))?50:0				// 50% more if they declared war on us
											+ (AREALLIED(i,rlm))?20:0 ;			// 20% less if they are permissive allies
									if (roll < min)
									{
										min = roll;
										TargetRealm = (REALM::REALM_TYPE)i;
										f = TRUE;
									}
								}
				}
			}

			if (TargetRealm && TargetRealm != rlm && min <= 40
				&& TargetRealm < LAND_REALM_COUNT)		// GWP PATCH CODE.
			{
				npc_ai[rlm].CurrentAction = action;
				
				WarDeclared(rlm, TargetRealm, FALSE);
#if 0
				RealmStatus[rlm][TargetRealm] = (TestAdjacent(rlm,TargetRealm))?STATUS_AT_WAR_ADJ:STATUS_AT_WAR;
				k = RealmReaction[rlm][TargetRealm] - (Tribute[TargetRealm][rlm] * 5);
				RealmReaction[rlm][TargetRealm] = (k>0)?k:0;
				k = RealmReaction[TargetRealm][rlm] - (5 + random(10) + (Tribute[rlm][TargetRealm] * 5));
				RealmReaction[TargetRealm][rlm] = (k>0)?k:0;
				Tribute[rlm][TargetRealm] = 0; Tribute[TargetRealm][rlm] = 0;
				npc_ai[rlm].OldAtWar = TargetRealm;
				if(TargetRealm == HomeRealm)
					AddReport(IMMEDIATE_NPC_DECLARE_WAR, CurrentRealm, 0, 0);
				else if(AREALLIED(TargetRealm, HomeRealm))
				{
					if(ISVASSAL(TargetRealm, HomeRealm))
						AddReport(IMMEDIATE_NPC_DECLARE_WAR_ALLY, CurrentRealm, 3, TargetRealm);
					else if(AREFULLALLIES(TargetRealm, HomeRealm))
						AddReport(IMMEDIATE_NPC_DECLARE_WAR_ALLY, CurrentRealm, 2, TargetRealm);
					else 
						AddReport(IMMEDIATE_NPC_DECLARE_WAR_ALLY, CurrentRealm, 1, TargetRealm);
				}
//printf("DECLARE WAR - %s on %s\n",realm[rlm].name,realm[TargetRealm].name);
#endif
				break;
			}
			goto ReRoll_;				// can't do the action so try another

		case ACTION_DIPLMCY_ALLY:
			#ifdef _WINDOWS
			if (IsMultiPlayer()) goto ReRoll_;
			#endif
			if (rlm == REALM::MONSTERS) goto ReRoll_;

			if (!FindRealm()) goto ReRoll_;
			TargetPlace = 0;
			StartPlace = 0;
			TargetProvince = NO_PROVINCE;
			gold = 0;
			offgold = 0;
			trib = 0;

			if (TargetRealm == REALM::ANY_REALM) goto ReRoll_;
			if (!CanAfford (1, 1, 0, CurrentRealm)) goto ReRoll_;

			// going for Full or Permissive alliance
			if (RealmStatus[TargetRealm][CurrentRealm] == STATUS_PERMISSIVE_ALLIANCE
				|| RealmStatus[TargetRealm][CurrentRealm] == STATUS_NEUTRAL)
			{
				value = random(25) - 10;						// their perceived value of the alliance

				if (random(3)==0 || value > 0)			// 33% or if needed
				{
					j = OfferHolding();						// TargetPlace is the place
					value -= j;
				}
				if (random(3)==0 || value < 0)			// 33% or if needed
				{
					j = DemandHolding(TargetRealm, 0);	// startPlace is the place we will demand
					value += j;
				}
				if (value < 0)									// make up what's left
				{
					gold = -value;
					if (!CanAfford (gold, 0, 0, TargetRealm))
						gold = realm[TargetRealm].mfGetTreasury()/10-1;
					if (gold < 0)
						gold = 0;
					value += gold;
				}
				else if (value > 0)							// make up what's left
				{
					offgold = value;
					if (!CanAfford(offgold, 0, 0, rlm))
						offgold = realm[rlm].mfGetTreasury()/10-1;
					if (offgold < 0)
						offgold = 0;
					value -= offgold;
				}

				//if (value < 10) goto ReRoll_;				// not good enough
			}

			// going for Vassalage
			else if (RealmStatus[TargetRealm][CurrentRealm] == STATUS_FULL_ALLIANCE)
			{
				value = random(25) + 10;					// their perceived value of the alliance

				if (random(3)==0 || value > 0)			// 33% or if needed
				{
					j = OfferHolding();
					value -= j;
				}
				if (random(3)==0 || value < 0)			// 33% or if needed
				{
					j = DemandHolding(TargetRealm, 0);
					value += j;
				}
				if (value < 0)									// make up what's left
				{
					gold = -value;
					if (!CanAfford (gold, 0, 0, TargetRealm))
						gold = realm[TargetRealm].mfGetTreasury()/10-1;
					if (gold < 0)
						gold = 0;
					value += gold;
				}
				else if (value > 0)							// make up what's left
				{
					offgold = 0;
					trib = value / 3;
					if (!CanAfford(0, 0, trib, rlm))
					{
						trib = 0;
						offgold = value;
						if (!CanAfford(offgold, 0, 0, rlm))
							offgold = realm[rlm].mfGetTreasury()/10-1;
						if (offgold < 0)
							offgold = 0;
						value -= offgold;
					}
					else
						value = 0;
				}

				//if (value < 10) goto ReRoll_;				// not good enough
			}

			npc_ai[rlm].CurrentAction = action;


			if (!realm[TargetRealm].mfIsPlayerCtrl())  //---- NPC vs. NPC
			{
				// Roll For Success
				if (random(4)==0) break;

				// do the action

				if (RealmStatus[TargetRealm][CurrentRealm] == STATUS_PERMISSIVE_ALLIANCE)
				{
					PayForIt(CurrentRealm, 1, 1, 0);
					SetGameData(MP_REALMSTATUS, TargetRealm, CurrentRealm, STATUS_FULL_ALLIANCE, FALSE );
					if (TargetRealm<LAND_REALM_COUNT)
					{
						//RealmStatus[CurrentRealm][TargetRealm] = STATUS_FULL_ALLIANCE;
						SetGameData(MP_REALMSTATUS, CurrentRealm, TargetRealm, STATUS_FULL_ALLIANCE, FALSE );
						//RealmReaction[CurrentRealm] [TargetRealm]= 95;
						SetGameData(MP_REALMREACTION, CurrentRealm, TargetRealm, 95, FALSE );
					}
					// RealmReaction[TargetRealm][CurrentRealm] = 95;
					SetGameData(MP_REALMREACTION, TargetRealm, CurrentRealm, 95, FALSE);

					realm[CurrentRealm].mfAddTreasury(gold * 10);
					realm[TargetRealm].mfAddTreasury( -(gold * 10));
					// offer holding
					if (TargetPlace)
						//SetGameData(MP_PLACES, MPPLACE_REALM, TargetPlace, TargetRealm, FALSE );
						CheckHolding(TargetPlace, TargetRealm, FALSE);
					if (StartPlace)
						//SetGameData(MP_PLACES, MPPLACE_REALM, StartPlace, CurrentRealm, FALSE );
						CheckHolding(StartPlace, CurrentRealm, FALSE);
				}
				else if (RealmStatus[TargetRealm][CurrentRealm] == STATUS_FULL_ALLIANCE)
				{
					PayForIt(CurrentRealm, gold, 1, 0);
					realm[TargetRealm].mfAddTreasury( gold* 10);
					// offer tribute
					Tribute[TargetRealm][CurrentRealm] = trib;

					// reset realm status and reaction
					SetGameData(MP_REALMSTATUS, TargetRealm, CurrentRealm, STATUS_VASSAL, FALSE );
					SetGameData(MP_REALMREACTION, TargetRealm, CurrentRealm, 150, FALSE );
					if (TargetRealm<LAND_REALM_COUNT)
					{
						SetGameData(MP_REALMSTATUS, CurrentRealm, TargetRealm, STATUS_FULL_ALLIANCE, FALSE );
						SetGameData(MP_REALMREACTION, CurrentRealm, TargetRealm, 95, FALSE );
						// offer province
						SetGameData(MP_PROVINCE, MPPROV_REALM, StartProvince, TargetRealm, FALSE );
						ReconstructMap();
					}
					else		// non-landed vassal becomes lieutenant instead
					{
						TargetProvince = (PROVINCE)units[regents[realm[CurrentRealm].mfGetRegent()].mfGetunit()].province;
						for (j=69; j<CHARACTER_COUNT; ++j)			// scan all regents
						{
							if (regents[j].mfGetRealm() == TargetRealm)
							{
								TargetPlace = j;
							 	j = CreateUnit(TargetProvince, regents[TargetPlace].mfGeticon(), (LONG) regents[TargetPlace].mfGetid(), CurrentRealm, FALSE);
								if (j != fERROR)
								{
									if (regents[TargetPlace].mfGetRealm() >= LAND_REALM_COUNT
									   	|| regents[TargetPlace].mfGetRealm() == HomeRealm)
										for (k=0; k<MAX_PLACES; ++k)
										{
											if(places[k].Realm == regents[TargetPlace].mfGetRealm())
											{
												CheckHolding(k, CurrentRealm, FALSE);
											}
										}
									SetGameData(MP_REGENT, MPREG_UNIT, TargetPlace, j, FALSE );
									// HACK HACK HACK HACK HACK
									// GWP Don't set this anymore. (It's read from the units array.
									// SetGameData(MP_REGENT, MPREG_REALM, TargetPlace, CurrentRealm, FALSE );
								}
							}
						}
					}
				}
				else
				{
					PayForIt(CurrentRealm, 1, 1, 0);
					SetGameData(MP_REALMSTATUS, TargetRealm, CurrentRealm, STATUS_PERMISSIVE_ALLIANCE, FALSE );

					if (TargetRealm<LAND_REALM_COUNT)
					{
						//RealmStatus[CurrentRealm][TargetRealm] = STATUS_PERMISSIVE_ALLIANCE;
						SetGameData(MP_REALMSTATUS, CurrentRealm, TargetRealm, STATUS_PERMISSIVE_ALLIANCE, FALSE );
						// RealmReaction[CurrentRealm] [TargetRealm]= 75;
						SetGameData(MP_REALMREACTION, CurrentRealm, TargetRealm, 75, FALSE );
					}

					//RealmReaction[TargetRealm][CurrentRealm] = 75;
					SetGameData(MP_REALMREACTION, TargetRealm, CurrentRealm, 75, FALSE );

					realm[CurrentRealm].mfAddTreasury(gold * 10);
					realm[TargetRealm].mfAddTreasury( -(gold * 10));

					// offer holding
					if (TargetPlace)
						//SetGameData(MP_PLACES, MPPLACE_REALM, TargetPlace, TargetRealm, FALSE );
						CheckHolding(TargetPlace, TargetRealm, FALSE);

					if (StartPlace)
						//SetGameData(MP_PLACES, MPPLACE_REALM, StartPlace, CurrentRealm, FALSE );
						CheckHolding(StartPlace, CurrentRealm, FALSE);
				}
			}

			else if ( TargetRealm == HomeRealm ) //---- Home realm is target
			{
				#ifdef _WINDOWS
				if ( IsMultiPlayer() )
				{
					fOtherDipMP = TRUE;  //---- signal we need to wait
				}
				#endif

				if (RealmStatus[TargetRealm][CurrentRealm] == STATUS_PERMISSIVE_ALLIANCE)
				{
					dData.d1.iAlliance = 2;
					dData.d1.iOffTrib  = 0;
				}
				else if (RealmStatus[TargetRealm][CurrentRealm] == STATUS_FULL_ALLIANCE)
				{
					dData.d1.iAlliance = 3;
					dData.d1.iOffTrib  = trib;
				}
				else
				{
					dData.d1.iAlliance = 1;
					dData.d1.iOffTrib  = 0;
				}

				dData.d1.iReqHold  = StartPlace;
				dData.d1.iOffHold  = TargetPlace;
				dData.d1.iReqGold  = gold;
				dData.d1.iOffGold  = offgold;

				dData.d1.iWhoFrom	= CurrentRealm;
				dData.d1.iReqProv	= 0;
				dData.d1.iOffProv = 0;
				dData.d1.iReqTrib	= 0;
				dData.d1.iOffRegy	= 1;

				if (curResponse < 8)
					++curResponse;
				response[curResponse].lWhichAction	= DIPLOMACY;
				response[curResponse].lWhichProvince= dData.d2.data1;
				response[curResponse].lWhichHold		= dData.d2.data2;
				response[curResponse].lSuccess	 	= dData.d2.data3;
				response[curResponse].lFromId			= 0;
				response[curResponse].lFromRealm		= 0;
				response[curResponse].lResult			= 0;

				ShowRequest(D_OTHERDIPLOMACY, curResponse);	// do Diplomacy style dialog
			}
			else   //----- Need to wait for remote player
			{
				fSync = TRUE;
			}
			break;

		case ACTION_DIPLMCY_DMD_PROV:
			#ifdef _WINDOWS
			if (IsMultiPlayer()) goto ReRoll_;
			#endif
			if (rlm == REALM::MONSTERS) goto ReRoll_;
			if(CurrentRealm == REALM::MONSTERS) goto ReRoll_;
			TargetPlace = 0;
			TargetProvince = NO_PROVINCE;
			TargetRealm = REALM::NO_COUNTRY;
			StartPlace = 0;
			
			if(!FindProv(action)) goto ReRoll_;
			TargetRealm = (REALM::REALM_TYPE)province[TargetProvince].Realm;

			tmpProvince = TargetProvince; //OfferHolding will change targetprovince to the province of the holding found

			if(!OfferHolding()) goto ReRoll_;

			if(50 > (RealmReaction[TargetRealm][CurrentRealm]-70+35+15))
				 reaction = 120-50-RealmReaction[TargetRealm][CurrentRealm];
			else 
				reaction = 1;
			if(!CanAfford (reaction/3, 1, 0, rlm)) goto ReRoll_;
			if(!random(3)) goto ReRoll_;

			npc_ai[rlm].CurrentAction = action;

			if (!realm[TargetRealm].mfIsPlayerCtrl())	 // NPC vs. NPC
			{
				// take care the demanded province
				CheckAndFixPlaces(tmpProvince);
				i = j = province[tmpProvince].FirstPlace;
				while(i!=0)
				{
					if(places[j].Icon == CASTLE1_ICON && places[j].Realm == province[tmpProvince].Realm)
						places[j].Realm = CurrentRealm;
					i = places[j].NextPlace;
					j = province[tmpProvince].FirstPlace + i;
				}
				province[tmpProvince].Realm = CurrentRealm;


				// take care of the offered holding
//				places[TargetPlace].Realm = TargetRealm;
				SetGameData(MP_PLACES, MPPLACE_REALM, TargetPlace, TargetRealm, FALSE );
				CheckHolding(TargetPlace, TargetRealm, FALSE);
				ReconstructMap();
				CheckRealmStatus(rlm,TargetRealm, FALSE );
				Tribute[CurrentRealm][TargetRealm]=reaction/5;
				gold = (reaction-reaction/5)/3;
				gold = (gold >= 1)?gold:1;
				PayForIt(CurrentRealm, gold, 1, 0);
				realm[TargetRealm].mfAddTreasury(gold* 10);
			}

			else if ( TargetRealm == HomeRealm )   //---- Target is us 
			{

				#ifdef _WINDOWS
				if ( IsMultiPlayer() )
				{
					fOtherDipMP = TRUE;  //---- signal we need to wait
				}
				#endif

				gold = (reaction-reaction/5)/3;
				gold = (gold >= 1)?gold:1;

				dData.d1.iAlliance  = 0;
				dData.d1.iOffGold	= gold;
				dData.d1.iWhoFrom	= CurrentRealm;
				dData.d1.iReqGold	= 0;
				dData.d1.iReqProv	= tmpProvince;
				dData.d1.iReqHold	= 0;
				dData.d1.iReqTrib	= 0;
				dData.d1.iOffProv	= 0;
				dData.d1.iOffHold	= TargetPlace;
				dData.d1.iOffTrib	= reaction/5;
				dData.d1.iOffRegy	= 1;

				if (curResponse < 8)
					++curResponse;
				response[curResponse].lWhichAction	= DIPLOMACY;
				response[curResponse].lWhichProvince= dData.d2.data1;
				response[curResponse].lWhichHold		= dData.d2.data2;
				response[curResponse].lSuccess	 	= dData.d2.data3;
				response[curResponse].lFromId			= 0;
				response[curResponse].lFromRealm		= 0;
				response[curResponse].lResult			= 0;

				ShowRequest(D_OTHERDIPLOMACY, curResponse);	// do Diplomacy style dialog
			}
			else   //----- Need to wait for remote player
			{
				fSync = TRUE;
			}
			
			break;


		case ACTION_DIPLMCY_DMD_HOLD:
			#ifdef _WINDOWS
			if (IsMultiPlayer()) goto ReRoll_;
			#endif
			if (rlm == REALM::MONSTERS) goto ReRoll_;
			if(CurrentRealm == REALM::MONSTERS) goto ReRoll_;
			TargetPlace = 0;
			StartPlace = 0;
			
			CurrentRegent = realm[CurrentRealm].mfGetRegent();
			
			if(!OfferHolding()) goto ReRoll_;
			
			if(!DemandHolding(REALM::NO_COUNTRY, 0)) goto ReRoll_;

			TargetRealm = (REALM::REALM_TYPE)places[StartPlace].Realm;
			if(50 > (RealmReaction[TargetRealm][CurrentRealm]-30+15))
				reaction = 50+30-15 - RealmReaction[TargetRealm][CurrentRealm];
			else
				reaction = 1;
			if(!CanAfford ((reaction-reaction/5)/3+1, reaction/5, 1, rlm)) goto ReRoll_;

			if(!random(3)) goto ReRoll_;

			npc_ai[rlm].CurrentAction = action;

			if (!realm[TargetRealm].mfIsPlayerCtrl())	
			{

				// set tribute
				Tribute[CurrentRealm][TargetRealm] = reaction/5;
				gold = (reaction - reaction/5)/3;
				gold = (gold >= 1)?gold:1;
 				PayForIt(CurrentRealm, gold, 1, 0);

				// take care the demanded holding
				// places[StartPlace].Realm = CurrentRealm;
				//SetGameData(MP_PLACES, MPPLACE_REALM, StartPlace, CurrentRealm, FALSE );
				CheckHolding(StartPlace, CurrentRealm, FALSE);
				
				// take care the offered TargetPlace
				//SetGameData(MP_PLACES, MPPLACE_REALM, TargetPlace, TargetRealm, FALSE );
				CheckHolding(TargetPlace, TargetRealm, FALSE);
			}	 	
			else if ( TargetRealm == HomeRealm )   // home realm is target
			{

#ifdef _WINDOWS  

				if ( IsMultiPlayer() )
				{
					fOtherDipMP = TRUE;  //---- signal we need to wait
				}
#endif

				gold = (reaction - reaction/5)/3;
				gold = (gold >= 1)?gold:1;

				dData.d1.iAlliance  = 0;
				dData.d1.iOffGold	= gold;
				dData.d1.iWhoFrom	= CurrentRealm;
				dData.d1.iReqGold	= 0;
				dData.d1.iReqProv	= 0;
				dData.d1.iReqHold	= StartPlace;
				dData.d1.iReqTrib	= 0;
				dData.d1.iOffProv	= 0;
				dData.d1.iOffHold	= TargetPlace;
				dData.d1.iOffTrib	= reaction/5;;
				dData.d1.iOffRegy	= 1;

				if (curResponse < 8)
					++curResponse;
				response[curResponse].lWhichAction	= DIPLOMACY;
				response[curResponse].lWhichProvince= dData.d2.data1;
				response[curResponse].lWhichHold		= dData.d2.data2;
				response[curResponse].lSuccess	 	= dData.d2.data3;
				response[curResponse].lFromId			= 0;
				response[curResponse].lFromRealm		= 0;
				response[curResponse].lResult			= 0;

				ShowRequest(D_OTHERDIPLOMACY, curResponse);	// do Diplomacy style dialog
			}
			else   //----- Need to wait for remote player
			{
				fSync = TRUE;
			}
			break;

		case ACTION_DIPLMCY_DMD_TRIB:
			#ifdef _WINDOWS
			if (IsMultiPlayer()) goto ReRoll_;
			#endif
			if (rlm == REALM::MONSTERS) goto ReRoll_;
			if(CurrentRealm == REALM::MONSTERS) goto ReRoll_;
			if(!FindRealm()) goto ReRoll_;
			if (TargetRealm == REALM::ANY_REALM) goto ReRoll_;
			if (!realm[TargetRealm].mfIsPlayerCtrl())	goto ReRoll_;

			npc_ai[rlm].CurrentAction = action;

			if ( TargetRealm == HomeRealm )  // home realm is target
			{

#ifdef _WINDOWS  

				if ( IsMultiPlayer() )
				{
					fOtherDipMP = TRUE;  //---- signal we need to wait
				}
#endif

				trib = random(3) + 1;
				if(50 > (RealmReaction[TargetRealm][CurrentRealm]-(trib*5)))
					gold = (50 + trib*5 - RealmReaction[TargetRealm][CurrentRealm])/3;
				else
					gold = 1;
				if(!CanAfford (gold, 1, 0, rlm)) goto ReRoll_;
				dData.d1.iAlliance  = 0;
				dData.d1.iOffGold	= gold;
				dData.d1.iWhoFrom	= CurrentRealm;
				dData.d1.iReqGold	= 0;
				dData.d1.iReqProv	= 0;
				dData.d1.iReqHold	= 0;
				dData.d1.iReqTrib	= trib;
				dData.d1.iOffProv	= 0;
				dData.d1.iOffHold	= 0;

				dData.d1.iOffTrib	= 0;
				dData.d1.iOffRegy	= 1;

				if (curResponse < 8)
					++curResponse;
				response[curResponse].lWhichAction	= DIPLOMACY;
				response[curResponse].lWhichProvince= dData.d2.data1;
				response[curResponse].lWhichHold		= dData.d2.data2;
				response[curResponse].lSuccess	 	= dData.d2.data3;
				response[curResponse].lFromId			= 0;
				response[curResponse].lFromRealm		= 0;
				response[curResponse].lResult			= 0;

				ShowRequest(D_OTHERDIPLOMACY, curResponse);	// do Diplomacy style dialog
			}

			else   //----- Need to wait for remote player
			{
				fSync = TRUE;
			}
			break;

		case ACTION_ESPIONAGE_ASSASSIN:
			if (rlm == REALM::MONSTERS) goto ReRoll_;
			if(!CanAfford (1, 0, 0, rlm)) goto ReRoll_;
			if (TriggeredTargetRealm && TriggeredTargetRealm!=rlm
					&& TriggeredTargetRealm < LAND_REALM_COUNT)
				TargetRealm = TriggeredTargetRealm;
			else if (!FindFoe(rlm,action)) goto ReRoll_;		// find a foe of ours
			if (TargetRealm == REALM::ANY_REALM) goto ReRoll_;
			if (!FindUnit(TargetRealm,action)) goto ReRoll_;
			npc_ai[rlm].CurrentAction = action;
			//if (!RollNPCSuccess(action)) break;
			if(units[TargetUnit].Realm == HomeRealm)
				AddReport(	IMMEDIATE_NPC_ASSASSIN, CurrentRealm, TargetProvince, 0);
			SetScrewed((REALM::REALM_TYPE)units[TargetUnit].Realm, CurrentRealm, FALSE );
			DeleteUnit(TargetUnit, FALSE );
			PayForIt(CurrentRealm, 1, 0, 0);
			break;

		case ACTION_FORTIFY:
			if (rlm == REALM::MONSTERS) goto ReRoll_;
			if (!FindProv(action)) goto ReRoll_;  	// can't do the action so try another
			if(!CreateHolding(4, random(province[TargetProvince].CivLevel) + 1, 0, TargetProvince, CurrentRealm, FALSE )) goto ReRoll_;
			npc_ai[rlm].CurrentAction = action;
			break;

		case ACTION_LEYLINE:
			if (rlm == REALM::MONSTERS) goto ReRoll_;
			TargetPlace = 0;
			TargetProvince = NO_PROVINCE;
			StartProvince = NO_PROVINCE;
			StartPlace = 0;
			for(i=1; i<PROVINCE_COUNT; ++i)
			{
				CheckAndFixPlaces((PROVINCE)i);
			 	j = k = province[i].FirstPlace; 
			 	while (k != 0 )
			 	{
					// look for a source with leyline going out but nothing coming in as a TargetPlace
			 	   	if(places[j].Icon == SOURCE1_ICON 
							&& places[j].Realm == CurrentRealm
						 	&& (places[j].iRoute1 || places[j].iRoute2 || places[j].iRoute3))  // Source has a leyline going out                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
					{
						for(m = 0; m< MAX_PLACES; ++m)
							if( places[m].Icon == SOURCE1_ICON 
									&& (places[m].iRoute1 == j || places[m].iRoute2 == j || places[m].iRoute3 == j))
								break;
						if(m == MAX_PLACES)
						{
							TargetProvince = (PROVINCE)i;
							TargetPlace	= j;
							break;
						}
			 		}
			 		k = places[j].NextPlace;
			 		j = province[i].FirstPlace + k;
			 	}
				if(k!=0)
					break;
			} 
		   	// look for a source without any leyline connect to as a StartPlace
		   	// if there is a targetProvince, look for the closet one, otherwise just pick one
			for(i=1; i<PROVINCE_COUNT; ++i)
			{
				CheckAndFixPlaces((PROVINCE)i);
			 	j = k = province[i].FirstPlace; 
			 	while (k != 0 )
			 	{
					if(places[j].Icon == SOURCE1_ICON 
								&& places[j].Realm == CurrentRealm
						 		&& !places[j].iRoute1&& !places[j].iRoute2 && !places[j].iRoute3)  // Source has a leyline going out                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
					{
						for(m = 0; m< MAX_PLACES; ++m)
							if( places[m].Icon == SOURCE1_ICON 
									&& (places[m].iRoute1 == j || places[m].iRoute2 == j || places[m].iRoute3 == j))
								break;
						if(m == MAX_PLACES)
						{
							if(TargetProvince == 0)
							{
								StartPlace = j;
								StartProvince = (PROVINCE)i;
								break;
							}
							dist = ProvDist (TargetProvince, i, 0, TRUE);
							if(dist < minDist)
							{
								minDist = dist;
								StartPlace = j;
							}
						}
					}
			 		k = places[j].NextPlace;
			 		j = province[i].FirstPlace + k;
			 	}
				if(k != 0)
					break;
			}
			minDist = 99;
			// Found a single node to start with, but didn't find any source with only leyline going out
			// look for a closet source 
			if(TargetPlace == 0 && StartPlace != 0)
			{
				for(i=1; i<PROVINCE_COUNT; ++i)
				{
					CheckAndFixPlaces((PROVINCE)i);
				 	j = k = province[i].FirstPlace; 
				 	while (k != 0 )
				 	{
						if(places[j].Icon == SOURCE1_ICON
						   		&& places[j].Realm == CurrentRealm
						   		&& j != StartPlace)
						{
							dist = ProvDist (StartProvince, i, 0, TRUE);
							if(dist < minDist)
							{
								minDist = dist;
								TargetPlace = j;
							}
						}

				 		k = places[j].NextPlace;
				 		j = province[i].FirstPlace + k;
				 	}
				}
			}
			if(!StartPlace || !TargetPlace)
				 goto ReRoll_;

			//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			//i = TargetPlace;
			//TargetPlace = 0;
			//j = TargetProvince;
			//TargetProvince = StartProvince;
			//if (!RollNPCSuccess(action)) break;
			//StartProvince = TargetProvince;
			//TargetProvince = j;
			//if (!RollNPCSuccess(action)) break;
			//TargetPlace = i;
			//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

			if(!CanAfford (minDist, minDist, 0, rlm)) goto ReRoll_;
			npc_ai[rlm].CurrentAction = action;
			SetGameData(MP_PLACES, MPPLACE_IROUTE1, StartPlace, TargetPlace, FALSE );
			PayForIt(CurrentRealm, minDist, minDist, 0);
			break;

		case ACTION_INVESTITURE:
			for (i=1; i<PROVINCE_COUNT; ++i)
			{
				if (province[i].OccupRealm == rlm)		// we occupy the prov
				{
					TargetProvince = (PROVINCE)i;
					TargetPlace=0;
					npc_ai[rlm].CurrentAction = action;
					if (!RollNPCSuccess(action, &fSync, &fSend)) goto ActionDone;
					j = province[i].Realm;
					SetGameData(MP_PROVINCE, MPPROV_REALM, i, rlm, fSend );
					SetGameData(MP_PROVINCE, MPPROV_OCCUPREALM, i, 0, fSend );
					if (fSend)
						SetGameData(MP_PROVINCE, MPPROV_INVESTED, rlm, j, TRUE );
					else
					{
						ReconstructMap();
						CheckRealmStatus(rlm, j, FALSE );
					}
					goto ActionDone;
				}
			}
			goto ReRoll_;				// can't do the action so try another

		case ACTION_LIEUTENANT:
/*temp*/	goto ReRoll_;				// can't do the action so try another
//			effect here
//			break;
		case ACTION_LTACT_:
/*temp*/	goto ReRoll_;				// can't do the action so try another
//			effect here
//			goto Another;				// action was free so do another


		case ACTION_MOVE_ATTACK_FOE:
		case ACTION_MOVE_ATTACK_OWN:
			if (!FindFoe(rlm,action)) goto ReRoll_;
			if (!FindProv(action)) goto ReRoll_;
			if (!FindUnit(rlm,action)) goto ReRoll_;
			goto actmovelbl;

		case ACTION_MOVE_BORDER_FOE:
		case ACTION_MOVE_FILL_FOE:
		case ACTION_MOVE_REINFORCE_FOE:
		case ACTION_MOVE_UNOCCUP_FOE:
		case ACTION_MOVE_BORDER_OWN:
			if (!FindFoe(rlm,action)) goto ReRoll_;
			if (!FindUnit(rlm,action)) goto ReRoll_;
			if (!FindProv(action)) goto ReRoll_;
actmovelbl:
			Clear_fProv();
			if (!npc_move(NO_PROVINCE)) goto ReRoll_;
#if 0
			// moved this functionality to gamemap.cpp
			// when troops actually cross borders
			
			if (TargetRealm != REALM::ANY_REALM)
			{
				if (TargetRealm == HomeRealm)
					AddReport(IMMEDIATE_NPC_MOVE_TROOP, CurrentRealm, TargetProvince, 0);
				else if (AREALLIED(TargetRealm, HomeRealm))
				{
					// don't display this if you're in a war already... you're busy!
					BOOL atwar = FALSE;
					LONG i;
					for (i = 1; i < LAND_REALM_COUNT; ++i)
					{
						if (ISATWAR(HomeRealm, i) || ISATWAR(i, HomeRealm))
						{
							atwar = TRUE;
							break;
						}
					}
					
					if (atwar)
					{
						// do nothing
					}
					else if (ISVASSAL(TargetRealm, HomeRealm))
						AddReport(IMMEDIATE_NPC_MOVE_TROOP_ALLY, CurrentRealm, 3, TargetRealm);
					else if (AREFULLALLIES(TargetRealm, HomeRealm))
						AddReport(IMMEDIATE_NPC_MOVE_TROOP_ALLY, CurrentRealm, 2, TargetRealm);
					else
						AddReport(IMMEDIATE_NPC_MOVE_TROOP_ALLY, CurrentRealm, 1, TargetRealm);
				}
			}
#endif

			npc_ai[rlm].CurrentAction = action;
			goto Another;				// action was free so do another

		case ACTION_MOVE_RETREAT:
		case ACTION_MOVE_FILL_OWN:
		case ACTION_MOVE_REINFORCE_OWN:
		case ACTION_MOVE_UNOCCUP_OWN:
			TargetRealm = rlm;
			if (!FindUnit(rlm,action)) goto ReRoll_;
			if (!FindProv(action)) goto ReRoll_;
			Clear_fProv();
			if (!npc_move(NO_PROVINCE)) goto ReRoll_;
			npc_ai[rlm].CurrentAction = action;
			goto Another;				// action was free so do another

		case ACTION_MUSTER_INF:
		case ACTION_MUSTER_EIN:
		case ACTION_MUSTER_BOW:
		case ACTION_MUSTER_IRR:
		case ACTION_MUSTER_PIK:
		case ACTION_MUSTER_LVY:
		case ACTION_MUSTER_SCT:
		case ACTION_MUSTER_KNT:
		case ACTION_MUSTER_CAV:
		case ACTION_MUSTER_MINF:
		case ACTION_MUSTER_MBOW:
		case ACTION_MUSTER_MIRR:
		case ACTION_MUSTER_MPIK:
		case ACTION_MUSTER_MCAV:
		case ACTION_MUSTER_EINF:
		case ACTION_MUSTER_EBOW:
		case ACTION_MUSTER_ECAV:
		case ACTION_MUSTER_DINF:
		case ACTION_MUSTER_DBOW:
		case ACTION_MUSTER_GINF:
		case ACTION_MUSTER_GBOW:
		case ACTION_MUSTER_GCAV:
		case ACTION_MUSTER_NINF:
		case ACTION_MUSTER_NIRR:
		case ACTION_MUSTER_CHPY:
		case ACTION_MUSTER_CSKL:
		case ACTION_MUSTER_CSPD:
			if (cntUnits > NPC_MAX_UNITS)
			{
				#ifdef _LOGCOMMENT	// #38
				{
					char temp[100];
					sprintf ( temp, "   muster unit %d - Failed1: cntUnits", 38 );
					RandomLogComment ( temp );
				}
				#endif

#if MUSTERINFO
				printf("MUSTER FAILED - MaxUnits limit, cntUnits:%d\n",cntUnits);
#endif
				goto ReRoll_;
			}

			if (!CanAfford(UnitMusterCost[action-ACTION_MUSTER_INF+1],0,UnitMaintCost[action-ACTION_MUSTER_INF+1], rlm))
			{
				#ifdef _LOGCOMMENT	// #39
				{
					char temp[100];
					sprintf ( temp, "   muster unit %d - Failed2: CanAfford", 39 );
					RandomLogComment ( temp );
				}
				#endif

#if MUSTERINFO
				printf("MUSTER FAILED - Can't afford, realm:%s\n",realm[rlm].mfGetName());
#endif
				goto ReRoll_;
			}
			if (!FindProv(action))
			{
				#ifdef _LOGCOMMENT	// #40
				{
					char temp[100];
					sprintf ( temp, "   muster unit %d - Failed3: FindProv", 40 );
					RandomLogComment ( temp );
				}
				#endif

				goto ReRoll_;
			}

			// GWP Because the muster actions are in the same order as the unit
			// icons this works fine.
			i = CreateUnit(TargetProvince, (MAP_ICON)(action-ACTION_MUSTER_INF+1), 0, CurrentRealm, FALSE );
			if (i)
			{
				#ifdef _LOGCOMMENT // #41
				{
					char temp[100];
					sprintf ( temp, "   MusterUnit %d - %s  in %s, index #%ld",
						41,
						realm[rlm].mfGetName(),
						province[TargetProvince].name,
						i);
					RandomLogComment ( temp );
				}
				#endif

				PayForIt(CurrentRealm, UnitMusterCost[action-ACTION_MUSTER_INF+1],0,UnitMaintCost[action-ACTION_MUSTER_INF+1]);
				++province[TargetProvince].LevyMustered;
				npc_ai[rlm].CurrentAction = action;
				goto Another;				// action was free so do another
			}

			#ifdef _LOGCOMMENT	// #42
			{
				char temp[100];
				sprintf ( temp, "   muster unit %d - Failed4: CreateUnit", 42 );
				RandomLogComment ( temp );
			}
			#endif

#if MUSTERINFO
			printf("MUSTER FAILED - Can't create unit, cntUnits:%d\n",cntUnits);
#endif
			goto ReRoll_;					// action failed so reroll

		case ACTION_RSPELL_BLESSLAND:
			if (!FindProv(action)) goto ReRoll_;
			if(!CanAfford (1, 1, 0, rlm)) goto ReRoll_;
			npc_ai[rlm].CurrentAction = action;
			PayForIt(rlm, 1, 1, 0);
			if (province[TargetProvince].Blighted==0)
				SetGameData(MP_PROVINCE, MPPROV_BLESSED, TargetProvince, 2, FALSE);
			else
				SetGameData(MP_PROVINCE, MPPROV_BLIGHTED, TargetProvince, 0, FALSE);
			SetHelped((REALM::REALM_TYPE)province[TargetProvince].Realm, CurrentRealm, FALSE );
			break;
		case ACTION_RSPELL_BLIGHT:
			if (TriggeredTargetRealm && TriggeredTargetRealm!=rlm
					&& TriggeredTargetRealm < LAND_REALM_COUNT)
				TargetRealm = TriggeredTargetRealm;
			else if (!FindFoe(rlm,action)) goto ReRoll_;		// find a foe of ours
			// have a foe in TargetRealm
			if (!FindProv(action)) goto ReRoll_;
			
			if(!CanAfford (2, 1, 0, rlm)) goto ReRoll_;
			npc_ai[rlm].CurrentAction = action;
			PayForIt(rlm, 2, 1, 0);
			if(province[TargetProvince].Blessed==0)
				SetGameData(MP_PROVINCE, MPPROV_BLIGHTED, TargetProvince, 2, FALSE);
			else
				SetGameData(MP_PROVINCE, MPPROV_BLESSED, TargetProvince, 0, FALSE );
 			if(TargetRealm == HomeRealm)
				AddReport(IMMEDIATE_NPC_BLIGHT, CurrentRealm, TargetProvince, 0);
			SetScrewed((REALM::REALM_TYPE)province[TargetProvince].Realm, CurrentRealm, FALSE );
			break;
		case ACTION_RSPELL_WARDING:
			if (TriggeredTargetRealm && TriggeredTargetRealm!=rlm
					&& TriggeredTargetRealm < LAND_REALM_COUNT)
				TargetRealm = TriggeredTargetRealm;
			else if (!FindFoe(rlm,action)) 
				goto ReRoll_;
			// have a foe in TargetRealm
			if (!FindProv(action)) goto ReRoll_;
			if(!CanAfford (5, 5, 0, rlm)) goto ReRoll_;
			npc_ai[rlm].CurrentAction = action;
			PayForIt(rlm, 5, 5, 0);
			SetGameData(MP_PROVINCE, MPPROV_WARDED, TargetProvince, 2, FALSE );
			SetGameData(MP_PROVINCE, MPPROV_DISPELLVL, TargetProvince, rlm, FALSE );
			SetGameData(MP_PROVINCE, MPPROV_DISPEL, TargetProvince, 0, FALSE );
 			if(TargetRealm == HomeRealm)
 				AddReport(IMMEDIATE_NPC_WARDING, CurrentRealm, TargetProvince, 0);
			SetScrewed((REALM::REALM_TYPE)province[TargetProvince].Realm, CurrentRealm, FALSE );
			break;
		case ACTION_RSPELL_DEMAGOGUE:
			// decrease the loyalty
			if (TriggeredTargetRealm && TriggeredTargetRealm!=rlm
					&& TriggeredTargetRealm < LAND_REALM_COUNT)
				TargetRealm = TriggeredTargetRealm;
			else if (!FindFoe(rlm,action)) 
				goto ReRoll_;
			// have a foe in TargetRealm
			if (!FindProv(action)) goto ReRoll_;
			if(!CanAfford (1, 5, 0, rlm)) goto ReRoll_;
			npc_ai[rlm].CurrentAction = action;
			PayForIt(rlm, 1, 5, 0);
			province[TargetProvince].Loyalty--;
			SetGameData(MP_PROVINCE, MPPROV_LOYALTY, TargetProvince, province[TargetProvince].Loyalty, FALSE );
 			if(TargetRealm == HomeRealm)
				AddReport(IMMEDIATE_NPC_DEMAGOGUE, CurrentRealm, TargetProvince, province[TargetProvince].Loyalty);
			SetScrewed((REALM::REALM_TYPE)province[TargetProvince].Realm, CurrentRealm, FALSE );
			break;
				
		case ACTION_RSPELL_RAZE:
			if (TriggeredTargetRealm && TriggeredTargetRealm!=rlm
					&& TriggeredTargetRealm < LAND_REALM_COUNT)
				TargetRealm = TriggeredTargetRealm;
			else if (!FindFoe(rlm,action)) 
				goto ReRoll_;
			// find the castle StartPlace in a province with source in it
			if (!FindProv(action)) goto ReRoll_;
			
			if(!CanAfford (2, 10, 0, rlm)) goto ReRoll_;
			npc_ai[rlm].CurrentAction = action;
			PayForIt(rlm, 2, 10, 0);
			places[TargetPlace].Level--;
			SetGameData(MP_PLACES, MPPLACE_LEVEL, TargetPlace, places[TargetPlace].Level, FALSE );
			SetGameData(MP_PLACES, MPPLACE_IICONBITM, TargetPlace, places[TargetPlace].Icon+(((places[TargetPlace].Level<8)?places[TargetPlace].Level:7)/2), FALSE );
 			if(TargetRealm == HomeRealm)
	 			AddReport(IMMEDIATE_RAZE, CurrentRealm, TargetProvince, places[TargetPlace].Level);
			SetScrewed((REALM::REALM_TYPE)province[TargetProvince].Realm, CurrentRealm, FALSE );
			break;

		case ACTION_RSPELL_STRONGHOLD:
			if (!FindProv(action)) goto ReRoll_;
			if(!CanAfford (10, 8, 0, rlm)) goto ReRoll_;
			npc_ai[rlm].CurrentAction = action;
			PayForIt(rlm, 10, 8, 0);

			CreateHolding(5, 0, 0, TargetProvince, CurrentRealm, FALSE );
			
			CheckAndFixPlaces(TargetProvince);
			i = j = province[TargetProvince].FirstPlace;
			while (j != 0 && i>=0 && i<MAX_PLACES)
			{
				if (places[i].Icon == WIZTOWER_ICON)	// find the new wiztower just created
				{
					++places[i].Level;
					SetGameData(MP_PLACES, MPPLACE_LEVEL, i, places[i].Level, FALSE );
					break;
				}
				j = places[i].NextPlace;
				i = province[TargetProvince].FirstPlace + j;
			}
 			if(province[TargetProvince].Realm == HomeRealm)
 		   		AddReport(IMMEDIATE_NPC_STRONGHOLD, CurrentRealm, TargetProvince, 0);	
			SetScrewed((REALM::REALM_TYPE)province[TargetProvince].Realm, CurrentRealm, FALSE );

			break;

		case ACTION_RSPELL_SUMMONING:
			if (!FindProv(action)) goto ReRoll_;
			if(!CanAfford (2, 5, 0, rlm)) goto ReRoll_;
			npc_ai[rlm].CurrentAction = action;
			PayForIt(rlm, 2, 5, 0);
			CreateUnit(TargetProvince, MonsterUnits[random(4)], 0, CurrentRealm, FALSE );
 			if(province[TargetProvince].Realm == HomeRealm)
	 			AddReport(IMMEDIATE_NPC_SUMMONING, CurrentRealm, TargetProvince, 0);
			SetScrewed((REALM::REALM_TYPE)province[TargetProvince].Realm, CurrentRealm, FALSE );
			break;
			
		case ACTION_RSPELL_BLESSARMY:
			if (!FindProv(action)) goto ReRoll_;
			if (!FindUnit(CurrentRealm, action)) goto ReRoll_;
			if(!CanAfford (1, 1, 0, rlm)) goto ReRoll_;
			npc_ai[rlm].CurrentAction = action;
			PayForIt(rlm, 1, 1, 0);
			// units[TargetUnit].Blessed = TRUE;
			SetGameData(MP_UNITS, MPUNITS_BLESSED, TargetUnit, TRUE, FALSE );
			break;

		case ACTION_RSPELL_DEATHPLAGUE:
			if (TriggeredTargetRealm && TriggeredTargetRealm!=rlm
					&& TriggeredTargetRealm < LAND_REALM_COUNT)
				TargetRealm = TriggeredTargetRealm;
			else if (!FindFoe(rlm,action)) 
				goto ReRoll_;
			if (!FindProv(action)) goto ReRoll_;
			if(!CanAfford (2, 1, 0, rlm)) goto ReRoll_;
			npc_ai[rlm].CurrentAction = action;
			PayForIt(rlm, 2, 1, 0);
			SetGameData(MP_PROVINCE, MPPROV_CIVLEVEL, TargetProvince, (province[TargetProvince].CivLevel-1), FALSE );
 			if(province[TargetProvince].Realm == HomeRealm)
 				AddReport(IMMEDIATE_NPC_DEATH_PLAGUE, CurrentRealm, TargetProvince, province[TargetProvince].CivLevel);	
			SetScrewed((REALM::REALM_TYPE)province[TargetProvince].Realm, CurrentRealm, FALSE );
			break;

		case ACTION_RSPELL_LEGIONOFTHEDEAD:
			if (!FindProv(action)) goto ReRoll_;
			if(!CanAfford (1, 4, 0, rlm)) goto ReRoll_;
			npc_ai[rlm].CurrentAction = action;
			PayForIt(rlm, 1, 4, 0);
			CreateUnit(TargetProvince, C_SKL_UNIT_ICON, 0, CurrentRealm, FALSE );
 			if(province[TargetProvince].Realm == HomeRealm)
 				AddReport(IMMEDIATE_NPC_LEGION_OF_DEAD, CurrentRealm, TargetProvince, 0);
			SetScrewed((REALM::REALM_TYPE)province[TargetProvince].Realm, CurrentRealm, FALSE );
			break;

		case ACTION_RSPELL_MASSDESTRUCTION:
			if (TriggeredTargetRealm && TriggeredTargetRealm!=rlm
					&& TriggeredTargetRealm < LAND_REALM_COUNT)
				TargetRealm = TriggeredTargetRealm;
			else if (!FindFoe(rlm,action)) 
				goto ReRoll_;
			if (!FindUnit(TargetRealm, action)) goto ReRoll_;
			if(!CanAfford (5, 10, 0, rlm)) goto ReRoll_;
			npc_ai[rlm].CurrentAction = action;
			PayForIt(rlm, 5, 10, 0);
 			if(TargetRealm == HomeRealm)
 				AddReport(IMMEDIATE_NPC_MASS_DESTRUCTION, CurrentRealm, TargetProvince, 0);
			
			SetScrewed(TargetRealm, CurrentRealm, FALSE );
			DeleteUnit(TargetUnit, FALSE);
			break;

		case ACTION_RULE_PROV:
			if (rlm == REALM::MONSTERS) goto ReRoll_;
			if (!FindProv(ACTION_RULE_PROV)) goto ReRoll_;
			TargetPlace=0;
			if (province[TargetProvince].CivLevel >= 10) goto ReRoll_;
			npc_ai[rlm].CurrentAction = action;
			if (!RollNPCSuccess(action, &fSync, &fSend)) break;

//			++province[TargetProvince].CivLevel;
			SetGameData(MP_PROVINCE, MPPROV_CIVLEVEL, TargetProvince, (province[TargetProvince].CivLevel+1), fSend );
//			province[TargetProvince].MagLevel--;
			if (province[TargetProvince].MagLevel>0 && !province[TargetProvince].ElfPop)
				SetGameData(MP_PROVINCE, MPPROV_MAGLEVEL, TargetProvince, (province[TargetProvince].MagLevel-1), fSend );

			//!!!!!!!!!!!!!!!!!!!!!! check and reduce sources here
#if 0
			CheckAndFixPlaces(TargetProvince);
			i = j = province[TargetProvince].FirstPlace;
			while (j != 0)
			{
				if(places[i].Icon == SOURCE1_ICON && places[i].Level > 0 )
				{
					places[i].Level--;
					SetGameData(MP_PLACES, MPPLACE_LEVEL, index, places[index].Level, TRUE );
				}

				j = places[index].NextPlace;
				index = province[i].FirstPlace + j;
			}
#endif
			//!!!!!!!!!!!!!!!!!!!!!! check and reduce sources here

			break;
		case ACTION_RULE_LAW:
			if (rlm == REALM::MONSTERS) goto ReRoll_;
			if (!FindHolding(REALM::ANY_REALM, rlm, ANY_PROVINCE, LAW1_ICON, FALSE)) goto ReRoll_;
			if (!CheckHoldLevels(TargetProvince,LAW1_ICON)) goto ReRoll_;
			npc_ai[rlm].CurrentAction = action;
			if (!RollNPCSuccess(action,&fSync, &fSend)) break;
			SetGameData(MP_PLACES, MPPLACE_LEVEL, TargetPlace, (places[TargetPlace].Level+1), fSend );
			SetGameData(MP_PLACES, MPPLACE_IICONBITM, TargetPlace, places[TargetPlace].Icon+(((places[TargetPlace].Level<8)?places[TargetPlace].Level:7)/2), fSend );
//			++places[TargetPlace].Level;
			break;
		case ACTION_RULE_GLD:
			if (rlm == REALM::MONSTERS) goto ReRoll_;
			if (!FindHolding(REALM::ANY_REALM, rlm, ANY_PROVINCE, GUILD1_ICON, FALSE)) goto ReRoll_;
			if (!CheckHoldLevels(TargetProvince,GUILD1_ICON)) goto ReRoll_;
			npc_ai[rlm].CurrentAction = action;
			if (!RollNPCSuccess(action, &fSync, &fSend)) break;
			SetGameData(MP_PLACES, MPPLACE_LEVEL, TargetPlace, (places[TargetPlace].Level+1), fSend );
			SetGameData(MP_PLACES, MPPLACE_IICONBITM, TargetPlace, places[TargetPlace].Icon+(((places[TargetPlace].Level<8)?places[TargetPlace].Level:7)/2), fSend );
//			++places[TargetPlace].Level;
			break;
		case ACTION_RULE_TMP:
			if (rlm == REALM::MONSTERS) goto ReRoll_;
			if (!FindHolding(REALM::ANY_REALM, rlm, ANY_PROVINCE, TEMPLE1_ICON, FALSE)) goto ReRoll_;
			if (!CheckHoldLevels(TargetProvince,TEMPLE1_ICON)) goto ReRoll_;
			npc_ai[rlm].CurrentAction = action;
			if (!RollNPCSuccess(action, &fSync, &fSend)) break;
			SetGameData(MP_PLACES, MPPLACE_LEVEL, TargetPlace, (places[TargetPlace].Level+1), fSend );
			SetGameData(MP_PLACES, MPPLACE_IICONBITM, TargetPlace, places[TargetPlace].Icon+(((places[TargetPlace].Level<8)?places[TargetPlace].Level:7)/2), fSend );
//			++places[TargetPlace].Level;
			break;
		case ACTION_RULE_SRC:
			if (rlm == REALM::MONSTERS) goto ReRoll_;
			if (!FindHolding(rlm, rlm, ANY_PROVINCE, SOURCE1_ICON, FALSE)) goto ReRoll_;
			if (!CheckHoldLevels(TargetProvince,SOURCE1_ICON)) goto ReRoll_;
			npc_ai[rlm].CurrentAction = action;
			if (!RollNPCSuccess(action, &fSync, &fSend )) break;
			SetGameData(MP_PLACES, MPPLACE_LEVEL, TargetPlace, (places[TargetPlace].Level+1), fSend );
			SetGameData(MP_PLACES, MPPLACE_IICONBITM, TargetPlace, places[TargetPlace].Icon+(((places[TargetPlace].Level<8)?places[TargetPlace].Level:7)/2), fSend );
//			++places[TargetPlace].Level;
			break;

		case ACTION_TRADEROUTE:
			if (rlm == REALM::MONSTERS) goto ReRoll_;
			//printf("TRADE ROUTE - start");
			if (!FindHolding(rlm,rlm,ANY_PROVINCE,GUILD1_ICON,TRUE)) goto ReRoll_; // if no guilds don't bother
			//printf(" found:%s  end",province[TargetProvince].name);
			StartProvince = TargetProvince;
			if (!FindDiffTerrain(VIA_ROAD)) goto ReRoll_;	// must be to diff terrain
			//printf(" found:%s\n",province[TargetProvince].name);

			//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			//i = TargetPlace;
			//TargetPlace = 0;
			//j = TargetProvince;
			//TargetProvince = StartProvince;
			//if (!RollNPCSuccess(action)) break;
			//StartProvince = TargetProvince;
			//TargetProvince = j;
			//if (!RollNPCSuccess(action)) break;
			//TargetPlace = i;
			//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

			if (!npc_traderoute(TargetPlace)) goto ReRoll_;
			npc_ai[rlm].CurrentAction = action;
			break;

		case ACTION_PASS:
			break;

		default:
			print_textf(320, 240, WHITE, STRMGR_GetStr(STR_MAPAI_UNSUPPORTED_ACTN_ERROR_FMT), realm[rlm].mfGetName(), action);
			goto ReRoll_;				// can't do the action so try another
		}
	}
ActionDone:

	#ifdef _WINDOWS
	//---- Waiting for RollNPCSuccess() on remote machine
	//---- Yes even more multiplayer ( SYNC POINT #5 )
	if (IsMultiPlayer() && fSync)
	{
		fSync = 0;
		StartSync( iMPS_SYNC_INITIATIVE + iCurrentRealmIndex );
		CheckSync( (iMPS_SYNC_INITIATIVE + iCurrentRealmIndex), TRUE, TRUE );
	}
	#endif

	#ifdef _LOGCOMMENT	// #43
	{
		char temp[100];
		sprintf ( temp, "--------    %d end of %s turn (GB:%d R:%d)    --------",
			43,
			realm[rlm].mfGetName(),
			realm[rlm].mfGetTreasury(),
			realm[rlm].mfGetRegency());
		RandomLogComment ( temp );
	}
	#endif

	fRedrawAll = TRUE;
	return FALSE;

ReRoll_:
	#ifdef _LOGCOMMENT // #44
	{
		char temp[100];
		sprintf ( temp, "DoNPCAction %d - Reroll",44 );
		RandomLogComment ( temp );
	}
	#endif

	// here to fix bug in compiler don't remove
	{
		char temp[100];
		sprintf ( temp, "DoNPCAction - Reroll" );
	}
	goto ReRoll;


Another_:
	// here to fix bug in compiler don't remove
	{
		char temp[100];
		sprintf ( temp, "DoNPCAction - Another" );
	}
	goto Another;
}

/* ======================================================================== */

/* ======================================================================== */
void MapAIPlayerResponseWaitSync (void)
{
	#ifdef _WINDOWS
	StartSync( iMPS_SYNC_INITIATIVE + iCurrentRealmIndex );
	CheckSync( (iMPS_SYNC_INITIATIVE + iCurrentRealmIndex), TRUE, TRUE );
	#endif
}

/* ======================================================================== */


